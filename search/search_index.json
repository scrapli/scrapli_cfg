{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"scrapli_cfg \u00b6 scrapli_cfg makes merging or replacing device configurations over Telnet or SSH easy. Why over Telnet or SSH? Because you pretty much will always have one of these options available to you, whereas you may not have eAPI or NETCONF ready and enabled (think day zero provisioning, or crazy security requirements locking down ports). scrapli_cfg is built on top of scrapli \"core\" and continues the \"look and feel\" of scrapli into the config management side of things.","title":"Scrapli Cfg"},{"location":"#scrapli_cfg","text":"scrapli_cfg makes merging or replacing device configurations over Telnet or SSH easy. Why over Telnet or SSH? Because you pretty much will always have one of these options available to you, whereas you may not have eAPI or NETCONF ready and enabled (think day zero provisioning, or crazy security requirements locking down ports). scrapli_cfg is built on top of scrapli \"core\" and continues the \"look and feel\" of scrapli into the config management side of things.","title":"scrapli_cfg"},{"location":"changelog/","text":"Changelog \u00b6 2021.XX.XX \u00b6 TODO","title":"Changelog"},{"location":"changelog/#changelog","text":"","title":"Changelog"},{"location":"changelog/#2021xxxx","text":"TODO","title":"2021.XX.XX"},{"location":"about/code_of_conduct/","text":"Code of Conduct \u00b6 Be excellent to each other!","title":"Code of Conduct"},{"location":"about/code_of_conduct/#code-of-conduct","text":"Be excellent to each other!","title":"Code of Conduct"},{"location":"about/contributing/","text":"Contributing \u00b6 Thanks for thinking about contributing to scrapli_cfg! Contributions are not expected, but are quite welcome. Contributions of all kinds are welcomed -- typos, doc updates, adding examples, bug fixes, and feature adds. Some notes on contributing: Please open an issue to discuss any bug fixes, feature adds, or really anything that could result in a pull request. This allows us to all be on the same page, and could save everyone some extra work! Once we've discussed any changes, pull requests are of course welcome and very much appreciated! All PRs should pass tests -- checkout the Makefile for some shortcuts for linting and testing. Please include tests! Even simple/basic tests are better than nothing -- it helps make sure changes in the future don't break functionality or make things act in unexpected ways!","title":"Contributing"},{"location":"about/contributing/#contributing","text":"Thanks for thinking about contributing to scrapli_cfg! Contributions are not expected, but are quite welcome. Contributions of all kinds are welcomed -- typos, doc updates, adding examples, bug fixes, and feature adds. Some notes on contributing: Please open an issue to discuss any bug fixes, feature adds, or really anything that could result in a pull request. This allows us to all be on the same page, and could save everyone some extra work! Once we've discussed any changes, pull requests are of course welcome and very much appreciated! All PRs should pass tests -- checkout the Makefile for some shortcuts for linting and testing. Please include tests! Even simple/basic tests are better than nothing -- it helps make sure changes in the future don't break functionality or make things act in unexpected ways!","title":"Contributing"},{"location":"api_docs/diff/","text":"window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting()) Module scrapli_cfg.diff \u00b6 scrapli_cfg.diff Expand source code \"\"\"scrapli_cfg.diff\"\"\" import difflib import shutil from typing import List, Tuple from scrapli_cfg.exceptions import DiffConfigError from scrapli_cfg.response import ScrapliCfgResponse GREEN = \"\\033[92m\" RED = \"\\033[91m\" YELLOW = \"\\033[93m\" END_COLOR = \"\\033[0m\" class ScrapliCfgDiffResponse(ScrapliCfgResponse): def __init__( self, host: str, source: str, colorize: bool = True, side_by_side_diff_width: int = 0 ) -> None: \"\"\" Scrapli config diff object Args: host: host the diff is for source: source config store from the device, typically running|startup colorize: True/False colorize diff output side_by_side_diff_width: width to use to generate the side-by-side diff, if not provided will fetch the current terminal width Returns: N/A Raises: N/A \"\"\" super().__init__(host=host, raise_for_status_exception=DiffConfigError) self.colorize = colorize self.side_by_side_diff_width = side_by_side_diff_width self.source = source self.source_config = \"\" self.candidate_config = \"\" self.device_diff = \"\" self._difflines: List[str] = [] self.additions = \"\" self.subtractions = \"\" self._unified_diff = \"\" self._side_by_side_diff = \"\" def record_diff_response( self, source_config: str, candidate_config: str, device_diff: str ) -> None: \"\"\" Scrapli config diff object Args: source_config: the actual contents of the source config candidate_config: the scrapli_cfg candidate config device_diff: diff generated by the device itself (if applicable) Returns: N/A Raises: N/A \"\"\" self.source_config = source_config self.candidate_config = candidate_config self.device_diff = device_diff _differ = difflib.Differ() self._difflines = list( _differ.compare( self.source_config.splitlines(keepends=True), self.candidate_config.splitlines(keepends=True), ) ) self.additions = \"\".join([line[2:] for line in self._difflines if line[:2] == \"+ \"]) self.subtractions = \"\".join([line[2:] for line in self._difflines if line[:2] == \"- \"]) @staticmethod def _generate_colors(colorize: bool) -> Tuple[str, str, str, str]: \"\"\" Generate the necessary strings for colorizing or not output Args: colorize: True/False colorize output Returns: tuple: tuple of strings for colorizing (or not) output Raises: N/A \"\"\" yellow = YELLOW if colorize else \"? \" red = RED if colorize else \"- \" green = GREEN if colorize else \"+ \" end = END_COLOR if colorize else \"\" return yellow, red, green, end @property def side_by_side_diff(self) -> str: \"\"\" Generate a side-by-side diff of source vs candidate Args: N/A Returns: str: unified diff text Raises: N/A \"\"\" if self._side_by_side_diff: return self._side_by_side_diff yellow, red, green, end = self._generate_colors(colorize=self.colorize) term_width = self.side_by_side_diff_width or shutil.get_terminal_size().columns half_term_width = int(term_width / 2) diff_side_width = int(half_term_width - 5) side_by_side_diff_lines = [] for line in self._difflines: if line[:2] == \" ?\": current = ( yellow + f\"{line[2:][:diff_side_width].rstrip() : < {half_term_width}}\" + end ) candidate = yellow + f\"{line[2:][:diff_side_width].rstrip()}\" + end elif line[:2] == \"- \": current = red + f\"{line[2:][:diff_side_width].rstrip() : < {half_term_width}}\" + end candidate = \"\" elif line[:2] == \"+ \": current = f\"{'' : < {half_term_width}}\" candidate = green + f\"{line[2:][:diff_side_width].rstrip()}\" + end else: current = f\"{line[2:][:diff_side_width].rstrip() : < {half_term_width}}\" candidate = f\"{line[2:][:diff_side_width].rstrip()}\" side_by_side_diff_lines.append(current + candidate) joined_side_by_side_diff = \"\\n\".join(side_by_side_diff_lines) self._side_by_side_diff = joined_side_by_side_diff return self._side_by_side_diff @property def unified_diff(self) -> str: \"\"\" Generate a unified diff of source vs candidate Args: N/A Returns: str: unified diff text Raises: N/A \"\"\" if self._unified_diff: return self._unified_diff yellow, red, green, end = self._generate_colors(colorize=self.colorize) unified_diff = [ yellow + line[2:] + end if line[:2] == \" ?\" else red + line[2:] + end if line[:2] == \"- \" else green + line[2:] + end if line[:2] == \"+ \" else line[2:] for line in self._difflines ] joined_unified_diff = \"\".join(unified_diff) self._unified_diff = joined_unified_diff return self._unified_diff Classes \u00b6 ScrapliCfgDiffResponse \u00b6 Scrapli config diff object Args: host: host the diff is for source: source config store from the device, typically running|startup colorize: True/False colorize diff output side_by_side_diff_width: width to use to generate the side-by-side diff, if not provided will fetch the current terminal width Returns: N/A Raises: N/A Expand source code class ScrapliCfgDiffResponse(ScrapliCfgResponse): def __init__( self, host: str, source: str, colorize: bool = True, side_by_side_diff_width: int = 0 ) -> None: \"\"\" Scrapli config diff object Args: host: host the diff is for source: source config store from the device, typically running|startup colorize: True/False colorize diff output side_by_side_diff_width: width to use to generate the side-by-side diff, if not provided will fetch the current terminal width Returns: N/A Raises: N/A \"\"\" super().__init__(host=host, raise_for_status_exception=DiffConfigError) self.colorize = colorize self.side_by_side_diff_width = side_by_side_diff_width self.source = source self.source_config = \"\" self.candidate_config = \"\" self.device_diff = \"\" self._difflines: List[str] = [] self.additions = \"\" self.subtractions = \"\" self._unified_diff = \"\" self._side_by_side_diff = \"\" def record_diff_response( self, source_config: str, candidate_config: str, device_diff: str ) -> None: \"\"\" Scrapli config diff object Args: source_config: the actual contents of the source config candidate_config: the scrapli_cfg candidate config device_diff: diff generated by the device itself (if applicable) Returns: N/A Raises: N/A \"\"\" self.source_config = source_config self.candidate_config = candidate_config self.device_diff = device_diff _differ = difflib.Differ() self._difflines = list( _differ.compare( self.source_config.splitlines(keepends=True), self.candidate_config.splitlines(keepends=True), ) ) self.additions = \"\".join([line[2:] for line in self._difflines if line[:2] == \"+ \"]) self.subtractions = \"\".join([line[2:] for line in self._difflines if line[:2] == \"- \"]) @staticmethod def _generate_colors(colorize: bool) -> Tuple[str, str, str, str]: \"\"\" Generate the necessary strings for colorizing or not output Args: colorize: True/False colorize output Returns: tuple: tuple of strings for colorizing (or not) output Raises: N/A \"\"\" yellow = YELLOW if colorize else \"? \" red = RED if colorize else \"- \" green = GREEN if colorize else \"+ \" end = END_COLOR if colorize else \"\" return yellow, red, green, end @property def side_by_side_diff(self) -> str: \"\"\" Generate a side-by-side diff of source vs candidate Args: N/A Returns: str: unified diff text Raises: N/A \"\"\" if self._side_by_side_diff: return self._side_by_side_diff yellow, red, green, end = self._generate_colors(colorize=self.colorize) term_width = self.side_by_side_diff_width or shutil.get_terminal_size().columns half_term_width = int(term_width / 2) diff_side_width = int(half_term_width - 5) side_by_side_diff_lines = [] for line in self._difflines: if line[:2] == \" ?\": current = ( yellow + f\"{line[2:][:diff_side_width].rstrip() : < {half_term_width}}\" + end ) candidate = yellow + f\"{line[2:][:diff_side_width].rstrip()}\" + end elif line[:2] == \"- \": current = red + f\"{line[2:][:diff_side_width].rstrip() : < {half_term_width}}\" + end candidate = \"\" elif line[:2] == \"+ \": current = f\"{'' : < {half_term_width}}\" candidate = green + f\"{line[2:][:diff_side_width].rstrip()}\" + end else: current = f\"{line[2:][:diff_side_width].rstrip() : < {half_term_width}}\" candidate = f\"{line[2:][:diff_side_width].rstrip()}\" side_by_side_diff_lines.append(current + candidate) joined_side_by_side_diff = \"\\n\".join(side_by_side_diff_lines) self._side_by_side_diff = joined_side_by_side_diff return self._side_by_side_diff @property def unified_diff(self) -> str: \"\"\" Generate a unified diff of source vs candidate Args: N/A Returns: str: unified diff text Raises: N/A \"\"\" if self._unified_diff: return self._unified_diff yellow, red, green, end = self._generate_colors(colorize=self.colorize) unified_diff = [ yellow + line[2:] + end if line[:2] == \" ?\" else red + line[2:] + end if line[:2] == \"- \" else green + line[2:] + end if line[:2] == \"+ \" else line[2:] for line in self._difflines ] joined_unified_diff = \"\".join(unified_diff) self._unified_diff = joined_unified_diff return self._unified_diff Ancestors (in MRO) \u00b6 scrapli_cfg.response.ScrapliCfgResponse Instance variables \u00b6 side_by_side_diff: str Generate a side-by-side diff of source vs candidate Args: N/A Returns: str: unified diff text Raises: N/A unified_diff: str Generate a unified diff of source vs candidate Args: N/A Returns: str: unified diff text Raises: N/A Methods \u00b6 record_diff_response \u00b6 record_diff_response(self, source_config: str, candidate_config: str, device_diff: str) \u2011> NoneType Scrapli config diff object Args: source_config: the actual contents of the source config candidate_config: the scrapli_cfg candidate config device_diff: diff generated by the device itself (if applicable) Returns: N/A Raises: N/A","title":"Diff"},{"location":"api_docs/diff/#module-scrapli_cfgdiff","text":"scrapli_cfg.diff Expand source code \"\"\"scrapli_cfg.diff\"\"\" import difflib import shutil from typing import List, Tuple from scrapli_cfg.exceptions import DiffConfigError from scrapli_cfg.response import ScrapliCfgResponse GREEN = \"\\033[92m\" RED = \"\\033[91m\" YELLOW = \"\\033[93m\" END_COLOR = \"\\033[0m\" class ScrapliCfgDiffResponse(ScrapliCfgResponse): def __init__( self, host: str, source: str, colorize: bool = True, side_by_side_diff_width: int = 0 ) -> None: \"\"\" Scrapli config diff object Args: host: host the diff is for source: source config store from the device, typically running|startup colorize: True/False colorize diff output side_by_side_diff_width: width to use to generate the side-by-side diff, if not provided will fetch the current terminal width Returns: N/A Raises: N/A \"\"\" super().__init__(host=host, raise_for_status_exception=DiffConfigError) self.colorize = colorize self.side_by_side_diff_width = side_by_side_diff_width self.source = source self.source_config = \"\" self.candidate_config = \"\" self.device_diff = \"\" self._difflines: List[str] = [] self.additions = \"\" self.subtractions = \"\" self._unified_diff = \"\" self._side_by_side_diff = \"\" def record_diff_response( self, source_config: str, candidate_config: str, device_diff: str ) -> None: \"\"\" Scrapli config diff object Args: source_config: the actual contents of the source config candidate_config: the scrapli_cfg candidate config device_diff: diff generated by the device itself (if applicable) Returns: N/A Raises: N/A \"\"\" self.source_config = source_config self.candidate_config = candidate_config self.device_diff = device_diff _differ = difflib.Differ() self._difflines = list( _differ.compare( self.source_config.splitlines(keepends=True), self.candidate_config.splitlines(keepends=True), ) ) self.additions = \"\".join([line[2:] for line in self._difflines if line[:2] == \"+ \"]) self.subtractions = \"\".join([line[2:] for line in self._difflines if line[:2] == \"- \"]) @staticmethod def _generate_colors(colorize: bool) -> Tuple[str, str, str, str]: \"\"\" Generate the necessary strings for colorizing or not output Args: colorize: True/False colorize output Returns: tuple: tuple of strings for colorizing (or not) output Raises: N/A \"\"\" yellow = YELLOW if colorize else \"? \" red = RED if colorize else \"- \" green = GREEN if colorize else \"+ \" end = END_COLOR if colorize else \"\" return yellow, red, green, end @property def side_by_side_diff(self) -> str: \"\"\" Generate a side-by-side diff of source vs candidate Args: N/A Returns: str: unified diff text Raises: N/A \"\"\" if self._side_by_side_diff: return self._side_by_side_diff yellow, red, green, end = self._generate_colors(colorize=self.colorize) term_width = self.side_by_side_diff_width or shutil.get_terminal_size().columns half_term_width = int(term_width / 2) diff_side_width = int(half_term_width - 5) side_by_side_diff_lines = [] for line in self._difflines: if line[:2] == \" ?\": current = ( yellow + f\"{line[2:][:diff_side_width].rstrip() : < {half_term_width}}\" + end ) candidate = yellow + f\"{line[2:][:diff_side_width].rstrip()}\" + end elif line[:2] == \"- \": current = red + f\"{line[2:][:diff_side_width].rstrip() : < {half_term_width}}\" + end candidate = \"\" elif line[:2] == \"+ \": current = f\"{'' : < {half_term_width}}\" candidate = green + f\"{line[2:][:diff_side_width].rstrip()}\" + end else: current = f\"{line[2:][:diff_side_width].rstrip() : < {half_term_width}}\" candidate = f\"{line[2:][:diff_side_width].rstrip()}\" side_by_side_diff_lines.append(current + candidate) joined_side_by_side_diff = \"\\n\".join(side_by_side_diff_lines) self._side_by_side_diff = joined_side_by_side_diff return self._side_by_side_diff @property def unified_diff(self) -> str: \"\"\" Generate a unified diff of source vs candidate Args: N/A Returns: str: unified diff text Raises: N/A \"\"\" if self._unified_diff: return self._unified_diff yellow, red, green, end = self._generate_colors(colorize=self.colorize) unified_diff = [ yellow + line[2:] + end if line[:2] == \" ?\" else red + line[2:] + end if line[:2] == \"- \" else green + line[2:] + end if line[:2] == \"+ \" else line[2:] for line in self._difflines ] joined_unified_diff = \"\".join(unified_diff) self._unified_diff = joined_unified_diff return self._unified_diff","title":"Module scrapli_cfg.diff"},{"location":"api_docs/diff/#classes","text":"","title":"Classes"},{"location":"api_docs/diff/#scraplicfgdiffresponse","text":"Scrapli config diff object Args: host: host the diff is for source: source config store from the device, typically running|startup colorize: True/False colorize diff output side_by_side_diff_width: width to use to generate the side-by-side diff, if not provided will fetch the current terminal width Returns: N/A Raises: N/A Expand source code class ScrapliCfgDiffResponse(ScrapliCfgResponse): def __init__( self, host: str, source: str, colorize: bool = True, side_by_side_diff_width: int = 0 ) -> None: \"\"\" Scrapli config diff object Args: host: host the diff is for source: source config store from the device, typically running|startup colorize: True/False colorize diff output side_by_side_diff_width: width to use to generate the side-by-side diff, if not provided will fetch the current terminal width Returns: N/A Raises: N/A \"\"\" super().__init__(host=host, raise_for_status_exception=DiffConfigError) self.colorize = colorize self.side_by_side_diff_width = side_by_side_diff_width self.source = source self.source_config = \"\" self.candidate_config = \"\" self.device_diff = \"\" self._difflines: List[str] = [] self.additions = \"\" self.subtractions = \"\" self._unified_diff = \"\" self._side_by_side_diff = \"\" def record_diff_response( self, source_config: str, candidate_config: str, device_diff: str ) -> None: \"\"\" Scrapli config diff object Args: source_config: the actual contents of the source config candidate_config: the scrapli_cfg candidate config device_diff: diff generated by the device itself (if applicable) Returns: N/A Raises: N/A \"\"\" self.source_config = source_config self.candidate_config = candidate_config self.device_diff = device_diff _differ = difflib.Differ() self._difflines = list( _differ.compare( self.source_config.splitlines(keepends=True), self.candidate_config.splitlines(keepends=True), ) ) self.additions = \"\".join([line[2:] for line in self._difflines if line[:2] == \"+ \"]) self.subtractions = \"\".join([line[2:] for line in self._difflines if line[:2] == \"- \"]) @staticmethod def _generate_colors(colorize: bool) -> Tuple[str, str, str, str]: \"\"\" Generate the necessary strings for colorizing or not output Args: colorize: True/False colorize output Returns: tuple: tuple of strings for colorizing (or not) output Raises: N/A \"\"\" yellow = YELLOW if colorize else \"? \" red = RED if colorize else \"- \" green = GREEN if colorize else \"+ \" end = END_COLOR if colorize else \"\" return yellow, red, green, end @property def side_by_side_diff(self) -> str: \"\"\" Generate a side-by-side diff of source vs candidate Args: N/A Returns: str: unified diff text Raises: N/A \"\"\" if self._side_by_side_diff: return self._side_by_side_diff yellow, red, green, end = self._generate_colors(colorize=self.colorize) term_width = self.side_by_side_diff_width or shutil.get_terminal_size().columns half_term_width = int(term_width / 2) diff_side_width = int(half_term_width - 5) side_by_side_diff_lines = [] for line in self._difflines: if line[:2] == \" ?\": current = ( yellow + f\"{line[2:][:diff_side_width].rstrip() : < {half_term_width}}\" + end ) candidate = yellow + f\"{line[2:][:diff_side_width].rstrip()}\" + end elif line[:2] == \"- \": current = red + f\"{line[2:][:diff_side_width].rstrip() : < {half_term_width}}\" + end candidate = \"\" elif line[:2] == \"+ \": current = f\"{'' : < {half_term_width}}\" candidate = green + f\"{line[2:][:diff_side_width].rstrip()}\" + end else: current = f\"{line[2:][:diff_side_width].rstrip() : < {half_term_width}}\" candidate = f\"{line[2:][:diff_side_width].rstrip()}\" side_by_side_diff_lines.append(current + candidate) joined_side_by_side_diff = \"\\n\".join(side_by_side_diff_lines) self._side_by_side_diff = joined_side_by_side_diff return self._side_by_side_diff @property def unified_diff(self) -> str: \"\"\" Generate a unified diff of source vs candidate Args: N/A Returns: str: unified diff text Raises: N/A \"\"\" if self._unified_diff: return self._unified_diff yellow, red, green, end = self._generate_colors(colorize=self.colorize) unified_diff = [ yellow + line[2:] + end if line[:2] == \" ?\" else red + line[2:] + end if line[:2] == \"- \" else green + line[2:] + end if line[:2] == \"+ \" else line[2:] for line in self._difflines ] joined_unified_diff = \"\".join(unified_diff) self._unified_diff = joined_unified_diff return self._unified_diff","title":"ScrapliCfgDiffResponse"},{"location":"api_docs/diff/#ancestors-in-mro","text":"scrapli_cfg.response.ScrapliCfgResponse","title":"Ancestors (in MRO)"},{"location":"api_docs/diff/#instance-variables","text":"side_by_side_diff: str Generate a side-by-side diff of source vs candidate Args: N/A Returns: str: unified diff text Raises: N/A unified_diff: str Generate a unified diff of source vs candidate Args: N/A Returns: str: unified diff text Raises: N/A","title":"Instance variables"},{"location":"api_docs/diff/#methods","text":"","title":"Methods"},{"location":"api_docs/diff/#record_diff_response","text":"record_diff_response(self, source_config: str, candidate_config: str, device_diff: str) \u2011> NoneType Scrapli config diff object Args: source_config: the actual contents of the source config candidate_config: the scrapli_cfg candidate config device_diff: diff generated by the device itself (if applicable) Returns: N/A Raises: N/A","title":"record_diff_response"},{"location":"api_docs/exceptions/","text":"window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting()) Module scrapli_cfg.exceptions \u00b6 scrapli_cfg.exceptions Expand source code \"\"\"scrapli_cfg.exceptions\"\"\" from scrapli.exceptions import ScrapliException class ScrapliCfgException(ScrapliException): # type: ignore \"\"\"Base scrapli_cfg exception\"\"\" class TemplateError(ScrapliCfgException): \"\"\"For errors relating to configuration templates\"\"\" class FailedToDetermineDeviceState(ScrapliCfgException): \"\"\"For issues determining device state (i.e. what mode is file prompt in, etc.)\"\"\" class VersionError(ScrapliCfgException): \"\"\"For errors related to getting/parsing/invalid versions\"\"\" class ConfigError(ScrapliCfgException): \"\"\"For configuration operation related errors\"\"\" class InvalidConfigTarget(ConfigError): \"\"\"User has provided an invalid configuration target\"\"\" class FailedToFetchSpaceAvailable(ConfigError): \"\"\"Unable to determine space available on filesystem\"\"\" class InsufficientSpaceAvailable(ConfigError): \"\"\"If space available on filesystem is insufficient\"\"\" class GetConfigError(ConfigError): \"\"\"For errors getting configuration from a device\"\"\" class LoadConfigError(ConfigError): \"\"\"For errors loading a configuration\"\"\" class DiffConfigError(ConfigError): \"\"\"For errors diffing a configuration\"\"\" class AbortConfigError(ConfigError): \"\"\"For errors aborting a configuration\"\"\" class CommitConfigError(ConfigError): \"\"\"For errors committing a configuration\"\"\" class CleanupError(ScrapliCfgException): \"\"\"For errors during cleanup (i.e. removing candidate config, etc.)\"\"\" Classes \u00b6 AbortConfigError \u00b6 For errors aborting a configuration Expand source code class AbortConfigError(ConfigError): \"\"\"For errors aborting a configuration\"\"\" Ancestors (in MRO) \u00b6 scrapli_cfg.exceptions.ConfigError scrapli_cfg.exceptions.ScrapliCfgException scrapli.exceptions.ScrapliException builtins.Exception builtins.BaseException CleanupError \u00b6 For errors during cleanup (i.e. removing candidate config, etc.) Expand source code class CleanupError(ScrapliCfgException): \"\"\"For errors during cleanup (i.e. removing candidate config, etc.)\"\"\" Ancestors (in MRO) \u00b6 scrapli_cfg.exceptions.ScrapliCfgException scrapli.exceptions.ScrapliException builtins.Exception builtins.BaseException CommitConfigError \u00b6 For errors committing a configuration Expand source code class CommitConfigError(ConfigError): \"\"\"For errors committing a configuration\"\"\" Ancestors (in MRO) \u00b6 scrapli_cfg.exceptions.ConfigError scrapli_cfg.exceptions.ScrapliCfgException scrapli.exceptions.ScrapliException builtins.Exception builtins.BaseException ConfigError \u00b6 For configuration operation related errors Expand source code class ConfigError(ScrapliCfgException): \"\"\"For configuration operation related errors\"\"\" Ancestors (in MRO) \u00b6 scrapli_cfg.exceptions.ScrapliCfgException scrapli.exceptions.ScrapliException builtins.Exception builtins.BaseException Descendants \u00b6 scrapli_cfg.exceptions.AbortConfigError scrapli_cfg.exceptions.CommitConfigError scrapli_cfg.exceptions.DiffConfigError scrapli_cfg.exceptions.FailedToFetchSpaceAvailable scrapli_cfg.exceptions.GetConfigError scrapli_cfg.exceptions.InsufficientSpaceAvailable scrapli_cfg.exceptions.InvalidConfigTarget scrapli_cfg.exceptions.LoadConfigError DiffConfigError \u00b6 For errors diffing a configuration Expand source code class DiffConfigError(ConfigError): \"\"\"For errors diffing a configuration\"\"\" Ancestors (in MRO) \u00b6 scrapli_cfg.exceptions.ConfigError scrapli_cfg.exceptions.ScrapliCfgException scrapli.exceptions.ScrapliException builtins.Exception builtins.BaseException FailedToDetermineDeviceState \u00b6 For issues determining device state (i.e. what mode is file prompt in, etc.) Expand source code class FailedToDetermineDeviceState(ScrapliCfgException): \"\"\"For issues determining device state (i.e. what mode is file prompt in, etc.)\"\"\" Ancestors (in MRO) \u00b6 scrapli_cfg.exceptions.ScrapliCfgException scrapli.exceptions.ScrapliException builtins.Exception builtins.BaseException FailedToFetchSpaceAvailable \u00b6 Unable to determine space available on filesystem Expand source code class FailedToFetchSpaceAvailable(ConfigError): \"\"\"Unable to determine space available on filesystem\"\"\" Ancestors (in MRO) \u00b6 scrapli_cfg.exceptions.ConfigError scrapli_cfg.exceptions.ScrapliCfgException scrapli.exceptions.ScrapliException builtins.Exception builtins.BaseException GetConfigError \u00b6 For errors getting configuration from a device Expand source code class GetConfigError(ConfigError): \"\"\"For errors getting configuration from a device\"\"\" Ancestors (in MRO) \u00b6 scrapli_cfg.exceptions.ConfigError scrapli_cfg.exceptions.ScrapliCfgException scrapli.exceptions.ScrapliException builtins.Exception builtins.BaseException InsufficientSpaceAvailable \u00b6 If space available on filesystem is insufficient Expand source code class InsufficientSpaceAvailable(ConfigError): \"\"\"If space available on filesystem is insufficient\"\"\" Ancestors (in MRO) \u00b6 scrapli_cfg.exceptions.ConfigError scrapli_cfg.exceptions.ScrapliCfgException scrapli.exceptions.ScrapliException builtins.Exception builtins.BaseException InvalidConfigTarget \u00b6 User has provided an invalid configuration target Expand source code class InvalidConfigTarget(ConfigError): \"\"\"User has provided an invalid configuration target\"\"\" Ancestors (in MRO) \u00b6 scrapli_cfg.exceptions.ConfigError scrapli_cfg.exceptions.ScrapliCfgException scrapli.exceptions.ScrapliException builtins.Exception builtins.BaseException LoadConfigError \u00b6 For errors loading a configuration Expand source code class LoadConfigError(ConfigError): \"\"\"For errors loading a configuration\"\"\" Ancestors (in MRO) \u00b6 scrapli_cfg.exceptions.ConfigError scrapli_cfg.exceptions.ScrapliCfgException scrapli.exceptions.ScrapliException builtins.Exception builtins.BaseException ScrapliCfgException \u00b6 Base scrapli_cfg exception Expand source code class ScrapliCfgException(ScrapliException): # type: ignore \"\"\"Base scrapli_cfg exception\"\"\" Ancestors (in MRO) \u00b6 scrapli.exceptions.ScrapliException builtins.Exception builtins.BaseException Descendants \u00b6 scrapli_cfg.exceptions.CleanupError scrapli_cfg.exceptions.ConfigError scrapli_cfg.exceptions.FailedToDetermineDeviceState scrapli_cfg.exceptions.TemplateError scrapli_cfg.exceptions.VersionError TemplateError \u00b6 For errors relating to configuration templates Expand source code class TemplateError(ScrapliCfgException): \"\"\"For errors relating to configuration templates\"\"\" Ancestors (in MRO) \u00b6 scrapli_cfg.exceptions.ScrapliCfgException scrapli.exceptions.ScrapliException builtins.Exception builtins.BaseException VersionError \u00b6 For errors related to getting/parsing/invalid versions Expand source code class VersionError(ScrapliCfgException): \"\"\"For errors related to getting/parsing/invalid versions\"\"\" Ancestors (in MRO) \u00b6 scrapli_cfg.exceptions.ScrapliCfgException scrapli.exceptions.ScrapliException builtins.Exception builtins.BaseException","title":"Exceptions"},{"location":"api_docs/exceptions/#module-scrapli_cfgexceptions","text":"scrapli_cfg.exceptions Expand source code \"\"\"scrapli_cfg.exceptions\"\"\" from scrapli.exceptions import ScrapliException class ScrapliCfgException(ScrapliException): # type: ignore \"\"\"Base scrapli_cfg exception\"\"\" class TemplateError(ScrapliCfgException): \"\"\"For errors relating to configuration templates\"\"\" class FailedToDetermineDeviceState(ScrapliCfgException): \"\"\"For issues determining device state (i.e. what mode is file prompt in, etc.)\"\"\" class VersionError(ScrapliCfgException): \"\"\"For errors related to getting/parsing/invalid versions\"\"\" class ConfigError(ScrapliCfgException): \"\"\"For configuration operation related errors\"\"\" class InvalidConfigTarget(ConfigError): \"\"\"User has provided an invalid configuration target\"\"\" class FailedToFetchSpaceAvailable(ConfigError): \"\"\"Unable to determine space available on filesystem\"\"\" class InsufficientSpaceAvailable(ConfigError): \"\"\"If space available on filesystem is insufficient\"\"\" class GetConfigError(ConfigError): \"\"\"For errors getting configuration from a device\"\"\" class LoadConfigError(ConfigError): \"\"\"For errors loading a configuration\"\"\" class DiffConfigError(ConfigError): \"\"\"For errors diffing a configuration\"\"\" class AbortConfigError(ConfigError): \"\"\"For errors aborting a configuration\"\"\" class CommitConfigError(ConfigError): \"\"\"For errors committing a configuration\"\"\" class CleanupError(ScrapliCfgException): \"\"\"For errors during cleanup (i.e. removing candidate config, etc.)\"\"\"","title":"Module scrapli_cfg.exceptions"},{"location":"api_docs/exceptions/#classes","text":"","title":"Classes"},{"location":"api_docs/exceptions/#abortconfigerror","text":"For errors aborting a configuration Expand source code class AbortConfigError(ConfigError): \"\"\"For errors aborting a configuration\"\"\"","title":"AbortConfigError"},{"location":"api_docs/exceptions/#ancestors-in-mro","text":"scrapli_cfg.exceptions.ConfigError scrapli_cfg.exceptions.ScrapliCfgException scrapli.exceptions.ScrapliException builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"api_docs/exceptions/#cleanuperror","text":"For errors during cleanup (i.e. removing candidate config, etc.) Expand source code class CleanupError(ScrapliCfgException): \"\"\"For errors during cleanup (i.e. removing candidate config, etc.)\"\"\"","title":"CleanupError"},{"location":"api_docs/exceptions/#ancestors-in-mro_1","text":"scrapli_cfg.exceptions.ScrapliCfgException scrapli.exceptions.ScrapliException builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"api_docs/exceptions/#commitconfigerror","text":"For errors committing a configuration Expand source code class CommitConfigError(ConfigError): \"\"\"For errors committing a configuration\"\"\"","title":"CommitConfigError"},{"location":"api_docs/exceptions/#ancestors-in-mro_2","text":"scrapli_cfg.exceptions.ConfigError scrapli_cfg.exceptions.ScrapliCfgException scrapli.exceptions.ScrapliException builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"api_docs/exceptions/#configerror","text":"For configuration operation related errors Expand source code class ConfigError(ScrapliCfgException): \"\"\"For configuration operation related errors\"\"\"","title":"ConfigError"},{"location":"api_docs/exceptions/#ancestors-in-mro_3","text":"scrapli_cfg.exceptions.ScrapliCfgException scrapli.exceptions.ScrapliException builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"api_docs/exceptions/#descendants","text":"scrapli_cfg.exceptions.AbortConfigError scrapli_cfg.exceptions.CommitConfigError scrapli_cfg.exceptions.DiffConfigError scrapli_cfg.exceptions.FailedToFetchSpaceAvailable scrapli_cfg.exceptions.GetConfigError scrapli_cfg.exceptions.InsufficientSpaceAvailable scrapli_cfg.exceptions.InvalidConfigTarget scrapli_cfg.exceptions.LoadConfigError","title":"Descendants"},{"location":"api_docs/exceptions/#diffconfigerror","text":"For errors diffing a configuration Expand source code class DiffConfigError(ConfigError): \"\"\"For errors diffing a configuration\"\"\"","title":"DiffConfigError"},{"location":"api_docs/exceptions/#ancestors-in-mro_4","text":"scrapli_cfg.exceptions.ConfigError scrapli_cfg.exceptions.ScrapliCfgException scrapli.exceptions.ScrapliException builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"api_docs/exceptions/#failedtodeterminedevicestate","text":"For issues determining device state (i.e. what mode is file prompt in, etc.) Expand source code class FailedToDetermineDeviceState(ScrapliCfgException): \"\"\"For issues determining device state (i.e. what mode is file prompt in, etc.)\"\"\"","title":"FailedToDetermineDeviceState"},{"location":"api_docs/exceptions/#ancestors-in-mro_5","text":"scrapli_cfg.exceptions.ScrapliCfgException scrapli.exceptions.ScrapliException builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"api_docs/exceptions/#failedtofetchspaceavailable","text":"Unable to determine space available on filesystem Expand source code class FailedToFetchSpaceAvailable(ConfigError): \"\"\"Unable to determine space available on filesystem\"\"\"","title":"FailedToFetchSpaceAvailable"},{"location":"api_docs/exceptions/#ancestors-in-mro_6","text":"scrapli_cfg.exceptions.ConfigError scrapli_cfg.exceptions.ScrapliCfgException scrapli.exceptions.ScrapliException builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"api_docs/exceptions/#getconfigerror","text":"For errors getting configuration from a device Expand source code class GetConfigError(ConfigError): \"\"\"For errors getting configuration from a device\"\"\"","title":"GetConfigError"},{"location":"api_docs/exceptions/#ancestors-in-mro_7","text":"scrapli_cfg.exceptions.ConfigError scrapli_cfg.exceptions.ScrapliCfgException scrapli.exceptions.ScrapliException builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"api_docs/exceptions/#insufficientspaceavailable","text":"If space available on filesystem is insufficient Expand source code class InsufficientSpaceAvailable(ConfigError): \"\"\"If space available on filesystem is insufficient\"\"\"","title":"InsufficientSpaceAvailable"},{"location":"api_docs/exceptions/#ancestors-in-mro_8","text":"scrapli_cfg.exceptions.ConfigError scrapli_cfg.exceptions.ScrapliCfgException scrapli.exceptions.ScrapliException builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"api_docs/exceptions/#invalidconfigtarget","text":"User has provided an invalid configuration target Expand source code class InvalidConfigTarget(ConfigError): \"\"\"User has provided an invalid configuration target\"\"\"","title":"InvalidConfigTarget"},{"location":"api_docs/exceptions/#ancestors-in-mro_9","text":"scrapli_cfg.exceptions.ConfigError scrapli_cfg.exceptions.ScrapliCfgException scrapli.exceptions.ScrapliException builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"api_docs/exceptions/#loadconfigerror","text":"For errors loading a configuration Expand source code class LoadConfigError(ConfigError): \"\"\"For errors loading a configuration\"\"\"","title":"LoadConfigError"},{"location":"api_docs/exceptions/#ancestors-in-mro_10","text":"scrapli_cfg.exceptions.ConfigError scrapli_cfg.exceptions.ScrapliCfgException scrapli.exceptions.ScrapliException builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"api_docs/exceptions/#scraplicfgexception","text":"Base scrapli_cfg exception Expand source code class ScrapliCfgException(ScrapliException): # type: ignore \"\"\"Base scrapli_cfg exception\"\"\"","title":"ScrapliCfgException"},{"location":"api_docs/exceptions/#ancestors-in-mro_11","text":"scrapli.exceptions.ScrapliException builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"api_docs/exceptions/#descendants_1","text":"scrapli_cfg.exceptions.CleanupError scrapli_cfg.exceptions.ConfigError scrapli_cfg.exceptions.FailedToDetermineDeviceState scrapli_cfg.exceptions.TemplateError scrapli_cfg.exceptions.VersionError","title":"Descendants"},{"location":"api_docs/exceptions/#templateerror","text":"For errors relating to configuration templates Expand source code class TemplateError(ScrapliCfgException): \"\"\"For errors relating to configuration templates\"\"\"","title":"TemplateError"},{"location":"api_docs/exceptions/#ancestors-in-mro_12","text":"scrapli_cfg.exceptions.ScrapliCfgException scrapli.exceptions.ScrapliException builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"api_docs/exceptions/#versionerror","text":"For errors related to getting/parsing/invalid versions Expand source code class VersionError(ScrapliCfgException): \"\"\"For errors related to getting/parsing/invalid versions\"\"\"","title":"VersionError"},{"location":"api_docs/exceptions/#ancestors-in-mro_13","text":"scrapli_cfg.exceptions.ScrapliCfgException scrapli.exceptions.ScrapliException builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"api_docs/factory/","text":"window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting()) Module scrapli_cfg.factory \u00b6 scrapli_cfg.factory Expand source code \"\"\"scrapli_cfg.factory\"\"\" from typing import TYPE_CHECKING, Any, Callable, List, Optional from scrapli.driver.network import AsyncNetworkDriver, NetworkDriver from scrapli_cfg.exceptions import ScrapliCfgException from scrapli_cfg.logging import logger from scrapli_cfg.platform.core.arista_eos import AsyncScrapliCfgEOS, ScrapliCfgEOS from scrapli_cfg.platform.core.cisco_iosxe import AsyncScrapliCfgIOSXE, ScrapliCfgIOSXE from scrapli_cfg.platform.core.cisco_iosxr import AsyncScrapliCfgIOSXR, ScrapliCfgIOSXR from scrapli_cfg.platform.core.cisco_nxos import AsyncScrapliCfgNXOS, ScrapliCfgNXOS if TYPE_CHECKING: from scrapli_cfg.platform.base.async_platform import AsyncScrapliCfgPlatform from scrapli_cfg.platform.base.sync_platform import ScrapliCfgPlatform ASYNC_CORE_PLATFORM_MAP = { \"arista_eos\": AsyncScrapliCfgEOS, \"cisco_iosxe\": AsyncScrapliCfgIOSXE, \"cisco_iosxr\": AsyncScrapliCfgIOSXR, \"cisco_nxos\": AsyncScrapliCfgNXOS, } SYNC_CORE_PLATFORM_MAP = { \"arista_eos\": ScrapliCfgEOS, \"cisco_iosxe\": ScrapliCfgIOSXE, \"cisco_iosxr\": ScrapliCfgIOSXR, \"cisco_nxos\": ScrapliCfgNXOS, } def ScrapliCfg( platform: str, conn: NetworkDriver, config_sources: Optional[List[str]] = None, on_open: Optional[Callable[..., Any]] = None, **kwargs: Any, ) -> \"ScrapliCfgPlatform\": \"\"\" Scrapli Config Sync Factory Return a sync scrapli config object for the provided platform. Prefer to use factory classes just so that the naming convention (w/ upper case things) is \"right\", but given that the class version inherited from the base ScrapliCfgPlatform and did not implement the abstract methods this felt like a better move. Args: platform: string name of platform -- i.e. cisco_iosxe, arista_eos conn: scrapli connection to use config_sources: list of config sources on_open: async callable to run at connection open kwargs: keyword args to pass to the scrapli_cfg object (for things like iosxe 'filesystem' argument) Returns: ScrapliCfg: sync scrapli cfg object Raises: ScrapliCfgException: if platform is not a string \"\"\" logger.debug(\"Scrapli factory initialized\") if not isinstance(platform, str): raise ScrapliCfgException(f\"Argument 'platform' must be 'str' got '{type(platform)}'\") platform_class = SYNC_CORE_PLATFORM_MAP.get(platform) if not platform_class: raise ScrapliCfgException(f\"platform '{platform}' not a valid platform name\") final_platform: \"ScrapliCfgPlatform\" = platform_class( conn=conn, config_sources=config_sources, on_open=on_open, **kwargs ) return final_platform def AsyncScrapliCfg( platform: str, conn: AsyncNetworkDriver, config_sources: Optional[List[str]] = None, on_open: Optional[Callable[..., Any]] = None, **kwargs: Any, ) -> \"AsyncScrapliCfgPlatform\": \"\"\" Scrapli Config Async Factory Return a async scrapli config object for the provided platform. Prefer to use factory classes just so that the naming convention (w/ upper case things) is \"right\", but given that the class version inherited from the base ScrapliCfgPlatform and did not implement the abstract methods this felt like a better move. Args: platform: string name of platform -- i.e. cisco_iosxe, arista_eos conn: scrapli connection to use config_sources: list of config sources on_open: async callable to run at connection open kwargs: keyword args to pass to the scrapli_cfg object (for things like iosxe 'filesystem' argument) Returns: AsyncScrapliCfg: async scrapli cfg object Raises: ScrapliCfgException: if platform is not a string \"\"\" logger.debug(\"Scrapli factory initialized\") if not isinstance(platform, str): raise ScrapliCfgException(f\"Argument 'platform' must be 'str' got '{type(platform)}'\") platform_class = ASYNC_CORE_PLATFORM_MAP.get(platform) if not platform_class: raise ScrapliCfgException(f\"platform '{platform}' not a valid platform name\") final_platform: \"AsyncScrapliCfgPlatform\" = platform_class( conn=conn, config_sources=config_sources, on_open=on_open, **kwargs ) return final_platform Functions \u00b6 AsyncScrapliCfg \u00b6 AsyncScrapliCfg(platform: str, conn: scrapli.driver.network.async_driver.AsyncNetworkDriver, config_sources: Union[List[str], NoneType] = None, on_open: Union[Callable[..., Any], NoneType] = None, **kwargs: Any) \u2011> AsyncScrapliCfgPlatform Scrapli Config Async Factory Return a async scrapli config object for the provided platform. Prefer to use factory classes just so that the naming convention (w/ upper case things) is \"right\", but given that the class version inherited from the base ScrapliCfgPlatform and did not implement the abstract methods this felt like a better move. Args: platform: string name of platform -- i.e. cisco_iosxe, arista_eos conn: scrapli connection to use config_sources: list of config sources on_open: async callable to run at connection open kwargs: keyword args to pass to the scrapli_cfg object (for things like iosxe 'filesystem' argument) Returns: AsyncScrapliCfg: async scrapli cfg object Raises: ScrapliCfgException: if platform is not a string ScrapliCfg \u00b6 ScrapliCfg(platform: str, conn: scrapli.driver.network.sync_driver.NetworkDriver, config_sources: Union[List[str], NoneType] = None, on_open: Union[Callable[..., Any], NoneType] = None, **kwargs: Any) \u2011> ScrapliCfgPlatform Scrapli Config Sync Factory Return a sync scrapli config object for the provided platform. Prefer to use factory classes just so that the naming convention (w/ upper case things) is \"right\", but given that the class version inherited from the base ScrapliCfgPlatform and did not implement the abstract methods this felt like a better move. Args: platform: string name of platform -- i.e. cisco_iosxe, arista_eos conn: scrapli connection to use config_sources: list of config sources on_open: async callable to run at connection open kwargs: keyword args to pass to the scrapli_cfg object (for things like iosxe 'filesystem' argument) Returns: ScrapliCfg: sync scrapli cfg object Raises: ScrapliCfgException: if platform is not a string","title":"Factory"},{"location":"api_docs/factory/#module-scrapli_cfgfactory","text":"scrapli_cfg.factory Expand source code \"\"\"scrapli_cfg.factory\"\"\" from typing import TYPE_CHECKING, Any, Callable, List, Optional from scrapli.driver.network import AsyncNetworkDriver, NetworkDriver from scrapli_cfg.exceptions import ScrapliCfgException from scrapli_cfg.logging import logger from scrapli_cfg.platform.core.arista_eos import AsyncScrapliCfgEOS, ScrapliCfgEOS from scrapli_cfg.platform.core.cisco_iosxe import AsyncScrapliCfgIOSXE, ScrapliCfgIOSXE from scrapli_cfg.platform.core.cisco_iosxr import AsyncScrapliCfgIOSXR, ScrapliCfgIOSXR from scrapli_cfg.platform.core.cisco_nxos import AsyncScrapliCfgNXOS, ScrapliCfgNXOS if TYPE_CHECKING: from scrapli_cfg.platform.base.async_platform import AsyncScrapliCfgPlatform from scrapli_cfg.platform.base.sync_platform import ScrapliCfgPlatform ASYNC_CORE_PLATFORM_MAP = { \"arista_eos\": AsyncScrapliCfgEOS, \"cisco_iosxe\": AsyncScrapliCfgIOSXE, \"cisco_iosxr\": AsyncScrapliCfgIOSXR, \"cisco_nxos\": AsyncScrapliCfgNXOS, } SYNC_CORE_PLATFORM_MAP = { \"arista_eos\": ScrapliCfgEOS, \"cisco_iosxe\": ScrapliCfgIOSXE, \"cisco_iosxr\": ScrapliCfgIOSXR, \"cisco_nxos\": ScrapliCfgNXOS, } def ScrapliCfg( platform: str, conn: NetworkDriver, config_sources: Optional[List[str]] = None, on_open: Optional[Callable[..., Any]] = None, **kwargs: Any, ) -> \"ScrapliCfgPlatform\": \"\"\" Scrapli Config Sync Factory Return a sync scrapli config object for the provided platform. Prefer to use factory classes just so that the naming convention (w/ upper case things) is \"right\", but given that the class version inherited from the base ScrapliCfgPlatform and did not implement the abstract methods this felt like a better move. Args: platform: string name of platform -- i.e. cisco_iosxe, arista_eos conn: scrapli connection to use config_sources: list of config sources on_open: async callable to run at connection open kwargs: keyword args to pass to the scrapli_cfg object (for things like iosxe 'filesystem' argument) Returns: ScrapliCfg: sync scrapli cfg object Raises: ScrapliCfgException: if platform is not a string \"\"\" logger.debug(\"Scrapli factory initialized\") if not isinstance(platform, str): raise ScrapliCfgException(f\"Argument 'platform' must be 'str' got '{type(platform)}'\") platform_class = SYNC_CORE_PLATFORM_MAP.get(platform) if not platform_class: raise ScrapliCfgException(f\"platform '{platform}' not a valid platform name\") final_platform: \"ScrapliCfgPlatform\" = platform_class( conn=conn, config_sources=config_sources, on_open=on_open, **kwargs ) return final_platform def AsyncScrapliCfg( platform: str, conn: AsyncNetworkDriver, config_sources: Optional[List[str]] = None, on_open: Optional[Callable[..., Any]] = None, **kwargs: Any, ) -> \"AsyncScrapliCfgPlatform\": \"\"\" Scrapli Config Async Factory Return a async scrapli config object for the provided platform. Prefer to use factory classes just so that the naming convention (w/ upper case things) is \"right\", but given that the class version inherited from the base ScrapliCfgPlatform and did not implement the abstract methods this felt like a better move. Args: platform: string name of platform -- i.e. cisco_iosxe, arista_eos conn: scrapli connection to use config_sources: list of config sources on_open: async callable to run at connection open kwargs: keyword args to pass to the scrapli_cfg object (for things like iosxe 'filesystem' argument) Returns: AsyncScrapliCfg: async scrapli cfg object Raises: ScrapliCfgException: if platform is not a string \"\"\" logger.debug(\"Scrapli factory initialized\") if not isinstance(platform, str): raise ScrapliCfgException(f\"Argument 'platform' must be 'str' got '{type(platform)}'\") platform_class = ASYNC_CORE_PLATFORM_MAP.get(platform) if not platform_class: raise ScrapliCfgException(f\"platform '{platform}' not a valid platform name\") final_platform: \"AsyncScrapliCfgPlatform\" = platform_class( conn=conn, config_sources=config_sources, on_open=on_open, **kwargs ) return final_platform","title":"Module scrapli_cfg.factory"},{"location":"api_docs/factory/#functions","text":"","title":"Functions"},{"location":"api_docs/factory/#asyncscraplicfg","text":"AsyncScrapliCfg(platform: str, conn: scrapli.driver.network.async_driver.AsyncNetworkDriver, config_sources: Union[List[str], NoneType] = None, on_open: Union[Callable[..., Any], NoneType] = None, **kwargs: Any) \u2011> AsyncScrapliCfgPlatform Scrapli Config Async Factory Return a async scrapli config object for the provided platform. Prefer to use factory classes just so that the naming convention (w/ upper case things) is \"right\", but given that the class version inherited from the base ScrapliCfgPlatform and did not implement the abstract methods this felt like a better move. Args: platform: string name of platform -- i.e. cisco_iosxe, arista_eos conn: scrapli connection to use config_sources: list of config sources on_open: async callable to run at connection open kwargs: keyword args to pass to the scrapli_cfg object (for things like iosxe 'filesystem' argument) Returns: AsyncScrapliCfg: async scrapli cfg object Raises: ScrapliCfgException: if platform is not a string","title":"AsyncScrapliCfg"},{"location":"api_docs/factory/#scraplicfg","text":"ScrapliCfg(platform: str, conn: scrapli.driver.network.sync_driver.NetworkDriver, config_sources: Union[List[str], NoneType] = None, on_open: Union[Callable[..., Any], NoneType] = None, **kwargs: Any) \u2011> ScrapliCfgPlatform Scrapli Config Sync Factory Return a sync scrapli config object for the provided platform. Prefer to use factory classes just so that the naming convention (w/ upper case things) is \"right\", but given that the class version inherited from the base ScrapliCfgPlatform and did not implement the abstract methods this felt like a better move. Args: platform: string name of platform -- i.e. cisco_iosxe, arista_eos conn: scrapli connection to use config_sources: list of config sources on_open: async callable to run at connection open kwargs: keyword args to pass to the scrapli_cfg object (for things like iosxe 'filesystem' argument) Returns: ScrapliCfg: sync scrapli cfg object Raises: ScrapliCfgException: if platform is not a string","title":"ScrapliCfg"},{"location":"api_docs/logging/","text":"window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting()) Module scrapli_cfg.logging \u00b6 scrapli_cfg.logging Expand source code \"\"\"scrapli_cfg.logging\"\"\" from logging import FileHandler, NullHandler, getLogger from typing import Union from scrapli.logging import ScrapliFileHandler, ScrapliFormatter def enable_basic_logging( file: Union[str, bool] = False, level: str = \"info\", caller_info: bool = False, buffer_log: bool = True, ) -> None: \"\"\" Enable opinionated logging for scrapli_cfg Uses scrapli \"core\" formatter/file handler Args: file: True to output to default log path (\"scrapli.log\"), otherwise string path to write log file to level: string name of logging level to use, i.e. \"info\", \"debug\", etc. caller_info: add info about module/function/line in the log entry buffer_log: buffer log read outputs Returns: None Raises: N/A \"\"\" logger.propagate = False logger.setLevel(level=level.upper()) scrapli_formatter = ScrapliFormatter(caller_info=caller_info) if file: if isinstance(file, bool): filename = \"scrapli_cfg.log\" else: filename = file if not buffer_log: fh = FileHandler(filename=filename, mode=\"w\") else: fh = ScrapliFileHandler(filename=filename, mode=\"w\") fh.setFormatter(scrapli_formatter) logger.addHandler(fh) logger = getLogger(\"scrapli_cfg\") logger.addHandler(NullHandler()) Functions \u00b6 enable_basic_logging \u00b6 enable_basic_logging(file: Union[str, bool] = False, level: str = 'info', caller_info: bool = False, buffer_log: bool = True) \u2011> NoneType Enable opinionated logging for scrapli_cfg Uses scrapli \"core\" formatter/file handler Args: file: True to output to default log path (\"scrapli.log\"), otherwise string path to write log file to level: string name of logging level to use, i.e. \"info\", \"debug\", etc. caller_info: add info about module/function/line in the log entry buffer_log: buffer log read outputs Returns: None Raises: N/A","title":"Logging"},{"location":"api_docs/logging/#module-scrapli_cfglogging","text":"scrapli_cfg.logging Expand source code \"\"\"scrapli_cfg.logging\"\"\" from logging import FileHandler, NullHandler, getLogger from typing import Union from scrapli.logging import ScrapliFileHandler, ScrapliFormatter def enable_basic_logging( file: Union[str, bool] = False, level: str = \"info\", caller_info: bool = False, buffer_log: bool = True, ) -> None: \"\"\" Enable opinionated logging for scrapli_cfg Uses scrapli \"core\" formatter/file handler Args: file: True to output to default log path (\"scrapli.log\"), otherwise string path to write log file to level: string name of logging level to use, i.e. \"info\", \"debug\", etc. caller_info: add info about module/function/line in the log entry buffer_log: buffer log read outputs Returns: None Raises: N/A \"\"\" logger.propagate = False logger.setLevel(level=level.upper()) scrapli_formatter = ScrapliFormatter(caller_info=caller_info) if file: if isinstance(file, bool): filename = \"scrapli_cfg.log\" else: filename = file if not buffer_log: fh = FileHandler(filename=filename, mode=\"w\") else: fh = ScrapliFileHandler(filename=filename, mode=\"w\") fh.setFormatter(scrapli_formatter) logger.addHandler(fh) logger = getLogger(\"scrapli_cfg\") logger.addHandler(NullHandler())","title":"Module scrapli_cfg.logging"},{"location":"api_docs/logging/#functions","text":"","title":"Functions"},{"location":"api_docs/logging/#enable_basic_logging","text":"enable_basic_logging(file: Union[str, bool] = False, level: str = 'info', caller_info: bool = False, buffer_log: bool = True) \u2011> NoneType Enable opinionated logging for scrapli_cfg Uses scrapli \"core\" formatter/file handler Args: file: True to output to default log path (\"scrapli.log\"), otherwise string path to write log file to level: string name of logging level to use, i.e. \"info\", \"debug\", etc. caller_info: add info about module/function/line in the log entry buffer_log: buffer log read outputs Returns: None Raises: N/A","title":"enable_basic_logging"},{"location":"api_docs/response/","text":"window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting()) Module scrapli_cfg.response \u00b6 scrapli_cfg.response Expand source code \"\"\"scrapli_cfg.response\"\"\" from datetime import datetime from typing import List, Optional, Type, Union from scrapli.response import MultiResponse, Response from scrapli_cfg.exceptions import ScrapliCfgException class ScrapliCfgResponse: def __init__( self, host: str, raise_for_status_exception: Type[Exception] = ScrapliCfgException ) -> None: \"\"\" Scrapli CFG Response object Args: host: host that was operated on raise_for_status_exception: exception to raise if response is failed and user calls `raise_for_status` Returns: N/A Raises: N/A \"\"\" self.host = host self.start_time = datetime.now() self.finish_time: Optional[datetime] = None self.elapsed_time: Optional[float] = None self.scrapli_responses: Optional[List[Union[Response, MultiResponse]]] = None self.result: str = \"\" self.raise_for_status_exception = raise_for_status_exception self.failed = True def __bool__(self) -> bool: \"\"\" Magic bool method based on operation being failed or not Args: N/A Returns: bool: True/False if channel_input failed Raises: N/A \"\"\" return self.failed def __repr__(self) -> str: \"\"\" Magic repr method for ScrapliCfgResponse class Args: N/A Returns: str: repr for class object Raises: N/A \"\"\" return f\"ScrapliCfgResponse \" def __str__(self) -> str: \"\"\" Magic str method for ScrapliCfgResponse class Args: N/A Returns: str: str for class object Raises: N/A \"\"\" return f\"ScrapliCfgResponse \" def record_response( self, scrapli_responses: List[Union[Response, MultiResponse]], result: str = \"\" ) -> None: \"\"\" Record channel_input results and elapsed time of channel input/reading output Args: scrapli_responses: list of scrapli response objects result: string to assign to final result for the scrapli cfg response object Returns: None Raises: N/A \"\"\" self.finish_time = datetime.now() self.elapsed_time = (self.finish_time - self.start_time).total_seconds() self.scrapli_responses = scrapli_responses self.result = result if not any(response.failed for response in self.scrapli_responses): self.failed = False def raise_for_status(self) -> None: \"\"\" Raise a `ScrapliCommandFailure` if command/config failed Args: N/A Returns: None Raises: raise_for_status_exception: exception raised is dependent on the type of response object \"\"\" if self.failed: raise self.raise_for_status_exception() Classes \u00b6 ScrapliCfgResponse \u00b6 Scrapli CFG Response object Args: host: host that was operated on raise_for_status_exception: exception to raise if response is failed and user calls `raise_for_status` Returns: N/A Raises: N/A Expand source code class ScrapliCfgResponse: def __init__( self, host: str, raise_for_status_exception: Type[Exception] = ScrapliCfgException ) -> None: \"\"\" Scrapli CFG Response object Args: host: host that was operated on raise_for_status_exception: exception to raise if response is failed and user calls `raise_for_status` Returns: N/A Raises: N/A \"\"\" self.host = host self.start_time = datetime.now() self.finish_time: Optional[datetime] = None self.elapsed_time: Optional[float] = None self.scrapli_responses: Optional[List[Union[Response, MultiResponse]]] = None self.result: str = \"\" self.raise_for_status_exception = raise_for_status_exception self.failed = True def __bool__(self) -> bool: \"\"\" Magic bool method based on operation being failed or not Args: N/A Returns: bool: True/False if channel_input failed Raises: N/A \"\"\" return self.failed def __repr__(self) -> str: \"\"\" Magic repr method for ScrapliCfgResponse class Args: N/A Returns: str: repr for class object Raises: N/A \"\"\" return f\"ScrapliCfgResponse \" def __str__(self) -> str: \"\"\" Magic str method for ScrapliCfgResponse class Args: N/A Returns: str: str for class object Raises: N/A \"\"\" return f\"ScrapliCfgResponse \" def record_response( self, scrapli_responses: List[Union[Response, MultiResponse]], result: str = \"\" ) -> None: \"\"\" Record channel_input results and elapsed time of channel input/reading output Args: scrapli_responses: list of scrapli response objects result: string to assign to final result for the scrapli cfg response object Returns: None Raises: N/A \"\"\" self.finish_time = datetime.now() self.elapsed_time = (self.finish_time - self.start_time).total_seconds() self.scrapli_responses = scrapli_responses self.result = result if not any(response.failed for response in self.scrapli_responses): self.failed = False def raise_for_status(self) -> None: \"\"\" Raise a `ScrapliCommandFailure` if command/config failed Args: N/A Returns: None Raises: raise_for_status_exception: exception raised is dependent on the type of response object \"\"\" if self.failed: raise self.raise_for_status_exception() Descendants \u00b6 scrapli_cfg.diff.ScrapliCfgDiffResponse Methods \u00b6 raise_for_status \u00b6 raise_for_status(self) \u2011> NoneType Raise a `ScrapliCommandFailure` if command/config failed Args: N/A Returns: None Raises: raise_for_status_exception: exception raised is dependent on the type of response object record_response \u00b6 record_response(self, scrapli_responses: List[Union[scrapli.response.Response, scrapli.response.MultiResponse]], result: str = '') \u2011> NoneType Record channel_input results and elapsed time of channel input/reading output Args: scrapli_responses: list of scrapli response objects result: string to assign to final result for the scrapli cfg response object Returns: None Raises: N/A","title":"Response"},{"location":"api_docs/response/#module-scrapli_cfgresponse","text":"scrapli_cfg.response Expand source code \"\"\"scrapli_cfg.response\"\"\" from datetime import datetime from typing import List, Optional, Type, Union from scrapli.response import MultiResponse, Response from scrapli_cfg.exceptions import ScrapliCfgException class ScrapliCfgResponse: def __init__( self, host: str, raise_for_status_exception: Type[Exception] = ScrapliCfgException ) -> None: \"\"\" Scrapli CFG Response object Args: host: host that was operated on raise_for_status_exception: exception to raise if response is failed and user calls `raise_for_status` Returns: N/A Raises: N/A \"\"\" self.host = host self.start_time = datetime.now() self.finish_time: Optional[datetime] = None self.elapsed_time: Optional[float] = None self.scrapli_responses: Optional[List[Union[Response, MultiResponse]]] = None self.result: str = \"\" self.raise_for_status_exception = raise_for_status_exception self.failed = True def __bool__(self) -> bool: \"\"\" Magic bool method based on operation being failed or not Args: N/A Returns: bool: True/False if channel_input failed Raises: N/A \"\"\" return self.failed def __repr__(self) -> str: \"\"\" Magic repr method for ScrapliCfgResponse class Args: N/A Returns: str: repr for class object Raises: N/A \"\"\" return f\"ScrapliCfgResponse \" def __str__(self) -> str: \"\"\" Magic str method for ScrapliCfgResponse class Args: N/A Returns: str: str for class object Raises: N/A \"\"\" return f\"ScrapliCfgResponse \" def record_response( self, scrapli_responses: List[Union[Response, MultiResponse]], result: str = \"\" ) -> None: \"\"\" Record channel_input results and elapsed time of channel input/reading output Args: scrapli_responses: list of scrapli response objects result: string to assign to final result for the scrapli cfg response object Returns: None Raises: N/A \"\"\" self.finish_time = datetime.now() self.elapsed_time = (self.finish_time - self.start_time).total_seconds() self.scrapli_responses = scrapli_responses self.result = result if not any(response.failed for response in self.scrapli_responses): self.failed = False def raise_for_status(self) -> None: \"\"\" Raise a `ScrapliCommandFailure` if command/config failed Args: N/A Returns: None Raises: raise_for_status_exception: exception raised is dependent on the type of response object \"\"\" if self.failed: raise self.raise_for_status_exception()","title":"Module scrapli_cfg.response"},{"location":"api_docs/response/#classes","text":"","title":"Classes"},{"location":"api_docs/response/#scraplicfgresponse","text":"Scrapli CFG Response object Args: host: host that was operated on raise_for_status_exception: exception to raise if response is failed and user calls `raise_for_status` Returns: N/A Raises: N/A Expand source code class ScrapliCfgResponse: def __init__( self, host: str, raise_for_status_exception: Type[Exception] = ScrapliCfgException ) -> None: \"\"\" Scrapli CFG Response object Args: host: host that was operated on raise_for_status_exception: exception to raise if response is failed and user calls `raise_for_status` Returns: N/A Raises: N/A \"\"\" self.host = host self.start_time = datetime.now() self.finish_time: Optional[datetime] = None self.elapsed_time: Optional[float] = None self.scrapli_responses: Optional[List[Union[Response, MultiResponse]]] = None self.result: str = \"\" self.raise_for_status_exception = raise_for_status_exception self.failed = True def __bool__(self) -> bool: \"\"\" Magic bool method based on operation being failed or not Args: N/A Returns: bool: True/False if channel_input failed Raises: N/A \"\"\" return self.failed def __repr__(self) -> str: \"\"\" Magic repr method for ScrapliCfgResponse class Args: N/A Returns: str: repr for class object Raises: N/A \"\"\" return f\"ScrapliCfgResponse \" def __str__(self) -> str: \"\"\" Magic str method for ScrapliCfgResponse class Args: N/A Returns: str: str for class object Raises: N/A \"\"\" return f\"ScrapliCfgResponse \" def record_response( self, scrapli_responses: List[Union[Response, MultiResponse]], result: str = \"\" ) -> None: \"\"\" Record channel_input results and elapsed time of channel input/reading output Args: scrapli_responses: list of scrapli response objects result: string to assign to final result for the scrapli cfg response object Returns: None Raises: N/A \"\"\" self.finish_time = datetime.now() self.elapsed_time = (self.finish_time - self.start_time).total_seconds() self.scrapli_responses = scrapli_responses self.result = result if not any(response.failed for response in self.scrapli_responses): self.failed = False def raise_for_status(self) -> None: \"\"\" Raise a `ScrapliCommandFailure` if command/config failed Args: N/A Returns: None Raises: raise_for_status_exception: exception raised is dependent on the type of response object \"\"\" if self.failed: raise self.raise_for_status_exception()","title":"ScrapliCfgResponse"},{"location":"api_docs/response/#descendants","text":"scrapli_cfg.diff.ScrapliCfgDiffResponse","title":"Descendants"},{"location":"api_docs/response/#methods","text":"","title":"Methods"},{"location":"api_docs/response/#raise_for_status","text":"raise_for_status(self) \u2011> NoneType Raise a `ScrapliCommandFailure` if command/config failed Args: N/A Returns: None Raises: raise_for_status_exception: exception raised is dependent on the type of response object","title":"raise_for_status"},{"location":"api_docs/response/#record_response","text":"record_response(self, scrapli_responses: List[Union[scrapli.response.Response, scrapli.response.MultiResponse]], result: str = '') \u2011> NoneType Record channel_input results and elapsed time of channel input/reading output Args: scrapli_responses: list of scrapli response objects result: string to assign to final result for the scrapli cfg response object Returns: None Raises: N/A","title":"record_response"},{"location":"api_docs/platform/base/async_platform/","text":"window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting()) Module scrapli_cfg.platform.base.async_platform \u00b6 scrapli_cfg.platform.async_platform Expand source code \"\"\"scrapli_cfg.platform.async_platform\"\"\" from abc import ABC, abstractmethod from types import TracebackType from typing import Any, Callable, List, Optional, Pattern, Tuple, Type from scrapli.driver import AsyncNetworkDriver from scrapli_cfg.diff import ScrapliCfgDiffResponse from scrapli_cfg.platform.base.base_platform import ScrapliCfgBase from scrapli_cfg.response import ScrapliCfgResponse class AsyncScrapliCfgPlatform(ABC, ScrapliCfgBase): def __init__( self, conn: AsyncNetworkDriver, config_sources: List[str], on_open: Callable[..., Any] ) -> None: \"\"\" Scrapli Config async base class Args: conn: scrapli connection to use config_sources: list of config sources on_open: async callable to run at connection open Returns: None Raises: N/A \"\"\" self.conn = conn self.on_open = on_open super().__init__(config_sources=config_sources) async def open(self) -> None: \"\"\" Open the connection and prepare for config operations Does \"normal\" scrapli open things, but also runs the _on_open method of scrapli config which generally does things like disable console logging Args: N/A Returns: None Raises: N/A \"\"\" self.logger.info(\"opening scrapli connection\") if not self.conn.isalive(): await self.conn.open() if self._ignore_version is False: self.logger.debug(\"ignore_version is False, fetching device version\") version_response = await self.get_version() self._validate_and_set_version(version_response=version_response) self.logger.debug(\"executing scrapli_cfg on open method\") await self.on_open(self) async def close(self) -> None: \"\"\" Close the scrapli connection Args: N/A Returns: None Raises: N/A \"\"\" self.logger.info(\"closing scrapli connection\") if self.conn.isalive(): await self.conn.close() async def __aenter__(self) -> \"AsyncScrapliCfgPlatform\": \"\"\" Enter method for async context manager Args: N/A Returns: AsyncScrapliCfg: opened AsyncScrapliCfg object Raises: N/A \"\"\" await self.open() return self async def __aexit__( self, exception_type: Optional[Type[BaseException]], exception_value: Optional[BaseException], traceback: Optional[TracebackType], ) -> None: \"\"\" Exit method to cleanup for async context manager Args: exception_type: exception type being raised exception_value: message from exception being raised traceback: traceback from exception being raised Returns: None Raises: N/A \"\"\" await self.close() async def get_version(self) -> ScrapliCfgResponse: \"\"\" Get device version string Args: N/A Returns: ScrapliCfgResponse: response object where result is the string of the primary version (as in the \"main\" os version) of the device Raises: N/A \"\"\" response = self._pre_get_version() version_result = await self.conn.send_command(command=self._get_version_command) return self._post_get_version( response=response, scrapli_responses=[version_result], result=self._parse_version(device_output=version_result.result), # type: ignore # noqa ) @abstractmethod async def get_config(self, source: str = \"running\") -> ScrapliCfgResponse: \"\"\" Get device configuration Args: source: name of the config source, generally running|startup Returns: ScrapliCfgResponse: response object containing string of the target config source as the `result` attribute Raises: N/A \"\"\" @abstractmethod async def load_config( self, config: str, replace: bool = False, **kwargs: Any ) -> ScrapliCfgResponse: \"\"\" Load configuration to a device Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see your specific platform for details Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" @abstractmethod async def abort_config(self) -> ScrapliCfgResponse: \"\"\" Abort a configuration -- discards any loaded config Args: N/A Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" @abstractmethod async def commit_config(self, source: str = \"running\") -> ScrapliCfgResponse: \"\"\" Commit a loaded configuration Args: source: name of the config source to commit against, generally running|startup Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" @abstractmethod async def diff_config(self, source: str = \"running\") -> ScrapliCfgDiffResponse: \"\"\" Diff a loaded configuration against the source config store Args: source: name of the config source to diff against, generally running|startup -- device diffs will generally not care about this argument, but the built in scrapli differ will Returns: ScrapliCfgDiffResponse: scrapli cfg diff object Raises: N/A \"\"\" async def render_substituted_config( self, config_template: str, substitutes: List[Tuple[str, Pattern[str]]], source: str = \"running\", ) -> str: \"\"\" Render a substituted configuration file Renders a configuration based on a user template, substitutes, and a target config from the device. Args: config_template: config file to use as the base for substitutions -- should contain jinja2-like variables that will be replaced with data fetched from the source config by the substitutes patterns substitutes: tuple of name, pattern -- where name matches the jinja2-like variable in the config_template file, and pattern is a compiled regular expression pattern to be used to fetch that section from the source config source: config source to use for the substitution efforts, typically running|startup Returns: str: substituted/rendered config Raises: N/A \"\"\" self.logger.info(\"fetching configuration and replacing with provided substitutes\") source_config = await self.get_config(source=source) return self._render_substituted_config( config_template=config_template, substitutes=substitutes, source_config=source_config.result, ) Classes \u00b6 AsyncScrapliCfgPlatform \u00b6 Helper class that provides a standard way to create an ABC using inheritance. Scrapli Config async base class Args: conn: scrapli connection to use config_sources: list of config sources on_open: async callable to run at connection open Returns: None Raises: N/A Expand source code class AsyncScrapliCfgPlatform(ABC, ScrapliCfgBase): def __init__( self, conn: AsyncNetworkDriver, config_sources: List[str], on_open: Callable[..., Any] ) -> None: \"\"\" Scrapli Config async base class Args: conn: scrapli connection to use config_sources: list of config sources on_open: async callable to run at connection open Returns: None Raises: N/A \"\"\" self.conn = conn self.on_open = on_open super().__init__(config_sources=config_sources) async def open(self) -> None: \"\"\" Open the connection and prepare for config operations Does \"normal\" scrapli open things, but also runs the _on_open method of scrapli config which generally does things like disable console logging Args: N/A Returns: None Raises: N/A \"\"\" self.logger.info(\"opening scrapli connection\") if not self.conn.isalive(): await self.conn.open() if self._ignore_version is False: self.logger.debug(\"ignore_version is False, fetching device version\") version_response = await self.get_version() self._validate_and_set_version(version_response=version_response) self.logger.debug(\"executing scrapli_cfg on open method\") await self.on_open(self) async def close(self) -> None: \"\"\" Close the scrapli connection Args: N/A Returns: None Raises: N/A \"\"\" self.logger.info(\"closing scrapli connection\") if self.conn.isalive(): await self.conn.close() async def __aenter__(self) -> \"AsyncScrapliCfgPlatform\": \"\"\" Enter method for async context manager Args: N/A Returns: AsyncScrapliCfg: opened AsyncScrapliCfg object Raises: N/A \"\"\" await self.open() return self async def __aexit__( self, exception_type: Optional[Type[BaseException]], exception_value: Optional[BaseException], traceback: Optional[TracebackType], ) -> None: \"\"\" Exit method to cleanup for async context manager Args: exception_type: exception type being raised exception_value: message from exception being raised traceback: traceback from exception being raised Returns: None Raises: N/A \"\"\" await self.close() async def get_version(self) -> ScrapliCfgResponse: \"\"\" Get device version string Args: N/A Returns: ScrapliCfgResponse: response object where result is the string of the primary version (as in the \"main\" os version) of the device Raises: N/A \"\"\" response = self._pre_get_version() version_result = await self.conn.send_command(command=self._get_version_command) return self._post_get_version( response=response, scrapli_responses=[version_result], result=self._parse_version(device_output=version_result.result), # type: ignore # noqa ) @abstractmethod async def get_config(self, source: str = \"running\") -> ScrapliCfgResponse: \"\"\" Get device configuration Args: source: name of the config source, generally running|startup Returns: ScrapliCfgResponse: response object containing string of the target config source as the `result` attribute Raises: N/A \"\"\" @abstractmethod async def load_config( self, config: str, replace: bool = False, **kwargs: Any ) -> ScrapliCfgResponse: \"\"\" Load configuration to a device Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see your specific platform for details Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" @abstractmethod async def abort_config(self) -> ScrapliCfgResponse: \"\"\" Abort a configuration -- discards any loaded config Args: N/A Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" @abstractmethod async def commit_config(self, source: str = \"running\") -> ScrapliCfgResponse: \"\"\" Commit a loaded configuration Args: source: name of the config source to commit against, generally running|startup Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" @abstractmethod async def diff_config(self, source: str = \"running\") -> ScrapliCfgDiffResponse: \"\"\" Diff a loaded configuration against the source config store Args: source: name of the config source to diff against, generally running|startup -- device diffs will generally not care about this argument, but the built in scrapli differ will Returns: ScrapliCfgDiffResponse: scrapli cfg diff object Raises: N/A \"\"\" async def render_substituted_config( self, config_template: str, substitutes: List[Tuple[str, Pattern[str]]], source: str = \"running\", ) -> str: \"\"\" Render a substituted configuration file Renders a configuration based on a user template, substitutes, and a target config from the device. Args: config_template: config file to use as the base for substitutions -- should contain jinja2-like variables that will be replaced with data fetched from the source config by the substitutes patterns substitutes: tuple of name, pattern -- where name matches the jinja2-like variable in the config_template file, and pattern is a compiled regular expression pattern to be used to fetch that section from the source config source: config source to use for the substitution efforts, typically running|startup Returns: str: substituted/rendered config Raises: N/A \"\"\" self.logger.info(\"fetching configuration and replacing with provided substitutes\") source_config = await self.get_config(source=source) return self._render_substituted_config( config_template=config_template, substitutes=substitutes, source_config=source_config.result, ) Ancestors (in MRO) \u00b6 abc.ABC scrapli_cfg.platform.base.base_platform.ScrapliCfgBase Descendants \u00b6 scrapli_cfg.platform.core.arista_eos.async_platform.AsyncScrapliCfgEOS scrapli_cfg.platform.core.cisco_iosxe.async_platform.AsyncScrapliCfgIOSXE scrapli_cfg.platform.core.cisco_iosxr.async_platform.AsyncScrapliCfgIOSXR scrapli_cfg.platform.core.cisco_nxos.async_platform.AsyncScrapliCfgNXOS Class variables \u00b6 conn: Union[scrapli.driver.network.sync_driver.NetworkDriver, scrapli.driver.network.async_driver.AsyncNetworkDriver] Methods \u00b6 abort_config \u00b6 abort_config(self) \u2011> scrapli_cfg.response.ScrapliCfgResponse Abort a configuration -- discards any loaded config Args: N/A Returns: ScrapliCfgResponse: response object Raises: N/A close \u00b6 close(self) \u2011> NoneType Close the scrapli connection Args: N/A Returns: None Raises: N/A commit_config \u00b6 commit_config(self, source: str = 'running') \u2011> scrapli_cfg.response.ScrapliCfgResponse Commit a loaded configuration Args: source: name of the config source to commit against, generally running|startup Returns: ScrapliCfgResponse: response object Raises: N/A diff_config \u00b6 diff_config(self, source: str = 'running') \u2011> scrapli_cfg.diff.ScrapliCfgDiffResponse Diff a loaded configuration against the source config store Args: source: name of the config source to diff against, generally running|startup -- device diffs will generally not care about this argument, but the built in scrapli differ will Returns: ScrapliCfgDiffResponse: scrapli cfg diff object Raises: N/A get_config \u00b6 get_config(self, source: str = 'running') \u2011> scrapli_cfg.response.ScrapliCfgResponse Get device configuration Args: source: name of the config source, generally running|startup Returns: ScrapliCfgResponse: response object containing string of the target config source as the `result` attribute Raises: N/A get_version \u00b6 get_version(self) \u2011> scrapli_cfg.response.ScrapliCfgResponse Get device version string Args: N/A Returns: ScrapliCfgResponse: response object where result is the string of the primary version (as in the \"main\" os version) of the device Raises: N/A load_config \u00b6 load_config(self, config: str, replace: bool = False, **kwargs: Any) \u2011> scrapli_cfg.response.ScrapliCfgResponse Load configuration to a device Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see your specific platform for details Returns: ScrapliCfgResponse: response object Raises: N/A open \u00b6 open(self) \u2011> NoneType Open the connection and prepare for config operations Does \"normal\" scrapli open things, but also runs the _on_open method of scrapli config which generally does things like disable console logging Args: N/A Returns: None Raises: N/A render_substituted_config \u00b6 render_substituted_config(self, config_template: str, substitutes: List[Tuple[str, Pattern[str]]], source: str = 'running') \u2011> str Render a substituted configuration file Renders a configuration based on a user template, substitutes, and a target config from the device. Args: config_template: config file to use as the base for substitutions -- should contain jinja2-like variables that will be replaced with data fetched from the source config by the substitutes patterns substitutes: tuple of name, pattern -- where name matches the jinja2-like variable in the config_template file, and pattern is a compiled regular expression pattern to be used to fetch that section from the source config source: config source to use for the substitution efforts, typically running|startup Returns: str: substituted/rendered config Raises: N/A","title":"Async Platform"},{"location":"api_docs/platform/base/async_platform/#module-scrapli_cfgplatformbaseasync_platform","text":"scrapli_cfg.platform.async_platform Expand source code \"\"\"scrapli_cfg.platform.async_platform\"\"\" from abc import ABC, abstractmethod from types import TracebackType from typing import Any, Callable, List, Optional, Pattern, Tuple, Type from scrapli.driver import AsyncNetworkDriver from scrapli_cfg.diff import ScrapliCfgDiffResponse from scrapli_cfg.platform.base.base_platform import ScrapliCfgBase from scrapli_cfg.response import ScrapliCfgResponse class AsyncScrapliCfgPlatform(ABC, ScrapliCfgBase): def __init__( self, conn: AsyncNetworkDriver, config_sources: List[str], on_open: Callable[..., Any] ) -> None: \"\"\" Scrapli Config async base class Args: conn: scrapli connection to use config_sources: list of config sources on_open: async callable to run at connection open Returns: None Raises: N/A \"\"\" self.conn = conn self.on_open = on_open super().__init__(config_sources=config_sources) async def open(self) -> None: \"\"\" Open the connection and prepare for config operations Does \"normal\" scrapli open things, but also runs the _on_open method of scrapli config which generally does things like disable console logging Args: N/A Returns: None Raises: N/A \"\"\" self.logger.info(\"opening scrapli connection\") if not self.conn.isalive(): await self.conn.open() if self._ignore_version is False: self.logger.debug(\"ignore_version is False, fetching device version\") version_response = await self.get_version() self._validate_and_set_version(version_response=version_response) self.logger.debug(\"executing scrapli_cfg on open method\") await self.on_open(self) async def close(self) -> None: \"\"\" Close the scrapli connection Args: N/A Returns: None Raises: N/A \"\"\" self.logger.info(\"closing scrapli connection\") if self.conn.isalive(): await self.conn.close() async def __aenter__(self) -> \"AsyncScrapliCfgPlatform\": \"\"\" Enter method for async context manager Args: N/A Returns: AsyncScrapliCfg: opened AsyncScrapliCfg object Raises: N/A \"\"\" await self.open() return self async def __aexit__( self, exception_type: Optional[Type[BaseException]], exception_value: Optional[BaseException], traceback: Optional[TracebackType], ) -> None: \"\"\" Exit method to cleanup for async context manager Args: exception_type: exception type being raised exception_value: message from exception being raised traceback: traceback from exception being raised Returns: None Raises: N/A \"\"\" await self.close() async def get_version(self) -> ScrapliCfgResponse: \"\"\" Get device version string Args: N/A Returns: ScrapliCfgResponse: response object where result is the string of the primary version (as in the \"main\" os version) of the device Raises: N/A \"\"\" response = self._pre_get_version() version_result = await self.conn.send_command(command=self._get_version_command) return self._post_get_version( response=response, scrapli_responses=[version_result], result=self._parse_version(device_output=version_result.result), # type: ignore # noqa ) @abstractmethod async def get_config(self, source: str = \"running\") -> ScrapliCfgResponse: \"\"\" Get device configuration Args: source: name of the config source, generally running|startup Returns: ScrapliCfgResponse: response object containing string of the target config source as the `result` attribute Raises: N/A \"\"\" @abstractmethod async def load_config( self, config: str, replace: bool = False, **kwargs: Any ) -> ScrapliCfgResponse: \"\"\" Load configuration to a device Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see your specific platform for details Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" @abstractmethod async def abort_config(self) -> ScrapliCfgResponse: \"\"\" Abort a configuration -- discards any loaded config Args: N/A Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" @abstractmethod async def commit_config(self, source: str = \"running\") -> ScrapliCfgResponse: \"\"\" Commit a loaded configuration Args: source: name of the config source to commit against, generally running|startup Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" @abstractmethod async def diff_config(self, source: str = \"running\") -> ScrapliCfgDiffResponse: \"\"\" Diff a loaded configuration against the source config store Args: source: name of the config source to diff against, generally running|startup -- device diffs will generally not care about this argument, but the built in scrapli differ will Returns: ScrapliCfgDiffResponse: scrapli cfg diff object Raises: N/A \"\"\" async def render_substituted_config( self, config_template: str, substitutes: List[Tuple[str, Pattern[str]]], source: str = \"running\", ) -> str: \"\"\" Render a substituted configuration file Renders a configuration based on a user template, substitutes, and a target config from the device. Args: config_template: config file to use as the base for substitutions -- should contain jinja2-like variables that will be replaced with data fetched from the source config by the substitutes patterns substitutes: tuple of name, pattern -- where name matches the jinja2-like variable in the config_template file, and pattern is a compiled regular expression pattern to be used to fetch that section from the source config source: config source to use for the substitution efforts, typically running|startup Returns: str: substituted/rendered config Raises: N/A \"\"\" self.logger.info(\"fetching configuration and replacing with provided substitutes\") source_config = await self.get_config(source=source) return self._render_substituted_config( config_template=config_template, substitutes=substitutes, source_config=source_config.result, )","title":"Module scrapli_cfg.platform.base.async_platform"},{"location":"api_docs/platform/base/async_platform/#classes","text":"","title":"Classes"},{"location":"api_docs/platform/base/async_platform/#asyncscraplicfgplatform","text":"Helper class that provides a standard way to create an ABC using inheritance. Scrapli Config async base class Args: conn: scrapli connection to use config_sources: list of config sources on_open: async callable to run at connection open Returns: None Raises: N/A Expand source code class AsyncScrapliCfgPlatform(ABC, ScrapliCfgBase): def __init__( self, conn: AsyncNetworkDriver, config_sources: List[str], on_open: Callable[..., Any] ) -> None: \"\"\" Scrapli Config async base class Args: conn: scrapli connection to use config_sources: list of config sources on_open: async callable to run at connection open Returns: None Raises: N/A \"\"\" self.conn = conn self.on_open = on_open super().__init__(config_sources=config_sources) async def open(self) -> None: \"\"\" Open the connection and prepare for config operations Does \"normal\" scrapli open things, but also runs the _on_open method of scrapli config which generally does things like disable console logging Args: N/A Returns: None Raises: N/A \"\"\" self.logger.info(\"opening scrapli connection\") if not self.conn.isalive(): await self.conn.open() if self._ignore_version is False: self.logger.debug(\"ignore_version is False, fetching device version\") version_response = await self.get_version() self._validate_and_set_version(version_response=version_response) self.logger.debug(\"executing scrapli_cfg on open method\") await self.on_open(self) async def close(self) -> None: \"\"\" Close the scrapli connection Args: N/A Returns: None Raises: N/A \"\"\" self.logger.info(\"closing scrapli connection\") if self.conn.isalive(): await self.conn.close() async def __aenter__(self) -> \"AsyncScrapliCfgPlatform\": \"\"\" Enter method for async context manager Args: N/A Returns: AsyncScrapliCfg: opened AsyncScrapliCfg object Raises: N/A \"\"\" await self.open() return self async def __aexit__( self, exception_type: Optional[Type[BaseException]], exception_value: Optional[BaseException], traceback: Optional[TracebackType], ) -> None: \"\"\" Exit method to cleanup for async context manager Args: exception_type: exception type being raised exception_value: message from exception being raised traceback: traceback from exception being raised Returns: None Raises: N/A \"\"\" await self.close() async def get_version(self) -> ScrapliCfgResponse: \"\"\" Get device version string Args: N/A Returns: ScrapliCfgResponse: response object where result is the string of the primary version (as in the \"main\" os version) of the device Raises: N/A \"\"\" response = self._pre_get_version() version_result = await self.conn.send_command(command=self._get_version_command) return self._post_get_version( response=response, scrapli_responses=[version_result], result=self._parse_version(device_output=version_result.result), # type: ignore # noqa ) @abstractmethod async def get_config(self, source: str = \"running\") -> ScrapliCfgResponse: \"\"\" Get device configuration Args: source: name of the config source, generally running|startup Returns: ScrapliCfgResponse: response object containing string of the target config source as the `result` attribute Raises: N/A \"\"\" @abstractmethod async def load_config( self, config: str, replace: bool = False, **kwargs: Any ) -> ScrapliCfgResponse: \"\"\" Load configuration to a device Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see your specific platform for details Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" @abstractmethod async def abort_config(self) -> ScrapliCfgResponse: \"\"\" Abort a configuration -- discards any loaded config Args: N/A Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" @abstractmethod async def commit_config(self, source: str = \"running\") -> ScrapliCfgResponse: \"\"\" Commit a loaded configuration Args: source: name of the config source to commit against, generally running|startup Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" @abstractmethod async def diff_config(self, source: str = \"running\") -> ScrapliCfgDiffResponse: \"\"\" Diff a loaded configuration against the source config store Args: source: name of the config source to diff against, generally running|startup -- device diffs will generally not care about this argument, but the built in scrapli differ will Returns: ScrapliCfgDiffResponse: scrapli cfg diff object Raises: N/A \"\"\" async def render_substituted_config( self, config_template: str, substitutes: List[Tuple[str, Pattern[str]]], source: str = \"running\", ) -> str: \"\"\" Render a substituted configuration file Renders a configuration based on a user template, substitutes, and a target config from the device. Args: config_template: config file to use as the base for substitutions -- should contain jinja2-like variables that will be replaced with data fetched from the source config by the substitutes patterns substitutes: tuple of name, pattern -- where name matches the jinja2-like variable in the config_template file, and pattern is a compiled regular expression pattern to be used to fetch that section from the source config source: config source to use for the substitution efforts, typically running|startup Returns: str: substituted/rendered config Raises: N/A \"\"\" self.logger.info(\"fetching configuration and replacing with provided substitutes\") source_config = await self.get_config(source=source) return self._render_substituted_config( config_template=config_template, substitutes=substitutes, source_config=source_config.result, )","title":"AsyncScrapliCfgPlatform"},{"location":"api_docs/platform/base/async_platform/#ancestors-in-mro","text":"abc.ABC scrapli_cfg.platform.base.base_platform.ScrapliCfgBase","title":"Ancestors (in MRO)"},{"location":"api_docs/platform/base/async_platform/#descendants","text":"scrapli_cfg.platform.core.arista_eos.async_platform.AsyncScrapliCfgEOS scrapli_cfg.platform.core.cisco_iosxe.async_platform.AsyncScrapliCfgIOSXE scrapli_cfg.platform.core.cisco_iosxr.async_platform.AsyncScrapliCfgIOSXR scrapli_cfg.platform.core.cisco_nxos.async_platform.AsyncScrapliCfgNXOS","title":"Descendants"},{"location":"api_docs/platform/base/async_platform/#class-variables","text":"conn: Union[scrapli.driver.network.sync_driver.NetworkDriver, scrapli.driver.network.async_driver.AsyncNetworkDriver]","title":"Class variables"},{"location":"api_docs/platform/base/async_platform/#methods","text":"","title":"Methods"},{"location":"api_docs/platform/base/async_platform/#abort_config","text":"abort_config(self) \u2011> scrapli_cfg.response.ScrapliCfgResponse Abort a configuration -- discards any loaded config Args: N/A Returns: ScrapliCfgResponse: response object Raises: N/A","title":"abort_config"},{"location":"api_docs/platform/base/async_platform/#close","text":"close(self) \u2011> NoneType Close the scrapli connection Args: N/A Returns: None Raises: N/A","title":"close"},{"location":"api_docs/platform/base/async_platform/#commit_config","text":"commit_config(self, source: str = 'running') \u2011> scrapli_cfg.response.ScrapliCfgResponse Commit a loaded configuration Args: source: name of the config source to commit against, generally running|startup Returns: ScrapliCfgResponse: response object Raises: N/A","title":"commit_config"},{"location":"api_docs/platform/base/async_platform/#diff_config","text":"diff_config(self, source: str = 'running') \u2011> scrapli_cfg.diff.ScrapliCfgDiffResponse Diff a loaded configuration against the source config store Args: source: name of the config source to diff against, generally running|startup -- device diffs will generally not care about this argument, but the built in scrapli differ will Returns: ScrapliCfgDiffResponse: scrapli cfg diff object Raises: N/A","title":"diff_config"},{"location":"api_docs/platform/base/async_platform/#get_config","text":"get_config(self, source: str = 'running') \u2011> scrapli_cfg.response.ScrapliCfgResponse Get device configuration Args: source: name of the config source, generally running|startup Returns: ScrapliCfgResponse: response object containing string of the target config source as the `result` attribute Raises: N/A","title":"get_config"},{"location":"api_docs/platform/base/async_platform/#get_version","text":"get_version(self) \u2011> scrapli_cfg.response.ScrapliCfgResponse Get device version string Args: N/A Returns: ScrapliCfgResponse: response object where result is the string of the primary version (as in the \"main\" os version) of the device Raises: N/A","title":"get_version"},{"location":"api_docs/platform/base/async_platform/#load_config","text":"load_config(self, config: str, replace: bool = False, **kwargs: Any) \u2011> scrapli_cfg.response.ScrapliCfgResponse Load configuration to a device Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see your specific platform for details Returns: ScrapliCfgResponse: response object Raises: N/A","title":"load_config"},{"location":"api_docs/platform/base/async_platform/#open","text":"open(self) \u2011> NoneType Open the connection and prepare for config operations Does \"normal\" scrapli open things, but also runs the _on_open method of scrapli config which generally does things like disable console logging Args: N/A Returns: None Raises: N/A","title":"open"},{"location":"api_docs/platform/base/async_platform/#render_substituted_config","text":"render_substituted_config(self, config_template: str, substitutes: List[Tuple[str, Pattern[str]]], source: str = 'running') \u2011> str Render a substituted configuration file Renders a configuration based on a user template, substitutes, and a target config from the device. Args: config_template: config file to use as the base for substitutions -- should contain jinja2-like variables that will be replaced with data fetched from the source config by the substitutes patterns substitutes: tuple of name, pattern -- where name matches the jinja2-like variable in the config_template file, and pattern is a compiled regular expression pattern to be used to fetch that section from the source config source: config source to use for the substitution efforts, typically running|startup Returns: str: substituted/rendered config Raises: N/A","title":"render_substituted_config"},{"location":"api_docs/platform/base/base_platform/","text":"window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting()) Module scrapli_cfg.platform.base.base_platform \u00b6 scrapli_cfg.platforms.base_platform Expand source code \"\"\"scrapli_cfg.platforms.base_platform\"\"\" import re from typing import List, Pattern, Tuple, Union from scrapli.driver import AsyncNetworkDriver, NetworkDriver from scrapli.logging import get_instance_logger from scrapli.response import Response from scrapli_cfg.diff import ScrapliCfgDiffResponse from scrapli_cfg.exceptions import ( AbortConfigError, CommitConfigError, DiffConfigError, GetConfigError, InvalidConfigTarget, LoadConfigError, TemplateError, VersionError, ) from scrapli_cfg.response import ScrapliCfgResponse class ScrapliCfgBase: conn: Union[NetworkDriver, AsyncNetworkDriver] def __init__(self, config_sources: List[str], ignore_version: bool = False) -> None: self.logger = get_instance_logger( instance_name=\"scrapli_cfg.platform\", host=self.conn.host, port=self.conn.port ) self.config_sources = config_sources self.candidate_config = \"\" self._ignore_version = ignore_version self._get_version_command = \"\" self._version_string = \"\" def _render_substituted_config( self, config_template: str, substitutes: List[Tuple[str, Pattern[str]]], source_config: str ) -> str: \"\"\" Render a substituted configuration file Renders a configuration based on a user template, substitutes, and a target config from the device. Args: config_template: config file to use as the base for substitutions -- should contain jinja2-like variables that will be replaced with data fetched from the source config by the substitutes patterns substitutes: tuple of name, pattern -- where name matches the jinja2-like variable in the config_template file, and pattern is a compiled regular expression pattern to be used to fetch that section from the source config source_config: current source config to use in substitution process Returns: None Raises: TemplateError: if no substitute sections are provided TemplateError: if one or more of the substitute sections is missing in the template TemplateError: if a substitute pattern is not found in the config template \"\"\" self.logger.debug(\"rendering substituted config\") if not substitutes: msg = \"no substitutes provided...\" self.logger.critical(msg) raise TemplateError(msg) if not all(f\"{{{{ {name} }}}}\" in config_template for name, _ in substitutes): msg = \"missing one or more of the provided substitutions from the config template\" self.logger.critical(msg) raise TemplateError(msg) replace_sections = [ (name, re.search(pattern=pattern, string=source_config)) for name, pattern in substitutes ] rendered_config = \"\" for name, replace_section in replace_sections: if not replace_section: msg = ( f\"substitution pattern {name} was unable to find a match in the target config\" \" source\" ) self.logger.critical(msg) raise TemplateError(msg) replace_group = replace_section.group() rendered_config = config_template.replace(f\"{{{{ {name} }}}}\", replace_group) # remove any totally empty lines (from bad regex, or just device spitting out lines w/ # nothing on it rendered_config = \"\\n\".join(line for line in rendered_config.splitlines() if line) self.logger.debug(\"rendering substituted config complete\") return rendered_config def _validate_and_set_version(self, version_response: ScrapliCfgResponse) -> None: \"\"\" Ensure version was fetched successfully and set internal version attribute Args: version_response: scrapli cfg response from get version operation Returns: None Raises: VersionError: if fetching version failed or failed to parse version \"\"\" if version_response.failed: msg = \"getting version from device failed\" self.logger.critical(msg) raise VersionError(msg) if not version_response.result: msg = \"failed parsing version string from device output\" self.logger.critical(msg) raise VersionError(msg) self._version_string = version_response.result def _pre_get_version(self) -> ScrapliCfgResponse: \"\"\" Handle pre \"get_version\" operations for parity between sync and async Args: N/A Returns: ScrapliCfgResponse: new response object to update w/ get results Raises: N/A \"\"\" self.logger.info(\"get_version requested\") response = ScrapliCfgResponse(host=self.conn.host, raise_for_status_exception=VersionError) return response def _post_get_version( self, response: ScrapliCfgResponse, scrapli_responses: List[Response], result: str, ) -> ScrapliCfgResponse: \"\"\" Handle post \"get_version\" operations for parity between sync and async Args: response: response object to update scrapli_responses: list of scrapli response objects from fetching the version result: final version string of the device Returns: ScrapliCfgResponse: response object containing string of the version as the `result` attribute Raises: N/A \"\"\" response.record_response(scrapli_responses=scrapli_responses, result=result) if response.failed: msg = \"failed to get version from device\" self.logger.critical(msg) return response def _pre_get_config(self, source: str) -> ScrapliCfgResponse: \"\"\" Handle pre \"get_config\" operations for parity between sync and async Args: source: name of the config source, generally running|startup Returns: ScrapliCfgResponse: new response object to update w/ get results Raises: InvalidConfigTarget: if the requested config source is not valid \"\"\" self.logger.info(f\"get_config for config source '{source}' requested\") if source not in self.config_sources: msg = ( f\"provided config source '{source}' not valid, must be one of {self.config_sources}\" ) self.logger.critical(msg) raise InvalidConfigTarget(msg) response = ScrapliCfgResponse( host=self.conn.host, raise_for_status_exception=GetConfigError ) return response def _post_get_config( self, response: ScrapliCfgResponse, source: str, scrapli_responses: List[Response], result: str, ) -> ScrapliCfgResponse: \"\"\" Handle post \"get_config\" operations for parity between sync and async Args: response: response object to update source: name of the config source, generally running|startup scrapli_responses: list of scrapli response objects from fetching the config result: final string of the \"get_config\" result Returns: ScrapliCfgResponse: response object containing string of the target config source as the `result` attribute Raises: N/A \"\"\" response.record_response(scrapli_responses=scrapli_responses, result=result) if response.failed: msg = f\"failed to get {source} config\" self.logger.critical(msg) return response def _pre_load_config(self, config: str) -> ScrapliCfgResponse: \"\"\" Handle pre \"load_config\" operations for parity between sync and async Args: config: candidate config to load Returns: ScrapliCfgResponse: new response object for load operation Raises: N/A \"\"\" self.logger.info(\"load_config requested\") self.candidate_config = config response = ScrapliCfgResponse( host=self.conn.host, raise_for_status_exception=LoadConfigError ) return response def _post_load_config( self, response: ScrapliCfgResponse, scrapli_responses: List[Response], ) -> ScrapliCfgResponse: \"\"\" Handle post \"get_config\" operations for parity between sync and async Args: response: response object to update scrapli_responses: list of scrapli response objects from fetching the config Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" response.record_response(scrapli_responses=scrapli_responses) if response.failed: msg = \"failed to load candidate config\" self.logger.critical(msg) return response def _pre_abort_config(self, session_or_config_file: bool) -> ScrapliCfgResponse: \"\"\" Handle pre \"abort_config\" operations for parity between sync and async Args: session_or_config_file: bool indicating if a session or candidate config file has been loaded -- in other words, is there anything to abort right now Returns: ScrapliCfgResponse: response object for abort operation Raises: AbortConfigError: if no config session or config file exists then we have no config to abort! \"\"\" self.logger.info(\"abort_config requested\") if session_or_config_file is False: msg = ( \"no configuration session or candidate configuration file exists, you must load a \" \"config in order to abort it!\" ) self.logger.critical(msg) raise AbortConfigError(msg) response = ScrapliCfgResponse( host=self.conn.host, raise_for_status_exception=AbortConfigError ) return response def _post_abort_config( self, response: ScrapliCfgResponse, scrapli_responses: List[Response], ) -> ScrapliCfgResponse: \"\"\" Handle post \"abort_config\" operations for parity between sync and async Args: response: response object to update scrapli_responses: list of scrapli response objects from aborting the config Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" response.record_response(scrapli_responses=scrapli_responses) if response.failed: msg = \"failed to abort config\" self.logger.critical(msg) return response def _pre_commit_config(self, source: str, session_or_config_file: bool) -> ScrapliCfgResponse: \"\"\" Handle pre \"commit_config\" operations for parity between sync and async Args: source: name of the config source, generally running|startup session_or_config_file: bool indicating if a session or candidate config file has been loaded -- in other words, is there anything to commit right now Returns: ScrapliCfgResponse: new response object to update w/ commit results Raises: InvalidConfigTarget: if the requested config source is not valid CommitConfigError: if no config session/file exists to commit \"\"\" self.logger.info(f\"get_config for config source '{source}' requested\") if source not in self.config_sources: msg = ( f\"provided config source '{source}' not valid, must be one of {self.config_sources}\" ) self.logger.critical(msg) raise InvalidConfigTarget(msg) if session_or_config_file is False: msg = ( \"no configuration session or candidate configuration file exists, you must load a \" \"config in order to commit it!\" ) self.logger.critical(msg) raise CommitConfigError(msg) response = ScrapliCfgResponse( host=self.conn.host, raise_for_status_exception=CommitConfigError ) return response def _post_commit_config( self, response: ScrapliCfgResponse, scrapli_responses: List[Response], ) -> ScrapliCfgResponse: \"\"\" Handle post \"commit_config\" operations for parity between sync and async Args: response: response object to update scrapli_responses: list of scrapli response objects from committing the config Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" response.record_response(scrapli_responses=scrapli_responses) if response.failed: msg = \"failed to commit config\" self.logger.critical(msg) return response def _pre_diff_config(self, source: str, session_or_config_file: bool) -> ScrapliCfgDiffResponse: \"\"\" Handle pre \"diff_config\" operations for parity between sync and async Args: source: config source to diff against session_or_config_file: bool of config_session_name or candidate_config_filename Returns: ScrapliCfgDiffResponse: diff object for diff operation Raises: InvalidConfigTarget: if trying to diff against an invalid config target DiffConfigError: if no config session or config file exists then we have no config to diff! \"\"\" self.logger.info(\"diff_config requested\") if source not in self.config_sources: msg = ( f\"provided config source '{source}' not valid, must be one of {self.config_sources}\" ) self.logger.critical(msg) raise InvalidConfigTarget(msg) if session_or_config_file is False: msg = ( \"no configuration session or candidate configuration file exists, you must load a \" \"config in order to diff it!\" ) self.logger.critical(msg) raise DiffConfigError(msg) diff_response = ScrapliCfgDiffResponse(host=self.conn.host, source=source) return diff_response def _post_diff_config( self, diff_response: ScrapliCfgDiffResponse, scrapli_responses: List[Response], source_config: str, candidate_config: str, device_diff: str, ) -> ScrapliCfgDiffResponse: \"\"\" Handle post \"diff_config\" operations for parity between sync and async Args: diff_response: response object to update scrapli_responses: list of scrapli response objects from committing the config source_config: previous source config from the device candidate_config: user provided configuration device_diff: diff generated from the device itself Returns: ScrapliCfgDiffResponse: diff object for diff operation Raises: N/A \"\"\" diff_response.record_response(scrapli_responses=scrapli_responses) diff_response.record_diff_response( source_config=source_config, candidate_config=candidate_config, device_diff=device_diff ) if diff_response.failed: msg = \"failed to diff config\" self.logger.critical(msg) return diff_response Classes \u00b6 ScrapliCfgBase \u00b6 Expand source code class ScrapliCfgBase: conn: Union[NetworkDriver, AsyncNetworkDriver] def __init__(self, config_sources: List[str], ignore_version: bool = False) -> None: self.logger = get_instance_logger( instance_name=\"scrapli_cfg.platform\", host=self.conn.host, port=self.conn.port ) self.config_sources = config_sources self.candidate_config = \"\" self._ignore_version = ignore_version self._get_version_command = \"\" self._version_string = \"\" def _render_substituted_config( self, config_template: str, substitutes: List[Tuple[str, Pattern[str]]], source_config: str ) -> str: \"\"\" Render a substituted configuration file Renders a configuration based on a user template, substitutes, and a target config from the device. Args: config_template: config file to use as the base for substitutions -- should contain jinja2-like variables that will be replaced with data fetched from the source config by the substitutes patterns substitutes: tuple of name, pattern -- where name matches the jinja2-like variable in the config_template file, and pattern is a compiled regular expression pattern to be used to fetch that section from the source config source_config: current source config to use in substitution process Returns: None Raises: TemplateError: if no substitute sections are provided TemplateError: if one or more of the substitute sections is missing in the template TemplateError: if a substitute pattern is not found in the config template \"\"\" self.logger.debug(\"rendering substituted config\") if not substitutes: msg = \"no substitutes provided...\" self.logger.critical(msg) raise TemplateError(msg) if not all(f\"{{{{ {name} }}}}\" in config_template for name, _ in substitutes): msg = \"missing one or more of the provided substitutions from the config template\" self.logger.critical(msg) raise TemplateError(msg) replace_sections = [ (name, re.search(pattern=pattern, string=source_config)) for name, pattern in substitutes ] rendered_config = \"\" for name, replace_section in replace_sections: if not replace_section: msg = ( f\"substitution pattern {name} was unable to find a match in the target config\" \" source\" ) self.logger.critical(msg) raise TemplateError(msg) replace_group = replace_section.group() rendered_config = config_template.replace(f\"{{{{ {name} }}}}\", replace_group) # remove any totally empty lines (from bad regex, or just device spitting out lines w/ # nothing on it rendered_config = \"\\n\".join(line for line in rendered_config.splitlines() if line) self.logger.debug(\"rendering substituted config complete\") return rendered_config def _validate_and_set_version(self, version_response: ScrapliCfgResponse) -> None: \"\"\" Ensure version was fetched successfully and set internal version attribute Args: version_response: scrapli cfg response from get version operation Returns: None Raises: VersionError: if fetching version failed or failed to parse version \"\"\" if version_response.failed: msg = \"getting version from device failed\" self.logger.critical(msg) raise VersionError(msg) if not version_response.result: msg = \"failed parsing version string from device output\" self.logger.critical(msg) raise VersionError(msg) self._version_string = version_response.result def _pre_get_version(self) -> ScrapliCfgResponse: \"\"\" Handle pre \"get_version\" operations for parity between sync and async Args: N/A Returns: ScrapliCfgResponse: new response object to update w/ get results Raises: N/A \"\"\" self.logger.info(\"get_version requested\") response = ScrapliCfgResponse(host=self.conn.host, raise_for_status_exception=VersionError) return response def _post_get_version( self, response: ScrapliCfgResponse, scrapli_responses: List[Response], result: str, ) -> ScrapliCfgResponse: \"\"\" Handle post \"get_version\" operations for parity between sync and async Args: response: response object to update scrapli_responses: list of scrapli response objects from fetching the version result: final version string of the device Returns: ScrapliCfgResponse: response object containing string of the version as the `result` attribute Raises: N/A \"\"\" response.record_response(scrapli_responses=scrapli_responses, result=result) if response.failed: msg = \"failed to get version from device\" self.logger.critical(msg) return response def _pre_get_config(self, source: str) -> ScrapliCfgResponse: \"\"\" Handle pre \"get_config\" operations for parity between sync and async Args: source: name of the config source, generally running|startup Returns: ScrapliCfgResponse: new response object to update w/ get results Raises: InvalidConfigTarget: if the requested config source is not valid \"\"\" self.logger.info(f\"get_config for config source '{source}' requested\") if source not in self.config_sources: msg = ( f\"provided config source '{source}' not valid, must be one of {self.config_sources}\" ) self.logger.critical(msg) raise InvalidConfigTarget(msg) response = ScrapliCfgResponse( host=self.conn.host, raise_for_status_exception=GetConfigError ) return response def _post_get_config( self, response: ScrapliCfgResponse, source: str, scrapli_responses: List[Response], result: str, ) -> ScrapliCfgResponse: \"\"\" Handle post \"get_config\" operations for parity between sync and async Args: response: response object to update source: name of the config source, generally running|startup scrapli_responses: list of scrapli response objects from fetching the config result: final string of the \"get_config\" result Returns: ScrapliCfgResponse: response object containing string of the target config source as the `result` attribute Raises: N/A \"\"\" response.record_response(scrapli_responses=scrapli_responses, result=result) if response.failed: msg = f\"failed to get {source} config\" self.logger.critical(msg) return response def _pre_load_config(self, config: str) -> ScrapliCfgResponse: \"\"\" Handle pre \"load_config\" operations for parity between sync and async Args: config: candidate config to load Returns: ScrapliCfgResponse: new response object for load operation Raises: N/A \"\"\" self.logger.info(\"load_config requested\") self.candidate_config = config response = ScrapliCfgResponse( host=self.conn.host, raise_for_status_exception=LoadConfigError ) return response def _post_load_config( self, response: ScrapliCfgResponse, scrapli_responses: List[Response], ) -> ScrapliCfgResponse: \"\"\" Handle post \"get_config\" operations for parity between sync and async Args: response: response object to update scrapli_responses: list of scrapli response objects from fetching the config Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" response.record_response(scrapli_responses=scrapli_responses) if response.failed: msg = \"failed to load candidate config\" self.logger.critical(msg) return response def _pre_abort_config(self, session_or_config_file: bool) -> ScrapliCfgResponse: \"\"\" Handle pre \"abort_config\" operations for parity between sync and async Args: session_or_config_file: bool indicating if a session or candidate config file has been loaded -- in other words, is there anything to abort right now Returns: ScrapliCfgResponse: response object for abort operation Raises: AbortConfigError: if no config session or config file exists then we have no config to abort! \"\"\" self.logger.info(\"abort_config requested\") if session_or_config_file is False: msg = ( \"no configuration session or candidate configuration file exists, you must load a \" \"config in order to abort it!\" ) self.logger.critical(msg) raise AbortConfigError(msg) response = ScrapliCfgResponse( host=self.conn.host, raise_for_status_exception=AbortConfigError ) return response def _post_abort_config( self, response: ScrapliCfgResponse, scrapli_responses: List[Response], ) -> ScrapliCfgResponse: \"\"\" Handle post \"abort_config\" operations for parity between sync and async Args: response: response object to update scrapli_responses: list of scrapli response objects from aborting the config Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" response.record_response(scrapli_responses=scrapli_responses) if response.failed: msg = \"failed to abort config\" self.logger.critical(msg) return response def _pre_commit_config(self, source: str, session_or_config_file: bool) -> ScrapliCfgResponse: \"\"\" Handle pre \"commit_config\" operations for parity between sync and async Args: source: name of the config source, generally running|startup session_or_config_file: bool indicating if a session or candidate config file has been loaded -- in other words, is there anything to commit right now Returns: ScrapliCfgResponse: new response object to update w/ commit results Raises: InvalidConfigTarget: if the requested config source is not valid CommitConfigError: if no config session/file exists to commit \"\"\" self.logger.info(f\"get_config for config source '{source}' requested\") if source not in self.config_sources: msg = ( f\"provided config source '{source}' not valid, must be one of {self.config_sources}\" ) self.logger.critical(msg) raise InvalidConfigTarget(msg) if session_or_config_file is False: msg = ( \"no configuration session or candidate configuration file exists, you must load a \" \"config in order to commit it!\" ) self.logger.critical(msg) raise CommitConfigError(msg) response = ScrapliCfgResponse( host=self.conn.host, raise_for_status_exception=CommitConfigError ) return response def _post_commit_config( self, response: ScrapliCfgResponse, scrapli_responses: List[Response], ) -> ScrapliCfgResponse: \"\"\" Handle post \"commit_config\" operations for parity between sync and async Args: response: response object to update scrapli_responses: list of scrapli response objects from committing the config Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" response.record_response(scrapli_responses=scrapli_responses) if response.failed: msg = \"failed to commit config\" self.logger.critical(msg) return response def _pre_diff_config(self, source: str, session_or_config_file: bool) -> ScrapliCfgDiffResponse: \"\"\" Handle pre \"diff_config\" operations for parity between sync and async Args: source: config source to diff against session_or_config_file: bool of config_session_name or candidate_config_filename Returns: ScrapliCfgDiffResponse: diff object for diff operation Raises: InvalidConfigTarget: if trying to diff against an invalid config target DiffConfigError: if no config session or config file exists then we have no config to diff! \"\"\" self.logger.info(\"diff_config requested\") if source not in self.config_sources: msg = ( f\"provided config source '{source}' not valid, must be one of {self.config_sources}\" ) self.logger.critical(msg) raise InvalidConfigTarget(msg) if session_or_config_file is False: msg = ( \"no configuration session or candidate configuration file exists, you must load a \" \"config in order to diff it!\" ) self.logger.critical(msg) raise DiffConfigError(msg) diff_response = ScrapliCfgDiffResponse(host=self.conn.host, source=source) return diff_response def _post_diff_config( self, diff_response: ScrapliCfgDiffResponse, scrapli_responses: List[Response], source_config: str, candidate_config: str, device_diff: str, ) -> ScrapliCfgDiffResponse: \"\"\" Handle post \"diff_config\" operations for parity between sync and async Args: diff_response: response object to update scrapli_responses: list of scrapli response objects from committing the config source_config: previous source config from the device candidate_config: user provided configuration device_diff: diff generated from the device itself Returns: ScrapliCfgDiffResponse: diff object for diff operation Raises: N/A \"\"\" diff_response.record_response(scrapli_responses=scrapli_responses) diff_response.record_diff_response( source_config=source_config, candidate_config=candidate_config, device_diff=device_diff ) if diff_response.failed: msg = \"failed to diff config\" self.logger.critical(msg) return diff_response Descendants \u00b6 scrapli_cfg.platform.base.async_platform.AsyncScrapliCfgPlatform scrapli_cfg.platform.base.sync_platform.ScrapliCfgPlatform Class variables \u00b6 conn: Union[scrapli.driver.network.sync_driver.NetworkDriver, scrapli.driver.network.async_driver.AsyncNetworkDriver]","title":"Base platform"},{"location":"api_docs/platform/base/base_platform/#module-scrapli_cfgplatformbasebase_platform","text":"scrapli_cfg.platforms.base_platform Expand source code \"\"\"scrapli_cfg.platforms.base_platform\"\"\" import re from typing import List, Pattern, Tuple, Union from scrapli.driver import AsyncNetworkDriver, NetworkDriver from scrapli.logging import get_instance_logger from scrapli.response import Response from scrapli_cfg.diff import ScrapliCfgDiffResponse from scrapli_cfg.exceptions import ( AbortConfigError, CommitConfigError, DiffConfigError, GetConfigError, InvalidConfigTarget, LoadConfigError, TemplateError, VersionError, ) from scrapli_cfg.response import ScrapliCfgResponse class ScrapliCfgBase: conn: Union[NetworkDriver, AsyncNetworkDriver] def __init__(self, config_sources: List[str], ignore_version: bool = False) -> None: self.logger = get_instance_logger( instance_name=\"scrapli_cfg.platform\", host=self.conn.host, port=self.conn.port ) self.config_sources = config_sources self.candidate_config = \"\" self._ignore_version = ignore_version self._get_version_command = \"\" self._version_string = \"\" def _render_substituted_config( self, config_template: str, substitutes: List[Tuple[str, Pattern[str]]], source_config: str ) -> str: \"\"\" Render a substituted configuration file Renders a configuration based on a user template, substitutes, and a target config from the device. Args: config_template: config file to use as the base for substitutions -- should contain jinja2-like variables that will be replaced with data fetched from the source config by the substitutes patterns substitutes: tuple of name, pattern -- where name matches the jinja2-like variable in the config_template file, and pattern is a compiled regular expression pattern to be used to fetch that section from the source config source_config: current source config to use in substitution process Returns: None Raises: TemplateError: if no substitute sections are provided TemplateError: if one or more of the substitute sections is missing in the template TemplateError: if a substitute pattern is not found in the config template \"\"\" self.logger.debug(\"rendering substituted config\") if not substitutes: msg = \"no substitutes provided...\" self.logger.critical(msg) raise TemplateError(msg) if not all(f\"{{{{ {name} }}}}\" in config_template for name, _ in substitutes): msg = \"missing one or more of the provided substitutions from the config template\" self.logger.critical(msg) raise TemplateError(msg) replace_sections = [ (name, re.search(pattern=pattern, string=source_config)) for name, pattern in substitutes ] rendered_config = \"\" for name, replace_section in replace_sections: if not replace_section: msg = ( f\"substitution pattern {name} was unable to find a match in the target config\" \" source\" ) self.logger.critical(msg) raise TemplateError(msg) replace_group = replace_section.group() rendered_config = config_template.replace(f\"{{{{ {name} }}}}\", replace_group) # remove any totally empty lines (from bad regex, or just device spitting out lines w/ # nothing on it rendered_config = \"\\n\".join(line for line in rendered_config.splitlines() if line) self.logger.debug(\"rendering substituted config complete\") return rendered_config def _validate_and_set_version(self, version_response: ScrapliCfgResponse) -> None: \"\"\" Ensure version was fetched successfully and set internal version attribute Args: version_response: scrapli cfg response from get version operation Returns: None Raises: VersionError: if fetching version failed or failed to parse version \"\"\" if version_response.failed: msg = \"getting version from device failed\" self.logger.critical(msg) raise VersionError(msg) if not version_response.result: msg = \"failed parsing version string from device output\" self.logger.critical(msg) raise VersionError(msg) self._version_string = version_response.result def _pre_get_version(self) -> ScrapliCfgResponse: \"\"\" Handle pre \"get_version\" operations for parity between sync and async Args: N/A Returns: ScrapliCfgResponse: new response object to update w/ get results Raises: N/A \"\"\" self.logger.info(\"get_version requested\") response = ScrapliCfgResponse(host=self.conn.host, raise_for_status_exception=VersionError) return response def _post_get_version( self, response: ScrapliCfgResponse, scrapli_responses: List[Response], result: str, ) -> ScrapliCfgResponse: \"\"\" Handle post \"get_version\" operations for parity between sync and async Args: response: response object to update scrapli_responses: list of scrapli response objects from fetching the version result: final version string of the device Returns: ScrapliCfgResponse: response object containing string of the version as the `result` attribute Raises: N/A \"\"\" response.record_response(scrapli_responses=scrapli_responses, result=result) if response.failed: msg = \"failed to get version from device\" self.logger.critical(msg) return response def _pre_get_config(self, source: str) -> ScrapliCfgResponse: \"\"\" Handle pre \"get_config\" operations for parity between sync and async Args: source: name of the config source, generally running|startup Returns: ScrapliCfgResponse: new response object to update w/ get results Raises: InvalidConfigTarget: if the requested config source is not valid \"\"\" self.logger.info(f\"get_config for config source '{source}' requested\") if source not in self.config_sources: msg = ( f\"provided config source '{source}' not valid, must be one of {self.config_sources}\" ) self.logger.critical(msg) raise InvalidConfigTarget(msg) response = ScrapliCfgResponse( host=self.conn.host, raise_for_status_exception=GetConfigError ) return response def _post_get_config( self, response: ScrapliCfgResponse, source: str, scrapli_responses: List[Response], result: str, ) -> ScrapliCfgResponse: \"\"\" Handle post \"get_config\" operations for parity between sync and async Args: response: response object to update source: name of the config source, generally running|startup scrapli_responses: list of scrapli response objects from fetching the config result: final string of the \"get_config\" result Returns: ScrapliCfgResponse: response object containing string of the target config source as the `result` attribute Raises: N/A \"\"\" response.record_response(scrapli_responses=scrapli_responses, result=result) if response.failed: msg = f\"failed to get {source} config\" self.logger.critical(msg) return response def _pre_load_config(self, config: str) -> ScrapliCfgResponse: \"\"\" Handle pre \"load_config\" operations for parity between sync and async Args: config: candidate config to load Returns: ScrapliCfgResponse: new response object for load operation Raises: N/A \"\"\" self.logger.info(\"load_config requested\") self.candidate_config = config response = ScrapliCfgResponse( host=self.conn.host, raise_for_status_exception=LoadConfigError ) return response def _post_load_config( self, response: ScrapliCfgResponse, scrapli_responses: List[Response], ) -> ScrapliCfgResponse: \"\"\" Handle post \"get_config\" operations for parity between sync and async Args: response: response object to update scrapli_responses: list of scrapli response objects from fetching the config Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" response.record_response(scrapli_responses=scrapli_responses) if response.failed: msg = \"failed to load candidate config\" self.logger.critical(msg) return response def _pre_abort_config(self, session_or_config_file: bool) -> ScrapliCfgResponse: \"\"\" Handle pre \"abort_config\" operations for parity between sync and async Args: session_or_config_file: bool indicating if a session or candidate config file has been loaded -- in other words, is there anything to abort right now Returns: ScrapliCfgResponse: response object for abort operation Raises: AbortConfigError: if no config session or config file exists then we have no config to abort! \"\"\" self.logger.info(\"abort_config requested\") if session_or_config_file is False: msg = ( \"no configuration session or candidate configuration file exists, you must load a \" \"config in order to abort it!\" ) self.logger.critical(msg) raise AbortConfigError(msg) response = ScrapliCfgResponse( host=self.conn.host, raise_for_status_exception=AbortConfigError ) return response def _post_abort_config( self, response: ScrapliCfgResponse, scrapli_responses: List[Response], ) -> ScrapliCfgResponse: \"\"\" Handle post \"abort_config\" operations for parity between sync and async Args: response: response object to update scrapli_responses: list of scrapli response objects from aborting the config Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" response.record_response(scrapli_responses=scrapli_responses) if response.failed: msg = \"failed to abort config\" self.logger.critical(msg) return response def _pre_commit_config(self, source: str, session_or_config_file: bool) -> ScrapliCfgResponse: \"\"\" Handle pre \"commit_config\" operations for parity between sync and async Args: source: name of the config source, generally running|startup session_or_config_file: bool indicating if a session or candidate config file has been loaded -- in other words, is there anything to commit right now Returns: ScrapliCfgResponse: new response object to update w/ commit results Raises: InvalidConfigTarget: if the requested config source is not valid CommitConfigError: if no config session/file exists to commit \"\"\" self.logger.info(f\"get_config for config source '{source}' requested\") if source not in self.config_sources: msg = ( f\"provided config source '{source}' not valid, must be one of {self.config_sources}\" ) self.logger.critical(msg) raise InvalidConfigTarget(msg) if session_or_config_file is False: msg = ( \"no configuration session or candidate configuration file exists, you must load a \" \"config in order to commit it!\" ) self.logger.critical(msg) raise CommitConfigError(msg) response = ScrapliCfgResponse( host=self.conn.host, raise_for_status_exception=CommitConfigError ) return response def _post_commit_config( self, response: ScrapliCfgResponse, scrapli_responses: List[Response], ) -> ScrapliCfgResponse: \"\"\" Handle post \"commit_config\" operations for parity between sync and async Args: response: response object to update scrapli_responses: list of scrapli response objects from committing the config Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" response.record_response(scrapli_responses=scrapli_responses) if response.failed: msg = \"failed to commit config\" self.logger.critical(msg) return response def _pre_diff_config(self, source: str, session_or_config_file: bool) -> ScrapliCfgDiffResponse: \"\"\" Handle pre \"diff_config\" operations for parity between sync and async Args: source: config source to diff against session_or_config_file: bool of config_session_name or candidate_config_filename Returns: ScrapliCfgDiffResponse: diff object for diff operation Raises: InvalidConfigTarget: if trying to diff against an invalid config target DiffConfigError: if no config session or config file exists then we have no config to diff! \"\"\" self.logger.info(\"diff_config requested\") if source not in self.config_sources: msg = ( f\"provided config source '{source}' not valid, must be one of {self.config_sources}\" ) self.logger.critical(msg) raise InvalidConfigTarget(msg) if session_or_config_file is False: msg = ( \"no configuration session or candidate configuration file exists, you must load a \" \"config in order to diff it!\" ) self.logger.critical(msg) raise DiffConfigError(msg) diff_response = ScrapliCfgDiffResponse(host=self.conn.host, source=source) return diff_response def _post_diff_config( self, diff_response: ScrapliCfgDiffResponse, scrapli_responses: List[Response], source_config: str, candidate_config: str, device_diff: str, ) -> ScrapliCfgDiffResponse: \"\"\" Handle post \"diff_config\" operations for parity between sync and async Args: diff_response: response object to update scrapli_responses: list of scrapli response objects from committing the config source_config: previous source config from the device candidate_config: user provided configuration device_diff: diff generated from the device itself Returns: ScrapliCfgDiffResponse: diff object for diff operation Raises: N/A \"\"\" diff_response.record_response(scrapli_responses=scrapli_responses) diff_response.record_diff_response( source_config=source_config, candidate_config=candidate_config, device_diff=device_diff ) if diff_response.failed: msg = \"failed to diff config\" self.logger.critical(msg) return diff_response","title":"Module scrapli_cfg.platform.base.base_platform"},{"location":"api_docs/platform/base/base_platform/#classes","text":"","title":"Classes"},{"location":"api_docs/platform/base/base_platform/#scraplicfgbase","text":"Expand source code class ScrapliCfgBase: conn: Union[NetworkDriver, AsyncNetworkDriver] def __init__(self, config_sources: List[str], ignore_version: bool = False) -> None: self.logger = get_instance_logger( instance_name=\"scrapli_cfg.platform\", host=self.conn.host, port=self.conn.port ) self.config_sources = config_sources self.candidate_config = \"\" self._ignore_version = ignore_version self._get_version_command = \"\" self._version_string = \"\" def _render_substituted_config( self, config_template: str, substitutes: List[Tuple[str, Pattern[str]]], source_config: str ) -> str: \"\"\" Render a substituted configuration file Renders a configuration based on a user template, substitutes, and a target config from the device. Args: config_template: config file to use as the base for substitutions -- should contain jinja2-like variables that will be replaced with data fetched from the source config by the substitutes patterns substitutes: tuple of name, pattern -- where name matches the jinja2-like variable in the config_template file, and pattern is a compiled regular expression pattern to be used to fetch that section from the source config source_config: current source config to use in substitution process Returns: None Raises: TemplateError: if no substitute sections are provided TemplateError: if one or more of the substitute sections is missing in the template TemplateError: if a substitute pattern is not found in the config template \"\"\" self.logger.debug(\"rendering substituted config\") if not substitutes: msg = \"no substitutes provided...\" self.logger.critical(msg) raise TemplateError(msg) if not all(f\"{{{{ {name} }}}}\" in config_template for name, _ in substitutes): msg = \"missing one or more of the provided substitutions from the config template\" self.logger.critical(msg) raise TemplateError(msg) replace_sections = [ (name, re.search(pattern=pattern, string=source_config)) for name, pattern in substitutes ] rendered_config = \"\" for name, replace_section in replace_sections: if not replace_section: msg = ( f\"substitution pattern {name} was unable to find a match in the target config\" \" source\" ) self.logger.critical(msg) raise TemplateError(msg) replace_group = replace_section.group() rendered_config = config_template.replace(f\"{{{{ {name} }}}}\", replace_group) # remove any totally empty lines (from bad regex, or just device spitting out lines w/ # nothing on it rendered_config = \"\\n\".join(line for line in rendered_config.splitlines() if line) self.logger.debug(\"rendering substituted config complete\") return rendered_config def _validate_and_set_version(self, version_response: ScrapliCfgResponse) -> None: \"\"\" Ensure version was fetched successfully and set internal version attribute Args: version_response: scrapli cfg response from get version operation Returns: None Raises: VersionError: if fetching version failed or failed to parse version \"\"\" if version_response.failed: msg = \"getting version from device failed\" self.logger.critical(msg) raise VersionError(msg) if not version_response.result: msg = \"failed parsing version string from device output\" self.logger.critical(msg) raise VersionError(msg) self._version_string = version_response.result def _pre_get_version(self) -> ScrapliCfgResponse: \"\"\" Handle pre \"get_version\" operations for parity between sync and async Args: N/A Returns: ScrapliCfgResponse: new response object to update w/ get results Raises: N/A \"\"\" self.logger.info(\"get_version requested\") response = ScrapliCfgResponse(host=self.conn.host, raise_for_status_exception=VersionError) return response def _post_get_version( self, response: ScrapliCfgResponse, scrapli_responses: List[Response], result: str, ) -> ScrapliCfgResponse: \"\"\" Handle post \"get_version\" operations for parity between sync and async Args: response: response object to update scrapli_responses: list of scrapli response objects from fetching the version result: final version string of the device Returns: ScrapliCfgResponse: response object containing string of the version as the `result` attribute Raises: N/A \"\"\" response.record_response(scrapli_responses=scrapli_responses, result=result) if response.failed: msg = \"failed to get version from device\" self.logger.critical(msg) return response def _pre_get_config(self, source: str) -> ScrapliCfgResponse: \"\"\" Handle pre \"get_config\" operations for parity between sync and async Args: source: name of the config source, generally running|startup Returns: ScrapliCfgResponse: new response object to update w/ get results Raises: InvalidConfigTarget: if the requested config source is not valid \"\"\" self.logger.info(f\"get_config for config source '{source}' requested\") if source not in self.config_sources: msg = ( f\"provided config source '{source}' not valid, must be one of {self.config_sources}\" ) self.logger.critical(msg) raise InvalidConfigTarget(msg) response = ScrapliCfgResponse( host=self.conn.host, raise_for_status_exception=GetConfigError ) return response def _post_get_config( self, response: ScrapliCfgResponse, source: str, scrapli_responses: List[Response], result: str, ) -> ScrapliCfgResponse: \"\"\" Handle post \"get_config\" operations for parity between sync and async Args: response: response object to update source: name of the config source, generally running|startup scrapli_responses: list of scrapli response objects from fetching the config result: final string of the \"get_config\" result Returns: ScrapliCfgResponse: response object containing string of the target config source as the `result` attribute Raises: N/A \"\"\" response.record_response(scrapli_responses=scrapli_responses, result=result) if response.failed: msg = f\"failed to get {source} config\" self.logger.critical(msg) return response def _pre_load_config(self, config: str) -> ScrapliCfgResponse: \"\"\" Handle pre \"load_config\" operations for parity between sync and async Args: config: candidate config to load Returns: ScrapliCfgResponse: new response object for load operation Raises: N/A \"\"\" self.logger.info(\"load_config requested\") self.candidate_config = config response = ScrapliCfgResponse( host=self.conn.host, raise_for_status_exception=LoadConfigError ) return response def _post_load_config( self, response: ScrapliCfgResponse, scrapli_responses: List[Response], ) -> ScrapliCfgResponse: \"\"\" Handle post \"get_config\" operations for parity between sync and async Args: response: response object to update scrapli_responses: list of scrapli response objects from fetching the config Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" response.record_response(scrapli_responses=scrapli_responses) if response.failed: msg = \"failed to load candidate config\" self.logger.critical(msg) return response def _pre_abort_config(self, session_or_config_file: bool) -> ScrapliCfgResponse: \"\"\" Handle pre \"abort_config\" operations for parity between sync and async Args: session_or_config_file: bool indicating if a session or candidate config file has been loaded -- in other words, is there anything to abort right now Returns: ScrapliCfgResponse: response object for abort operation Raises: AbortConfigError: if no config session or config file exists then we have no config to abort! \"\"\" self.logger.info(\"abort_config requested\") if session_or_config_file is False: msg = ( \"no configuration session or candidate configuration file exists, you must load a \" \"config in order to abort it!\" ) self.logger.critical(msg) raise AbortConfigError(msg) response = ScrapliCfgResponse( host=self.conn.host, raise_for_status_exception=AbortConfigError ) return response def _post_abort_config( self, response: ScrapliCfgResponse, scrapli_responses: List[Response], ) -> ScrapliCfgResponse: \"\"\" Handle post \"abort_config\" operations for parity between sync and async Args: response: response object to update scrapli_responses: list of scrapli response objects from aborting the config Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" response.record_response(scrapli_responses=scrapli_responses) if response.failed: msg = \"failed to abort config\" self.logger.critical(msg) return response def _pre_commit_config(self, source: str, session_or_config_file: bool) -> ScrapliCfgResponse: \"\"\" Handle pre \"commit_config\" operations for parity between sync and async Args: source: name of the config source, generally running|startup session_or_config_file: bool indicating if a session or candidate config file has been loaded -- in other words, is there anything to commit right now Returns: ScrapliCfgResponse: new response object to update w/ commit results Raises: InvalidConfigTarget: if the requested config source is not valid CommitConfigError: if no config session/file exists to commit \"\"\" self.logger.info(f\"get_config for config source '{source}' requested\") if source not in self.config_sources: msg = ( f\"provided config source '{source}' not valid, must be one of {self.config_sources}\" ) self.logger.critical(msg) raise InvalidConfigTarget(msg) if session_or_config_file is False: msg = ( \"no configuration session or candidate configuration file exists, you must load a \" \"config in order to commit it!\" ) self.logger.critical(msg) raise CommitConfigError(msg) response = ScrapliCfgResponse( host=self.conn.host, raise_for_status_exception=CommitConfigError ) return response def _post_commit_config( self, response: ScrapliCfgResponse, scrapli_responses: List[Response], ) -> ScrapliCfgResponse: \"\"\" Handle post \"commit_config\" operations for parity between sync and async Args: response: response object to update scrapli_responses: list of scrapli response objects from committing the config Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" response.record_response(scrapli_responses=scrapli_responses) if response.failed: msg = \"failed to commit config\" self.logger.critical(msg) return response def _pre_diff_config(self, source: str, session_or_config_file: bool) -> ScrapliCfgDiffResponse: \"\"\" Handle pre \"diff_config\" operations for parity between sync and async Args: source: config source to diff against session_or_config_file: bool of config_session_name or candidate_config_filename Returns: ScrapliCfgDiffResponse: diff object for diff operation Raises: InvalidConfigTarget: if trying to diff against an invalid config target DiffConfigError: if no config session or config file exists then we have no config to diff! \"\"\" self.logger.info(\"diff_config requested\") if source not in self.config_sources: msg = ( f\"provided config source '{source}' not valid, must be one of {self.config_sources}\" ) self.logger.critical(msg) raise InvalidConfigTarget(msg) if session_or_config_file is False: msg = ( \"no configuration session or candidate configuration file exists, you must load a \" \"config in order to diff it!\" ) self.logger.critical(msg) raise DiffConfigError(msg) diff_response = ScrapliCfgDiffResponse(host=self.conn.host, source=source) return diff_response def _post_diff_config( self, diff_response: ScrapliCfgDiffResponse, scrapli_responses: List[Response], source_config: str, candidate_config: str, device_diff: str, ) -> ScrapliCfgDiffResponse: \"\"\" Handle post \"diff_config\" operations for parity between sync and async Args: diff_response: response object to update scrapli_responses: list of scrapli response objects from committing the config source_config: previous source config from the device candidate_config: user provided configuration device_diff: diff generated from the device itself Returns: ScrapliCfgDiffResponse: diff object for diff operation Raises: N/A \"\"\" diff_response.record_response(scrapli_responses=scrapli_responses) diff_response.record_diff_response( source_config=source_config, candidate_config=candidate_config, device_diff=device_diff ) if diff_response.failed: msg = \"failed to diff config\" self.logger.critical(msg) return diff_response","title":"ScrapliCfgBase"},{"location":"api_docs/platform/base/base_platform/#descendants","text":"scrapli_cfg.platform.base.async_platform.AsyncScrapliCfgPlatform scrapli_cfg.platform.base.sync_platform.ScrapliCfgPlatform","title":"Descendants"},{"location":"api_docs/platform/base/base_platform/#class-variables","text":"conn: Union[scrapli.driver.network.sync_driver.NetworkDriver, scrapli.driver.network.async_driver.AsyncNetworkDriver]","title":"Class variables"},{"location":"api_docs/platform/base/sync_platform/","text":"window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting()) Module scrapli_cfg.platform.base.sync_platform \u00b6 scrapli_cfg.platform.sync_platform Expand source code \"\"\"scrapli_cfg.platform.sync_platform\"\"\" from abc import ABC, abstractmethod from types import TracebackType from typing import Any, Callable, List, Optional, Pattern, Tuple, Type from scrapli.driver import NetworkDriver from scrapli_cfg.diff import ScrapliCfgDiffResponse from scrapli_cfg.platform.base.base_platform import ScrapliCfgBase from scrapli_cfg.response import ScrapliCfgResponse class ScrapliCfgPlatform(ABC, ScrapliCfgBase): def __init__( self, conn: NetworkDriver, config_sources: List[str], on_open: Callable[..., Any] ) -> None: \"\"\" Scrapli Config base class Args: conn: scrapli connection to use config_sources: list of config sources on_open: async callable to run at connection open Returns: None Raises: N/A \"\"\" self.conn = conn self.on_open = on_open super().__init__(config_sources=config_sources) def open(self) -> None: \"\"\" Open the connection and prepare for config operations Does \"normal\" scrapli open things, but also runs the _on_open method of scrapli config which generally does things like disable console logging Args: N/A Returns: None Raises: N/A \"\"\" self.logger.info(\"opening scrapli connection\") if not self.conn.isalive(): self.conn.open() if self._ignore_version is False: self.logger.debug(\"ignore_version is False, fetching device version\") version_response = self.get_version() self._validate_and_set_version(version_response=version_response) self.logger.debug(\"executing scrapli_cfg on open method\") self.on_open(self) def close(self) -> None: \"\"\" Close the scrapli connection Args: N/A Returns: None Raises: N/A \"\"\" self.logger.info(\"closing scrapli connection\") if self.conn.isalive(): self.conn.close() def __enter__(self) -> \"ScrapliCfgPlatform\": \"\"\" Enter method for context manager Args: N/A Returns: ScrapliCfg: opened ScrapliCfg object Raises: N/A \"\"\" self.open() return self def __exit__( self, exception_type: Optional[Type[BaseException]], exception_value: Optional[BaseException], traceback: Optional[TracebackType], ) -> None: \"\"\" Exit method to cleanup for context manager Args: exception_type: exception type being raised exception_value: message from exception being raised traceback: traceback from exception being raised Returns: None Raises: N/A \"\"\" self.close() def get_version(self) -> ScrapliCfgResponse: \"\"\" Get device version string Args: N/A Returns: ScrapliCfgResponse: response object where result is the string of the primary version (as in the \"main\" os version) of the device Raises: N/A \"\"\" response = self._pre_get_version() version_result = self.conn.send_command(command=self._get_version_command) return self._post_get_version( response=response, scrapli_responses=[version_result], # due to the class hierarchy (and perhaps bad design/decisions?!) implementing a # _parse_version method as an abstractmethod in the platform/base/base_platform class # wont work because of the way the mro will line up, so we will ignore this, but each # platform *must* implement this method (in their respective base platform class) result=self._parse_version(device_output=version_result.result), # type: ignore # noqa ) @abstractmethod def get_config(self, source: str = \"running\") -> ScrapliCfgResponse: \"\"\" Get device configuration Args: source: name of the config source, generally running|startup Returns: ScrapliCfgResponse: response object containing string of the target config source as the `result` attribute Raises: N/A \"\"\" @abstractmethod def load_config(self, config: str, replace: bool = False, **kwargs: Any) -> ScrapliCfgResponse: \"\"\" Load configuration to a device Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see your specific platform for details Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" @abstractmethod def abort_config(self) -> ScrapliCfgResponse: \"\"\" Abort a configuration -- discards any loaded config Args: N/A Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" @abstractmethod def commit_config(self, source: str = \"running\") -> ScrapliCfgResponse: \"\"\" Commit a loaded configuration Args: source: name of the config source to commit against, generally running|startup Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" @abstractmethod def diff_config(self, source: str = \"running\") -> ScrapliCfgDiffResponse: \"\"\" Diff a loaded configuration against the source config store Args: source: name of the config source to diff against, generally running|startup -- device diffs will generally not care about this argument, but the built in scrapli differ will Returns: ScrapliCfgDiffResponse: scrapli cfg diff object Raises: N/A \"\"\" def render_substituted_config( self, config_template: str, substitutes: List[Tuple[str, Pattern[str]]], source: str = \"running\", ) -> str: \"\"\" Render a substituted configuration file Renders a configuration based on a user template, substitutes, and a target config from the device. Args: config_template: config file to use as the base for substitutions -- should contain jinja2-like variables that will be replaced with data fetched from the source config by the substitutes patterns substitutes: tuple of name, pattern -- where name matches the jinja2-like variable in the config_template file, and pattern is a compiled regular expression pattern to be used to fetch that section from the source config source: config source to use for the substitution efforts, typically running|startup Returns: str: substituted/rendered config Raises: N/A \"\"\" self.logger.info(\"fetching configuration and replacing with provided substitutes\") source_config = self.get_config(source=source) return self._render_substituted_config( config_template=config_template, substitutes=substitutes, source_config=source_config.result, ) Classes \u00b6 ScrapliCfgPlatform \u00b6 Helper class that provides a standard way to create an ABC using inheritance. Scrapli Config base class Args: conn: scrapli connection to use config_sources: list of config sources on_open: async callable to run at connection open Returns: None Raises: N/A Expand source code class ScrapliCfgPlatform(ABC, ScrapliCfgBase): def __init__( self, conn: NetworkDriver, config_sources: List[str], on_open: Callable[..., Any] ) -> None: \"\"\" Scrapli Config base class Args: conn: scrapli connection to use config_sources: list of config sources on_open: async callable to run at connection open Returns: None Raises: N/A \"\"\" self.conn = conn self.on_open = on_open super().__init__(config_sources=config_sources) def open(self) -> None: \"\"\" Open the connection and prepare for config operations Does \"normal\" scrapli open things, but also runs the _on_open method of scrapli config which generally does things like disable console logging Args: N/A Returns: None Raises: N/A \"\"\" self.logger.info(\"opening scrapli connection\") if not self.conn.isalive(): self.conn.open() if self._ignore_version is False: self.logger.debug(\"ignore_version is False, fetching device version\") version_response = self.get_version() self._validate_and_set_version(version_response=version_response) self.logger.debug(\"executing scrapli_cfg on open method\") self.on_open(self) def close(self) -> None: \"\"\" Close the scrapli connection Args: N/A Returns: None Raises: N/A \"\"\" self.logger.info(\"closing scrapli connection\") if self.conn.isalive(): self.conn.close() def __enter__(self) -> \"ScrapliCfgPlatform\": \"\"\" Enter method for context manager Args: N/A Returns: ScrapliCfg: opened ScrapliCfg object Raises: N/A \"\"\" self.open() return self def __exit__( self, exception_type: Optional[Type[BaseException]], exception_value: Optional[BaseException], traceback: Optional[TracebackType], ) -> None: \"\"\" Exit method to cleanup for context manager Args: exception_type: exception type being raised exception_value: message from exception being raised traceback: traceback from exception being raised Returns: None Raises: N/A \"\"\" self.close() def get_version(self) -> ScrapliCfgResponse: \"\"\" Get device version string Args: N/A Returns: ScrapliCfgResponse: response object where result is the string of the primary version (as in the \"main\" os version) of the device Raises: N/A \"\"\" response = self._pre_get_version() version_result = self.conn.send_command(command=self._get_version_command) return self._post_get_version( response=response, scrapli_responses=[version_result], # due to the class hierarchy (and perhaps bad design/decisions?!) implementing a # _parse_version method as an abstractmethod in the platform/base/base_platform class # wont work because of the way the mro will line up, so we will ignore this, but each # platform *must* implement this method (in their respective base platform class) result=self._parse_version(device_output=version_result.result), # type: ignore # noqa ) @abstractmethod def get_config(self, source: str = \"running\") -> ScrapliCfgResponse: \"\"\" Get device configuration Args: source: name of the config source, generally running|startup Returns: ScrapliCfgResponse: response object containing string of the target config source as the `result` attribute Raises: N/A \"\"\" @abstractmethod def load_config(self, config: str, replace: bool = False, **kwargs: Any) -> ScrapliCfgResponse: \"\"\" Load configuration to a device Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see your specific platform for details Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" @abstractmethod def abort_config(self) -> ScrapliCfgResponse: \"\"\" Abort a configuration -- discards any loaded config Args: N/A Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" @abstractmethod def commit_config(self, source: str = \"running\") -> ScrapliCfgResponse: \"\"\" Commit a loaded configuration Args: source: name of the config source to commit against, generally running|startup Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" @abstractmethod def diff_config(self, source: str = \"running\") -> ScrapliCfgDiffResponse: \"\"\" Diff a loaded configuration against the source config store Args: source: name of the config source to diff against, generally running|startup -- device diffs will generally not care about this argument, but the built in scrapli differ will Returns: ScrapliCfgDiffResponse: scrapli cfg diff object Raises: N/A \"\"\" def render_substituted_config( self, config_template: str, substitutes: List[Tuple[str, Pattern[str]]], source: str = \"running\", ) -> str: \"\"\" Render a substituted configuration file Renders a configuration based on a user template, substitutes, and a target config from the device. Args: config_template: config file to use as the base for substitutions -- should contain jinja2-like variables that will be replaced with data fetched from the source config by the substitutes patterns substitutes: tuple of name, pattern -- where name matches the jinja2-like variable in the config_template file, and pattern is a compiled regular expression pattern to be used to fetch that section from the source config source: config source to use for the substitution efforts, typically running|startup Returns: str: substituted/rendered config Raises: N/A \"\"\" self.logger.info(\"fetching configuration and replacing with provided substitutes\") source_config = self.get_config(source=source) return self._render_substituted_config( config_template=config_template, substitutes=substitutes, source_config=source_config.result, ) Ancestors (in MRO) \u00b6 abc.ABC scrapli_cfg.platform.base.base_platform.ScrapliCfgBase Descendants \u00b6 scrapli_cfg.platform.core.arista_eos.sync_platform.ScrapliCfgEOS scrapli_cfg.platform.core.cisco_iosxe.sync_platform.ScrapliCfgIOSXE scrapli_cfg.platform.core.cisco_iosxr.sync_platform.ScrapliCfgIOSXR scrapli_cfg.platform.core.cisco_nxos.sync_platform.ScrapliCfgNXOS Class variables \u00b6 conn: Union[scrapli.driver.network.sync_driver.NetworkDriver, scrapli.driver.network.async_driver.AsyncNetworkDriver] Methods \u00b6 abort_config \u00b6 abort_config(self) \u2011> scrapli_cfg.response.ScrapliCfgResponse Abort a configuration -- discards any loaded config Args: N/A Returns: ScrapliCfgResponse: response object Raises: N/A close \u00b6 close(self) \u2011> NoneType Close the scrapli connection Args: N/A Returns: None Raises: N/A commit_config \u00b6 commit_config(self, source: str = 'running') \u2011> scrapli_cfg.response.ScrapliCfgResponse Commit a loaded configuration Args: source: name of the config source to commit against, generally running|startup Returns: ScrapliCfgResponse: response object Raises: N/A diff_config \u00b6 diff_config(self, source: str = 'running') \u2011> scrapli_cfg.diff.ScrapliCfgDiffResponse Diff a loaded configuration against the source config store Args: source: name of the config source to diff against, generally running|startup -- device diffs will generally not care about this argument, but the built in scrapli differ will Returns: ScrapliCfgDiffResponse: scrapli cfg diff object Raises: N/A get_config \u00b6 get_config(self, source: str = 'running') \u2011> scrapli_cfg.response.ScrapliCfgResponse Get device configuration Args: source: name of the config source, generally running|startup Returns: ScrapliCfgResponse: response object containing string of the target config source as the `result` attribute Raises: N/A get_version \u00b6 get_version(self) \u2011> scrapli_cfg.response.ScrapliCfgResponse Get device version string Args: N/A Returns: ScrapliCfgResponse: response object where result is the string of the primary version (as in the \"main\" os version) of the device Raises: N/A load_config \u00b6 load_config(self, config: str, replace: bool = False, **kwargs: Any) \u2011> scrapli_cfg.response.ScrapliCfgResponse Load configuration to a device Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see your specific platform for details Returns: ScrapliCfgResponse: response object Raises: N/A open \u00b6 open(self) \u2011> NoneType Open the connection and prepare for config operations Does \"normal\" scrapli open things, but also runs the _on_open method of scrapli config which generally does things like disable console logging Args: N/A Returns: None Raises: N/A render_substituted_config \u00b6 render_substituted_config(self, config_template: str, substitutes: List[Tuple[str, Pattern[str]]], source: str = 'running') \u2011> str Render a substituted configuration file Renders a configuration based on a user template, substitutes, and a target config from the device. Args: config_template: config file to use as the base for substitutions -- should contain jinja2-like variables that will be replaced with data fetched from the source config by the substitutes patterns substitutes: tuple of name, pattern -- where name matches the jinja2-like variable in the config_template file, and pattern is a compiled regular expression pattern to be used to fetch that section from the source config source: config source to use for the substitution efforts, typically running|startup Returns: str: substituted/rendered config Raises: N/A","title":"Sync Platform"},{"location":"api_docs/platform/base/sync_platform/#module-scrapli_cfgplatformbasesync_platform","text":"scrapli_cfg.platform.sync_platform Expand source code \"\"\"scrapli_cfg.platform.sync_platform\"\"\" from abc import ABC, abstractmethod from types import TracebackType from typing import Any, Callable, List, Optional, Pattern, Tuple, Type from scrapli.driver import NetworkDriver from scrapli_cfg.diff import ScrapliCfgDiffResponse from scrapli_cfg.platform.base.base_platform import ScrapliCfgBase from scrapli_cfg.response import ScrapliCfgResponse class ScrapliCfgPlatform(ABC, ScrapliCfgBase): def __init__( self, conn: NetworkDriver, config_sources: List[str], on_open: Callable[..., Any] ) -> None: \"\"\" Scrapli Config base class Args: conn: scrapli connection to use config_sources: list of config sources on_open: async callable to run at connection open Returns: None Raises: N/A \"\"\" self.conn = conn self.on_open = on_open super().__init__(config_sources=config_sources) def open(self) -> None: \"\"\" Open the connection and prepare for config operations Does \"normal\" scrapli open things, but also runs the _on_open method of scrapli config which generally does things like disable console logging Args: N/A Returns: None Raises: N/A \"\"\" self.logger.info(\"opening scrapli connection\") if not self.conn.isalive(): self.conn.open() if self._ignore_version is False: self.logger.debug(\"ignore_version is False, fetching device version\") version_response = self.get_version() self._validate_and_set_version(version_response=version_response) self.logger.debug(\"executing scrapli_cfg on open method\") self.on_open(self) def close(self) -> None: \"\"\" Close the scrapli connection Args: N/A Returns: None Raises: N/A \"\"\" self.logger.info(\"closing scrapli connection\") if self.conn.isalive(): self.conn.close() def __enter__(self) -> \"ScrapliCfgPlatform\": \"\"\" Enter method for context manager Args: N/A Returns: ScrapliCfg: opened ScrapliCfg object Raises: N/A \"\"\" self.open() return self def __exit__( self, exception_type: Optional[Type[BaseException]], exception_value: Optional[BaseException], traceback: Optional[TracebackType], ) -> None: \"\"\" Exit method to cleanup for context manager Args: exception_type: exception type being raised exception_value: message from exception being raised traceback: traceback from exception being raised Returns: None Raises: N/A \"\"\" self.close() def get_version(self) -> ScrapliCfgResponse: \"\"\" Get device version string Args: N/A Returns: ScrapliCfgResponse: response object where result is the string of the primary version (as in the \"main\" os version) of the device Raises: N/A \"\"\" response = self._pre_get_version() version_result = self.conn.send_command(command=self._get_version_command) return self._post_get_version( response=response, scrapli_responses=[version_result], # due to the class hierarchy (and perhaps bad design/decisions?!) implementing a # _parse_version method as an abstractmethod in the platform/base/base_platform class # wont work because of the way the mro will line up, so we will ignore this, but each # platform *must* implement this method (in their respective base platform class) result=self._parse_version(device_output=version_result.result), # type: ignore # noqa ) @abstractmethod def get_config(self, source: str = \"running\") -> ScrapliCfgResponse: \"\"\" Get device configuration Args: source: name of the config source, generally running|startup Returns: ScrapliCfgResponse: response object containing string of the target config source as the `result` attribute Raises: N/A \"\"\" @abstractmethod def load_config(self, config: str, replace: bool = False, **kwargs: Any) -> ScrapliCfgResponse: \"\"\" Load configuration to a device Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see your specific platform for details Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" @abstractmethod def abort_config(self) -> ScrapliCfgResponse: \"\"\" Abort a configuration -- discards any loaded config Args: N/A Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" @abstractmethod def commit_config(self, source: str = \"running\") -> ScrapliCfgResponse: \"\"\" Commit a loaded configuration Args: source: name of the config source to commit against, generally running|startup Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" @abstractmethod def diff_config(self, source: str = \"running\") -> ScrapliCfgDiffResponse: \"\"\" Diff a loaded configuration against the source config store Args: source: name of the config source to diff against, generally running|startup -- device diffs will generally not care about this argument, but the built in scrapli differ will Returns: ScrapliCfgDiffResponse: scrapli cfg diff object Raises: N/A \"\"\" def render_substituted_config( self, config_template: str, substitutes: List[Tuple[str, Pattern[str]]], source: str = \"running\", ) -> str: \"\"\" Render a substituted configuration file Renders a configuration based on a user template, substitutes, and a target config from the device. Args: config_template: config file to use as the base for substitutions -- should contain jinja2-like variables that will be replaced with data fetched from the source config by the substitutes patterns substitutes: tuple of name, pattern -- where name matches the jinja2-like variable in the config_template file, and pattern is a compiled regular expression pattern to be used to fetch that section from the source config source: config source to use for the substitution efforts, typically running|startup Returns: str: substituted/rendered config Raises: N/A \"\"\" self.logger.info(\"fetching configuration and replacing with provided substitutes\") source_config = self.get_config(source=source) return self._render_substituted_config( config_template=config_template, substitutes=substitutes, source_config=source_config.result, )","title":"Module scrapli_cfg.platform.base.sync_platform"},{"location":"api_docs/platform/base/sync_platform/#classes","text":"","title":"Classes"},{"location":"api_docs/platform/base/sync_platform/#scraplicfgplatform","text":"Helper class that provides a standard way to create an ABC using inheritance. Scrapli Config base class Args: conn: scrapli connection to use config_sources: list of config sources on_open: async callable to run at connection open Returns: None Raises: N/A Expand source code class ScrapliCfgPlatform(ABC, ScrapliCfgBase): def __init__( self, conn: NetworkDriver, config_sources: List[str], on_open: Callable[..., Any] ) -> None: \"\"\" Scrapli Config base class Args: conn: scrapli connection to use config_sources: list of config sources on_open: async callable to run at connection open Returns: None Raises: N/A \"\"\" self.conn = conn self.on_open = on_open super().__init__(config_sources=config_sources) def open(self) -> None: \"\"\" Open the connection and prepare for config operations Does \"normal\" scrapli open things, but also runs the _on_open method of scrapli config which generally does things like disable console logging Args: N/A Returns: None Raises: N/A \"\"\" self.logger.info(\"opening scrapli connection\") if not self.conn.isalive(): self.conn.open() if self._ignore_version is False: self.logger.debug(\"ignore_version is False, fetching device version\") version_response = self.get_version() self._validate_and_set_version(version_response=version_response) self.logger.debug(\"executing scrapli_cfg on open method\") self.on_open(self) def close(self) -> None: \"\"\" Close the scrapli connection Args: N/A Returns: None Raises: N/A \"\"\" self.logger.info(\"closing scrapli connection\") if self.conn.isalive(): self.conn.close() def __enter__(self) -> \"ScrapliCfgPlatform\": \"\"\" Enter method for context manager Args: N/A Returns: ScrapliCfg: opened ScrapliCfg object Raises: N/A \"\"\" self.open() return self def __exit__( self, exception_type: Optional[Type[BaseException]], exception_value: Optional[BaseException], traceback: Optional[TracebackType], ) -> None: \"\"\" Exit method to cleanup for context manager Args: exception_type: exception type being raised exception_value: message from exception being raised traceback: traceback from exception being raised Returns: None Raises: N/A \"\"\" self.close() def get_version(self) -> ScrapliCfgResponse: \"\"\" Get device version string Args: N/A Returns: ScrapliCfgResponse: response object where result is the string of the primary version (as in the \"main\" os version) of the device Raises: N/A \"\"\" response = self._pre_get_version() version_result = self.conn.send_command(command=self._get_version_command) return self._post_get_version( response=response, scrapli_responses=[version_result], # due to the class hierarchy (and perhaps bad design/decisions?!) implementing a # _parse_version method as an abstractmethod in the platform/base/base_platform class # wont work because of the way the mro will line up, so we will ignore this, but each # platform *must* implement this method (in their respective base platform class) result=self._parse_version(device_output=version_result.result), # type: ignore # noqa ) @abstractmethod def get_config(self, source: str = \"running\") -> ScrapliCfgResponse: \"\"\" Get device configuration Args: source: name of the config source, generally running|startup Returns: ScrapliCfgResponse: response object containing string of the target config source as the `result` attribute Raises: N/A \"\"\" @abstractmethod def load_config(self, config: str, replace: bool = False, **kwargs: Any) -> ScrapliCfgResponse: \"\"\" Load configuration to a device Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see your specific platform for details Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" @abstractmethod def abort_config(self) -> ScrapliCfgResponse: \"\"\" Abort a configuration -- discards any loaded config Args: N/A Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" @abstractmethod def commit_config(self, source: str = \"running\") -> ScrapliCfgResponse: \"\"\" Commit a loaded configuration Args: source: name of the config source to commit against, generally running|startup Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" @abstractmethod def diff_config(self, source: str = \"running\") -> ScrapliCfgDiffResponse: \"\"\" Diff a loaded configuration against the source config store Args: source: name of the config source to diff against, generally running|startup -- device diffs will generally not care about this argument, but the built in scrapli differ will Returns: ScrapliCfgDiffResponse: scrapli cfg diff object Raises: N/A \"\"\" def render_substituted_config( self, config_template: str, substitutes: List[Tuple[str, Pattern[str]]], source: str = \"running\", ) -> str: \"\"\" Render a substituted configuration file Renders a configuration based on a user template, substitutes, and a target config from the device. Args: config_template: config file to use as the base for substitutions -- should contain jinja2-like variables that will be replaced with data fetched from the source config by the substitutes patterns substitutes: tuple of name, pattern -- where name matches the jinja2-like variable in the config_template file, and pattern is a compiled regular expression pattern to be used to fetch that section from the source config source: config source to use for the substitution efforts, typically running|startup Returns: str: substituted/rendered config Raises: N/A \"\"\" self.logger.info(\"fetching configuration and replacing with provided substitutes\") source_config = self.get_config(source=source) return self._render_substituted_config( config_template=config_template, substitutes=substitutes, source_config=source_config.result, )","title":"ScrapliCfgPlatform"},{"location":"api_docs/platform/base/sync_platform/#ancestors-in-mro","text":"abc.ABC scrapli_cfg.platform.base.base_platform.ScrapliCfgBase","title":"Ancestors (in MRO)"},{"location":"api_docs/platform/base/sync_platform/#descendants","text":"scrapli_cfg.platform.core.arista_eos.sync_platform.ScrapliCfgEOS scrapli_cfg.platform.core.cisco_iosxe.sync_platform.ScrapliCfgIOSXE scrapli_cfg.platform.core.cisco_iosxr.sync_platform.ScrapliCfgIOSXR scrapli_cfg.platform.core.cisco_nxos.sync_platform.ScrapliCfgNXOS","title":"Descendants"},{"location":"api_docs/platform/base/sync_platform/#class-variables","text":"conn: Union[scrapli.driver.network.sync_driver.NetworkDriver, scrapli.driver.network.async_driver.AsyncNetworkDriver]","title":"Class variables"},{"location":"api_docs/platform/base/sync_platform/#methods","text":"","title":"Methods"},{"location":"api_docs/platform/base/sync_platform/#abort_config","text":"abort_config(self) \u2011> scrapli_cfg.response.ScrapliCfgResponse Abort a configuration -- discards any loaded config Args: N/A Returns: ScrapliCfgResponse: response object Raises: N/A","title":"abort_config"},{"location":"api_docs/platform/base/sync_platform/#close","text":"close(self) \u2011> NoneType Close the scrapli connection Args: N/A Returns: None Raises: N/A","title":"close"},{"location":"api_docs/platform/base/sync_platform/#commit_config","text":"commit_config(self, source: str = 'running') \u2011> scrapli_cfg.response.ScrapliCfgResponse Commit a loaded configuration Args: source: name of the config source to commit against, generally running|startup Returns: ScrapliCfgResponse: response object Raises: N/A","title":"commit_config"},{"location":"api_docs/platform/base/sync_platform/#diff_config","text":"diff_config(self, source: str = 'running') \u2011> scrapli_cfg.diff.ScrapliCfgDiffResponse Diff a loaded configuration against the source config store Args: source: name of the config source to diff against, generally running|startup -- device diffs will generally not care about this argument, but the built in scrapli differ will Returns: ScrapliCfgDiffResponse: scrapli cfg diff object Raises: N/A","title":"diff_config"},{"location":"api_docs/platform/base/sync_platform/#get_config","text":"get_config(self, source: str = 'running') \u2011> scrapli_cfg.response.ScrapliCfgResponse Get device configuration Args: source: name of the config source, generally running|startup Returns: ScrapliCfgResponse: response object containing string of the target config source as the `result` attribute Raises: N/A","title":"get_config"},{"location":"api_docs/platform/base/sync_platform/#get_version","text":"get_version(self) \u2011> scrapli_cfg.response.ScrapliCfgResponse Get device version string Args: N/A Returns: ScrapliCfgResponse: response object where result is the string of the primary version (as in the \"main\" os version) of the device Raises: N/A","title":"get_version"},{"location":"api_docs/platform/base/sync_platform/#load_config","text":"load_config(self, config: str, replace: bool = False, **kwargs: Any) \u2011> scrapli_cfg.response.ScrapliCfgResponse Load configuration to a device Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see your specific platform for details Returns: ScrapliCfgResponse: response object Raises: N/A","title":"load_config"},{"location":"api_docs/platform/base/sync_platform/#open","text":"open(self) \u2011> NoneType Open the connection and prepare for config operations Does \"normal\" scrapli open things, but also runs the _on_open method of scrapli config which generally does things like disable console logging Args: N/A Returns: None Raises: N/A","title":"open"},{"location":"api_docs/platform/base/sync_platform/#render_substituted_config","text":"render_substituted_config(self, config_template: str, substitutes: List[Tuple[str, Pattern[str]]], source: str = 'running') \u2011> str Render a substituted configuration file Renders a configuration based on a user template, substitutes, and a target config from the device. Args: config_template: config file to use as the base for substitutions -- should contain jinja2-like variables that will be replaced with data fetched from the source config by the substitutes patterns substitutes: tuple of name, pattern -- where name matches the jinja2-like variable in the config_template file, and pattern is a compiled regular expression pattern to be used to fetch that section from the source config source: config source to use for the substitution efforts, typically running|startup Returns: str: substituted/rendered config Raises: N/A","title":"render_substituted_config"},{"location":"api_docs/platform/core/arista_eos/async_platform/","text":"window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting()) Module scrapli_cfg.platform.core.arista_eos.async_platform \u00b6 scrapli_cfg.platform.core.arista_eos.async_platform Expand source code \"\"\"scrapli_cfg.platform.core.arista_eos.async_platform\"\"\" from typing import Any, Callable, List, Optional from scrapli.driver import AsyncNetworkDriver from scrapli.response import Response from scrapli_cfg.diff import ScrapliCfgDiffResponse from scrapli_cfg.exceptions import DiffConfigError, LoadConfigError, ScrapliCfgException from scrapli_cfg.platform.base.async_platform import AsyncScrapliCfgPlatform from scrapli_cfg.platform.core.arista_eos.base_platform import CONFIG_SOURCES, ScrapliCfgEOSBase from scrapli_cfg.response import ScrapliCfgResponse async def async_eos_on_open(cls: AsyncScrapliCfgPlatform) -> None: \"\"\" Scrapli CFG EOS On open Disable console logging, perhaps more things in the future! Args: cls: ScrapliCfg object Returns: None Raises: N/A \"\"\" await cls.conn.send_config(config=\"no logging console\") class AsyncScrapliCfgEOS(AsyncScrapliCfgPlatform, ScrapliCfgEOSBase): def __init__( self, conn: AsyncNetworkDriver, config_sources: Optional[List[str]] = None, on_open: Optional[Callable[..., Any]] = None, ) -> None: if config_sources is None: config_sources = CONFIG_SOURCES if on_open is None: on_open = async_eos_on_open super().__init__(conn=conn, config_sources=config_sources, on_open=on_open) self.config_session_name = \"\" self._get_version_command = \"show version | i Software image version\" async def _clear_config_session(self, session_name: str) -> Response: \"\"\" Clear a configuration session Args: session_name: name of session to clear Returns: Response: scrapli response from clearing the session Raises: N/A \"\"\" # Note, early versions of eos supporting config sessions cant be aborted like this, but # i dont want to register a config session for each session we want to delete so we'll just # roll w/ this for now return await self.conn.send_command(command=f\"configure session {session_name} abort\") async def clear_config_sessions( self, session_name: str = \"\", session_prefix: str = \"\" ) -> ScrapliCfgResponse: \"\"\" Clear a specific config session or all sessions with a prefix (ex: scrapli_cfg_) Args: session_name: name of specific config session to clear session_prefix: prefix of session(s) to clear -- ignored if session_name is provided Returns: ScrapliCfgResponse: response object containing string of the target config source as the `result` attribute Raises: N/A \"\"\" scrapli_responses = [] response = self._pre_clear_config_sessions() try: get_config_sessions_result = await self.conn.send_command( command=\"show config sessions | json\" ) scrapli_responses.append(get_config_sessions_result) if get_config_sessions_result.failed: msg = \"failed to show current config sessions\" self.logger.critical(msg) raise ScrapliCfgException(msg) config_session_names = self._parse_config_sessions( device_output=get_config_sessions_result.result ) for config_session in config_session_names: if session_name: if config_session == session_name: clear_config_session_result = await self._clear_config_session( session_name=session_name ) scrapli_responses.append(clear_config_session_result) else: if config_session.startswith(session_prefix): clear_config_session_result = await self._clear_config_session( session_name=session_name ) scrapli_responses.append(clear_config_session_result) except ScrapliCfgException: pass return self._post_clear_config_sessions( response=response, scrapli_responses=scrapli_responses ) async def get_config(self, source: str = \"running\") -> ScrapliCfgResponse: response = self._pre_get_config(source=source) config_result = await self.conn.send_command( command=self._get_config_command(source=source) ) return self._post_get_config( response=response, source=source, scrapli_responses=[config_result], result=config_result.result, ) async def load_config( self, config: str, replace: bool = False, **kwargs: Any ) -> ScrapliCfgResponse: \"\"\" Load configuration to a device Supported kwargs: N/A Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for eos supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" scrapli_responses = [] response = self._pre_load_config(config=config) ( config, eager_config, register_config_session, ) = self._prepare_load_config_session_and_payload(config=config) try: if register_config_session: # only need to register a session if we havent -- we will reset session to an empty # string after any commits/aborts so we know if we are doing \"new\" operations self.conn.register_configuration_session(session_name=self.config_session_name) if replace: # default the config session - we only need to do this if we are doing a REPLACE rollback_clean_config_result = await self.conn.send_config( config=\"rollback clean-config\", privilege_level=self.config_session_name ) if rollback_clean_config_result.failed: msg = \"failed to load clean config in configuration session\" self.logger.critical(msg) raise LoadConfigError(msg) config_result = await self.conn.send_config( config=config, privilege_level=self.config_session_name ) scrapli_responses.append(config_result) if config_result.failed: msg = \"failed to load the candidate config into the config session\" self.logger.critical(msg) raise LoadConfigError(msg) # eager cuz banners and such; perhaps if no banner/macro we can disable eager though.... if eager_config: eager_config_result = await self.conn.send_config( config=eager_config, privilege_level=self.config_session_name, eager=True ) scrapli_responses.append(eager_config_result) if eager_config_result.failed: msg = \"failed to load the candidate config into the config session\" self.logger.critical(msg) raise LoadConfigError(msg) except LoadConfigError: # we catch our own exception so we dont need to do any if failed checks along the way # as soon as we hit this (or when we are done w/ the try block) we are done loading the # config and can build and return a response object pass return self._post_load_config( response=response, scrapli_responses=scrapli_responses, ) async def abort_config(self) -> ScrapliCfgResponse: response = self._pre_abort_config(session_or_config_file=bool(self.config_session_name)) await self.conn.acquire_priv(desired_priv=self.config_session_name) await self.conn._abort_config() # pylint: disable=W0212 self._reset_config_session() return self._post_abort_config( response=response, scrapli_responses=[], ) async def commit_config(self, source: str = \"running\") -> ScrapliCfgResponse: response = self._pre_commit_config( source=source, session_or_config_file=bool(self.config_session_name) ) commit_results = await self.conn.send_commands( commands=[ f\"configure session {self.config_session_name} commit\", \"copy running-config startup-config\", ] ) self._reset_config_session() return self._post_commit_config(response=response, scrapli_responses=commit_results) async def diff_config(self, source: str = \"running\") -> ScrapliCfgDiffResponse: scrapli_responses = [] device_diff = \"\" source_config = \"\" diff_response = self._pre_diff_config( source=source, session_or_config_file=bool(self.config_session_name) ) try: diff_result = await self.conn.send_config( config=\"show session-config diffs\", privilege_level=self.config_session_name ) scrapli_responses.append(diff_result) if diff_result.failed: msg = \"failed generating diff for config session\" self.logger.critical(msg) raise DiffConfigError(msg) device_diff = diff_result.result source_config_result = await self.get_config(source=source) source_config = source_config_result.result if source_config_result.scrapli_responses: scrapli_responses.extend(source_config_result.scrapli_responses) if source_config_result.failed: msg = \"failed fetching source config for diff comparison\" self.logger.critical(msg) raise DiffConfigError(msg) except DiffConfigError: pass source_config, candidate_config = self._normalize_source_candidate_configs( source_config=source_config ) return self._post_diff_config( diff_response=diff_response, scrapli_responses=scrapli_responses, source_config=source_config, candidate_config=candidate_config, device_diff=device_diff, ) Functions \u00b6 async_eos_on_open \u00b6 async_eos_on_open(cls: scrapli_cfg.platform.base.async_platform.AsyncScrapliCfgPlatform) \u2011> NoneType Scrapli CFG EOS On open Disable console logging, perhaps more things in the future! Args: cls: ScrapliCfg object Returns: None Raises: N/A Classes \u00b6 AsyncScrapliCfgEOS \u00b6 Helper class that provides a standard way to create an ABC using inheritance. Scrapli Config async base class Args: conn: scrapli connection to use config_sources: list of config sources on_open: async callable to run at connection open Returns: None Raises: N/A Expand source code class AsyncScrapliCfgEOS(AsyncScrapliCfgPlatform, ScrapliCfgEOSBase): def __init__( self, conn: AsyncNetworkDriver, config_sources: Optional[List[str]] = None, on_open: Optional[Callable[..., Any]] = None, ) -> None: if config_sources is None: config_sources = CONFIG_SOURCES if on_open is None: on_open = async_eos_on_open super().__init__(conn=conn, config_sources=config_sources, on_open=on_open) self.config_session_name = \"\" self._get_version_command = \"show version | i Software image version\" async def _clear_config_session(self, session_name: str) -> Response: \"\"\" Clear a configuration session Args: session_name: name of session to clear Returns: Response: scrapli response from clearing the session Raises: N/A \"\"\" # Note, early versions of eos supporting config sessions cant be aborted like this, but # i dont want to register a config session for each session we want to delete so we'll just # roll w/ this for now return await self.conn.send_command(command=f\"configure session {session_name} abort\") async def clear_config_sessions( self, session_name: str = \"\", session_prefix: str = \"\" ) -> ScrapliCfgResponse: \"\"\" Clear a specific config session or all sessions with a prefix (ex: scrapli_cfg_) Args: session_name: name of specific config session to clear session_prefix: prefix of session(s) to clear -- ignored if session_name is provided Returns: ScrapliCfgResponse: response object containing string of the target config source as the `result` attribute Raises: N/A \"\"\" scrapli_responses = [] response = self._pre_clear_config_sessions() try: get_config_sessions_result = await self.conn.send_command( command=\"show config sessions | json\" ) scrapli_responses.append(get_config_sessions_result) if get_config_sessions_result.failed: msg = \"failed to show current config sessions\" self.logger.critical(msg) raise ScrapliCfgException(msg) config_session_names = self._parse_config_sessions( device_output=get_config_sessions_result.result ) for config_session in config_session_names: if session_name: if config_session == session_name: clear_config_session_result = await self._clear_config_session( session_name=session_name ) scrapli_responses.append(clear_config_session_result) else: if config_session.startswith(session_prefix): clear_config_session_result = await self._clear_config_session( session_name=session_name ) scrapli_responses.append(clear_config_session_result) except ScrapliCfgException: pass return self._post_clear_config_sessions( response=response, scrapli_responses=scrapli_responses ) async def get_config(self, source: str = \"running\") -> ScrapliCfgResponse: response = self._pre_get_config(source=source) config_result = await self.conn.send_command( command=self._get_config_command(source=source) ) return self._post_get_config( response=response, source=source, scrapli_responses=[config_result], result=config_result.result, ) async def load_config( self, config: str, replace: bool = False, **kwargs: Any ) -> ScrapliCfgResponse: \"\"\" Load configuration to a device Supported kwargs: N/A Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for eos supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" scrapli_responses = [] response = self._pre_load_config(config=config) ( config, eager_config, register_config_session, ) = self._prepare_load_config_session_and_payload(config=config) try: if register_config_session: # only need to register a session if we havent -- we will reset session to an empty # string after any commits/aborts so we know if we are doing \"new\" operations self.conn.register_configuration_session(session_name=self.config_session_name) if replace: # default the config session - we only need to do this if we are doing a REPLACE rollback_clean_config_result = await self.conn.send_config( config=\"rollback clean-config\", privilege_level=self.config_session_name ) if rollback_clean_config_result.failed: msg = \"failed to load clean config in configuration session\" self.logger.critical(msg) raise LoadConfigError(msg) config_result = await self.conn.send_config( config=config, privilege_level=self.config_session_name ) scrapli_responses.append(config_result) if config_result.failed: msg = \"failed to load the candidate config into the config session\" self.logger.critical(msg) raise LoadConfigError(msg) # eager cuz banners and such; perhaps if no banner/macro we can disable eager though.... if eager_config: eager_config_result = await self.conn.send_config( config=eager_config, privilege_level=self.config_session_name, eager=True ) scrapli_responses.append(eager_config_result) if eager_config_result.failed: msg = \"failed to load the candidate config into the config session\" self.logger.critical(msg) raise LoadConfigError(msg) except LoadConfigError: # we catch our own exception so we dont need to do any if failed checks along the way # as soon as we hit this (or when we are done w/ the try block) we are done loading the # config and can build and return a response object pass return self._post_load_config( response=response, scrapli_responses=scrapli_responses, ) async def abort_config(self) -> ScrapliCfgResponse: response = self._pre_abort_config(session_or_config_file=bool(self.config_session_name)) await self.conn.acquire_priv(desired_priv=self.config_session_name) await self.conn._abort_config() # pylint: disable=W0212 self._reset_config_session() return self._post_abort_config( response=response, scrapli_responses=[], ) async def commit_config(self, source: str = \"running\") -> ScrapliCfgResponse: response = self._pre_commit_config( source=source, session_or_config_file=bool(self.config_session_name) ) commit_results = await self.conn.send_commands( commands=[ f\"configure session {self.config_session_name} commit\", \"copy running-config startup-config\", ] ) self._reset_config_session() return self._post_commit_config(response=response, scrapli_responses=commit_results) async def diff_config(self, source: str = \"running\") -> ScrapliCfgDiffResponse: scrapli_responses = [] device_diff = \"\" source_config = \"\" diff_response = self._pre_diff_config( source=source, session_or_config_file=bool(self.config_session_name) ) try: diff_result = await self.conn.send_config( config=\"show session-config diffs\", privilege_level=self.config_session_name ) scrapli_responses.append(diff_result) if diff_result.failed: msg = \"failed generating diff for config session\" self.logger.critical(msg) raise DiffConfigError(msg) device_diff = diff_result.result source_config_result = await self.get_config(source=source) source_config = source_config_result.result if source_config_result.scrapli_responses: scrapli_responses.extend(source_config_result.scrapli_responses) if source_config_result.failed: msg = \"failed fetching source config for diff comparison\" self.logger.critical(msg) raise DiffConfigError(msg) except DiffConfigError: pass source_config, candidate_config = self._normalize_source_candidate_configs( source_config=source_config ) return self._post_diff_config( diff_response=diff_response, scrapli_responses=scrapli_responses, source_config=source_config, candidate_config=candidate_config, device_diff=device_diff, ) Ancestors (in MRO) \u00b6 scrapli_cfg.platform.base.async_platform.AsyncScrapliCfgPlatform abc.ABC scrapli_cfg.platform.base.base_platform.ScrapliCfgBase scrapli_cfg.platform.core.arista_eos.base_platform.ScrapliCfgEOSBase Class variables \u00b6 conn: Union[scrapli.driver.network.sync_driver.NetworkDriver, scrapli.driver.network.async_driver.AsyncNetworkDriver] Methods \u00b6 clear_config_sessions \u00b6 clear_config_sessions(self, session_name: str = '', session_prefix: str = '') \u2011> scrapli_cfg.response.ScrapliCfgResponse Clear a specific config session or all sessions with a prefix (ex: scrapli_cfg_) Args: session_name: name of specific config session to clear session_prefix: prefix of session(s) to clear -- ignored if session_name is provided Returns: ScrapliCfgResponse: response object containing string of the target config source as the `result` attribute Raises: N/A load_config \u00b6 load_config(self, config: str, replace: bool = False, **kwargs: Any) \u2011> scrapli_cfg.response.ScrapliCfgResponse Load configuration to a device Supported kwargs: N/A Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for eos supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A","title":"Async Platform"},{"location":"api_docs/platform/core/arista_eos/async_platform/#module-scrapli_cfgplatformcorearista_eosasync_platform","text":"scrapli_cfg.platform.core.arista_eos.async_platform Expand source code \"\"\"scrapli_cfg.platform.core.arista_eos.async_platform\"\"\" from typing import Any, Callable, List, Optional from scrapli.driver import AsyncNetworkDriver from scrapli.response import Response from scrapli_cfg.diff import ScrapliCfgDiffResponse from scrapli_cfg.exceptions import DiffConfigError, LoadConfigError, ScrapliCfgException from scrapli_cfg.platform.base.async_platform import AsyncScrapliCfgPlatform from scrapli_cfg.platform.core.arista_eos.base_platform import CONFIG_SOURCES, ScrapliCfgEOSBase from scrapli_cfg.response import ScrapliCfgResponse async def async_eos_on_open(cls: AsyncScrapliCfgPlatform) -> None: \"\"\" Scrapli CFG EOS On open Disable console logging, perhaps more things in the future! Args: cls: ScrapliCfg object Returns: None Raises: N/A \"\"\" await cls.conn.send_config(config=\"no logging console\") class AsyncScrapliCfgEOS(AsyncScrapliCfgPlatform, ScrapliCfgEOSBase): def __init__( self, conn: AsyncNetworkDriver, config_sources: Optional[List[str]] = None, on_open: Optional[Callable[..., Any]] = None, ) -> None: if config_sources is None: config_sources = CONFIG_SOURCES if on_open is None: on_open = async_eos_on_open super().__init__(conn=conn, config_sources=config_sources, on_open=on_open) self.config_session_name = \"\" self._get_version_command = \"show version | i Software image version\" async def _clear_config_session(self, session_name: str) -> Response: \"\"\" Clear a configuration session Args: session_name: name of session to clear Returns: Response: scrapli response from clearing the session Raises: N/A \"\"\" # Note, early versions of eos supporting config sessions cant be aborted like this, but # i dont want to register a config session for each session we want to delete so we'll just # roll w/ this for now return await self.conn.send_command(command=f\"configure session {session_name} abort\") async def clear_config_sessions( self, session_name: str = \"\", session_prefix: str = \"\" ) -> ScrapliCfgResponse: \"\"\" Clear a specific config session or all sessions with a prefix (ex: scrapli_cfg_) Args: session_name: name of specific config session to clear session_prefix: prefix of session(s) to clear -- ignored if session_name is provided Returns: ScrapliCfgResponse: response object containing string of the target config source as the `result` attribute Raises: N/A \"\"\" scrapli_responses = [] response = self._pre_clear_config_sessions() try: get_config_sessions_result = await self.conn.send_command( command=\"show config sessions | json\" ) scrapli_responses.append(get_config_sessions_result) if get_config_sessions_result.failed: msg = \"failed to show current config sessions\" self.logger.critical(msg) raise ScrapliCfgException(msg) config_session_names = self._parse_config_sessions( device_output=get_config_sessions_result.result ) for config_session in config_session_names: if session_name: if config_session == session_name: clear_config_session_result = await self._clear_config_session( session_name=session_name ) scrapli_responses.append(clear_config_session_result) else: if config_session.startswith(session_prefix): clear_config_session_result = await self._clear_config_session( session_name=session_name ) scrapli_responses.append(clear_config_session_result) except ScrapliCfgException: pass return self._post_clear_config_sessions( response=response, scrapli_responses=scrapli_responses ) async def get_config(self, source: str = \"running\") -> ScrapliCfgResponse: response = self._pre_get_config(source=source) config_result = await self.conn.send_command( command=self._get_config_command(source=source) ) return self._post_get_config( response=response, source=source, scrapli_responses=[config_result], result=config_result.result, ) async def load_config( self, config: str, replace: bool = False, **kwargs: Any ) -> ScrapliCfgResponse: \"\"\" Load configuration to a device Supported kwargs: N/A Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for eos supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" scrapli_responses = [] response = self._pre_load_config(config=config) ( config, eager_config, register_config_session, ) = self._prepare_load_config_session_and_payload(config=config) try: if register_config_session: # only need to register a session if we havent -- we will reset session to an empty # string after any commits/aborts so we know if we are doing \"new\" operations self.conn.register_configuration_session(session_name=self.config_session_name) if replace: # default the config session - we only need to do this if we are doing a REPLACE rollback_clean_config_result = await self.conn.send_config( config=\"rollback clean-config\", privilege_level=self.config_session_name ) if rollback_clean_config_result.failed: msg = \"failed to load clean config in configuration session\" self.logger.critical(msg) raise LoadConfigError(msg) config_result = await self.conn.send_config( config=config, privilege_level=self.config_session_name ) scrapli_responses.append(config_result) if config_result.failed: msg = \"failed to load the candidate config into the config session\" self.logger.critical(msg) raise LoadConfigError(msg) # eager cuz banners and such; perhaps if no banner/macro we can disable eager though.... if eager_config: eager_config_result = await self.conn.send_config( config=eager_config, privilege_level=self.config_session_name, eager=True ) scrapli_responses.append(eager_config_result) if eager_config_result.failed: msg = \"failed to load the candidate config into the config session\" self.logger.critical(msg) raise LoadConfigError(msg) except LoadConfigError: # we catch our own exception so we dont need to do any if failed checks along the way # as soon as we hit this (or when we are done w/ the try block) we are done loading the # config and can build and return a response object pass return self._post_load_config( response=response, scrapli_responses=scrapli_responses, ) async def abort_config(self) -> ScrapliCfgResponse: response = self._pre_abort_config(session_or_config_file=bool(self.config_session_name)) await self.conn.acquire_priv(desired_priv=self.config_session_name) await self.conn._abort_config() # pylint: disable=W0212 self._reset_config_session() return self._post_abort_config( response=response, scrapli_responses=[], ) async def commit_config(self, source: str = \"running\") -> ScrapliCfgResponse: response = self._pre_commit_config( source=source, session_or_config_file=bool(self.config_session_name) ) commit_results = await self.conn.send_commands( commands=[ f\"configure session {self.config_session_name} commit\", \"copy running-config startup-config\", ] ) self._reset_config_session() return self._post_commit_config(response=response, scrapli_responses=commit_results) async def diff_config(self, source: str = \"running\") -> ScrapliCfgDiffResponse: scrapli_responses = [] device_diff = \"\" source_config = \"\" diff_response = self._pre_diff_config( source=source, session_or_config_file=bool(self.config_session_name) ) try: diff_result = await self.conn.send_config( config=\"show session-config diffs\", privilege_level=self.config_session_name ) scrapli_responses.append(diff_result) if diff_result.failed: msg = \"failed generating diff for config session\" self.logger.critical(msg) raise DiffConfigError(msg) device_diff = diff_result.result source_config_result = await self.get_config(source=source) source_config = source_config_result.result if source_config_result.scrapli_responses: scrapli_responses.extend(source_config_result.scrapli_responses) if source_config_result.failed: msg = \"failed fetching source config for diff comparison\" self.logger.critical(msg) raise DiffConfigError(msg) except DiffConfigError: pass source_config, candidate_config = self._normalize_source_candidate_configs( source_config=source_config ) return self._post_diff_config( diff_response=diff_response, scrapli_responses=scrapli_responses, source_config=source_config, candidate_config=candidate_config, device_diff=device_diff, )","title":"Module scrapli_cfg.platform.core.arista_eos.async_platform"},{"location":"api_docs/platform/core/arista_eos/async_platform/#functions","text":"","title":"Functions"},{"location":"api_docs/platform/core/arista_eos/async_platform/#async_eos_on_open","text":"async_eos_on_open(cls: scrapli_cfg.platform.base.async_platform.AsyncScrapliCfgPlatform) \u2011> NoneType Scrapli CFG EOS On open Disable console logging, perhaps more things in the future! Args: cls: ScrapliCfg object Returns: None Raises: N/A","title":"async_eos_on_open"},{"location":"api_docs/platform/core/arista_eos/async_platform/#classes","text":"","title":"Classes"},{"location":"api_docs/platform/core/arista_eos/async_platform/#asyncscraplicfgeos","text":"Helper class that provides a standard way to create an ABC using inheritance. Scrapli Config async base class Args: conn: scrapli connection to use config_sources: list of config sources on_open: async callable to run at connection open Returns: None Raises: N/A Expand source code class AsyncScrapliCfgEOS(AsyncScrapliCfgPlatform, ScrapliCfgEOSBase): def __init__( self, conn: AsyncNetworkDriver, config_sources: Optional[List[str]] = None, on_open: Optional[Callable[..., Any]] = None, ) -> None: if config_sources is None: config_sources = CONFIG_SOURCES if on_open is None: on_open = async_eos_on_open super().__init__(conn=conn, config_sources=config_sources, on_open=on_open) self.config_session_name = \"\" self._get_version_command = \"show version | i Software image version\" async def _clear_config_session(self, session_name: str) -> Response: \"\"\" Clear a configuration session Args: session_name: name of session to clear Returns: Response: scrapli response from clearing the session Raises: N/A \"\"\" # Note, early versions of eos supporting config sessions cant be aborted like this, but # i dont want to register a config session for each session we want to delete so we'll just # roll w/ this for now return await self.conn.send_command(command=f\"configure session {session_name} abort\") async def clear_config_sessions( self, session_name: str = \"\", session_prefix: str = \"\" ) -> ScrapliCfgResponse: \"\"\" Clear a specific config session or all sessions with a prefix (ex: scrapli_cfg_) Args: session_name: name of specific config session to clear session_prefix: prefix of session(s) to clear -- ignored if session_name is provided Returns: ScrapliCfgResponse: response object containing string of the target config source as the `result` attribute Raises: N/A \"\"\" scrapli_responses = [] response = self._pre_clear_config_sessions() try: get_config_sessions_result = await self.conn.send_command( command=\"show config sessions | json\" ) scrapli_responses.append(get_config_sessions_result) if get_config_sessions_result.failed: msg = \"failed to show current config sessions\" self.logger.critical(msg) raise ScrapliCfgException(msg) config_session_names = self._parse_config_sessions( device_output=get_config_sessions_result.result ) for config_session in config_session_names: if session_name: if config_session == session_name: clear_config_session_result = await self._clear_config_session( session_name=session_name ) scrapli_responses.append(clear_config_session_result) else: if config_session.startswith(session_prefix): clear_config_session_result = await self._clear_config_session( session_name=session_name ) scrapli_responses.append(clear_config_session_result) except ScrapliCfgException: pass return self._post_clear_config_sessions( response=response, scrapli_responses=scrapli_responses ) async def get_config(self, source: str = \"running\") -> ScrapliCfgResponse: response = self._pre_get_config(source=source) config_result = await self.conn.send_command( command=self._get_config_command(source=source) ) return self._post_get_config( response=response, source=source, scrapli_responses=[config_result], result=config_result.result, ) async def load_config( self, config: str, replace: bool = False, **kwargs: Any ) -> ScrapliCfgResponse: \"\"\" Load configuration to a device Supported kwargs: N/A Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for eos supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" scrapli_responses = [] response = self._pre_load_config(config=config) ( config, eager_config, register_config_session, ) = self._prepare_load_config_session_and_payload(config=config) try: if register_config_session: # only need to register a session if we havent -- we will reset session to an empty # string after any commits/aborts so we know if we are doing \"new\" operations self.conn.register_configuration_session(session_name=self.config_session_name) if replace: # default the config session - we only need to do this if we are doing a REPLACE rollback_clean_config_result = await self.conn.send_config( config=\"rollback clean-config\", privilege_level=self.config_session_name ) if rollback_clean_config_result.failed: msg = \"failed to load clean config in configuration session\" self.logger.critical(msg) raise LoadConfigError(msg) config_result = await self.conn.send_config( config=config, privilege_level=self.config_session_name ) scrapli_responses.append(config_result) if config_result.failed: msg = \"failed to load the candidate config into the config session\" self.logger.critical(msg) raise LoadConfigError(msg) # eager cuz banners and such; perhaps if no banner/macro we can disable eager though.... if eager_config: eager_config_result = await self.conn.send_config( config=eager_config, privilege_level=self.config_session_name, eager=True ) scrapli_responses.append(eager_config_result) if eager_config_result.failed: msg = \"failed to load the candidate config into the config session\" self.logger.critical(msg) raise LoadConfigError(msg) except LoadConfigError: # we catch our own exception so we dont need to do any if failed checks along the way # as soon as we hit this (or when we are done w/ the try block) we are done loading the # config and can build and return a response object pass return self._post_load_config( response=response, scrapli_responses=scrapli_responses, ) async def abort_config(self) -> ScrapliCfgResponse: response = self._pre_abort_config(session_or_config_file=bool(self.config_session_name)) await self.conn.acquire_priv(desired_priv=self.config_session_name) await self.conn._abort_config() # pylint: disable=W0212 self._reset_config_session() return self._post_abort_config( response=response, scrapli_responses=[], ) async def commit_config(self, source: str = \"running\") -> ScrapliCfgResponse: response = self._pre_commit_config( source=source, session_or_config_file=bool(self.config_session_name) ) commit_results = await self.conn.send_commands( commands=[ f\"configure session {self.config_session_name} commit\", \"copy running-config startup-config\", ] ) self._reset_config_session() return self._post_commit_config(response=response, scrapli_responses=commit_results) async def diff_config(self, source: str = \"running\") -> ScrapliCfgDiffResponse: scrapli_responses = [] device_diff = \"\" source_config = \"\" diff_response = self._pre_diff_config( source=source, session_or_config_file=bool(self.config_session_name) ) try: diff_result = await self.conn.send_config( config=\"show session-config diffs\", privilege_level=self.config_session_name ) scrapli_responses.append(diff_result) if diff_result.failed: msg = \"failed generating diff for config session\" self.logger.critical(msg) raise DiffConfigError(msg) device_diff = diff_result.result source_config_result = await self.get_config(source=source) source_config = source_config_result.result if source_config_result.scrapli_responses: scrapli_responses.extend(source_config_result.scrapli_responses) if source_config_result.failed: msg = \"failed fetching source config for diff comparison\" self.logger.critical(msg) raise DiffConfigError(msg) except DiffConfigError: pass source_config, candidate_config = self._normalize_source_candidate_configs( source_config=source_config ) return self._post_diff_config( diff_response=diff_response, scrapli_responses=scrapli_responses, source_config=source_config, candidate_config=candidate_config, device_diff=device_diff, )","title":"AsyncScrapliCfgEOS"},{"location":"api_docs/platform/core/arista_eos/async_platform/#ancestors-in-mro","text":"scrapli_cfg.platform.base.async_platform.AsyncScrapliCfgPlatform abc.ABC scrapli_cfg.platform.base.base_platform.ScrapliCfgBase scrapli_cfg.platform.core.arista_eos.base_platform.ScrapliCfgEOSBase","title":"Ancestors (in MRO)"},{"location":"api_docs/platform/core/arista_eos/async_platform/#class-variables","text":"conn: Union[scrapli.driver.network.sync_driver.NetworkDriver, scrapli.driver.network.async_driver.AsyncNetworkDriver]","title":"Class variables"},{"location":"api_docs/platform/core/arista_eos/async_platform/#methods","text":"","title":"Methods"},{"location":"api_docs/platform/core/arista_eos/async_platform/#clear_config_sessions","text":"clear_config_sessions(self, session_name: str = '', session_prefix: str = '') \u2011> scrapli_cfg.response.ScrapliCfgResponse Clear a specific config session or all sessions with a prefix (ex: scrapli_cfg_) Args: session_name: name of specific config session to clear session_prefix: prefix of session(s) to clear -- ignored if session_name is provided Returns: ScrapliCfgResponse: response object containing string of the target config source as the `result` attribute Raises: N/A","title":"clear_config_sessions"},{"location":"api_docs/platform/core/arista_eos/async_platform/#load_config","text":"load_config(self, config: str, replace: bool = False, **kwargs: Any) \u2011> scrapli_cfg.response.ScrapliCfgResponse Load configuration to a device Supported kwargs: N/A Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for eos supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A","title":"load_config"},{"location":"api_docs/platform/core/arista_eos/base_platform/","text":"window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting()) Module scrapli_cfg.platform.core.arista_eos.base_platform \u00b6 scrapli_cfg.platform.core.arista_eos.base Expand source code \"\"\"scrapli_cfg.platform.core.arista_eos.base\"\"\" import json import re from datetime import datetime from logging import LoggerAdapter from typing import List, Tuple, Union from scrapli.driver import AsyncNetworkDriver, NetworkDriver from scrapli.response import Response from scrapli_cfg.exceptions import ScrapliCfgException from scrapli_cfg.platform.core.arista_eos.patterns import ( BANNER_PATTERN, END_PATTERN, GLOBAL_COMMENT_LINE_PATTERN, VERSION_PATTERN, ) from scrapli_cfg.response import ScrapliCfgResponse CONFIG_SOURCES = [ \"running\", \"startup\", ] class ScrapliCfgEOSBase: conn: Union[NetworkDriver, AsyncNetworkDriver] logger: LoggerAdapter config_sources: List[str] config_session_name: str candidate_config: str @staticmethod def _parse_version(device_output: str) -> str: \"\"\" Parse version string out of device output Args: device_output: output from show version command Returns: str: device version string Raises: N/A \"\"\" version_string_search = re.search(pattern=VERSION_PATTERN, string=device_output) if not version_string_search: return \"\" version_string = version_string_search.group(0) or \"\" return version_string @staticmethod def _parse_config_sessions(device_output: str) -> List[str]: \"\"\" Parse config session names out of device output Args: device_output: output from show version command Returns: list[str]: config session names Raises: N/A \"\"\" try: config_session_dict = json.loads(device_output) except json.JSONDecodeError: return [] sessions = list(config_session_dict.get(\"sessions\", {})) return sessions @staticmethod def _get_config_command(source: str) -> str: \"\"\" Return command to use to get config based on the provided source Args: source: name of the config source, generally running|startup Returns: str: command to use to fetch the requested config Raises: N/A \"\"\" if source == \"running\": return \"show running-config\" return \"show startup-config\" @staticmethod def _prepare_config_payloads(config: str) -> Tuple[str, str]: \"\"\" Prepare a configuration so it can be nicely sent to the device via scrapli Args: config: configuration to prep Returns: tuple: tuple of \"normal\" config lines and \"eager\" config lines Raises: N/A \"\"\" # remove comment lines config = re.sub(pattern=GLOBAL_COMMENT_LINE_PATTERN, repl=\"!\", string=config) # remove \"end\" at the end of config if present - if its present it will drop scrapli out # of the config session which we do not want config = re.sub(pattern=END_PATTERN, repl=\"!\", string=config) # find all sections that need to be \"eagerly\" sent eager_config = re.findall(pattern=BANNER_PATTERN, string=config) for eager_section in eager_config: config = config.replace(eager_section, \"!\") joined_eager_config = \"\\n\".join(eager_config) return config, joined_eager_config def _prepare_load_config_session_and_payload(self, config: str) -> Tuple[str, str, bool]: \"\"\" Prepare the normal and eager payloads and decide if we need to register a config session Args: config: candidate config to load Returns: tuple: tuple containing \"normal\" config elements to send to the device and \"eager\" mode config elements to send to the device (things like banners/macro that require scrapli \"eager=True\"), and lastly a bool indicating if the config session needs to be registered on the device Raises: N/A \"\"\" config, eager_config = self._prepare_config_payloads(config=config) register_config_session = False if not self.config_session_name: self.config_session_name = f\"scrapli_cfg_{round(datetime.now().timestamp())}\" self.logger.debug(f\"configuration session name will be '{self.config_session_name}'\") register_config_session = True return config, eager_config, register_config_session def _reset_config_session(self) -> None: \"\"\" Reset config session info Resets the candidate config and config session name attributes -- when these are \"empty\" we know there is no current config session Args: N/A Returns: None Raises: N/A \"\"\" self.logger.debug(\"resetting candidate config and config session name\") self.candidate_config = \"\" self.config_session_name = \"\" def _normalize_source_candidate_configs(self, source_config: str) -> Tuple[str, str]: \"\"\" Normalize candidate config and source config so that we can easily diff them Args: source_config: current config of the source config store Returns: ScrapliCfgDiff: scrapli cfg diff object Raises: N/A \"\"\" self.logger.debug(\"normalizing source and candidate configs for diff object\") # Remove all comment lines from both the source and candidate configs -- this is only done # here pre-diff, so we dont modify the user provided candidate config which can totally have # those comment lines - we only remove \"global\" (top level) comments though... user comments # attached to interfaces and the stuff will remain source_config = re.sub(pattern=GLOBAL_COMMENT_LINE_PATTERN, string=source_config, repl=\"\") source_config = \"\\n\".join(line for line in source_config.splitlines() if line) candidate_config = re.sub( pattern=GLOBAL_COMMENT_LINE_PATTERN, string=self.candidate_config, repl=\"\" ) candidate_config = \"\\n\".join(line for line in candidate_config.splitlines() if line) return source_config, candidate_config def _pre_clear_config_sessions(self) -> ScrapliCfgResponse: \"\"\" Handle pre \"clear_config_sessions\" operations for parity between sync and async Args: N/A Returns: ScrapliCfgResponse: new response object to update w/ get results Raises: N/A \"\"\" self.logger.info(\"clear_config_sessions requested\") response = ScrapliCfgResponse( host=self.conn.host, raise_for_status_exception=ScrapliCfgException ) return response def _post_clear_config_sessions( self, response: ScrapliCfgResponse, scrapli_responses: List[Response], ) -> ScrapliCfgResponse: \"\"\" Handle post \"clear_config_sessions\" operations for parity between sync and async Args: response: response object to update scrapli_responses: list of scrapli response objects from fetching the version Returns: ScrapliCfgResponse: response object containing string of the version as the `result` attribute Raises: N/A \"\"\" response.record_response(scrapli_responses=scrapli_responses) if response.failed: msg = \"failed to clear device configuration session(s)\" self.logger.critical(msg) response.result = msg else: response.result = \"configuration session(s) cleared\" return response Classes \u00b6 ScrapliCfgEOSBase \u00b6 Expand source code class ScrapliCfgEOSBase: conn: Union[NetworkDriver, AsyncNetworkDriver] logger: LoggerAdapter config_sources: List[str] config_session_name: str candidate_config: str @staticmethod def _parse_version(device_output: str) -> str: \"\"\" Parse version string out of device output Args: device_output: output from show version command Returns: str: device version string Raises: N/A \"\"\" version_string_search = re.search(pattern=VERSION_PATTERN, string=device_output) if not version_string_search: return \"\" version_string = version_string_search.group(0) or \"\" return version_string @staticmethod def _parse_config_sessions(device_output: str) -> List[str]: \"\"\" Parse config session names out of device output Args: device_output: output from show version command Returns: list[str]: config session names Raises: N/A \"\"\" try: config_session_dict = json.loads(device_output) except json.JSONDecodeError: return [] sessions = list(config_session_dict.get(\"sessions\", {})) return sessions @staticmethod def _get_config_command(source: str) -> str: \"\"\" Return command to use to get config based on the provided source Args: source: name of the config source, generally running|startup Returns: str: command to use to fetch the requested config Raises: N/A \"\"\" if source == \"running\": return \"show running-config\" return \"show startup-config\" @staticmethod def _prepare_config_payloads(config: str) -> Tuple[str, str]: \"\"\" Prepare a configuration so it can be nicely sent to the device via scrapli Args: config: configuration to prep Returns: tuple: tuple of \"normal\" config lines and \"eager\" config lines Raises: N/A \"\"\" # remove comment lines config = re.sub(pattern=GLOBAL_COMMENT_LINE_PATTERN, repl=\"!\", string=config) # remove \"end\" at the end of config if present - if its present it will drop scrapli out # of the config session which we do not want config = re.sub(pattern=END_PATTERN, repl=\"!\", string=config) # find all sections that need to be \"eagerly\" sent eager_config = re.findall(pattern=BANNER_PATTERN, string=config) for eager_section in eager_config: config = config.replace(eager_section, \"!\") joined_eager_config = \"\\n\".join(eager_config) return config, joined_eager_config def _prepare_load_config_session_and_payload(self, config: str) -> Tuple[str, str, bool]: \"\"\" Prepare the normal and eager payloads and decide if we need to register a config session Args: config: candidate config to load Returns: tuple: tuple containing \"normal\" config elements to send to the device and \"eager\" mode config elements to send to the device (things like banners/macro that require scrapli \"eager=True\"), and lastly a bool indicating if the config session needs to be registered on the device Raises: N/A \"\"\" config, eager_config = self._prepare_config_payloads(config=config) register_config_session = False if not self.config_session_name: self.config_session_name = f\"scrapli_cfg_{round(datetime.now().timestamp())}\" self.logger.debug(f\"configuration session name will be '{self.config_session_name}'\") register_config_session = True return config, eager_config, register_config_session def _reset_config_session(self) -> None: \"\"\" Reset config session info Resets the candidate config and config session name attributes -- when these are \"empty\" we know there is no current config session Args: N/A Returns: None Raises: N/A \"\"\" self.logger.debug(\"resetting candidate config and config session name\") self.candidate_config = \"\" self.config_session_name = \"\" def _normalize_source_candidate_configs(self, source_config: str) -> Tuple[str, str]: \"\"\" Normalize candidate config and source config so that we can easily diff them Args: source_config: current config of the source config store Returns: ScrapliCfgDiff: scrapli cfg diff object Raises: N/A \"\"\" self.logger.debug(\"normalizing source and candidate configs for diff object\") # Remove all comment lines from both the source and candidate configs -- this is only done # here pre-diff, so we dont modify the user provided candidate config which can totally have # those comment lines - we only remove \"global\" (top level) comments though... user comments # attached to interfaces and the stuff will remain source_config = re.sub(pattern=GLOBAL_COMMENT_LINE_PATTERN, string=source_config, repl=\"\") source_config = \"\\n\".join(line for line in source_config.splitlines() if line) candidate_config = re.sub( pattern=GLOBAL_COMMENT_LINE_PATTERN, string=self.candidate_config, repl=\"\" ) candidate_config = \"\\n\".join(line for line in candidate_config.splitlines() if line) return source_config, candidate_config def _pre_clear_config_sessions(self) -> ScrapliCfgResponse: \"\"\" Handle pre \"clear_config_sessions\" operations for parity between sync and async Args: N/A Returns: ScrapliCfgResponse: new response object to update w/ get results Raises: N/A \"\"\" self.logger.info(\"clear_config_sessions requested\") response = ScrapliCfgResponse( host=self.conn.host, raise_for_status_exception=ScrapliCfgException ) return response def _post_clear_config_sessions( self, response: ScrapliCfgResponse, scrapli_responses: List[Response], ) -> ScrapliCfgResponse: \"\"\" Handle post \"clear_config_sessions\" operations for parity between sync and async Args: response: response object to update scrapli_responses: list of scrapli response objects from fetching the version Returns: ScrapliCfgResponse: response object containing string of the version as the `result` attribute Raises: N/A \"\"\" response.record_response(scrapli_responses=scrapli_responses) if response.failed: msg = \"failed to clear device configuration session(s)\" self.logger.critical(msg) response.result = msg else: response.result = \"configuration session(s) cleared\" return response Descendants \u00b6 scrapli_cfg.platform.core.arista_eos.async_platform.AsyncScrapliCfgEOS scrapli_cfg.platform.core.arista_eos.sync_platform.ScrapliCfgEOS Class variables \u00b6 candidate_config: str config_session_name: str config_sources: List[str] conn: Union[scrapli.driver.network.sync_driver.NetworkDriver, scrapli.driver.network.async_driver.AsyncNetworkDriver] logger: logging.LoggerAdapter","title":"Base platform"},{"location":"api_docs/platform/core/arista_eos/base_platform/#module-scrapli_cfgplatformcorearista_eosbase_platform","text":"scrapli_cfg.platform.core.arista_eos.base Expand source code \"\"\"scrapli_cfg.platform.core.arista_eos.base\"\"\" import json import re from datetime import datetime from logging import LoggerAdapter from typing import List, Tuple, Union from scrapli.driver import AsyncNetworkDriver, NetworkDriver from scrapli.response import Response from scrapli_cfg.exceptions import ScrapliCfgException from scrapli_cfg.platform.core.arista_eos.patterns import ( BANNER_PATTERN, END_PATTERN, GLOBAL_COMMENT_LINE_PATTERN, VERSION_PATTERN, ) from scrapli_cfg.response import ScrapliCfgResponse CONFIG_SOURCES = [ \"running\", \"startup\", ] class ScrapliCfgEOSBase: conn: Union[NetworkDriver, AsyncNetworkDriver] logger: LoggerAdapter config_sources: List[str] config_session_name: str candidate_config: str @staticmethod def _parse_version(device_output: str) -> str: \"\"\" Parse version string out of device output Args: device_output: output from show version command Returns: str: device version string Raises: N/A \"\"\" version_string_search = re.search(pattern=VERSION_PATTERN, string=device_output) if not version_string_search: return \"\" version_string = version_string_search.group(0) or \"\" return version_string @staticmethod def _parse_config_sessions(device_output: str) -> List[str]: \"\"\" Parse config session names out of device output Args: device_output: output from show version command Returns: list[str]: config session names Raises: N/A \"\"\" try: config_session_dict = json.loads(device_output) except json.JSONDecodeError: return [] sessions = list(config_session_dict.get(\"sessions\", {})) return sessions @staticmethod def _get_config_command(source: str) -> str: \"\"\" Return command to use to get config based on the provided source Args: source: name of the config source, generally running|startup Returns: str: command to use to fetch the requested config Raises: N/A \"\"\" if source == \"running\": return \"show running-config\" return \"show startup-config\" @staticmethod def _prepare_config_payloads(config: str) -> Tuple[str, str]: \"\"\" Prepare a configuration so it can be nicely sent to the device via scrapli Args: config: configuration to prep Returns: tuple: tuple of \"normal\" config lines and \"eager\" config lines Raises: N/A \"\"\" # remove comment lines config = re.sub(pattern=GLOBAL_COMMENT_LINE_PATTERN, repl=\"!\", string=config) # remove \"end\" at the end of config if present - if its present it will drop scrapli out # of the config session which we do not want config = re.sub(pattern=END_PATTERN, repl=\"!\", string=config) # find all sections that need to be \"eagerly\" sent eager_config = re.findall(pattern=BANNER_PATTERN, string=config) for eager_section in eager_config: config = config.replace(eager_section, \"!\") joined_eager_config = \"\\n\".join(eager_config) return config, joined_eager_config def _prepare_load_config_session_and_payload(self, config: str) -> Tuple[str, str, bool]: \"\"\" Prepare the normal and eager payloads and decide if we need to register a config session Args: config: candidate config to load Returns: tuple: tuple containing \"normal\" config elements to send to the device and \"eager\" mode config elements to send to the device (things like banners/macro that require scrapli \"eager=True\"), and lastly a bool indicating if the config session needs to be registered on the device Raises: N/A \"\"\" config, eager_config = self._prepare_config_payloads(config=config) register_config_session = False if not self.config_session_name: self.config_session_name = f\"scrapli_cfg_{round(datetime.now().timestamp())}\" self.logger.debug(f\"configuration session name will be '{self.config_session_name}'\") register_config_session = True return config, eager_config, register_config_session def _reset_config_session(self) -> None: \"\"\" Reset config session info Resets the candidate config and config session name attributes -- when these are \"empty\" we know there is no current config session Args: N/A Returns: None Raises: N/A \"\"\" self.logger.debug(\"resetting candidate config and config session name\") self.candidate_config = \"\" self.config_session_name = \"\" def _normalize_source_candidate_configs(self, source_config: str) -> Tuple[str, str]: \"\"\" Normalize candidate config and source config so that we can easily diff them Args: source_config: current config of the source config store Returns: ScrapliCfgDiff: scrapli cfg diff object Raises: N/A \"\"\" self.logger.debug(\"normalizing source and candidate configs for diff object\") # Remove all comment lines from both the source and candidate configs -- this is only done # here pre-diff, so we dont modify the user provided candidate config which can totally have # those comment lines - we only remove \"global\" (top level) comments though... user comments # attached to interfaces and the stuff will remain source_config = re.sub(pattern=GLOBAL_COMMENT_LINE_PATTERN, string=source_config, repl=\"\") source_config = \"\\n\".join(line for line in source_config.splitlines() if line) candidate_config = re.sub( pattern=GLOBAL_COMMENT_LINE_PATTERN, string=self.candidate_config, repl=\"\" ) candidate_config = \"\\n\".join(line for line in candidate_config.splitlines() if line) return source_config, candidate_config def _pre_clear_config_sessions(self) -> ScrapliCfgResponse: \"\"\" Handle pre \"clear_config_sessions\" operations for parity between sync and async Args: N/A Returns: ScrapliCfgResponse: new response object to update w/ get results Raises: N/A \"\"\" self.logger.info(\"clear_config_sessions requested\") response = ScrapliCfgResponse( host=self.conn.host, raise_for_status_exception=ScrapliCfgException ) return response def _post_clear_config_sessions( self, response: ScrapliCfgResponse, scrapli_responses: List[Response], ) -> ScrapliCfgResponse: \"\"\" Handle post \"clear_config_sessions\" operations for parity between sync and async Args: response: response object to update scrapli_responses: list of scrapli response objects from fetching the version Returns: ScrapliCfgResponse: response object containing string of the version as the `result` attribute Raises: N/A \"\"\" response.record_response(scrapli_responses=scrapli_responses) if response.failed: msg = \"failed to clear device configuration session(s)\" self.logger.critical(msg) response.result = msg else: response.result = \"configuration session(s) cleared\" return response","title":"Module scrapli_cfg.platform.core.arista_eos.base_platform"},{"location":"api_docs/platform/core/arista_eos/base_platform/#classes","text":"","title":"Classes"},{"location":"api_docs/platform/core/arista_eos/base_platform/#scraplicfgeosbase","text":"Expand source code class ScrapliCfgEOSBase: conn: Union[NetworkDriver, AsyncNetworkDriver] logger: LoggerAdapter config_sources: List[str] config_session_name: str candidate_config: str @staticmethod def _parse_version(device_output: str) -> str: \"\"\" Parse version string out of device output Args: device_output: output from show version command Returns: str: device version string Raises: N/A \"\"\" version_string_search = re.search(pattern=VERSION_PATTERN, string=device_output) if not version_string_search: return \"\" version_string = version_string_search.group(0) or \"\" return version_string @staticmethod def _parse_config_sessions(device_output: str) -> List[str]: \"\"\" Parse config session names out of device output Args: device_output: output from show version command Returns: list[str]: config session names Raises: N/A \"\"\" try: config_session_dict = json.loads(device_output) except json.JSONDecodeError: return [] sessions = list(config_session_dict.get(\"sessions\", {})) return sessions @staticmethod def _get_config_command(source: str) -> str: \"\"\" Return command to use to get config based on the provided source Args: source: name of the config source, generally running|startup Returns: str: command to use to fetch the requested config Raises: N/A \"\"\" if source == \"running\": return \"show running-config\" return \"show startup-config\" @staticmethod def _prepare_config_payloads(config: str) -> Tuple[str, str]: \"\"\" Prepare a configuration so it can be nicely sent to the device via scrapli Args: config: configuration to prep Returns: tuple: tuple of \"normal\" config lines and \"eager\" config lines Raises: N/A \"\"\" # remove comment lines config = re.sub(pattern=GLOBAL_COMMENT_LINE_PATTERN, repl=\"!\", string=config) # remove \"end\" at the end of config if present - if its present it will drop scrapli out # of the config session which we do not want config = re.sub(pattern=END_PATTERN, repl=\"!\", string=config) # find all sections that need to be \"eagerly\" sent eager_config = re.findall(pattern=BANNER_PATTERN, string=config) for eager_section in eager_config: config = config.replace(eager_section, \"!\") joined_eager_config = \"\\n\".join(eager_config) return config, joined_eager_config def _prepare_load_config_session_and_payload(self, config: str) -> Tuple[str, str, bool]: \"\"\" Prepare the normal and eager payloads and decide if we need to register a config session Args: config: candidate config to load Returns: tuple: tuple containing \"normal\" config elements to send to the device and \"eager\" mode config elements to send to the device (things like banners/macro that require scrapli \"eager=True\"), and lastly a bool indicating if the config session needs to be registered on the device Raises: N/A \"\"\" config, eager_config = self._prepare_config_payloads(config=config) register_config_session = False if not self.config_session_name: self.config_session_name = f\"scrapli_cfg_{round(datetime.now().timestamp())}\" self.logger.debug(f\"configuration session name will be '{self.config_session_name}'\") register_config_session = True return config, eager_config, register_config_session def _reset_config_session(self) -> None: \"\"\" Reset config session info Resets the candidate config and config session name attributes -- when these are \"empty\" we know there is no current config session Args: N/A Returns: None Raises: N/A \"\"\" self.logger.debug(\"resetting candidate config and config session name\") self.candidate_config = \"\" self.config_session_name = \"\" def _normalize_source_candidate_configs(self, source_config: str) -> Tuple[str, str]: \"\"\" Normalize candidate config and source config so that we can easily diff them Args: source_config: current config of the source config store Returns: ScrapliCfgDiff: scrapli cfg diff object Raises: N/A \"\"\" self.logger.debug(\"normalizing source and candidate configs for diff object\") # Remove all comment lines from both the source and candidate configs -- this is only done # here pre-diff, so we dont modify the user provided candidate config which can totally have # those comment lines - we only remove \"global\" (top level) comments though... user comments # attached to interfaces and the stuff will remain source_config = re.sub(pattern=GLOBAL_COMMENT_LINE_PATTERN, string=source_config, repl=\"\") source_config = \"\\n\".join(line for line in source_config.splitlines() if line) candidate_config = re.sub( pattern=GLOBAL_COMMENT_LINE_PATTERN, string=self.candidate_config, repl=\"\" ) candidate_config = \"\\n\".join(line for line in candidate_config.splitlines() if line) return source_config, candidate_config def _pre_clear_config_sessions(self) -> ScrapliCfgResponse: \"\"\" Handle pre \"clear_config_sessions\" operations for parity between sync and async Args: N/A Returns: ScrapliCfgResponse: new response object to update w/ get results Raises: N/A \"\"\" self.logger.info(\"clear_config_sessions requested\") response = ScrapliCfgResponse( host=self.conn.host, raise_for_status_exception=ScrapliCfgException ) return response def _post_clear_config_sessions( self, response: ScrapliCfgResponse, scrapli_responses: List[Response], ) -> ScrapliCfgResponse: \"\"\" Handle post \"clear_config_sessions\" operations for parity between sync and async Args: response: response object to update scrapli_responses: list of scrapli response objects from fetching the version Returns: ScrapliCfgResponse: response object containing string of the version as the `result` attribute Raises: N/A \"\"\" response.record_response(scrapli_responses=scrapli_responses) if response.failed: msg = \"failed to clear device configuration session(s)\" self.logger.critical(msg) response.result = msg else: response.result = \"configuration session(s) cleared\" return response","title":"ScrapliCfgEOSBase"},{"location":"api_docs/platform/core/arista_eos/base_platform/#descendants","text":"scrapli_cfg.platform.core.arista_eos.async_platform.AsyncScrapliCfgEOS scrapli_cfg.platform.core.arista_eos.sync_platform.ScrapliCfgEOS","title":"Descendants"},{"location":"api_docs/platform/core/arista_eos/base_platform/#class-variables","text":"candidate_config: str config_session_name: str config_sources: List[str] conn: Union[scrapli.driver.network.sync_driver.NetworkDriver, scrapli.driver.network.async_driver.AsyncNetworkDriver] logger: logging.LoggerAdapter","title":"Class variables"},{"location":"api_docs/platform/core/arista_eos/patterns/","text":"window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting()) Module scrapli_cfg.platform.core.arista_eos.patterns \u00b6 scrapli_cfg.platform.core.arista_eos.patterns Expand source code \"\"\"scrapli_cfg.platform.core.arista_eos.patterns\"\"\" import re VERSION_PATTERN = re.compile(pattern=r\"\\d+\\.\\d+\\.[a-z0-9\\-]+(\\.\\d+[a-z]{0,1})?\", flags=re.I) GLOBAL_COMMENT_LINE_PATTERN = re.compile(pattern=r\"^\\! .*$\", flags=re.I | re.M) BANNER_PATTERN = re.compile(pattern=r\"^banner.*EOF$\", flags=re.I | re.M | re.S) END_PATTERN = re.compile(pattern=\"end$\") # pre-canned config section grabber patterns # match all ethernet interfaces w/ or w/out config items below them ETHERNET_INTERFACES = re.compile( pattern=r\"(^interface ethernet\\d+$(?:\\n^\\s{3}.*$)*\\n!\\n)+\", flags=re.I | re.M ) # match management1 interface and config items below it MANAGEMENT_ONE_INTERFACE = re.compile( pattern=r\"^interface management1$(?:\\n^\\s{3}.*$)*\\n!\", flags=re.I | re.M )","title":"Patterns"},{"location":"api_docs/platform/core/arista_eos/patterns/#module-scrapli_cfgplatformcorearista_eospatterns","text":"scrapli_cfg.platform.core.arista_eos.patterns Expand source code \"\"\"scrapli_cfg.platform.core.arista_eos.patterns\"\"\" import re VERSION_PATTERN = re.compile(pattern=r\"\\d+\\.\\d+\\.[a-z0-9\\-]+(\\.\\d+[a-z]{0,1})?\", flags=re.I) GLOBAL_COMMENT_LINE_PATTERN = re.compile(pattern=r\"^\\! .*$\", flags=re.I | re.M) BANNER_PATTERN = re.compile(pattern=r\"^banner.*EOF$\", flags=re.I | re.M | re.S) END_PATTERN = re.compile(pattern=\"end$\") # pre-canned config section grabber patterns # match all ethernet interfaces w/ or w/out config items below them ETHERNET_INTERFACES = re.compile( pattern=r\"(^interface ethernet\\d+$(?:\\n^\\s{3}.*$)*\\n!\\n)+\", flags=re.I | re.M ) # match management1 interface and config items below it MANAGEMENT_ONE_INTERFACE = re.compile( pattern=r\"^interface management1$(?:\\n^\\s{3}.*$)*\\n!\", flags=re.I | re.M )","title":"Module scrapli_cfg.platform.core.arista_eos.patterns"},{"location":"api_docs/platform/core/arista_eos/sync_platform/","text":"window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting()) Module scrapli_cfg.platform.core.arista_eos.sync_platform \u00b6 scrapli_cfg.platform.core.arista_eos.sync Expand source code \"\"\"scrapli_cfg.platform.core.arista_eos.sync\"\"\" from typing import Any, Callable, List, Optional from scrapli.driver import NetworkDriver from scrapli.response import Response from scrapli_cfg.diff import ScrapliCfgDiffResponse from scrapli_cfg.exceptions import DiffConfigError, LoadConfigError, ScrapliCfgException from scrapli_cfg.platform.base.sync_platform import ScrapliCfgPlatform from scrapli_cfg.platform.core.arista_eos.base_platform import CONFIG_SOURCES, ScrapliCfgEOSBase from scrapli_cfg.response import ScrapliCfgResponse def eos_on_open(cls: ScrapliCfgPlatform) -> None: \"\"\" Scrapli CFG EOS On open Disable console logging, perhaps more things in the future! Args: cls: ScrapliCfg object Returns: None Raises: N/A \"\"\" cls.conn.send_config(config=\"no logging console\") class ScrapliCfgEOS(ScrapliCfgPlatform, ScrapliCfgEOSBase): def __init__( self, conn: NetworkDriver, config_sources: Optional[List[str]] = None, on_open: Optional[Callable[..., Any]] = None, ) -> None: if config_sources is None: config_sources = CONFIG_SOURCES if on_open is None: on_open = eos_on_open super().__init__(conn=conn, config_sources=config_sources, on_open=on_open) self.config_session_name = \"\" self._get_version_command = \"show version | i Software image version\" def _clear_config_session(self, session_name: str) -> Response: \"\"\" Clear a configuration session Args: session_name: name of session to clear Returns: Response: scrapli response from clearing the session Raises: N/A \"\"\" # Note, early versions of eos supporting config sessions cant be aborted like this, but # i dont want to register a config session for each session we want to delete so we'll just # roll w/ this for now return self.conn.send_command(command=f\"configure session {session_name} abort\") def clear_config_sessions( self, session_name: str = \"\", session_prefix: str = \"\" ) -> ScrapliCfgResponse: \"\"\" Clear a specific config session or all sessions with a prefix (ex: scrapli_cfg_) Args: session_name: name of specific config session to clear session_prefix: prefix of session(s) to clear -- ignored if session_name is provided Returns: ScrapliCfgResponse: response object containing string of the target config source as the `result` attribute Raises: N/A \"\"\" scrapli_responses = [] response = self._pre_clear_config_sessions() try: get_config_sessions_result = self.conn.send_command( command=\"show config sessions | json\" ) scrapli_responses.append(get_config_sessions_result) if get_config_sessions_result.failed: msg = \"failed to show current config sessions\" self.logger.critical(msg) raise ScrapliCfgException(msg) config_session_names = self._parse_config_sessions( device_output=get_config_sessions_result.result ) for config_session in config_session_names: if session_name: if config_session == session_name: clear_config_session_result = self._clear_config_session( session_name=session_name ) scrapli_responses.append(clear_config_session_result) else: if config_session.startswith(session_prefix): clear_config_session_result = self._clear_config_session( session_name=session_name ) scrapli_responses.append(clear_config_session_result) except ScrapliCfgException: pass return self._post_clear_config_sessions( response=response, scrapli_responses=scrapli_responses ) def get_config(self, source: str = \"running\") -> ScrapliCfgResponse: response = self._pre_get_config(source=source) config_result = self.conn.send_command(command=self._get_config_command(source=source)) return self._post_get_config( response=response, source=source, scrapli_responses=[config_result], result=config_result.result, ) def load_config(self, config: str, replace: bool = False, **kwargs: Any) -> ScrapliCfgResponse: \"\"\" Load configuration to a device Supported kwargs: N/A Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for eos supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" scrapli_responses = [] response = self._pre_load_config(config=config) ( config, eager_config, register_config_session, ) = self._prepare_load_config_session_and_payload(config=config) if register_config_session is True: # only need to register a session if we havent -- we will reset session to an empty # string after any commits/aborts so we know if we are doing \"new\" operations self.conn.register_configuration_session(session_name=self.config_session_name) try: if replace: # default the config session - we only need to do this if we are doing a REPLACE rollback_clean_config_result = self.conn.send_config( config=\"rollback clean-config\", privilege_level=self.config_session_name ) scrapli_responses.append(rollback_clean_config_result) if rollback_clean_config_result.failed: msg = \"failed to load clean config in configuration session\" self.logger.critical(msg) raise LoadConfigError(msg) config_result = self.conn.send_config( config=config, privilege_level=self.config_session_name ) scrapli_responses.append(config_result) if config_result.failed: msg = \"failed to load the candidate config into the config session\" self.logger.critical(msg) raise LoadConfigError(msg) # eager cuz banners and such; perhaps if no banner/macro we can disable eager though.... if eager_config: eager_config_result = self.conn.send_config( config=eager_config, privilege_level=self.config_session_name, eager=True ) scrapli_responses.append(eager_config_result) if eager_config_result.failed: msg = \"failed to load the candidate config into the config session\" self.logger.critical(msg) raise LoadConfigError(msg) except LoadConfigError: # we catch our own exception so we dont need to do any if failed checks along the way # as soon as we hit this (or when we are done w/ the try block) we are done loading the # config and can build and return a response object pass return self._post_load_config( response=response, scrapli_responses=scrapli_responses, ) def abort_config(self) -> ScrapliCfgResponse: response = self._pre_abort_config(session_or_config_file=bool(self.config_session_name)) self.conn.acquire_priv(desired_priv=self.config_session_name) self.conn._abort_config() # pylint: disable=W0212 self._reset_config_session() return self._post_abort_config(response=response, scrapli_responses=[]) def commit_config(self, source: str = \"running\") -> ScrapliCfgResponse: response = self._pre_commit_config( source=source, session_or_config_file=bool(self.config_session_name) ) commit_results = self.conn.send_commands( commands=[ f\"configure session {self.config_session_name} commit\", \"copy running-config startup-config\", ] ) self._reset_config_session() return self._post_commit_config(response=response, scrapli_responses=commit_results) def diff_config(self, source: str = \"running\") -> ScrapliCfgDiffResponse: scrapli_responses = [] device_diff = \"\" source_config = \"\" diff_response = self._pre_diff_config( source=source, session_or_config_file=bool(self.config_session_name) ) try: diff_result = self.conn.send_config( config=\"show session-config diffs\", privilege_level=self.config_session_name ) scrapli_responses.append(diff_response) if diff_result.failed: msg = \"failed generating diff for config session\" self.logger.critical(msg) raise DiffConfigError(msg) device_diff = diff_result.result source_config_result = self.get_config(source=source) source_config = source_config_result.result if source_config_result.scrapli_responses: scrapli_responses.extend(source_config_result.scrapli_responses) if source_config_result.failed: msg = \"failed fetching source config for diff comparison\" self.logger.critical(msg) raise DiffConfigError(msg) except DiffConfigError: pass source_config, candidate_config = self._normalize_source_candidate_configs( source_config=source_config ) return self._post_diff_config( diff_response=diff_response, scrapli_responses=scrapli_responses, source_config=source_config, candidate_config=candidate_config, device_diff=device_diff, ) Functions \u00b6 eos_on_open \u00b6 eos_on_open(cls: scrapli_cfg.platform.base.sync_platform.ScrapliCfgPlatform) \u2011> NoneType Scrapli CFG EOS On open Disable console logging, perhaps more things in the future! Args: cls: ScrapliCfg object Returns: None Raises: N/A Classes \u00b6 ScrapliCfgEOS \u00b6 Helper class that provides a standard way to create an ABC using inheritance. Scrapli Config base class Args: conn: scrapli connection to use config_sources: list of config sources on_open: async callable to run at connection open Returns: None Raises: N/A Expand source code class ScrapliCfgEOS(ScrapliCfgPlatform, ScrapliCfgEOSBase): def __init__( self, conn: NetworkDriver, config_sources: Optional[List[str]] = None, on_open: Optional[Callable[..., Any]] = None, ) -> None: if config_sources is None: config_sources = CONFIG_SOURCES if on_open is None: on_open = eos_on_open super().__init__(conn=conn, config_sources=config_sources, on_open=on_open) self.config_session_name = \"\" self._get_version_command = \"show version | i Software image version\" def _clear_config_session(self, session_name: str) -> Response: \"\"\" Clear a configuration session Args: session_name: name of session to clear Returns: Response: scrapli response from clearing the session Raises: N/A \"\"\" # Note, early versions of eos supporting config sessions cant be aborted like this, but # i dont want to register a config session for each session we want to delete so we'll just # roll w/ this for now return self.conn.send_command(command=f\"configure session {session_name} abort\") def clear_config_sessions( self, session_name: str = \"\", session_prefix: str = \"\" ) -> ScrapliCfgResponse: \"\"\" Clear a specific config session or all sessions with a prefix (ex: scrapli_cfg_) Args: session_name: name of specific config session to clear session_prefix: prefix of session(s) to clear -- ignored if session_name is provided Returns: ScrapliCfgResponse: response object containing string of the target config source as the `result` attribute Raises: N/A \"\"\" scrapli_responses = [] response = self._pre_clear_config_sessions() try: get_config_sessions_result = self.conn.send_command( command=\"show config sessions | json\" ) scrapli_responses.append(get_config_sessions_result) if get_config_sessions_result.failed: msg = \"failed to show current config sessions\" self.logger.critical(msg) raise ScrapliCfgException(msg) config_session_names = self._parse_config_sessions( device_output=get_config_sessions_result.result ) for config_session in config_session_names: if session_name: if config_session == session_name: clear_config_session_result = self._clear_config_session( session_name=session_name ) scrapli_responses.append(clear_config_session_result) else: if config_session.startswith(session_prefix): clear_config_session_result = self._clear_config_session( session_name=session_name ) scrapli_responses.append(clear_config_session_result) except ScrapliCfgException: pass return self._post_clear_config_sessions( response=response, scrapli_responses=scrapli_responses ) def get_config(self, source: str = \"running\") -> ScrapliCfgResponse: response = self._pre_get_config(source=source) config_result = self.conn.send_command(command=self._get_config_command(source=source)) return self._post_get_config( response=response, source=source, scrapli_responses=[config_result], result=config_result.result, ) def load_config(self, config: str, replace: bool = False, **kwargs: Any) -> ScrapliCfgResponse: \"\"\" Load configuration to a device Supported kwargs: N/A Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for eos supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" scrapli_responses = [] response = self._pre_load_config(config=config) ( config, eager_config, register_config_session, ) = self._prepare_load_config_session_and_payload(config=config) if register_config_session is True: # only need to register a session if we havent -- we will reset session to an empty # string after any commits/aborts so we know if we are doing \"new\" operations self.conn.register_configuration_session(session_name=self.config_session_name) try: if replace: # default the config session - we only need to do this if we are doing a REPLACE rollback_clean_config_result = self.conn.send_config( config=\"rollback clean-config\", privilege_level=self.config_session_name ) scrapli_responses.append(rollback_clean_config_result) if rollback_clean_config_result.failed: msg = \"failed to load clean config in configuration session\" self.logger.critical(msg) raise LoadConfigError(msg) config_result = self.conn.send_config( config=config, privilege_level=self.config_session_name ) scrapli_responses.append(config_result) if config_result.failed: msg = \"failed to load the candidate config into the config session\" self.logger.critical(msg) raise LoadConfigError(msg) # eager cuz banners and such; perhaps if no banner/macro we can disable eager though.... if eager_config: eager_config_result = self.conn.send_config( config=eager_config, privilege_level=self.config_session_name, eager=True ) scrapli_responses.append(eager_config_result) if eager_config_result.failed: msg = \"failed to load the candidate config into the config session\" self.logger.critical(msg) raise LoadConfigError(msg) except LoadConfigError: # we catch our own exception so we dont need to do any if failed checks along the way # as soon as we hit this (or when we are done w/ the try block) we are done loading the # config and can build and return a response object pass return self._post_load_config( response=response, scrapli_responses=scrapli_responses, ) def abort_config(self) -> ScrapliCfgResponse: response = self._pre_abort_config(session_or_config_file=bool(self.config_session_name)) self.conn.acquire_priv(desired_priv=self.config_session_name) self.conn._abort_config() # pylint: disable=W0212 self._reset_config_session() return self._post_abort_config(response=response, scrapli_responses=[]) def commit_config(self, source: str = \"running\") -> ScrapliCfgResponse: response = self._pre_commit_config( source=source, session_or_config_file=bool(self.config_session_name) ) commit_results = self.conn.send_commands( commands=[ f\"configure session {self.config_session_name} commit\", \"copy running-config startup-config\", ] ) self._reset_config_session() return self._post_commit_config(response=response, scrapli_responses=commit_results) def diff_config(self, source: str = \"running\") -> ScrapliCfgDiffResponse: scrapli_responses = [] device_diff = \"\" source_config = \"\" diff_response = self._pre_diff_config( source=source, session_or_config_file=bool(self.config_session_name) ) try: diff_result = self.conn.send_config( config=\"show session-config diffs\", privilege_level=self.config_session_name ) scrapli_responses.append(diff_response) if diff_result.failed: msg = \"failed generating diff for config session\" self.logger.critical(msg) raise DiffConfigError(msg) device_diff = diff_result.result source_config_result = self.get_config(source=source) source_config = source_config_result.result if source_config_result.scrapli_responses: scrapli_responses.extend(source_config_result.scrapli_responses) if source_config_result.failed: msg = \"failed fetching source config for diff comparison\" self.logger.critical(msg) raise DiffConfigError(msg) except DiffConfigError: pass source_config, candidate_config = self._normalize_source_candidate_configs( source_config=source_config ) return self._post_diff_config( diff_response=diff_response, scrapli_responses=scrapli_responses, source_config=source_config, candidate_config=candidate_config, device_diff=device_diff, ) Ancestors (in MRO) \u00b6 scrapli_cfg.platform.base.sync_platform.ScrapliCfgPlatform abc.ABC scrapli_cfg.platform.base.base_platform.ScrapliCfgBase scrapli_cfg.platform.core.arista_eos.base_platform.ScrapliCfgEOSBase Class variables \u00b6 conn: Union[scrapli.driver.network.sync_driver.NetworkDriver, scrapli.driver.network.async_driver.AsyncNetworkDriver] Methods \u00b6 clear_config_sessions \u00b6 clear_config_sessions(self, session_name: str = '', session_prefix: str = '') \u2011> scrapli_cfg.response.ScrapliCfgResponse Clear a specific config session or all sessions with a prefix (ex: scrapli_cfg_) Args: session_name: name of specific config session to clear session_prefix: prefix of session(s) to clear -- ignored if session_name is provided Returns: ScrapliCfgResponse: response object containing string of the target config source as the `result` attribute Raises: N/A load_config \u00b6 load_config(self, config: str, replace: bool = False, **kwargs: Any) \u2011> scrapli_cfg.response.ScrapliCfgResponse Load configuration to a device Supported kwargs: N/A Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for eos supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A","title":"Sync Platform"},{"location":"api_docs/platform/core/arista_eos/sync_platform/#module-scrapli_cfgplatformcorearista_eossync_platform","text":"scrapli_cfg.platform.core.arista_eos.sync Expand source code \"\"\"scrapli_cfg.platform.core.arista_eos.sync\"\"\" from typing import Any, Callable, List, Optional from scrapli.driver import NetworkDriver from scrapli.response import Response from scrapli_cfg.diff import ScrapliCfgDiffResponse from scrapli_cfg.exceptions import DiffConfigError, LoadConfigError, ScrapliCfgException from scrapli_cfg.platform.base.sync_platform import ScrapliCfgPlatform from scrapli_cfg.platform.core.arista_eos.base_platform import CONFIG_SOURCES, ScrapliCfgEOSBase from scrapli_cfg.response import ScrapliCfgResponse def eos_on_open(cls: ScrapliCfgPlatform) -> None: \"\"\" Scrapli CFG EOS On open Disable console logging, perhaps more things in the future! Args: cls: ScrapliCfg object Returns: None Raises: N/A \"\"\" cls.conn.send_config(config=\"no logging console\") class ScrapliCfgEOS(ScrapliCfgPlatform, ScrapliCfgEOSBase): def __init__( self, conn: NetworkDriver, config_sources: Optional[List[str]] = None, on_open: Optional[Callable[..., Any]] = None, ) -> None: if config_sources is None: config_sources = CONFIG_SOURCES if on_open is None: on_open = eos_on_open super().__init__(conn=conn, config_sources=config_sources, on_open=on_open) self.config_session_name = \"\" self._get_version_command = \"show version | i Software image version\" def _clear_config_session(self, session_name: str) -> Response: \"\"\" Clear a configuration session Args: session_name: name of session to clear Returns: Response: scrapli response from clearing the session Raises: N/A \"\"\" # Note, early versions of eos supporting config sessions cant be aborted like this, but # i dont want to register a config session for each session we want to delete so we'll just # roll w/ this for now return self.conn.send_command(command=f\"configure session {session_name} abort\") def clear_config_sessions( self, session_name: str = \"\", session_prefix: str = \"\" ) -> ScrapliCfgResponse: \"\"\" Clear a specific config session or all sessions with a prefix (ex: scrapli_cfg_) Args: session_name: name of specific config session to clear session_prefix: prefix of session(s) to clear -- ignored if session_name is provided Returns: ScrapliCfgResponse: response object containing string of the target config source as the `result` attribute Raises: N/A \"\"\" scrapli_responses = [] response = self._pre_clear_config_sessions() try: get_config_sessions_result = self.conn.send_command( command=\"show config sessions | json\" ) scrapli_responses.append(get_config_sessions_result) if get_config_sessions_result.failed: msg = \"failed to show current config sessions\" self.logger.critical(msg) raise ScrapliCfgException(msg) config_session_names = self._parse_config_sessions( device_output=get_config_sessions_result.result ) for config_session in config_session_names: if session_name: if config_session == session_name: clear_config_session_result = self._clear_config_session( session_name=session_name ) scrapli_responses.append(clear_config_session_result) else: if config_session.startswith(session_prefix): clear_config_session_result = self._clear_config_session( session_name=session_name ) scrapli_responses.append(clear_config_session_result) except ScrapliCfgException: pass return self._post_clear_config_sessions( response=response, scrapli_responses=scrapli_responses ) def get_config(self, source: str = \"running\") -> ScrapliCfgResponse: response = self._pre_get_config(source=source) config_result = self.conn.send_command(command=self._get_config_command(source=source)) return self._post_get_config( response=response, source=source, scrapli_responses=[config_result], result=config_result.result, ) def load_config(self, config: str, replace: bool = False, **kwargs: Any) -> ScrapliCfgResponse: \"\"\" Load configuration to a device Supported kwargs: N/A Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for eos supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" scrapli_responses = [] response = self._pre_load_config(config=config) ( config, eager_config, register_config_session, ) = self._prepare_load_config_session_and_payload(config=config) if register_config_session is True: # only need to register a session if we havent -- we will reset session to an empty # string after any commits/aborts so we know if we are doing \"new\" operations self.conn.register_configuration_session(session_name=self.config_session_name) try: if replace: # default the config session - we only need to do this if we are doing a REPLACE rollback_clean_config_result = self.conn.send_config( config=\"rollback clean-config\", privilege_level=self.config_session_name ) scrapli_responses.append(rollback_clean_config_result) if rollback_clean_config_result.failed: msg = \"failed to load clean config in configuration session\" self.logger.critical(msg) raise LoadConfigError(msg) config_result = self.conn.send_config( config=config, privilege_level=self.config_session_name ) scrapli_responses.append(config_result) if config_result.failed: msg = \"failed to load the candidate config into the config session\" self.logger.critical(msg) raise LoadConfigError(msg) # eager cuz banners and such; perhaps if no banner/macro we can disable eager though.... if eager_config: eager_config_result = self.conn.send_config( config=eager_config, privilege_level=self.config_session_name, eager=True ) scrapli_responses.append(eager_config_result) if eager_config_result.failed: msg = \"failed to load the candidate config into the config session\" self.logger.critical(msg) raise LoadConfigError(msg) except LoadConfigError: # we catch our own exception so we dont need to do any if failed checks along the way # as soon as we hit this (or when we are done w/ the try block) we are done loading the # config and can build and return a response object pass return self._post_load_config( response=response, scrapli_responses=scrapli_responses, ) def abort_config(self) -> ScrapliCfgResponse: response = self._pre_abort_config(session_or_config_file=bool(self.config_session_name)) self.conn.acquire_priv(desired_priv=self.config_session_name) self.conn._abort_config() # pylint: disable=W0212 self._reset_config_session() return self._post_abort_config(response=response, scrapli_responses=[]) def commit_config(self, source: str = \"running\") -> ScrapliCfgResponse: response = self._pre_commit_config( source=source, session_or_config_file=bool(self.config_session_name) ) commit_results = self.conn.send_commands( commands=[ f\"configure session {self.config_session_name} commit\", \"copy running-config startup-config\", ] ) self._reset_config_session() return self._post_commit_config(response=response, scrapli_responses=commit_results) def diff_config(self, source: str = \"running\") -> ScrapliCfgDiffResponse: scrapli_responses = [] device_diff = \"\" source_config = \"\" diff_response = self._pre_diff_config( source=source, session_or_config_file=bool(self.config_session_name) ) try: diff_result = self.conn.send_config( config=\"show session-config diffs\", privilege_level=self.config_session_name ) scrapli_responses.append(diff_response) if diff_result.failed: msg = \"failed generating diff for config session\" self.logger.critical(msg) raise DiffConfigError(msg) device_diff = diff_result.result source_config_result = self.get_config(source=source) source_config = source_config_result.result if source_config_result.scrapli_responses: scrapli_responses.extend(source_config_result.scrapli_responses) if source_config_result.failed: msg = \"failed fetching source config for diff comparison\" self.logger.critical(msg) raise DiffConfigError(msg) except DiffConfigError: pass source_config, candidate_config = self._normalize_source_candidate_configs( source_config=source_config ) return self._post_diff_config( diff_response=diff_response, scrapli_responses=scrapli_responses, source_config=source_config, candidate_config=candidate_config, device_diff=device_diff, )","title":"Module scrapli_cfg.platform.core.arista_eos.sync_platform"},{"location":"api_docs/platform/core/arista_eos/sync_platform/#functions","text":"","title":"Functions"},{"location":"api_docs/platform/core/arista_eos/sync_platform/#eos_on_open","text":"eos_on_open(cls: scrapli_cfg.platform.base.sync_platform.ScrapliCfgPlatform) \u2011> NoneType Scrapli CFG EOS On open Disable console logging, perhaps more things in the future! Args: cls: ScrapliCfg object Returns: None Raises: N/A","title":"eos_on_open"},{"location":"api_docs/platform/core/arista_eos/sync_platform/#classes","text":"","title":"Classes"},{"location":"api_docs/platform/core/arista_eos/sync_platform/#scraplicfgeos","text":"Helper class that provides a standard way to create an ABC using inheritance. Scrapli Config base class Args: conn: scrapli connection to use config_sources: list of config sources on_open: async callable to run at connection open Returns: None Raises: N/A Expand source code class ScrapliCfgEOS(ScrapliCfgPlatform, ScrapliCfgEOSBase): def __init__( self, conn: NetworkDriver, config_sources: Optional[List[str]] = None, on_open: Optional[Callable[..., Any]] = None, ) -> None: if config_sources is None: config_sources = CONFIG_SOURCES if on_open is None: on_open = eos_on_open super().__init__(conn=conn, config_sources=config_sources, on_open=on_open) self.config_session_name = \"\" self._get_version_command = \"show version | i Software image version\" def _clear_config_session(self, session_name: str) -> Response: \"\"\" Clear a configuration session Args: session_name: name of session to clear Returns: Response: scrapli response from clearing the session Raises: N/A \"\"\" # Note, early versions of eos supporting config sessions cant be aborted like this, but # i dont want to register a config session for each session we want to delete so we'll just # roll w/ this for now return self.conn.send_command(command=f\"configure session {session_name} abort\") def clear_config_sessions( self, session_name: str = \"\", session_prefix: str = \"\" ) -> ScrapliCfgResponse: \"\"\" Clear a specific config session or all sessions with a prefix (ex: scrapli_cfg_) Args: session_name: name of specific config session to clear session_prefix: prefix of session(s) to clear -- ignored if session_name is provided Returns: ScrapliCfgResponse: response object containing string of the target config source as the `result` attribute Raises: N/A \"\"\" scrapli_responses = [] response = self._pre_clear_config_sessions() try: get_config_sessions_result = self.conn.send_command( command=\"show config sessions | json\" ) scrapli_responses.append(get_config_sessions_result) if get_config_sessions_result.failed: msg = \"failed to show current config sessions\" self.logger.critical(msg) raise ScrapliCfgException(msg) config_session_names = self._parse_config_sessions( device_output=get_config_sessions_result.result ) for config_session in config_session_names: if session_name: if config_session == session_name: clear_config_session_result = self._clear_config_session( session_name=session_name ) scrapli_responses.append(clear_config_session_result) else: if config_session.startswith(session_prefix): clear_config_session_result = self._clear_config_session( session_name=session_name ) scrapli_responses.append(clear_config_session_result) except ScrapliCfgException: pass return self._post_clear_config_sessions( response=response, scrapli_responses=scrapli_responses ) def get_config(self, source: str = \"running\") -> ScrapliCfgResponse: response = self._pre_get_config(source=source) config_result = self.conn.send_command(command=self._get_config_command(source=source)) return self._post_get_config( response=response, source=source, scrapli_responses=[config_result], result=config_result.result, ) def load_config(self, config: str, replace: bool = False, **kwargs: Any) -> ScrapliCfgResponse: \"\"\" Load configuration to a device Supported kwargs: N/A Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for eos supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" scrapli_responses = [] response = self._pre_load_config(config=config) ( config, eager_config, register_config_session, ) = self._prepare_load_config_session_and_payload(config=config) if register_config_session is True: # only need to register a session if we havent -- we will reset session to an empty # string after any commits/aborts so we know if we are doing \"new\" operations self.conn.register_configuration_session(session_name=self.config_session_name) try: if replace: # default the config session - we only need to do this if we are doing a REPLACE rollback_clean_config_result = self.conn.send_config( config=\"rollback clean-config\", privilege_level=self.config_session_name ) scrapli_responses.append(rollback_clean_config_result) if rollback_clean_config_result.failed: msg = \"failed to load clean config in configuration session\" self.logger.critical(msg) raise LoadConfigError(msg) config_result = self.conn.send_config( config=config, privilege_level=self.config_session_name ) scrapli_responses.append(config_result) if config_result.failed: msg = \"failed to load the candidate config into the config session\" self.logger.critical(msg) raise LoadConfigError(msg) # eager cuz banners and such; perhaps if no banner/macro we can disable eager though.... if eager_config: eager_config_result = self.conn.send_config( config=eager_config, privilege_level=self.config_session_name, eager=True ) scrapli_responses.append(eager_config_result) if eager_config_result.failed: msg = \"failed to load the candidate config into the config session\" self.logger.critical(msg) raise LoadConfigError(msg) except LoadConfigError: # we catch our own exception so we dont need to do any if failed checks along the way # as soon as we hit this (or when we are done w/ the try block) we are done loading the # config and can build and return a response object pass return self._post_load_config( response=response, scrapli_responses=scrapli_responses, ) def abort_config(self) -> ScrapliCfgResponse: response = self._pre_abort_config(session_or_config_file=bool(self.config_session_name)) self.conn.acquire_priv(desired_priv=self.config_session_name) self.conn._abort_config() # pylint: disable=W0212 self._reset_config_session() return self._post_abort_config(response=response, scrapli_responses=[]) def commit_config(self, source: str = \"running\") -> ScrapliCfgResponse: response = self._pre_commit_config( source=source, session_or_config_file=bool(self.config_session_name) ) commit_results = self.conn.send_commands( commands=[ f\"configure session {self.config_session_name} commit\", \"copy running-config startup-config\", ] ) self._reset_config_session() return self._post_commit_config(response=response, scrapli_responses=commit_results) def diff_config(self, source: str = \"running\") -> ScrapliCfgDiffResponse: scrapli_responses = [] device_diff = \"\" source_config = \"\" diff_response = self._pre_diff_config( source=source, session_or_config_file=bool(self.config_session_name) ) try: diff_result = self.conn.send_config( config=\"show session-config diffs\", privilege_level=self.config_session_name ) scrapli_responses.append(diff_response) if diff_result.failed: msg = \"failed generating diff for config session\" self.logger.critical(msg) raise DiffConfigError(msg) device_diff = diff_result.result source_config_result = self.get_config(source=source) source_config = source_config_result.result if source_config_result.scrapli_responses: scrapli_responses.extend(source_config_result.scrapli_responses) if source_config_result.failed: msg = \"failed fetching source config for diff comparison\" self.logger.critical(msg) raise DiffConfigError(msg) except DiffConfigError: pass source_config, candidate_config = self._normalize_source_candidate_configs( source_config=source_config ) return self._post_diff_config( diff_response=diff_response, scrapli_responses=scrapli_responses, source_config=source_config, candidate_config=candidate_config, device_diff=device_diff, )","title":"ScrapliCfgEOS"},{"location":"api_docs/platform/core/arista_eos/sync_platform/#ancestors-in-mro","text":"scrapli_cfg.platform.base.sync_platform.ScrapliCfgPlatform abc.ABC scrapli_cfg.platform.base.base_platform.ScrapliCfgBase scrapli_cfg.platform.core.arista_eos.base_platform.ScrapliCfgEOSBase","title":"Ancestors (in MRO)"},{"location":"api_docs/platform/core/arista_eos/sync_platform/#class-variables","text":"conn: Union[scrapli.driver.network.sync_driver.NetworkDriver, scrapli.driver.network.async_driver.AsyncNetworkDriver]","title":"Class variables"},{"location":"api_docs/platform/core/arista_eos/sync_platform/#methods","text":"","title":"Methods"},{"location":"api_docs/platform/core/arista_eos/sync_platform/#clear_config_sessions","text":"clear_config_sessions(self, session_name: str = '', session_prefix: str = '') \u2011> scrapli_cfg.response.ScrapliCfgResponse Clear a specific config session or all sessions with a prefix (ex: scrapli_cfg_) Args: session_name: name of specific config session to clear session_prefix: prefix of session(s) to clear -- ignored if session_name is provided Returns: ScrapliCfgResponse: response object containing string of the target config source as the `result` attribute Raises: N/A","title":"clear_config_sessions"},{"location":"api_docs/platform/core/arista_eos/sync_platform/#load_config","text":"load_config(self, config: str, replace: bool = False, **kwargs: Any) \u2011> scrapli_cfg.response.ScrapliCfgResponse Load configuration to a device Supported kwargs: N/A Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for eos supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A","title":"load_config"},{"location":"api_docs/platform/core/cisco_iosxe/async_platform/","text":"window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting()) Module scrapli_cfg.platform.core.cisco_iosxe.async_platform \u00b6 scrapli_cfg.platform.core.cisco_iosxe.async_platform Expand source code \"\"\"scrapli_cfg.platform.core.cisco_iosxe.async_platform\"\"\" from typing import Any, Callable, List, Optional from scrapli.driver import AsyncNetworkDriver from scrapli.response import Response from scrapli_cfg.diff import ScrapliCfgDiffResponse from scrapli_cfg.exceptions import DiffConfigError, FailedToDetermineDeviceState from scrapli_cfg.platform.base.async_platform import AsyncScrapliCfgPlatform from scrapli_cfg.platform.core.cisco_iosxe.base_platform import CONFIG_SOURCES, ScrapliCfgIOSXEBase from scrapli_cfg.platform.core.cisco_iosxe.types import FilePromptMode from scrapli_cfg.response import ScrapliCfgResponse async def async_iosxe_on_open(cls: AsyncScrapliCfgPlatform) -> None: \"\"\" Scrapli CFG IOSXE On open Disable console logging, perhaps more things in the future! Args: cls: ScrapliCfg object Returns: None Raises: N/A \"\"\" await cls.conn.send_config(config=\"no logging monitor\") class AsyncScrapliCfgIOSXE(AsyncScrapliCfgPlatform, ScrapliCfgIOSXEBase): def __init__( self, conn: AsyncNetworkDriver, config_sources: Optional[List[str]] = None, on_open: Optional[Callable[..., Any]] = None, filesystem: str = \"flash:\", cleanup_post_commit: bool = True, ) -> None: if config_sources is None: config_sources = CONFIG_SOURCES if on_open is None: on_open = async_iosxe_on_open super().__init__(conn=conn, config_sources=config_sources, on_open=on_open) self.filesystem = filesystem self._filesystem_space_available_buffer_perc = 10 self._replace = False self.candidate_config_filename = \"\" self.cleanup_post_commit = cleanup_post_commit self._get_version_command = \"show version | i Version\" async def _get_filesystem_space_available(self) -> int: \"\"\" Abort a configuration -- discards any loaded config Args: N/A Returns: None Raises: FailedToDetermineDeviceState: if unable to fetch file filesystem bytes available \"\"\" filesystem_size_result = await self.conn.send_command( command=f\"dir {self.filesystem} | i bytes\" ) if filesystem_size_result.failed: raise FailedToDetermineDeviceState(\"failed to determine space available on filesystem\") return self._post_get_filesystem_space_available(output=filesystem_size_result.result) async def _determine_file_prompt_mode(self) -> FilePromptMode: \"\"\" Determine the device file prompt mode Args: N/A Returns: FilePromptMode: enum representing file prompt mode Raises: FailedToDetermineDeviceState: if unable to fetch file prompt mode \"\"\" file_prompt_mode_result = await self.conn.send_command(command=\"show run | i file prompt\") if file_prompt_mode_result.failed: raise FailedToDetermineDeviceState(\"failed to determine file prompt mode\") return self._post_determine_file_prompt_mode(output=file_prompt_mode_result.result) async def _delete_candidate_config(self) -> Response: \"\"\" Delete candidate config from the filesystem Args: N/A Returns: Response: response from deleting the candidate config Raises: N/A \"\"\" # have to check again because the candidate config may have changed this! file_prompt_mode = await self._determine_file_prompt_mode() if file_prompt_mode in (FilePromptMode.ALERT, FilePromptMode.NOISY): delete_events = [ ( f\"delete {self.filesystem}{self.candidate_config_filename}\", \"Delete filename\", ), ( \"\", \"[confirm]\", ), (\"\", \"\"), ] else: delete_events = [ (f\"delete {self.filesystem}{self.candidate_config_filename}\", \"[confirm]\"), (\"\", \"\"), ] delete_result = await self.conn.send_interactive(interact_events=delete_events) return delete_result async def get_config(self, source: str = \"running\") -> ScrapliCfgResponse: response = self._pre_get_config(source=source) config_result = await self.conn.send_command( command=self._get_config_command(source=source) ) return self._post_get_config( response=response, source=source, scrapli_responses=[config_result], result=config_result.result, ) async def load_config( self, config: str, replace: bool = False, **kwargs: Any ) -> ScrapliCfgResponse: \"\"\" Load configuration to a device Supported kwargs: N/A Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for iosxe supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" response = self._pre_load_config(config=config) config = self._prepare_load_config(config=config, replace=replace) filesystem_bytes_available = await self._get_filesystem_space_available() self._space_available(filesystem_bytes_available=filesystem_bytes_available) # when in tcl command mode or whatever it is, tcl wants \\r for return char, so stash the # original return char and sub in \\r for a bit original_return_char = self.conn.comms_return_char tcl_comms_return_char = \"\\r\" # pop into tclsh before swapping the return char just to be safe -- \\r or \\n should both be # fine for up to here but who knows... :) await self.conn.acquire_priv(desired_priv=\"tclsh\") self.conn.comms_return_char = tcl_comms_return_char config_result = await self.conn.send_config(config=config, privilege_level=\"tclsh\") # reset the return char to the \"normal\" one and drop into whatever is the \"default\" priv self.conn.comms_return_char = original_return_char await self.conn.acquire_priv(desired_priv=self.conn.default_desired_privilege_level) return self._post_load_config( response=response, scrapli_responses=[config_result], ) async def abort_config(self) -> ScrapliCfgResponse: response = self._pre_abort_config( session_or_config_file=bool(self.candidate_config_filename) ) abort_result = await self._delete_candidate_config() self._reset_config_session() return self._post_abort_config(response=response, scrapli_responses=[abort_result]) async def commit_config(self, source: str = \"running\") -> ScrapliCfgResponse: scrapli_responses = [] response = self._pre_commit_config( source=source, session_or_config_file=bool(self.candidate_config_filename) ) if self._replace is True: replace_command = ( f\"configure replace {self.filesystem}{self.candidate_config_filename} force\" ) commit_result = await self.conn.send_command(command=replace_command) else: file_prompt_mode = await self._determine_file_prompt_mode() if file_prompt_mode == FilePromptMode.ALERT: merge_events = [ ( f\"copy {self.filesystem}{self.candidate_config_filename} running-config\", \"Destination filename\", ), (\"\", \"\"), ] elif file_prompt_mode == FilePromptMode.NOISY: merge_events = [ ( f\"copy {self.filesystem}{self.candidate_config_filename} running-config\", \"Source filename\", ), ( \"\", \"Destination filename\", ), (\"\", \"\"), ] else: merge_events = [ (f\"copy {self.filesystem}{self.candidate_config_filename} running-config\", \"\") ] commit_result = await self.conn.send_interactive(interact_events=merge_events) scrapli_responses.append(commit_result) save_config_result = await self.conn.send_command( command=\"copy running-config startup-config\" ) scrapli_responses.append(save_config_result) if self.cleanup_post_commit: cleanup_result = await self._delete_candidate_config() scrapli_responses.append(cleanup_result) self._reset_config_session() return self._post_load_config( response=response, scrapli_responses=scrapli_responses, ) async def diff_config(self, source: str = \"running\") -> ScrapliCfgDiffResponse: scrapli_responses = [] device_diff = \"\" source_config = \"\" diff_response = self._pre_diff_config( source=source, session_or_config_file=bool(self.candidate_config_filename) ) try: diff_result = await self.conn.send_command( command=self._get_diff_command(source=source) ) scrapli_responses.append(diff_response) if diff_result.failed: msg = \"failed generating diff for config session\" self.logger.critical(msg) raise DiffConfigError(msg) device_diff = diff_result.result source_config_result = await self.get_config(source=source) source_config = source_config_result.result if source_config_result.scrapli_responses: scrapli_responses.extend(source_config_result.scrapli_responses) if source_config_result.failed: msg = \"failed fetching source config for diff comparison\" self.logger.critical(msg) raise DiffConfigError(msg) except DiffConfigError: pass source_config, candidate_config = self._normalize_source_candidate_configs( source_config=source_config ) return self._post_diff_config( diff_response=diff_response, scrapli_responses=scrapli_responses, source_config=source_config, candidate_config=candidate_config, device_diff=device_diff, ) Functions \u00b6 async_iosxe_on_open \u00b6 async_iosxe_on_open(cls: scrapli_cfg.platform.base.async_platform.AsyncScrapliCfgPlatform) \u2011> NoneType Scrapli CFG IOSXE On open Disable console logging, perhaps more things in the future! Args: cls: ScrapliCfg object Returns: None Raises: N/A Classes \u00b6 AsyncScrapliCfgIOSXE \u00b6 Helper class that provides a standard way to create an ABC using inheritance. Scrapli Config async base class Args: conn: scrapli connection to use config_sources: list of config sources on_open: async callable to run at connection open Returns: None Raises: N/A Expand source code class AsyncScrapliCfgIOSXE(AsyncScrapliCfgPlatform, ScrapliCfgIOSXEBase): def __init__( self, conn: AsyncNetworkDriver, config_sources: Optional[List[str]] = None, on_open: Optional[Callable[..., Any]] = None, filesystem: str = \"flash:\", cleanup_post_commit: bool = True, ) -> None: if config_sources is None: config_sources = CONFIG_SOURCES if on_open is None: on_open = async_iosxe_on_open super().__init__(conn=conn, config_sources=config_sources, on_open=on_open) self.filesystem = filesystem self._filesystem_space_available_buffer_perc = 10 self._replace = False self.candidate_config_filename = \"\" self.cleanup_post_commit = cleanup_post_commit self._get_version_command = \"show version | i Version\" async def _get_filesystem_space_available(self) -> int: \"\"\" Abort a configuration -- discards any loaded config Args: N/A Returns: None Raises: FailedToDetermineDeviceState: if unable to fetch file filesystem bytes available \"\"\" filesystem_size_result = await self.conn.send_command( command=f\"dir {self.filesystem} | i bytes\" ) if filesystem_size_result.failed: raise FailedToDetermineDeviceState(\"failed to determine space available on filesystem\") return self._post_get_filesystem_space_available(output=filesystem_size_result.result) async def _determine_file_prompt_mode(self) -> FilePromptMode: \"\"\" Determine the device file prompt mode Args: N/A Returns: FilePromptMode: enum representing file prompt mode Raises: FailedToDetermineDeviceState: if unable to fetch file prompt mode \"\"\" file_prompt_mode_result = await self.conn.send_command(command=\"show run | i file prompt\") if file_prompt_mode_result.failed: raise FailedToDetermineDeviceState(\"failed to determine file prompt mode\") return self._post_determine_file_prompt_mode(output=file_prompt_mode_result.result) async def _delete_candidate_config(self) -> Response: \"\"\" Delete candidate config from the filesystem Args: N/A Returns: Response: response from deleting the candidate config Raises: N/A \"\"\" # have to check again because the candidate config may have changed this! file_prompt_mode = await self._determine_file_prompt_mode() if file_prompt_mode in (FilePromptMode.ALERT, FilePromptMode.NOISY): delete_events = [ ( f\"delete {self.filesystem}{self.candidate_config_filename}\", \"Delete filename\", ), ( \"\", \"[confirm]\", ), (\"\", \"\"), ] else: delete_events = [ (f\"delete {self.filesystem}{self.candidate_config_filename}\", \"[confirm]\"), (\"\", \"\"), ] delete_result = await self.conn.send_interactive(interact_events=delete_events) return delete_result async def get_config(self, source: str = \"running\") -> ScrapliCfgResponse: response = self._pre_get_config(source=source) config_result = await self.conn.send_command( command=self._get_config_command(source=source) ) return self._post_get_config( response=response, source=source, scrapli_responses=[config_result], result=config_result.result, ) async def load_config( self, config: str, replace: bool = False, **kwargs: Any ) -> ScrapliCfgResponse: \"\"\" Load configuration to a device Supported kwargs: N/A Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for iosxe supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" response = self._pre_load_config(config=config) config = self._prepare_load_config(config=config, replace=replace) filesystem_bytes_available = await self._get_filesystem_space_available() self._space_available(filesystem_bytes_available=filesystem_bytes_available) # when in tcl command mode or whatever it is, tcl wants \\r for return char, so stash the # original return char and sub in \\r for a bit original_return_char = self.conn.comms_return_char tcl_comms_return_char = \"\\r\" # pop into tclsh before swapping the return char just to be safe -- \\r or \\n should both be # fine for up to here but who knows... :) await self.conn.acquire_priv(desired_priv=\"tclsh\") self.conn.comms_return_char = tcl_comms_return_char config_result = await self.conn.send_config(config=config, privilege_level=\"tclsh\") # reset the return char to the \"normal\" one and drop into whatever is the \"default\" priv self.conn.comms_return_char = original_return_char await self.conn.acquire_priv(desired_priv=self.conn.default_desired_privilege_level) return self._post_load_config( response=response, scrapli_responses=[config_result], ) async def abort_config(self) -> ScrapliCfgResponse: response = self._pre_abort_config( session_or_config_file=bool(self.candidate_config_filename) ) abort_result = await self._delete_candidate_config() self._reset_config_session() return self._post_abort_config(response=response, scrapli_responses=[abort_result]) async def commit_config(self, source: str = \"running\") -> ScrapliCfgResponse: scrapli_responses = [] response = self._pre_commit_config( source=source, session_or_config_file=bool(self.candidate_config_filename) ) if self._replace is True: replace_command = ( f\"configure replace {self.filesystem}{self.candidate_config_filename} force\" ) commit_result = await self.conn.send_command(command=replace_command) else: file_prompt_mode = await self._determine_file_prompt_mode() if file_prompt_mode == FilePromptMode.ALERT: merge_events = [ ( f\"copy {self.filesystem}{self.candidate_config_filename} running-config\", \"Destination filename\", ), (\"\", \"\"), ] elif file_prompt_mode == FilePromptMode.NOISY: merge_events = [ ( f\"copy {self.filesystem}{self.candidate_config_filename} running-config\", \"Source filename\", ), ( \"\", \"Destination filename\", ), (\"\", \"\"), ] else: merge_events = [ (f\"copy {self.filesystem}{self.candidate_config_filename} running-config\", \"\") ] commit_result = await self.conn.send_interactive(interact_events=merge_events) scrapli_responses.append(commit_result) save_config_result = await self.conn.send_command( command=\"copy running-config startup-config\" ) scrapli_responses.append(save_config_result) if self.cleanup_post_commit: cleanup_result = await self._delete_candidate_config() scrapli_responses.append(cleanup_result) self._reset_config_session() return self._post_load_config( response=response, scrapli_responses=scrapli_responses, ) async def diff_config(self, source: str = \"running\") -> ScrapliCfgDiffResponse: scrapli_responses = [] device_diff = \"\" source_config = \"\" diff_response = self._pre_diff_config( source=source, session_or_config_file=bool(self.candidate_config_filename) ) try: diff_result = await self.conn.send_command( command=self._get_diff_command(source=source) ) scrapli_responses.append(diff_response) if diff_result.failed: msg = \"failed generating diff for config session\" self.logger.critical(msg) raise DiffConfigError(msg) device_diff = diff_result.result source_config_result = await self.get_config(source=source) source_config = source_config_result.result if source_config_result.scrapli_responses: scrapli_responses.extend(source_config_result.scrapli_responses) if source_config_result.failed: msg = \"failed fetching source config for diff comparison\" self.logger.critical(msg) raise DiffConfigError(msg) except DiffConfigError: pass source_config, candidate_config = self._normalize_source_candidate_configs( source_config=source_config ) return self._post_diff_config( diff_response=diff_response, scrapli_responses=scrapli_responses, source_config=source_config, candidate_config=candidate_config, device_diff=device_diff, ) Ancestors (in MRO) \u00b6 scrapli_cfg.platform.base.async_platform.AsyncScrapliCfgPlatform abc.ABC scrapli_cfg.platform.base.base_platform.ScrapliCfgBase scrapli_cfg.platform.core.cisco_iosxe.base_platform.ScrapliCfgIOSXEBase Class variables \u00b6 conn: Union[scrapli.driver.network.sync_driver.NetworkDriver, scrapli.driver.network.async_driver.AsyncNetworkDriver] Methods \u00b6 load_config \u00b6 load_config(self, config: str, replace: bool = False, **kwargs: Any) \u2011> scrapli_cfg.response.ScrapliCfgResponse Load configuration to a device Supported kwargs: N/A Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for iosxe supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A","title":"Async Platform"},{"location":"api_docs/platform/core/cisco_iosxe/async_platform/#module-scrapli_cfgplatformcorecisco_iosxeasync_platform","text":"scrapli_cfg.platform.core.cisco_iosxe.async_platform Expand source code \"\"\"scrapli_cfg.platform.core.cisco_iosxe.async_platform\"\"\" from typing import Any, Callable, List, Optional from scrapli.driver import AsyncNetworkDriver from scrapli.response import Response from scrapli_cfg.diff import ScrapliCfgDiffResponse from scrapli_cfg.exceptions import DiffConfigError, FailedToDetermineDeviceState from scrapli_cfg.platform.base.async_platform import AsyncScrapliCfgPlatform from scrapli_cfg.platform.core.cisco_iosxe.base_platform import CONFIG_SOURCES, ScrapliCfgIOSXEBase from scrapli_cfg.platform.core.cisco_iosxe.types import FilePromptMode from scrapli_cfg.response import ScrapliCfgResponse async def async_iosxe_on_open(cls: AsyncScrapliCfgPlatform) -> None: \"\"\" Scrapli CFG IOSXE On open Disable console logging, perhaps more things in the future! Args: cls: ScrapliCfg object Returns: None Raises: N/A \"\"\" await cls.conn.send_config(config=\"no logging monitor\") class AsyncScrapliCfgIOSXE(AsyncScrapliCfgPlatform, ScrapliCfgIOSXEBase): def __init__( self, conn: AsyncNetworkDriver, config_sources: Optional[List[str]] = None, on_open: Optional[Callable[..., Any]] = None, filesystem: str = \"flash:\", cleanup_post_commit: bool = True, ) -> None: if config_sources is None: config_sources = CONFIG_SOURCES if on_open is None: on_open = async_iosxe_on_open super().__init__(conn=conn, config_sources=config_sources, on_open=on_open) self.filesystem = filesystem self._filesystem_space_available_buffer_perc = 10 self._replace = False self.candidate_config_filename = \"\" self.cleanup_post_commit = cleanup_post_commit self._get_version_command = \"show version | i Version\" async def _get_filesystem_space_available(self) -> int: \"\"\" Abort a configuration -- discards any loaded config Args: N/A Returns: None Raises: FailedToDetermineDeviceState: if unable to fetch file filesystem bytes available \"\"\" filesystem_size_result = await self.conn.send_command( command=f\"dir {self.filesystem} | i bytes\" ) if filesystem_size_result.failed: raise FailedToDetermineDeviceState(\"failed to determine space available on filesystem\") return self._post_get_filesystem_space_available(output=filesystem_size_result.result) async def _determine_file_prompt_mode(self) -> FilePromptMode: \"\"\" Determine the device file prompt mode Args: N/A Returns: FilePromptMode: enum representing file prompt mode Raises: FailedToDetermineDeviceState: if unable to fetch file prompt mode \"\"\" file_prompt_mode_result = await self.conn.send_command(command=\"show run | i file prompt\") if file_prompt_mode_result.failed: raise FailedToDetermineDeviceState(\"failed to determine file prompt mode\") return self._post_determine_file_prompt_mode(output=file_prompt_mode_result.result) async def _delete_candidate_config(self) -> Response: \"\"\" Delete candidate config from the filesystem Args: N/A Returns: Response: response from deleting the candidate config Raises: N/A \"\"\" # have to check again because the candidate config may have changed this! file_prompt_mode = await self._determine_file_prompt_mode() if file_prompt_mode in (FilePromptMode.ALERT, FilePromptMode.NOISY): delete_events = [ ( f\"delete {self.filesystem}{self.candidate_config_filename}\", \"Delete filename\", ), ( \"\", \"[confirm]\", ), (\"\", \"\"), ] else: delete_events = [ (f\"delete {self.filesystem}{self.candidate_config_filename}\", \"[confirm]\"), (\"\", \"\"), ] delete_result = await self.conn.send_interactive(interact_events=delete_events) return delete_result async def get_config(self, source: str = \"running\") -> ScrapliCfgResponse: response = self._pre_get_config(source=source) config_result = await self.conn.send_command( command=self._get_config_command(source=source) ) return self._post_get_config( response=response, source=source, scrapli_responses=[config_result], result=config_result.result, ) async def load_config( self, config: str, replace: bool = False, **kwargs: Any ) -> ScrapliCfgResponse: \"\"\" Load configuration to a device Supported kwargs: N/A Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for iosxe supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" response = self._pre_load_config(config=config) config = self._prepare_load_config(config=config, replace=replace) filesystem_bytes_available = await self._get_filesystem_space_available() self._space_available(filesystem_bytes_available=filesystem_bytes_available) # when in tcl command mode or whatever it is, tcl wants \\r for return char, so stash the # original return char and sub in \\r for a bit original_return_char = self.conn.comms_return_char tcl_comms_return_char = \"\\r\" # pop into tclsh before swapping the return char just to be safe -- \\r or \\n should both be # fine for up to here but who knows... :) await self.conn.acquire_priv(desired_priv=\"tclsh\") self.conn.comms_return_char = tcl_comms_return_char config_result = await self.conn.send_config(config=config, privilege_level=\"tclsh\") # reset the return char to the \"normal\" one and drop into whatever is the \"default\" priv self.conn.comms_return_char = original_return_char await self.conn.acquire_priv(desired_priv=self.conn.default_desired_privilege_level) return self._post_load_config( response=response, scrapli_responses=[config_result], ) async def abort_config(self) -> ScrapliCfgResponse: response = self._pre_abort_config( session_or_config_file=bool(self.candidate_config_filename) ) abort_result = await self._delete_candidate_config() self._reset_config_session() return self._post_abort_config(response=response, scrapli_responses=[abort_result]) async def commit_config(self, source: str = \"running\") -> ScrapliCfgResponse: scrapli_responses = [] response = self._pre_commit_config( source=source, session_or_config_file=bool(self.candidate_config_filename) ) if self._replace is True: replace_command = ( f\"configure replace {self.filesystem}{self.candidate_config_filename} force\" ) commit_result = await self.conn.send_command(command=replace_command) else: file_prompt_mode = await self._determine_file_prompt_mode() if file_prompt_mode == FilePromptMode.ALERT: merge_events = [ ( f\"copy {self.filesystem}{self.candidate_config_filename} running-config\", \"Destination filename\", ), (\"\", \"\"), ] elif file_prompt_mode == FilePromptMode.NOISY: merge_events = [ ( f\"copy {self.filesystem}{self.candidate_config_filename} running-config\", \"Source filename\", ), ( \"\", \"Destination filename\", ), (\"\", \"\"), ] else: merge_events = [ (f\"copy {self.filesystem}{self.candidate_config_filename} running-config\", \"\") ] commit_result = await self.conn.send_interactive(interact_events=merge_events) scrapli_responses.append(commit_result) save_config_result = await self.conn.send_command( command=\"copy running-config startup-config\" ) scrapli_responses.append(save_config_result) if self.cleanup_post_commit: cleanup_result = await self._delete_candidate_config() scrapli_responses.append(cleanup_result) self._reset_config_session() return self._post_load_config( response=response, scrapli_responses=scrapli_responses, ) async def diff_config(self, source: str = \"running\") -> ScrapliCfgDiffResponse: scrapli_responses = [] device_diff = \"\" source_config = \"\" diff_response = self._pre_diff_config( source=source, session_or_config_file=bool(self.candidate_config_filename) ) try: diff_result = await self.conn.send_command( command=self._get_diff_command(source=source) ) scrapli_responses.append(diff_response) if diff_result.failed: msg = \"failed generating diff for config session\" self.logger.critical(msg) raise DiffConfigError(msg) device_diff = diff_result.result source_config_result = await self.get_config(source=source) source_config = source_config_result.result if source_config_result.scrapli_responses: scrapli_responses.extend(source_config_result.scrapli_responses) if source_config_result.failed: msg = \"failed fetching source config for diff comparison\" self.logger.critical(msg) raise DiffConfigError(msg) except DiffConfigError: pass source_config, candidate_config = self._normalize_source_candidate_configs( source_config=source_config ) return self._post_diff_config( diff_response=diff_response, scrapli_responses=scrapli_responses, source_config=source_config, candidate_config=candidate_config, device_diff=device_diff, )","title":"Module scrapli_cfg.platform.core.cisco_iosxe.async_platform"},{"location":"api_docs/platform/core/cisco_iosxe/async_platform/#functions","text":"","title":"Functions"},{"location":"api_docs/platform/core/cisco_iosxe/async_platform/#async_iosxe_on_open","text":"async_iosxe_on_open(cls: scrapli_cfg.platform.base.async_platform.AsyncScrapliCfgPlatform) \u2011> NoneType Scrapli CFG IOSXE On open Disable console logging, perhaps more things in the future! Args: cls: ScrapliCfg object Returns: None Raises: N/A","title":"async_iosxe_on_open"},{"location":"api_docs/platform/core/cisco_iosxe/async_platform/#classes","text":"","title":"Classes"},{"location":"api_docs/platform/core/cisco_iosxe/async_platform/#asyncscraplicfgiosxe","text":"Helper class that provides a standard way to create an ABC using inheritance. Scrapli Config async base class Args: conn: scrapli connection to use config_sources: list of config sources on_open: async callable to run at connection open Returns: None Raises: N/A Expand source code class AsyncScrapliCfgIOSXE(AsyncScrapliCfgPlatform, ScrapliCfgIOSXEBase): def __init__( self, conn: AsyncNetworkDriver, config_sources: Optional[List[str]] = None, on_open: Optional[Callable[..., Any]] = None, filesystem: str = \"flash:\", cleanup_post_commit: bool = True, ) -> None: if config_sources is None: config_sources = CONFIG_SOURCES if on_open is None: on_open = async_iosxe_on_open super().__init__(conn=conn, config_sources=config_sources, on_open=on_open) self.filesystem = filesystem self._filesystem_space_available_buffer_perc = 10 self._replace = False self.candidate_config_filename = \"\" self.cleanup_post_commit = cleanup_post_commit self._get_version_command = \"show version | i Version\" async def _get_filesystem_space_available(self) -> int: \"\"\" Abort a configuration -- discards any loaded config Args: N/A Returns: None Raises: FailedToDetermineDeviceState: if unable to fetch file filesystem bytes available \"\"\" filesystem_size_result = await self.conn.send_command( command=f\"dir {self.filesystem} | i bytes\" ) if filesystem_size_result.failed: raise FailedToDetermineDeviceState(\"failed to determine space available on filesystem\") return self._post_get_filesystem_space_available(output=filesystem_size_result.result) async def _determine_file_prompt_mode(self) -> FilePromptMode: \"\"\" Determine the device file prompt mode Args: N/A Returns: FilePromptMode: enum representing file prompt mode Raises: FailedToDetermineDeviceState: if unable to fetch file prompt mode \"\"\" file_prompt_mode_result = await self.conn.send_command(command=\"show run | i file prompt\") if file_prompt_mode_result.failed: raise FailedToDetermineDeviceState(\"failed to determine file prompt mode\") return self._post_determine_file_prompt_mode(output=file_prompt_mode_result.result) async def _delete_candidate_config(self) -> Response: \"\"\" Delete candidate config from the filesystem Args: N/A Returns: Response: response from deleting the candidate config Raises: N/A \"\"\" # have to check again because the candidate config may have changed this! file_prompt_mode = await self._determine_file_prompt_mode() if file_prompt_mode in (FilePromptMode.ALERT, FilePromptMode.NOISY): delete_events = [ ( f\"delete {self.filesystem}{self.candidate_config_filename}\", \"Delete filename\", ), ( \"\", \"[confirm]\", ), (\"\", \"\"), ] else: delete_events = [ (f\"delete {self.filesystem}{self.candidate_config_filename}\", \"[confirm]\"), (\"\", \"\"), ] delete_result = await self.conn.send_interactive(interact_events=delete_events) return delete_result async def get_config(self, source: str = \"running\") -> ScrapliCfgResponse: response = self._pre_get_config(source=source) config_result = await self.conn.send_command( command=self._get_config_command(source=source) ) return self._post_get_config( response=response, source=source, scrapli_responses=[config_result], result=config_result.result, ) async def load_config( self, config: str, replace: bool = False, **kwargs: Any ) -> ScrapliCfgResponse: \"\"\" Load configuration to a device Supported kwargs: N/A Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for iosxe supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" response = self._pre_load_config(config=config) config = self._prepare_load_config(config=config, replace=replace) filesystem_bytes_available = await self._get_filesystem_space_available() self._space_available(filesystem_bytes_available=filesystem_bytes_available) # when in tcl command mode or whatever it is, tcl wants \\r for return char, so stash the # original return char and sub in \\r for a bit original_return_char = self.conn.comms_return_char tcl_comms_return_char = \"\\r\" # pop into tclsh before swapping the return char just to be safe -- \\r or \\n should both be # fine for up to here but who knows... :) await self.conn.acquire_priv(desired_priv=\"tclsh\") self.conn.comms_return_char = tcl_comms_return_char config_result = await self.conn.send_config(config=config, privilege_level=\"tclsh\") # reset the return char to the \"normal\" one and drop into whatever is the \"default\" priv self.conn.comms_return_char = original_return_char await self.conn.acquire_priv(desired_priv=self.conn.default_desired_privilege_level) return self._post_load_config( response=response, scrapli_responses=[config_result], ) async def abort_config(self) -> ScrapliCfgResponse: response = self._pre_abort_config( session_or_config_file=bool(self.candidate_config_filename) ) abort_result = await self._delete_candidate_config() self._reset_config_session() return self._post_abort_config(response=response, scrapli_responses=[abort_result]) async def commit_config(self, source: str = \"running\") -> ScrapliCfgResponse: scrapli_responses = [] response = self._pre_commit_config( source=source, session_or_config_file=bool(self.candidate_config_filename) ) if self._replace is True: replace_command = ( f\"configure replace {self.filesystem}{self.candidate_config_filename} force\" ) commit_result = await self.conn.send_command(command=replace_command) else: file_prompt_mode = await self._determine_file_prompt_mode() if file_prompt_mode == FilePromptMode.ALERT: merge_events = [ ( f\"copy {self.filesystem}{self.candidate_config_filename} running-config\", \"Destination filename\", ), (\"\", \"\"), ] elif file_prompt_mode == FilePromptMode.NOISY: merge_events = [ ( f\"copy {self.filesystem}{self.candidate_config_filename} running-config\", \"Source filename\", ), ( \"\", \"Destination filename\", ), (\"\", \"\"), ] else: merge_events = [ (f\"copy {self.filesystem}{self.candidate_config_filename} running-config\", \"\") ] commit_result = await self.conn.send_interactive(interact_events=merge_events) scrapli_responses.append(commit_result) save_config_result = await self.conn.send_command( command=\"copy running-config startup-config\" ) scrapli_responses.append(save_config_result) if self.cleanup_post_commit: cleanup_result = await self._delete_candidate_config() scrapli_responses.append(cleanup_result) self._reset_config_session() return self._post_load_config( response=response, scrapli_responses=scrapli_responses, ) async def diff_config(self, source: str = \"running\") -> ScrapliCfgDiffResponse: scrapli_responses = [] device_diff = \"\" source_config = \"\" diff_response = self._pre_diff_config( source=source, session_or_config_file=bool(self.candidate_config_filename) ) try: diff_result = await self.conn.send_command( command=self._get_diff_command(source=source) ) scrapli_responses.append(diff_response) if diff_result.failed: msg = \"failed generating diff for config session\" self.logger.critical(msg) raise DiffConfigError(msg) device_diff = diff_result.result source_config_result = await self.get_config(source=source) source_config = source_config_result.result if source_config_result.scrapli_responses: scrapli_responses.extend(source_config_result.scrapli_responses) if source_config_result.failed: msg = \"failed fetching source config for diff comparison\" self.logger.critical(msg) raise DiffConfigError(msg) except DiffConfigError: pass source_config, candidate_config = self._normalize_source_candidate_configs( source_config=source_config ) return self._post_diff_config( diff_response=diff_response, scrapli_responses=scrapli_responses, source_config=source_config, candidate_config=candidate_config, device_diff=device_diff, )","title":"AsyncScrapliCfgIOSXE"},{"location":"api_docs/platform/core/cisco_iosxe/async_platform/#ancestors-in-mro","text":"scrapli_cfg.platform.base.async_platform.AsyncScrapliCfgPlatform abc.ABC scrapli_cfg.platform.base.base_platform.ScrapliCfgBase scrapli_cfg.platform.core.cisco_iosxe.base_platform.ScrapliCfgIOSXEBase","title":"Ancestors (in MRO)"},{"location":"api_docs/platform/core/cisco_iosxe/async_platform/#class-variables","text":"conn: Union[scrapli.driver.network.sync_driver.NetworkDriver, scrapli.driver.network.async_driver.AsyncNetworkDriver]","title":"Class variables"},{"location":"api_docs/platform/core/cisco_iosxe/async_platform/#methods","text":"","title":"Methods"},{"location":"api_docs/platform/core/cisco_iosxe/async_platform/#load_config","text":"load_config(self, config: str, replace: bool = False, **kwargs: Any) \u2011> scrapli_cfg.response.ScrapliCfgResponse Load configuration to a device Supported kwargs: N/A Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for iosxe supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A","title":"load_config"},{"location":"api_docs/platform/core/cisco_iosxe/base_platform/","text":"window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting()) Module scrapli_cfg.platform.core.cisco_iosxe.base_platform \u00b6 scrapli_cfg.platform.core.cisco_iosxe.base Expand source code \"\"\"scrapli_cfg.platform.core.cisco_iosxe.base\"\"\" import re from datetime import datetime from logging import LoggerAdapter from typing import Tuple from scrapli_cfg.exceptions import FailedToFetchSpaceAvailable, InsufficientSpaceAvailable from scrapli_cfg.platform.core.cisco_iosxe.patterns import ( BYTES_FREE, FILE_PROMPT_MODE, OUTPUT_HEADER_PATTERN, VERSION_PATTERN, ) from scrapli_cfg.platform.core.cisco_iosxe.types import FilePromptMode CONFIG_SOURCES = [ \"running\", \"startup\", ] class ScrapliCfgIOSXEBase: logger: LoggerAdapter candidate_config: str candidate_config_filename: str _replace: bool filesystem: str _filesystem_space_available_buffer_perc: int def _post_get_filesystem_space_available(self, output: str) -> int: \"\"\" Handle post \"get_filesystem_space_available\" operations for parity between sync and async Args: output: output that was fetched from the device Returns: int: bytes of space available on filesystem Raises: FailedToFetchSpaceAvailable: if could not determine space available... duh :) \"\"\" self.logger.info(\"determining space available from device output\") bytes_available_match = re.search(pattern=BYTES_FREE, string=output) if not bytes_available_match: msg = \"could not determine space available on filesystem\" self.logger.critical(msg) raise FailedToFetchSpaceAvailable(msg) return int(bytes_available_match.groupdict()[\"bytes_available\"]) def _space_available(self, filesystem_bytes_available: int) -> None: \"\"\" Space available operations for parity between sync and async It seems that on iosxe the length of the config is near enough 1:1 to the size it takes up on the disk... so roll w/ that plus a bit of buffer based on the available buffer perc Args: filesystem_bytes_available: bytes available on filesystem Returns: None Raises: InsufficientSpaceAvailable: if... insufficient space available.... \"\"\" if filesystem_bytes_available < ( len(self.candidate_config) / self._filesystem_space_available_buffer_perc ) + len(self.candidate_config): # filesystem has less than candidate config file size + 10% (by default) space, bail out msg = ( f\"insufficient space available for candidate config + \" f\"{self._filesystem_space_available_buffer_perc}% (buffer)\" ) self.logger.critical(msg) raise InsufficientSpaceAvailable(msg) def _post_determine_file_prompt_mode(self, output: str) -> FilePromptMode: \"\"\" Handle post \"determine_file_prompt_mode\" operations for parity between sync and async Args: output: output that was fetched from the device Returns: FilePromptMode: enum representing file prompt mode Raises: N/A \"\"\" self.logger.debug(\"determining file prompt mode from device output\") file_prompt_match = re.search(pattern=FILE_PROMPT_MODE, string=output) if not file_prompt_match: return FilePromptMode.ALERT prompt_mode = file_prompt_match.groupdict()[\"prompt_mode\"] if prompt_mode == \"noisy\": return FilePromptMode.NOISY return FilePromptMode.QUIET @staticmethod def _parse_version(device_output: str) -> str: \"\"\" Parse version string out of device output Args: device_output: output from show version command Returns: str: device version string Raises: N/A \"\"\" version_string_search = re.search(pattern=VERSION_PATTERN, string=device_output) if not version_string_search: return \"\" version_string = version_string_search.group(0) or \"\" return version_string def _reset_config_session(self) -> None: \"\"\" Reset config session info Resets the candidate config and config session name attributes -- when these are \"empty\" we know there is no current config session Args: N/A Returns: None Raises: N/A \"\"\" self.logger.debug(\"resetting candidate config and candidate config file name\") self.candidate_config = \"\" self.candidate_config_filename = \"\" @staticmethod def _get_config_command(source: str) -> str: \"\"\" Return command to use to get config based on the provided source Args: source: name of the config source, generally running|startup Returns: str: command to use to fetch the requested config Raises: N/A \"\"\" if source == \"running\": return \"show running-config\" return \"show startup-config\" def _get_diff_command(self, source: str) -> str: \"\"\" Return command to use to get config diff based on the provided source Args: source: name of the config source, generally running|startup Returns: str: command to use to fetch the requested config Raises: N/A \"\"\" if self._replace: return ( f\"show archive config differences system:{source}-config {self.filesystem}\" f\"{self.candidate_config_filename}\" ) return ( f\"show archive config incremental-diffs {self.filesystem}\" f\"{self.candidate_config_filename} ignorecase\" ) def _prepare_config_payloads(self, config: str) -> str: \"\"\" Prepare a configuration so it can be nicely sent to the device via scrapli Args: config: configuration to prep Returns: str: string of config lines to write to candidate config file Raises: N/A \"\"\" tclsh_start_file = f'puts [open \"{self.filesystem}{self.candidate_config_filename}\" w+] {{' tclsh_end_file = \"}\" final_config = \"\\n\".join((tclsh_start_file, config, tclsh_end_file)) return final_config def _prepare_load_config(self, config: str, replace: bool) -> str: \"\"\" Handle pre \"load_config\" operations for parity between sync and async Args: config: candidate config to load replace: True/False replace the configuration; passed here so it can be set at the class level as we need to stay in config mode and we need to know if we are doing a merge or a replace when we go to diff things Returns: str: string of config to write to candidate config file Raises: N/A \"\"\" self.candidate_config = config if not self.candidate_config_filename: self.candidate_config_filename = f\"scrapli_cfg_{round(datetime.now().timestamp())}\" self.logger.debug( f\"candidate config file name will be '{self.candidate_config_filename}'\" ) config = self._prepare_config_payloads(config=config) self._replace = replace return config def _normalize_source_candidate_configs(self, source_config: str) -> Tuple[str, str]: \"\"\" Normalize candidate config and source config so that we can easily diff them Args: source_config: current config of the source config store Returns: ScrapliCfgDiff: scrapli cfg diff object Raises: N/A \"\"\" self.logger.debug(\"normalizing source and candidate configs for diff object\") # remove any of the leading timestamp/building config/config size/last change lines in # both the source and candidate configs so they dont need to be compared source_config = re.sub(pattern=OUTPUT_HEADER_PATTERN, string=source_config, repl=\"\") source_config = \"\\n\".join(line for line in source_config.splitlines() if line) candidate_config = re.sub( pattern=OUTPUT_HEADER_PATTERN, string=self.candidate_config, repl=\"\" ) candidate_config = \"\\n\".join(line for line in candidate_config.splitlines() if line) return source_config, candidate_config Classes \u00b6 ScrapliCfgIOSXEBase \u00b6 Expand source code class ScrapliCfgIOSXEBase: logger: LoggerAdapter candidate_config: str candidate_config_filename: str _replace: bool filesystem: str _filesystem_space_available_buffer_perc: int def _post_get_filesystem_space_available(self, output: str) -> int: \"\"\" Handle post \"get_filesystem_space_available\" operations for parity between sync and async Args: output: output that was fetched from the device Returns: int: bytes of space available on filesystem Raises: FailedToFetchSpaceAvailable: if could not determine space available... duh :) \"\"\" self.logger.info(\"determining space available from device output\") bytes_available_match = re.search(pattern=BYTES_FREE, string=output) if not bytes_available_match: msg = \"could not determine space available on filesystem\" self.logger.critical(msg) raise FailedToFetchSpaceAvailable(msg) return int(bytes_available_match.groupdict()[\"bytes_available\"]) def _space_available(self, filesystem_bytes_available: int) -> None: \"\"\" Space available operations for parity between sync and async It seems that on iosxe the length of the config is near enough 1:1 to the size it takes up on the disk... so roll w/ that plus a bit of buffer based on the available buffer perc Args: filesystem_bytes_available: bytes available on filesystem Returns: None Raises: InsufficientSpaceAvailable: if... insufficient space available.... \"\"\" if filesystem_bytes_available < ( len(self.candidate_config) / self._filesystem_space_available_buffer_perc ) + len(self.candidate_config): # filesystem has less than candidate config file size + 10% (by default) space, bail out msg = ( f\"insufficient space available for candidate config + \" f\"{self._filesystem_space_available_buffer_perc}% (buffer)\" ) self.logger.critical(msg) raise InsufficientSpaceAvailable(msg) def _post_determine_file_prompt_mode(self, output: str) -> FilePromptMode: \"\"\" Handle post \"determine_file_prompt_mode\" operations for parity between sync and async Args: output: output that was fetched from the device Returns: FilePromptMode: enum representing file prompt mode Raises: N/A \"\"\" self.logger.debug(\"determining file prompt mode from device output\") file_prompt_match = re.search(pattern=FILE_PROMPT_MODE, string=output) if not file_prompt_match: return FilePromptMode.ALERT prompt_mode = file_prompt_match.groupdict()[\"prompt_mode\"] if prompt_mode == \"noisy\": return FilePromptMode.NOISY return FilePromptMode.QUIET @staticmethod def _parse_version(device_output: str) -> str: \"\"\" Parse version string out of device output Args: device_output: output from show version command Returns: str: device version string Raises: N/A \"\"\" version_string_search = re.search(pattern=VERSION_PATTERN, string=device_output) if not version_string_search: return \"\" version_string = version_string_search.group(0) or \"\" return version_string def _reset_config_session(self) -> None: \"\"\" Reset config session info Resets the candidate config and config session name attributes -- when these are \"empty\" we know there is no current config session Args: N/A Returns: None Raises: N/A \"\"\" self.logger.debug(\"resetting candidate config and candidate config file name\") self.candidate_config = \"\" self.candidate_config_filename = \"\" @staticmethod def _get_config_command(source: str) -> str: \"\"\" Return command to use to get config based on the provided source Args: source: name of the config source, generally running|startup Returns: str: command to use to fetch the requested config Raises: N/A \"\"\" if source == \"running\": return \"show running-config\" return \"show startup-config\" def _get_diff_command(self, source: str) -> str: \"\"\" Return command to use to get config diff based on the provided source Args: source: name of the config source, generally running|startup Returns: str: command to use to fetch the requested config Raises: N/A \"\"\" if self._replace: return ( f\"show archive config differences system:{source}-config {self.filesystem}\" f\"{self.candidate_config_filename}\" ) return ( f\"show archive config incremental-diffs {self.filesystem}\" f\"{self.candidate_config_filename} ignorecase\" ) def _prepare_config_payloads(self, config: str) -> str: \"\"\" Prepare a configuration so it can be nicely sent to the device via scrapli Args: config: configuration to prep Returns: str: string of config lines to write to candidate config file Raises: N/A \"\"\" tclsh_start_file = f'puts [open \"{self.filesystem}{self.candidate_config_filename}\" w+] {{' tclsh_end_file = \"}\" final_config = \"\\n\".join((tclsh_start_file, config, tclsh_end_file)) return final_config def _prepare_load_config(self, config: str, replace: bool) -> str: \"\"\" Handle pre \"load_config\" operations for parity between sync and async Args: config: candidate config to load replace: True/False replace the configuration; passed here so it can be set at the class level as we need to stay in config mode and we need to know if we are doing a merge or a replace when we go to diff things Returns: str: string of config to write to candidate config file Raises: N/A \"\"\" self.candidate_config = config if not self.candidate_config_filename: self.candidate_config_filename = f\"scrapli_cfg_{round(datetime.now().timestamp())}\" self.logger.debug( f\"candidate config file name will be '{self.candidate_config_filename}'\" ) config = self._prepare_config_payloads(config=config) self._replace = replace return config def _normalize_source_candidate_configs(self, source_config: str) -> Tuple[str, str]: \"\"\" Normalize candidate config and source config so that we can easily diff them Args: source_config: current config of the source config store Returns: ScrapliCfgDiff: scrapli cfg diff object Raises: N/A \"\"\" self.logger.debug(\"normalizing source and candidate configs for diff object\") # remove any of the leading timestamp/building config/config size/last change lines in # both the source and candidate configs so they dont need to be compared source_config = re.sub(pattern=OUTPUT_HEADER_PATTERN, string=source_config, repl=\"\") source_config = \"\\n\".join(line for line in source_config.splitlines() if line) candidate_config = re.sub( pattern=OUTPUT_HEADER_PATTERN, string=self.candidate_config, repl=\"\" ) candidate_config = \"\\n\".join(line for line in candidate_config.splitlines() if line) return source_config, candidate_config Descendants \u00b6 scrapli_cfg.platform.core.cisco_iosxe.async_platform.AsyncScrapliCfgIOSXE scrapli_cfg.platform.core.cisco_iosxe.sync_platform.ScrapliCfgIOSXE Class variables \u00b6 candidate_config: str candidate_config_filename: str filesystem: str logger: logging.LoggerAdapter","title":"Base platform"},{"location":"api_docs/platform/core/cisco_iosxe/base_platform/#module-scrapli_cfgplatformcorecisco_iosxebase_platform","text":"scrapli_cfg.platform.core.cisco_iosxe.base Expand source code \"\"\"scrapli_cfg.platform.core.cisco_iosxe.base\"\"\" import re from datetime import datetime from logging import LoggerAdapter from typing import Tuple from scrapli_cfg.exceptions import FailedToFetchSpaceAvailable, InsufficientSpaceAvailable from scrapli_cfg.platform.core.cisco_iosxe.patterns import ( BYTES_FREE, FILE_PROMPT_MODE, OUTPUT_HEADER_PATTERN, VERSION_PATTERN, ) from scrapli_cfg.platform.core.cisco_iosxe.types import FilePromptMode CONFIG_SOURCES = [ \"running\", \"startup\", ] class ScrapliCfgIOSXEBase: logger: LoggerAdapter candidate_config: str candidate_config_filename: str _replace: bool filesystem: str _filesystem_space_available_buffer_perc: int def _post_get_filesystem_space_available(self, output: str) -> int: \"\"\" Handle post \"get_filesystem_space_available\" operations for parity between sync and async Args: output: output that was fetched from the device Returns: int: bytes of space available on filesystem Raises: FailedToFetchSpaceAvailable: if could not determine space available... duh :) \"\"\" self.logger.info(\"determining space available from device output\") bytes_available_match = re.search(pattern=BYTES_FREE, string=output) if not bytes_available_match: msg = \"could not determine space available on filesystem\" self.logger.critical(msg) raise FailedToFetchSpaceAvailable(msg) return int(bytes_available_match.groupdict()[\"bytes_available\"]) def _space_available(self, filesystem_bytes_available: int) -> None: \"\"\" Space available operations for parity between sync and async It seems that on iosxe the length of the config is near enough 1:1 to the size it takes up on the disk... so roll w/ that plus a bit of buffer based on the available buffer perc Args: filesystem_bytes_available: bytes available on filesystem Returns: None Raises: InsufficientSpaceAvailable: if... insufficient space available.... \"\"\" if filesystem_bytes_available < ( len(self.candidate_config) / self._filesystem_space_available_buffer_perc ) + len(self.candidate_config): # filesystem has less than candidate config file size + 10% (by default) space, bail out msg = ( f\"insufficient space available for candidate config + \" f\"{self._filesystem_space_available_buffer_perc}% (buffer)\" ) self.logger.critical(msg) raise InsufficientSpaceAvailable(msg) def _post_determine_file_prompt_mode(self, output: str) -> FilePromptMode: \"\"\" Handle post \"determine_file_prompt_mode\" operations for parity between sync and async Args: output: output that was fetched from the device Returns: FilePromptMode: enum representing file prompt mode Raises: N/A \"\"\" self.logger.debug(\"determining file prompt mode from device output\") file_prompt_match = re.search(pattern=FILE_PROMPT_MODE, string=output) if not file_prompt_match: return FilePromptMode.ALERT prompt_mode = file_prompt_match.groupdict()[\"prompt_mode\"] if prompt_mode == \"noisy\": return FilePromptMode.NOISY return FilePromptMode.QUIET @staticmethod def _parse_version(device_output: str) -> str: \"\"\" Parse version string out of device output Args: device_output: output from show version command Returns: str: device version string Raises: N/A \"\"\" version_string_search = re.search(pattern=VERSION_PATTERN, string=device_output) if not version_string_search: return \"\" version_string = version_string_search.group(0) or \"\" return version_string def _reset_config_session(self) -> None: \"\"\" Reset config session info Resets the candidate config and config session name attributes -- when these are \"empty\" we know there is no current config session Args: N/A Returns: None Raises: N/A \"\"\" self.logger.debug(\"resetting candidate config and candidate config file name\") self.candidate_config = \"\" self.candidate_config_filename = \"\" @staticmethod def _get_config_command(source: str) -> str: \"\"\" Return command to use to get config based on the provided source Args: source: name of the config source, generally running|startup Returns: str: command to use to fetch the requested config Raises: N/A \"\"\" if source == \"running\": return \"show running-config\" return \"show startup-config\" def _get_diff_command(self, source: str) -> str: \"\"\" Return command to use to get config diff based on the provided source Args: source: name of the config source, generally running|startup Returns: str: command to use to fetch the requested config Raises: N/A \"\"\" if self._replace: return ( f\"show archive config differences system:{source}-config {self.filesystem}\" f\"{self.candidate_config_filename}\" ) return ( f\"show archive config incremental-diffs {self.filesystem}\" f\"{self.candidate_config_filename} ignorecase\" ) def _prepare_config_payloads(self, config: str) -> str: \"\"\" Prepare a configuration so it can be nicely sent to the device via scrapli Args: config: configuration to prep Returns: str: string of config lines to write to candidate config file Raises: N/A \"\"\" tclsh_start_file = f'puts [open \"{self.filesystem}{self.candidate_config_filename}\" w+] {{' tclsh_end_file = \"}\" final_config = \"\\n\".join((tclsh_start_file, config, tclsh_end_file)) return final_config def _prepare_load_config(self, config: str, replace: bool) -> str: \"\"\" Handle pre \"load_config\" operations for parity between sync and async Args: config: candidate config to load replace: True/False replace the configuration; passed here so it can be set at the class level as we need to stay in config mode and we need to know if we are doing a merge or a replace when we go to diff things Returns: str: string of config to write to candidate config file Raises: N/A \"\"\" self.candidate_config = config if not self.candidate_config_filename: self.candidate_config_filename = f\"scrapli_cfg_{round(datetime.now().timestamp())}\" self.logger.debug( f\"candidate config file name will be '{self.candidate_config_filename}'\" ) config = self._prepare_config_payloads(config=config) self._replace = replace return config def _normalize_source_candidate_configs(self, source_config: str) -> Tuple[str, str]: \"\"\" Normalize candidate config and source config so that we can easily diff them Args: source_config: current config of the source config store Returns: ScrapliCfgDiff: scrapli cfg diff object Raises: N/A \"\"\" self.logger.debug(\"normalizing source and candidate configs for diff object\") # remove any of the leading timestamp/building config/config size/last change lines in # both the source and candidate configs so they dont need to be compared source_config = re.sub(pattern=OUTPUT_HEADER_PATTERN, string=source_config, repl=\"\") source_config = \"\\n\".join(line for line in source_config.splitlines() if line) candidate_config = re.sub( pattern=OUTPUT_HEADER_PATTERN, string=self.candidate_config, repl=\"\" ) candidate_config = \"\\n\".join(line for line in candidate_config.splitlines() if line) return source_config, candidate_config","title":"Module scrapli_cfg.platform.core.cisco_iosxe.base_platform"},{"location":"api_docs/platform/core/cisco_iosxe/base_platform/#classes","text":"","title":"Classes"},{"location":"api_docs/platform/core/cisco_iosxe/base_platform/#scraplicfgiosxebase","text":"Expand source code class ScrapliCfgIOSXEBase: logger: LoggerAdapter candidate_config: str candidate_config_filename: str _replace: bool filesystem: str _filesystem_space_available_buffer_perc: int def _post_get_filesystem_space_available(self, output: str) -> int: \"\"\" Handle post \"get_filesystem_space_available\" operations for parity between sync and async Args: output: output that was fetched from the device Returns: int: bytes of space available on filesystem Raises: FailedToFetchSpaceAvailable: if could not determine space available... duh :) \"\"\" self.logger.info(\"determining space available from device output\") bytes_available_match = re.search(pattern=BYTES_FREE, string=output) if not bytes_available_match: msg = \"could not determine space available on filesystem\" self.logger.critical(msg) raise FailedToFetchSpaceAvailable(msg) return int(bytes_available_match.groupdict()[\"bytes_available\"]) def _space_available(self, filesystem_bytes_available: int) -> None: \"\"\" Space available operations for parity between sync and async It seems that on iosxe the length of the config is near enough 1:1 to the size it takes up on the disk... so roll w/ that plus a bit of buffer based on the available buffer perc Args: filesystem_bytes_available: bytes available on filesystem Returns: None Raises: InsufficientSpaceAvailable: if... insufficient space available.... \"\"\" if filesystem_bytes_available < ( len(self.candidate_config) / self._filesystem_space_available_buffer_perc ) + len(self.candidate_config): # filesystem has less than candidate config file size + 10% (by default) space, bail out msg = ( f\"insufficient space available for candidate config + \" f\"{self._filesystem_space_available_buffer_perc}% (buffer)\" ) self.logger.critical(msg) raise InsufficientSpaceAvailable(msg) def _post_determine_file_prompt_mode(self, output: str) -> FilePromptMode: \"\"\" Handle post \"determine_file_prompt_mode\" operations for parity between sync and async Args: output: output that was fetched from the device Returns: FilePromptMode: enum representing file prompt mode Raises: N/A \"\"\" self.logger.debug(\"determining file prompt mode from device output\") file_prompt_match = re.search(pattern=FILE_PROMPT_MODE, string=output) if not file_prompt_match: return FilePromptMode.ALERT prompt_mode = file_prompt_match.groupdict()[\"prompt_mode\"] if prompt_mode == \"noisy\": return FilePromptMode.NOISY return FilePromptMode.QUIET @staticmethod def _parse_version(device_output: str) -> str: \"\"\" Parse version string out of device output Args: device_output: output from show version command Returns: str: device version string Raises: N/A \"\"\" version_string_search = re.search(pattern=VERSION_PATTERN, string=device_output) if not version_string_search: return \"\" version_string = version_string_search.group(0) or \"\" return version_string def _reset_config_session(self) -> None: \"\"\" Reset config session info Resets the candidate config and config session name attributes -- when these are \"empty\" we know there is no current config session Args: N/A Returns: None Raises: N/A \"\"\" self.logger.debug(\"resetting candidate config and candidate config file name\") self.candidate_config = \"\" self.candidate_config_filename = \"\" @staticmethod def _get_config_command(source: str) -> str: \"\"\" Return command to use to get config based on the provided source Args: source: name of the config source, generally running|startup Returns: str: command to use to fetch the requested config Raises: N/A \"\"\" if source == \"running\": return \"show running-config\" return \"show startup-config\" def _get_diff_command(self, source: str) -> str: \"\"\" Return command to use to get config diff based on the provided source Args: source: name of the config source, generally running|startup Returns: str: command to use to fetch the requested config Raises: N/A \"\"\" if self._replace: return ( f\"show archive config differences system:{source}-config {self.filesystem}\" f\"{self.candidate_config_filename}\" ) return ( f\"show archive config incremental-diffs {self.filesystem}\" f\"{self.candidate_config_filename} ignorecase\" ) def _prepare_config_payloads(self, config: str) -> str: \"\"\" Prepare a configuration so it can be nicely sent to the device via scrapli Args: config: configuration to prep Returns: str: string of config lines to write to candidate config file Raises: N/A \"\"\" tclsh_start_file = f'puts [open \"{self.filesystem}{self.candidate_config_filename}\" w+] {{' tclsh_end_file = \"}\" final_config = \"\\n\".join((tclsh_start_file, config, tclsh_end_file)) return final_config def _prepare_load_config(self, config: str, replace: bool) -> str: \"\"\" Handle pre \"load_config\" operations for parity between sync and async Args: config: candidate config to load replace: True/False replace the configuration; passed here so it can be set at the class level as we need to stay in config mode and we need to know if we are doing a merge or a replace when we go to diff things Returns: str: string of config to write to candidate config file Raises: N/A \"\"\" self.candidate_config = config if not self.candidate_config_filename: self.candidate_config_filename = f\"scrapli_cfg_{round(datetime.now().timestamp())}\" self.logger.debug( f\"candidate config file name will be '{self.candidate_config_filename}'\" ) config = self._prepare_config_payloads(config=config) self._replace = replace return config def _normalize_source_candidate_configs(self, source_config: str) -> Tuple[str, str]: \"\"\" Normalize candidate config and source config so that we can easily diff them Args: source_config: current config of the source config store Returns: ScrapliCfgDiff: scrapli cfg diff object Raises: N/A \"\"\" self.logger.debug(\"normalizing source and candidate configs for diff object\") # remove any of the leading timestamp/building config/config size/last change lines in # both the source and candidate configs so they dont need to be compared source_config = re.sub(pattern=OUTPUT_HEADER_PATTERN, string=source_config, repl=\"\") source_config = \"\\n\".join(line for line in source_config.splitlines() if line) candidate_config = re.sub( pattern=OUTPUT_HEADER_PATTERN, string=self.candidate_config, repl=\"\" ) candidate_config = \"\\n\".join(line for line in candidate_config.splitlines() if line) return source_config, candidate_config","title":"ScrapliCfgIOSXEBase"},{"location":"api_docs/platform/core/cisco_iosxe/base_platform/#descendants","text":"scrapli_cfg.platform.core.cisco_iosxe.async_platform.AsyncScrapliCfgIOSXE scrapli_cfg.platform.core.cisco_iosxe.sync_platform.ScrapliCfgIOSXE","title":"Descendants"},{"location":"api_docs/platform/core/cisco_iosxe/base_platform/#class-variables","text":"candidate_config: str candidate_config_filename: str filesystem: str logger: logging.LoggerAdapter","title":"Class variables"},{"location":"api_docs/platform/core/cisco_iosxe/patterns/","text":"window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting()) Module scrapli_cfg.platform.core.cisco_iosxe.patterns \u00b6 scrapli_cfg.platform.core.cisco_iosxe.patterns Expand source code \"\"\"scrapli_cfg.platform.core.cisco_iosxe.patterns\"\"\" import re VERSION_PATTERN = re.compile(pattern=r\"\\d+\\.[a-z0-9\\(\\)\\.]+\", flags=re.I) BYTES_FREE = re.compile(pattern=r\"(?P \\d+)(?: bytes free)\", flags=re.I) FILE_PROMPT_MODE = re.compile(pattern=r\"(?:file prompt )(?P \\w+)\", flags=re.I) OUTPUT_HEADER_PATTERN = re.compile( pattern=r\".*(?=(version \\d+\\.\\d+))\", flags=re.I | re.S, )","title":"Patterns"},{"location":"api_docs/platform/core/cisco_iosxe/patterns/#module-scrapli_cfgplatformcorecisco_iosxepatterns","text":"scrapli_cfg.platform.core.cisco_iosxe.patterns Expand source code \"\"\"scrapli_cfg.platform.core.cisco_iosxe.patterns\"\"\" import re VERSION_PATTERN = re.compile(pattern=r\"\\d+\\.[a-z0-9\\(\\)\\.]+\", flags=re.I) BYTES_FREE = re.compile(pattern=r\"(?P \\d+)(?: bytes free)\", flags=re.I) FILE_PROMPT_MODE = re.compile(pattern=r\"(?:file prompt )(?P \\w+)\", flags=re.I) OUTPUT_HEADER_PATTERN = re.compile( pattern=r\".*(?=(version \\d+\\.\\d+))\", flags=re.I | re.S, )","title":"Module scrapli_cfg.platform.core.cisco_iosxe.patterns"},{"location":"api_docs/platform/core/cisco_iosxe/sync_platform/","text":"window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting()) Module scrapli_cfg.platform.core.cisco_iosxe.sync_platform \u00b6 scrapli_cfg.platform.core.cisco_iosxe.sync_platform Expand source code \"\"\"scrapli_cfg.platform.core.cisco_iosxe.sync_platform\"\"\" from typing import Any, Callable, List, Optional from scrapli.driver import NetworkDriver from scrapli.response import Response from scrapli_cfg.diff import ScrapliCfgDiffResponse from scrapli_cfg.exceptions import DiffConfigError, FailedToDetermineDeviceState from scrapli_cfg.platform.base.sync_platform import ScrapliCfgPlatform from scrapli_cfg.platform.core.cisco_iosxe.base_platform import CONFIG_SOURCES, ScrapliCfgIOSXEBase from scrapli_cfg.platform.core.cisco_iosxe.types import FilePromptMode from scrapli_cfg.response import ScrapliCfgResponse def iosxe_on_open(cls: ScrapliCfgPlatform) -> None: \"\"\" Scrapli CFG IOSXE On open Disable console logging, perhaps more things in the future! Args: cls: ScrapliCfg object Returns: None Raises: N/A \"\"\" cls.conn.send_config(config=\"no logging monitor\") class ScrapliCfgIOSXE(ScrapliCfgPlatform, ScrapliCfgIOSXEBase): def __init__( self, conn: NetworkDriver, config_sources: Optional[List[str]] = None, on_open: Optional[Callable[..., Any]] = None, filesystem: str = \"flash:\", cleanup_post_commit: bool = True, ) -> None: if config_sources is None: config_sources = CONFIG_SOURCES if on_open is None: on_open = iosxe_on_open super().__init__(conn=conn, config_sources=config_sources, on_open=on_open) self.filesystem = filesystem self._filesystem_space_available_buffer_perc = 10 self._replace = False self.candidate_config_filename = \"\" self.cleanup_post_commit = cleanup_post_commit self._get_version_command = \"show version | i Version\" def _get_filesystem_space_available(self) -> int: \"\"\" Abort a configuration -- discards any loaded config Args: N/A Returns: None Raises: FailedToDetermineDeviceState: if unable to fetch file filesystem bytes available \"\"\" filesystem_size_result = self.conn.send_command(command=f\"dir {self.filesystem} | i bytes\") if filesystem_size_result.failed: raise FailedToDetermineDeviceState(\"failed to determine space available on filesystem\") return self._post_get_filesystem_space_available(output=filesystem_size_result.result) def _determine_file_prompt_mode(self) -> FilePromptMode: \"\"\" Determine the device file prompt mode Args: N/A Returns: FilePromptMode: enum representing file prompt mode Raises: FailedToDetermineDeviceState: if unable to fetch file prompt mode \"\"\" file_prompt_mode_result = self.conn.send_command(command=\"show run | i file prompt\") if file_prompt_mode_result.failed: raise FailedToDetermineDeviceState(\"failed to determine file prompt mode\") return self._post_determine_file_prompt_mode(output=file_prompt_mode_result.result) def _delete_candidate_config(self) -> Response: \"\"\" Delete candidate config from the filesystem Args: N/A Returns: Response: response from deleting the candidate config Raises: N/A \"\"\" # have to check again because the candidate config may have changed this! file_prompt_mode = self._determine_file_prompt_mode() if file_prompt_mode in (FilePromptMode.ALERT, FilePromptMode.NOISY): delete_events = [ ( f\"delete {self.filesystem}{self.candidate_config_filename}\", \"Delete filename\", ), ( \"\", \"[confirm]\", ), (\"\", \"\"), ] else: delete_events = [ (f\"delete {self.filesystem}{self.candidate_config_filename}\", \"[confirm]\"), (\"\", \"\"), ] delete_result = self.conn.send_interactive(interact_events=delete_events) return delete_result def get_config(self, source: str = \"running\") -> ScrapliCfgResponse: response = self._pre_get_config(source=source) config_result = self.conn.send_command(command=self._get_config_command(source=source)) return self._post_get_config( response=response, source=source, scrapli_responses=[config_result], result=config_result.result, ) def load_config(self, config: str, replace: bool = False, **kwargs: Any) -> ScrapliCfgResponse: \"\"\" Load configuration to a device Supported kwargs: N/A Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for iosxe supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" response = self._pre_load_config(config=config) config = self._prepare_load_config(config=config, replace=replace) filesystem_bytes_available = self._get_filesystem_space_available() self._space_available(filesystem_bytes_available=filesystem_bytes_available) # when in tcl command mode or whatever it is, tcl wants \\r for return char, so stash the # original return char and sub in \\r for a bit original_return_char = self.conn.comms_return_char tcl_comms_return_char = \"\\r\" # pop into tclsh before swapping the return char just to be safe -- \\r or \\n should both be # fine for up to here but who knows... :) self.conn.acquire_priv(desired_priv=\"tclsh\") self.conn.comms_return_char = tcl_comms_return_char config_result = self.conn.send_config(config=config, privilege_level=\"tclsh\") # reset the return char to the \"normal\" one and drop into whatever is the \"default\" priv self.conn.comms_return_char = original_return_char self.conn.acquire_priv(desired_priv=self.conn.default_desired_privilege_level) return self._post_load_config( response=response, scrapli_responses=[config_result], ) def abort_config(self) -> ScrapliCfgResponse: response = self._pre_abort_config( session_or_config_file=bool(self.candidate_config_filename) ) abort_result = self._delete_candidate_config() self._reset_config_session() return self._post_abort_config(response=response, scrapli_responses=[abort_result]) def commit_config(self, source: str = \"running\") -> ScrapliCfgResponse: scrapli_responses = [] response = self._pre_commit_config( source=source, session_or_config_file=bool(self.candidate_config_filename) ) if self._replace is True: replace_command = ( f\"configure replace {self.filesystem}{self.candidate_config_filename} force\" ) commit_result = self.conn.send_command(command=replace_command) else: file_prompt_mode = self._determine_file_prompt_mode() if file_prompt_mode == FilePromptMode.ALERT: merge_events = [ ( f\"copy {self.filesystem}{self.candidate_config_filename} running-config\", \"Destination filename\", ), (\"\", \"\"), ] elif file_prompt_mode == FilePromptMode.NOISY: merge_events = [ ( f\"copy {self.filesystem}{self.candidate_config_filename} running-config\", \"Source filename\", ), ( \"\", \"Destination filename\", ), (\"\", \"\"), ] else: merge_events = [ (f\"copy {self.filesystem}{self.candidate_config_filename} running-config\", \"\") ] commit_result = self.conn.send_interactive(interact_events=merge_events) scrapli_responses.append(commit_result) save_config_result = self.conn.send_command(command=\"copy running-config startup-config\") scrapli_responses.append(save_config_result) if self.cleanup_post_commit: cleanup_result = self._delete_candidate_config() scrapli_responses.append(cleanup_result) self._reset_config_session() return self._post_load_config( response=response, scrapli_responses=scrapli_responses, ) def diff_config(self, source: str = \"running\") -> ScrapliCfgDiffResponse: scrapli_responses = [] device_diff = \"\" source_config = \"\" diff_response = self._pre_diff_config( source=source, session_or_config_file=bool(self.candidate_config_filename) ) try: diff_result = self.conn.send_command(command=self._get_diff_command(source=source)) scrapli_responses.append(diff_response) if diff_result.failed: msg = \"failed generating diff for config session\" self.logger.critical(msg) raise DiffConfigError(msg) device_diff = diff_result.result source_config_result = self.get_config(source=source) source_config = source_config_result.result if source_config_result.scrapli_responses: scrapli_responses.extend(source_config_result.scrapli_responses) if source_config_result.failed: msg = \"failed fetching source config for diff comparison\" self.logger.critical(msg) raise DiffConfigError(msg) except DiffConfigError: pass source_config, candidate_config = self._normalize_source_candidate_configs( source_config=source_config ) return self._post_diff_config( diff_response=diff_response, scrapli_responses=scrapli_responses, source_config=source_config, candidate_config=candidate_config, device_diff=device_diff, ) Functions \u00b6 iosxe_on_open \u00b6 iosxe_on_open(cls: scrapli_cfg.platform.base.sync_platform.ScrapliCfgPlatform) \u2011> NoneType Scrapli CFG IOSXE On open Disable console logging, perhaps more things in the future! Args: cls: ScrapliCfg object Returns: None Raises: N/A Classes \u00b6 ScrapliCfgIOSXE \u00b6 Helper class that provides a standard way to create an ABC using inheritance. Scrapli Config base class Args: conn: scrapli connection to use config_sources: list of config sources on_open: async callable to run at connection open Returns: None Raises: N/A Expand source code class ScrapliCfgIOSXE(ScrapliCfgPlatform, ScrapliCfgIOSXEBase): def __init__( self, conn: NetworkDriver, config_sources: Optional[List[str]] = None, on_open: Optional[Callable[..., Any]] = None, filesystem: str = \"flash:\", cleanup_post_commit: bool = True, ) -> None: if config_sources is None: config_sources = CONFIG_SOURCES if on_open is None: on_open = iosxe_on_open super().__init__(conn=conn, config_sources=config_sources, on_open=on_open) self.filesystem = filesystem self._filesystem_space_available_buffer_perc = 10 self._replace = False self.candidate_config_filename = \"\" self.cleanup_post_commit = cleanup_post_commit self._get_version_command = \"show version | i Version\" def _get_filesystem_space_available(self) -> int: \"\"\" Abort a configuration -- discards any loaded config Args: N/A Returns: None Raises: FailedToDetermineDeviceState: if unable to fetch file filesystem bytes available \"\"\" filesystem_size_result = self.conn.send_command(command=f\"dir {self.filesystem} | i bytes\") if filesystem_size_result.failed: raise FailedToDetermineDeviceState(\"failed to determine space available on filesystem\") return self._post_get_filesystem_space_available(output=filesystem_size_result.result) def _determine_file_prompt_mode(self) -> FilePromptMode: \"\"\" Determine the device file prompt mode Args: N/A Returns: FilePromptMode: enum representing file prompt mode Raises: FailedToDetermineDeviceState: if unable to fetch file prompt mode \"\"\" file_prompt_mode_result = self.conn.send_command(command=\"show run | i file prompt\") if file_prompt_mode_result.failed: raise FailedToDetermineDeviceState(\"failed to determine file prompt mode\") return self._post_determine_file_prompt_mode(output=file_prompt_mode_result.result) def _delete_candidate_config(self) -> Response: \"\"\" Delete candidate config from the filesystem Args: N/A Returns: Response: response from deleting the candidate config Raises: N/A \"\"\" # have to check again because the candidate config may have changed this! file_prompt_mode = self._determine_file_prompt_mode() if file_prompt_mode in (FilePromptMode.ALERT, FilePromptMode.NOISY): delete_events = [ ( f\"delete {self.filesystem}{self.candidate_config_filename}\", \"Delete filename\", ), ( \"\", \"[confirm]\", ), (\"\", \"\"), ] else: delete_events = [ (f\"delete {self.filesystem}{self.candidate_config_filename}\", \"[confirm]\"), (\"\", \"\"), ] delete_result = self.conn.send_interactive(interact_events=delete_events) return delete_result def get_config(self, source: str = \"running\") -> ScrapliCfgResponse: response = self._pre_get_config(source=source) config_result = self.conn.send_command(command=self._get_config_command(source=source)) return self._post_get_config( response=response, source=source, scrapli_responses=[config_result], result=config_result.result, ) def load_config(self, config: str, replace: bool = False, **kwargs: Any) -> ScrapliCfgResponse: \"\"\" Load configuration to a device Supported kwargs: N/A Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for iosxe supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" response = self._pre_load_config(config=config) config = self._prepare_load_config(config=config, replace=replace) filesystem_bytes_available = self._get_filesystem_space_available() self._space_available(filesystem_bytes_available=filesystem_bytes_available) # when in tcl command mode or whatever it is, tcl wants \\r for return char, so stash the # original return char and sub in \\r for a bit original_return_char = self.conn.comms_return_char tcl_comms_return_char = \"\\r\" # pop into tclsh before swapping the return char just to be safe -- \\r or \\n should both be # fine for up to here but who knows... :) self.conn.acquire_priv(desired_priv=\"tclsh\") self.conn.comms_return_char = tcl_comms_return_char config_result = self.conn.send_config(config=config, privilege_level=\"tclsh\") # reset the return char to the \"normal\" one and drop into whatever is the \"default\" priv self.conn.comms_return_char = original_return_char self.conn.acquire_priv(desired_priv=self.conn.default_desired_privilege_level) return self._post_load_config( response=response, scrapli_responses=[config_result], ) def abort_config(self) -> ScrapliCfgResponse: response = self._pre_abort_config( session_or_config_file=bool(self.candidate_config_filename) ) abort_result = self._delete_candidate_config() self._reset_config_session() return self._post_abort_config(response=response, scrapli_responses=[abort_result]) def commit_config(self, source: str = \"running\") -> ScrapliCfgResponse: scrapli_responses = [] response = self._pre_commit_config( source=source, session_or_config_file=bool(self.candidate_config_filename) ) if self._replace is True: replace_command = ( f\"configure replace {self.filesystem}{self.candidate_config_filename} force\" ) commit_result = self.conn.send_command(command=replace_command) else: file_prompt_mode = self._determine_file_prompt_mode() if file_prompt_mode == FilePromptMode.ALERT: merge_events = [ ( f\"copy {self.filesystem}{self.candidate_config_filename} running-config\", \"Destination filename\", ), (\"\", \"\"), ] elif file_prompt_mode == FilePromptMode.NOISY: merge_events = [ ( f\"copy {self.filesystem}{self.candidate_config_filename} running-config\", \"Source filename\", ), ( \"\", \"Destination filename\", ), (\"\", \"\"), ] else: merge_events = [ (f\"copy {self.filesystem}{self.candidate_config_filename} running-config\", \"\") ] commit_result = self.conn.send_interactive(interact_events=merge_events) scrapli_responses.append(commit_result) save_config_result = self.conn.send_command(command=\"copy running-config startup-config\") scrapli_responses.append(save_config_result) if self.cleanup_post_commit: cleanup_result = self._delete_candidate_config() scrapli_responses.append(cleanup_result) self._reset_config_session() return self._post_load_config( response=response, scrapli_responses=scrapli_responses, ) def diff_config(self, source: str = \"running\") -> ScrapliCfgDiffResponse: scrapli_responses = [] device_diff = \"\" source_config = \"\" diff_response = self._pre_diff_config( source=source, session_or_config_file=bool(self.candidate_config_filename) ) try: diff_result = self.conn.send_command(command=self._get_diff_command(source=source)) scrapli_responses.append(diff_response) if diff_result.failed: msg = \"failed generating diff for config session\" self.logger.critical(msg) raise DiffConfigError(msg) device_diff = diff_result.result source_config_result = self.get_config(source=source) source_config = source_config_result.result if source_config_result.scrapli_responses: scrapli_responses.extend(source_config_result.scrapli_responses) if source_config_result.failed: msg = \"failed fetching source config for diff comparison\" self.logger.critical(msg) raise DiffConfigError(msg) except DiffConfigError: pass source_config, candidate_config = self._normalize_source_candidate_configs( source_config=source_config ) return self._post_diff_config( diff_response=diff_response, scrapli_responses=scrapli_responses, source_config=source_config, candidate_config=candidate_config, device_diff=device_diff, ) Ancestors (in MRO) \u00b6 scrapli_cfg.platform.base.sync_platform.ScrapliCfgPlatform abc.ABC scrapli_cfg.platform.base.base_platform.ScrapliCfgBase scrapli_cfg.platform.core.cisco_iosxe.base_platform.ScrapliCfgIOSXEBase Class variables \u00b6 conn: Union[scrapli.driver.network.sync_driver.NetworkDriver, scrapli.driver.network.async_driver.AsyncNetworkDriver] Methods \u00b6 load_config \u00b6 load_config(self, config: str, replace: bool = False, **kwargs: Any) \u2011> scrapli_cfg.response.ScrapliCfgResponse Load configuration to a device Supported kwargs: N/A Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for iosxe supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A","title":"Sync Platform"},{"location":"api_docs/platform/core/cisco_iosxe/sync_platform/#module-scrapli_cfgplatformcorecisco_iosxesync_platform","text":"scrapli_cfg.platform.core.cisco_iosxe.sync_platform Expand source code \"\"\"scrapli_cfg.platform.core.cisco_iosxe.sync_platform\"\"\" from typing import Any, Callable, List, Optional from scrapli.driver import NetworkDriver from scrapli.response import Response from scrapli_cfg.diff import ScrapliCfgDiffResponse from scrapli_cfg.exceptions import DiffConfigError, FailedToDetermineDeviceState from scrapli_cfg.platform.base.sync_platform import ScrapliCfgPlatform from scrapli_cfg.platform.core.cisco_iosxe.base_platform import CONFIG_SOURCES, ScrapliCfgIOSXEBase from scrapli_cfg.platform.core.cisco_iosxe.types import FilePromptMode from scrapli_cfg.response import ScrapliCfgResponse def iosxe_on_open(cls: ScrapliCfgPlatform) -> None: \"\"\" Scrapli CFG IOSXE On open Disable console logging, perhaps more things in the future! Args: cls: ScrapliCfg object Returns: None Raises: N/A \"\"\" cls.conn.send_config(config=\"no logging monitor\") class ScrapliCfgIOSXE(ScrapliCfgPlatform, ScrapliCfgIOSXEBase): def __init__( self, conn: NetworkDriver, config_sources: Optional[List[str]] = None, on_open: Optional[Callable[..., Any]] = None, filesystem: str = \"flash:\", cleanup_post_commit: bool = True, ) -> None: if config_sources is None: config_sources = CONFIG_SOURCES if on_open is None: on_open = iosxe_on_open super().__init__(conn=conn, config_sources=config_sources, on_open=on_open) self.filesystem = filesystem self._filesystem_space_available_buffer_perc = 10 self._replace = False self.candidate_config_filename = \"\" self.cleanup_post_commit = cleanup_post_commit self._get_version_command = \"show version | i Version\" def _get_filesystem_space_available(self) -> int: \"\"\" Abort a configuration -- discards any loaded config Args: N/A Returns: None Raises: FailedToDetermineDeviceState: if unable to fetch file filesystem bytes available \"\"\" filesystem_size_result = self.conn.send_command(command=f\"dir {self.filesystem} | i bytes\") if filesystem_size_result.failed: raise FailedToDetermineDeviceState(\"failed to determine space available on filesystem\") return self._post_get_filesystem_space_available(output=filesystem_size_result.result) def _determine_file_prompt_mode(self) -> FilePromptMode: \"\"\" Determine the device file prompt mode Args: N/A Returns: FilePromptMode: enum representing file prompt mode Raises: FailedToDetermineDeviceState: if unable to fetch file prompt mode \"\"\" file_prompt_mode_result = self.conn.send_command(command=\"show run | i file prompt\") if file_prompt_mode_result.failed: raise FailedToDetermineDeviceState(\"failed to determine file prompt mode\") return self._post_determine_file_prompt_mode(output=file_prompt_mode_result.result) def _delete_candidate_config(self) -> Response: \"\"\" Delete candidate config from the filesystem Args: N/A Returns: Response: response from deleting the candidate config Raises: N/A \"\"\" # have to check again because the candidate config may have changed this! file_prompt_mode = self._determine_file_prompt_mode() if file_prompt_mode in (FilePromptMode.ALERT, FilePromptMode.NOISY): delete_events = [ ( f\"delete {self.filesystem}{self.candidate_config_filename}\", \"Delete filename\", ), ( \"\", \"[confirm]\", ), (\"\", \"\"), ] else: delete_events = [ (f\"delete {self.filesystem}{self.candidate_config_filename}\", \"[confirm]\"), (\"\", \"\"), ] delete_result = self.conn.send_interactive(interact_events=delete_events) return delete_result def get_config(self, source: str = \"running\") -> ScrapliCfgResponse: response = self._pre_get_config(source=source) config_result = self.conn.send_command(command=self._get_config_command(source=source)) return self._post_get_config( response=response, source=source, scrapli_responses=[config_result], result=config_result.result, ) def load_config(self, config: str, replace: bool = False, **kwargs: Any) -> ScrapliCfgResponse: \"\"\" Load configuration to a device Supported kwargs: N/A Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for iosxe supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" response = self._pre_load_config(config=config) config = self._prepare_load_config(config=config, replace=replace) filesystem_bytes_available = self._get_filesystem_space_available() self._space_available(filesystem_bytes_available=filesystem_bytes_available) # when in tcl command mode or whatever it is, tcl wants \\r for return char, so stash the # original return char and sub in \\r for a bit original_return_char = self.conn.comms_return_char tcl_comms_return_char = \"\\r\" # pop into tclsh before swapping the return char just to be safe -- \\r or \\n should both be # fine for up to here but who knows... :) self.conn.acquire_priv(desired_priv=\"tclsh\") self.conn.comms_return_char = tcl_comms_return_char config_result = self.conn.send_config(config=config, privilege_level=\"tclsh\") # reset the return char to the \"normal\" one and drop into whatever is the \"default\" priv self.conn.comms_return_char = original_return_char self.conn.acquire_priv(desired_priv=self.conn.default_desired_privilege_level) return self._post_load_config( response=response, scrapli_responses=[config_result], ) def abort_config(self) -> ScrapliCfgResponse: response = self._pre_abort_config( session_or_config_file=bool(self.candidate_config_filename) ) abort_result = self._delete_candidate_config() self._reset_config_session() return self._post_abort_config(response=response, scrapli_responses=[abort_result]) def commit_config(self, source: str = \"running\") -> ScrapliCfgResponse: scrapli_responses = [] response = self._pre_commit_config( source=source, session_or_config_file=bool(self.candidate_config_filename) ) if self._replace is True: replace_command = ( f\"configure replace {self.filesystem}{self.candidate_config_filename} force\" ) commit_result = self.conn.send_command(command=replace_command) else: file_prompt_mode = self._determine_file_prompt_mode() if file_prompt_mode == FilePromptMode.ALERT: merge_events = [ ( f\"copy {self.filesystem}{self.candidate_config_filename} running-config\", \"Destination filename\", ), (\"\", \"\"), ] elif file_prompt_mode == FilePromptMode.NOISY: merge_events = [ ( f\"copy {self.filesystem}{self.candidate_config_filename} running-config\", \"Source filename\", ), ( \"\", \"Destination filename\", ), (\"\", \"\"), ] else: merge_events = [ (f\"copy {self.filesystem}{self.candidate_config_filename} running-config\", \"\") ] commit_result = self.conn.send_interactive(interact_events=merge_events) scrapli_responses.append(commit_result) save_config_result = self.conn.send_command(command=\"copy running-config startup-config\") scrapli_responses.append(save_config_result) if self.cleanup_post_commit: cleanup_result = self._delete_candidate_config() scrapli_responses.append(cleanup_result) self._reset_config_session() return self._post_load_config( response=response, scrapli_responses=scrapli_responses, ) def diff_config(self, source: str = \"running\") -> ScrapliCfgDiffResponse: scrapli_responses = [] device_diff = \"\" source_config = \"\" diff_response = self._pre_diff_config( source=source, session_or_config_file=bool(self.candidate_config_filename) ) try: diff_result = self.conn.send_command(command=self._get_diff_command(source=source)) scrapli_responses.append(diff_response) if diff_result.failed: msg = \"failed generating diff for config session\" self.logger.critical(msg) raise DiffConfigError(msg) device_diff = diff_result.result source_config_result = self.get_config(source=source) source_config = source_config_result.result if source_config_result.scrapli_responses: scrapli_responses.extend(source_config_result.scrapli_responses) if source_config_result.failed: msg = \"failed fetching source config for diff comparison\" self.logger.critical(msg) raise DiffConfigError(msg) except DiffConfigError: pass source_config, candidate_config = self._normalize_source_candidate_configs( source_config=source_config ) return self._post_diff_config( diff_response=diff_response, scrapli_responses=scrapli_responses, source_config=source_config, candidate_config=candidate_config, device_diff=device_diff, )","title":"Module scrapli_cfg.platform.core.cisco_iosxe.sync_platform"},{"location":"api_docs/platform/core/cisco_iosxe/sync_platform/#functions","text":"","title":"Functions"},{"location":"api_docs/platform/core/cisco_iosxe/sync_platform/#iosxe_on_open","text":"iosxe_on_open(cls: scrapli_cfg.platform.base.sync_platform.ScrapliCfgPlatform) \u2011> NoneType Scrapli CFG IOSXE On open Disable console logging, perhaps more things in the future! Args: cls: ScrapliCfg object Returns: None Raises: N/A","title":"iosxe_on_open"},{"location":"api_docs/platform/core/cisco_iosxe/sync_platform/#classes","text":"","title":"Classes"},{"location":"api_docs/platform/core/cisco_iosxe/sync_platform/#scraplicfgiosxe","text":"Helper class that provides a standard way to create an ABC using inheritance. Scrapli Config base class Args: conn: scrapli connection to use config_sources: list of config sources on_open: async callable to run at connection open Returns: None Raises: N/A Expand source code class ScrapliCfgIOSXE(ScrapliCfgPlatform, ScrapliCfgIOSXEBase): def __init__( self, conn: NetworkDriver, config_sources: Optional[List[str]] = None, on_open: Optional[Callable[..., Any]] = None, filesystem: str = \"flash:\", cleanup_post_commit: bool = True, ) -> None: if config_sources is None: config_sources = CONFIG_SOURCES if on_open is None: on_open = iosxe_on_open super().__init__(conn=conn, config_sources=config_sources, on_open=on_open) self.filesystem = filesystem self._filesystem_space_available_buffer_perc = 10 self._replace = False self.candidate_config_filename = \"\" self.cleanup_post_commit = cleanup_post_commit self._get_version_command = \"show version | i Version\" def _get_filesystem_space_available(self) -> int: \"\"\" Abort a configuration -- discards any loaded config Args: N/A Returns: None Raises: FailedToDetermineDeviceState: if unable to fetch file filesystem bytes available \"\"\" filesystem_size_result = self.conn.send_command(command=f\"dir {self.filesystem} | i bytes\") if filesystem_size_result.failed: raise FailedToDetermineDeviceState(\"failed to determine space available on filesystem\") return self._post_get_filesystem_space_available(output=filesystem_size_result.result) def _determine_file_prompt_mode(self) -> FilePromptMode: \"\"\" Determine the device file prompt mode Args: N/A Returns: FilePromptMode: enum representing file prompt mode Raises: FailedToDetermineDeviceState: if unable to fetch file prompt mode \"\"\" file_prompt_mode_result = self.conn.send_command(command=\"show run | i file prompt\") if file_prompt_mode_result.failed: raise FailedToDetermineDeviceState(\"failed to determine file prompt mode\") return self._post_determine_file_prompt_mode(output=file_prompt_mode_result.result) def _delete_candidate_config(self) -> Response: \"\"\" Delete candidate config from the filesystem Args: N/A Returns: Response: response from deleting the candidate config Raises: N/A \"\"\" # have to check again because the candidate config may have changed this! file_prompt_mode = self._determine_file_prompt_mode() if file_prompt_mode in (FilePromptMode.ALERT, FilePromptMode.NOISY): delete_events = [ ( f\"delete {self.filesystem}{self.candidate_config_filename}\", \"Delete filename\", ), ( \"\", \"[confirm]\", ), (\"\", \"\"), ] else: delete_events = [ (f\"delete {self.filesystem}{self.candidate_config_filename}\", \"[confirm]\"), (\"\", \"\"), ] delete_result = self.conn.send_interactive(interact_events=delete_events) return delete_result def get_config(self, source: str = \"running\") -> ScrapliCfgResponse: response = self._pre_get_config(source=source) config_result = self.conn.send_command(command=self._get_config_command(source=source)) return self._post_get_config( response=response, source=source, scrapli_responses=[config_result], result=config_result.result, ) def load_config(self, config: str, replace: bool = False, **kwargs: Any) -> ScrapliCfgResponse: \"\"\" Load configuration to a device Supported kwargs: N/A Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for iosxe supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" response = self._pre_load_config(config=config) config = self._prepare_load_config(config=config, replace=replace) filesystem_bytes_available = self._get_filesystem_space_available() self._space_available(filesystem_bytes_available=filesystem_bytes_available) # when in tcl command mode or whatever it is, tcl wants \\r for return char, so stash the # original return char and sub in \\r for a bit original_return_char = self.conn.comms_return_char tcl_comms_return_char = \"\\r\" # pop into tclsh before swapping the return char just to be safe -- \\r or \\n should both be # fine for up to here but who knows... :) self.conn.acquire_priv(desired_priv=\"tclsh\") self.conn.comms_return_char = tcl_comms_return_char config_result = self.conn.send_config(config=config, privilege_level=\"tclsh\") # reset the return char to the \"normal\" one and drop into whatever is the \"default\" priv self.conn.comms_return_char = original_return_char self.conn.acquire_priv(desired_priv=self.conn.default_desired_privilege_level) return self._post_load_config( response=response, scrapli_responses=[config_result], ) def abort_config(self) -> ScrapliCfgResponse: response = self._pre_abort_config( session_or_config_file=bool(self.candidate_config_filename) ) abort_result = self._delete_candidate_config() self._reset_config_session() return self._post_abort_config(response=response, scrapli_responses=[abort_result]) def commit_config(self, source: str = \"running\") -> ScrapliCfgResponse: scrapli_responses = [] response = self._pre_commit_config( source=source, session_or_config_file=bool(self.candidate_config_filename) ) if self._replace is True: replace_command = ( f\"configure replace {self.filesystem}{self.candidate_config_filename} force\" ) commit_result = self.conn.send_command(command=replace_command) else: file_prompt_mode = self._determine_file_prompt_mode() if file_prompt_mode == FilePromptMode.ALERT: merge_events = [ ( f\"copy {self.filesystem}{self.candidate_config_filename} running-config\", \"Destination filename\", ), (\"\", \"\"), ] elif file_prompt_mode == FilePromptMode.NOISY: merge_events = [ ( f\"copy {self.filesystem}{self.candidate_config_filename} running-config\", \"Source filename\", ), ( \"\", \"Destination filename\", ), (\"\", \"\"), ] else: merge_events = [ (f\"copy {self.filesystem}{self.candidate_config_filename} running-config\", \"\") ] commit_result = self.conn.send_interactive(interact_events=merge_events) scrapli_responses.append(commit_result) save_config_result = self.conn.send_command(command=\"copy running-config startup-config\") scrapli_responses.append(save_config_result) if self.cleanup_post_commit: cleanup_result = self._delete_candidate_config() scrapli_responses.append(cleanup_result) self._reset_config_session() return self._post_load_config( response=response, scrapli_responses=scrapli_responses, ) def diff_config(self, source: str = \"running\") -> ScrapliCfgDiffResponse: scrapli_responses = [] device_diff = \"\" source_config = \"\" diff_response = self._pre_diff_config( source=source, session_or_config_file=bool(self.candidate_config_filename) ) try: diff_result = self.conn.send_command(command=self._get_diff_command(source=source)) scrapli_responses.append(diff_response) if diff_result.failed: msg = \"failed generating diff for config session\" self.logger.critical(msg) raise DiffConfigError(msg) device_diff = diff_result.result source_config_result = self.get_config(source=source) source_config = source_config_result.result if source_config_result.scrapli_responses: scrapli_responses.extend(source_config_result.scrapli_responses) if source_config_result.failed: msg = \"failed fetching source config for diff comparison\" self.logger.critical(msg) raise DiffConfigError(msg) except DiffConfigError: pass source_config, candidate_config = self._normalize_source_candidate_configs( source_config=source_config ) return self._post_diff_config( diff_response=diff_response, scrapli_responses=scrapli_responses, source_config=source_config, candidate_config=candidate_config, device_diff=device_diff, )","title":"ScrapliCfgIOSXE"},{"location":"api_docs/platform/core/cisco_iosxe/sync_platform/#ancestors-in-mro","text":"scrapli_cfg.platform.base.sync_platform.ScrapliCfgPlatform abc.ABC scrapli_cfg.platform.base.base_platform.ScrapliCfgBase scrapli_cfg.platform.core.cisco_iosxe.base_platform.ScrapliCfgIOSXEBase","title":"Ancestors (in MRO)"},{"location":"api_docs/platform/core/cisco_iosxe/sync_platform/#class-variables","text":"conn: Union[scrapli.driver.network.sync_driver.NetworkDriver, scrapli.driver.network.async_driver.AsyncNetworkDriver]","title":"Class variables"},{"location":"api_docs/platform/core/cisco_iosxe/sync_platform/#methods","text":"","title":"Methods"},{"location":"api_docs/platform/core/cisco_iosxe/sync_platform/#load_config","text":"load_config(self, config: str, replace: bool = False, **kwargs: Any) \u2011> scrapli_cfg.response.ScrapliCfgResponse Load configuration to a device Supported kwargs: N/A Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for iosxe supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A","title":"load_config"},{"location":"api_docs/platform/core/cisco_iosxe/types/","text":"window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting()) Module scrapli_cfg.platform.core.cisco_iosxe.types \u00b6 scrapli_cfg.platform.core.cisco_iosxe.types Expand source code \"\"\"scrapli_cfg.platform.core.cisco_iosxe.types\"\"\" from enum import Enum class FilePromptMode(Enum): \"\"\"Enum representing file prompt modes\"\"\" NOISY = \"noisy\" ALERT = \"alert\" QUIET = \"quiet\" Classes \u00b6 FilePromptMode \u00b6 Enum representing file prompt modes Expand source code class FilePromptMode(Enum): \"\"\"Enum representing file prompt modes\"\"\" NOISY = \"noisy\" ALERT = \"alert\" QUIET = \"quiet\" Ancestors (in MRO) \u00b6 enum.Enum Class variables \u00b6 ALERT NOISY QUIET","title":"Types"},{"location":"api_docs/platform/core/cisco_iosxe/types/#module-scrapli_cfgplatformcorecisco_iosxetypes","text":"scrapli_cfg.platform.core.cisco_iosxe.types Expand source code \"\"\"scrapli_cfg.platform.core.cisco_iosxe.types\"\"\" from enum import Enum class FilePromptMode(Enum): \"\"\"Enum representing file prompt modes\"\"\" NOISY = \"noisy\" ALERT = \"alert\" QUIET = \"quiet\"","title":"Module scrapli_cfg.platform.core.cisco_iosxe.types"},{"location":"api_docs/platform/core/cisco_iosxe/types/#classes","text":"","title":"Classes"},{"location":"api_docs/platform/core/cisco_iosxe/types/#filepromptmode","text":"Enum representing file prompt modes Expand source code class FilePromptMode(Enum): \"\"\"Enum representing file prompt modes\"\"\" NOISY = \"noisy\" ALERT = \"alert\" QUIET = \"quiet\"","title":"FilePromptMode"},{"location":"api_docs/platform/core/cisco_iosxe/types/#ancestors-in-mro","text":"enum.Enum","title":"Ancestors (in MRO)"},{"location":"api_docs/platform/core/cisco_iosxe/types/#class-variables","text":"ALERT NOISY QUIET","title":"Class variables"},{"location":"api_docs/platform/core/cisco_iosxr/async_platform/","text":"window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting()) Module scrapli_cfg.platform.core.cisco_iosxr.async_platform \u00b6 scrapli_cfg.platform.core.cisco_iosxr.async_platform Expand source code \"\"\"scrapli_cfg.platform.core.cisco_iosxr.async_platform\"\"\" from typing import Any, Callable, List, Optional from scrapli.driver import AsyncNetworkDriver from scrapli_cfg.diff import ScrapliCfgDiffResponse from scrapli_cfg.exceptions import DiffConfigError, LoadConfigError from scrapli_cfg.platform.base.async_platform import AsyncScrapliCfgPlatform from scrapli_cfg.platform.core.cisco_iosxr.base_platform import CONFIG_SOURCES, ScrapliCfgIOSXRBase from scrapli_cfg.response import ScrapliCfgResponse async def async_iosxr_on_open(cls: AsyncScrapliCfgPlatform) -> None: \"\"\" Scrapli CFG IOSXR On open Disable console logging, perhaps more things in the future! Args: cls: ScrapliCfg object Returns: None Raises: N/A \"\"\" await cls.conn.send_configs(configs=[\"no logging console\", \"commit\"]) class AsyncScrapliCfgIOSXR(AsyncScrapliCfgPlatform, ScrapliCfgIOSXRBase): def __init__( self, conn: AsyncNetworkDriver, config_sources: Optional[List[str]] = None, on_open: Optional[Callable[..., Any]] = None, ) -> None: if config_sources is None: config_sources = CONFIG_SOURCES if on_open is None: on_open = async_iosxr_on_open super().__init__(conn=conn, config_sources=config_sources, on_open=on_open) self._replace = False self._in_configuration_session = False self._config_privilege_level = \"configuration\" self._get_version_command = \"show version | i Version\" async def get_config(self, source: str = \"running\") -> ScrapliCfgResponse: response = self._pre_get_config(source=source) if not self._in_configuration_session: config_result = await self.conn.send_command(command=\"show running-config\") else: config_result = await self.conn.send_config( config=\"show running-config\", privilege_level=self._config_privilege_level ) return self._post_get_config( response=response, source=source, scrapli_responses=[config_result], result=config_result.result, ) async def load_config( self, config: str, replace: bool = False, **kwargs: Any ) -> ScrapliCfgResponse: \"\"\" Load configuration to a device Supported kwargs: exclusive: True/False use `configure exclusive` mode Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for iosxr supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" scrapli_responses = [] response = self._pre_load_config(config=config) exclusive = kwargs.get(\"exclusive\", False) config, eager_config = self._prepare_load_config_session_and_payload( config=config, replace=replace, exclusive=exclusive ) try: config_result = await self.conn.send_config( config=config, privilege_level=self._config_privilege_level ) scrapli_responses.append(config_result) if config_result.failed: msg = \"failed to load the candidate config into the config session\" self.logger.critical(msg) raise LoadConfigError(msg) # eager cuz banners and such; perhaps if no banner/macro we can disable eager though.... if eager_config: eager_config_result = await self.conn.send_config( config=eager_config, privilege_level=self._config_privilege_level, eager=True ) scrapli_responses.append(eager_config_result) if eager_config_result.failed: msg = \"failed to load the candidate config into the config session\" self.logger.critical(msg) raise LoadConfigError(msg) except LoadConfigError: pass return self._post_load_config( response=response, scrapli_responses=scrapli_responses, ) async def abort_config(self) -> ScrapliCfgResponse: response = self._pre_abort_config(session_or_config_file=self._in_configuration_session) await self.conn._abort_config() # pylint: disable=W0212 self._reset_config_session() return self._post_abort_config(response=response, scrapli_responses=[]) async def commit_config(self, source: str = \"running\") -> ScrapliCfgResponse: response = self._pre_commit_config( source=source, session_or_config_file=self._in_configuration_session ) commit_result = await self.conn.send_config(config=\"commit\") self._reset_config_session() return self._post_commit_config(response=response, scrapli_responses=[commit_result]) async def diff_config(self, source: str = \"running\") -> ScrapliCfgDiffResponse: scrapli_responses = [] device_diff = \"\" source_config = \"\" diff_response = self._pre_diff_config( source=source, session_or_config_file=self._in_configuration_session ) try: diff_result = await self.conn.send_config( config=self._get_diff_command(), privilege_level=self._config_privilege_level ) scrapli_responses.append(diff_response) if diff_result.failed: msg = \"failed generating diff for config session\" self.logger.critical(msg) raise DiffConfigError(msg) device_diff = diff_result.result source_config_result = await self.get_config(source=source) source_config = source_config_result.result if source_config_result.scrapli_responses: scrapli_responses.extend(source_config_result.scrapli_responses) if source_config_result.failed: msg = \"failed fetching source config for diff comparison\" self.logger.critical(msg) raise DiffConfigError(msg) except DiffConfigError: pass source_config, candidate_config = self._normalize_source_candidate_configs( source_config=source_config ) return self._post_diff_config( diff_response=diff_response, scrapli_responses=scrapli_responses, source_config=source_config, candidate_config=candidate_config, device_diff=device_diff, ) Functions \u00b6 async_iosxr_on_open \u00b6 async_iosxr_on_open(cls: scrapli_cfg.platform.base.async_platform.AsyncScrapliCfgPlatform) \u2011> NoneType Scrapli CFG IOSXR On open Disable console logging, perhaps more things in the future! Args: cls: ScrapliCfg object Returns: None Raises: N/A Classes \u00b6 AsyncScrapliCfgIOSXR \u00b6 Helper class that provides a standard way to create an ABC using inheritance. Scrapli Config async base class Args: conn: scrapli connection to use config_sources: list of config sources on_open: async callable to run at connection open Returns: None Raises: N/A Expand source code class AsyncScrapliCfgIOSXR(AsyncScrapliCfgPlatform, ScrapliCfgIOSXRBase): def __init__( self, conn: AsyncNetworkDriver, config_sources: Optional[List[str]] = None, on_open: Optional[Callable[..., Any]] = None, ) -> None: if config_sources is None: config_sources = CONFIG_SOURCES if on_open is None: on_open = async_iosxr_on_open super().__init__(conn=conn, config_sources=config_sources, on_open=on_open) self._replace = False self._in_configuration_session = False self._config_privilege_level = \"configuration\" self._get_version_command = \"show version | i Version\" async def get_config(self, source: str = \"running\") -> ScrapliCfgResponse: response = self._pre_get_config(source=source) if not self._in_configuration_session: config_result = await self.conn.send_command(command=\"show running-config\") else: config_result = await self.conn.send_config( config=\"show running-config\", privilege_level=self._config_privilege_level ) return self._post_get_config( response=response, source=source, scrapli_responses=[config_result], result=config_result.result, ) async def load_config( self, config: str, replace: bool = False, **kwargs: Any ) -> ScrapliCfgResponse: \"\"\" Load configuration to a device Supported kwargs: exclusive: True/False use `configure exclusive` mode Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for iosxr supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" scrapli_responses = [] response = self._pre_load_config(config=config) exclusive = kwargs.get(\"exclusive\", False) config, eager_config = self._prepare_load_config_session_and_payload( config=config, replace=replace, exclusive=exclusive ) try: config_result = await self.conn.send_config( config=config, privilege_level=self._config_privilege_level ) scrapli_responses.append(config_result) if config_result.failed: msg = \"failed to load the candidate config into the config session\" self.logger.critical(msg) raise LoadConfigError(msg) # eager cuz banners and such; perhaps if no banner/macro we can disable eager though.... if eager_config: eager_config_result = await self.conn.send_config( config=eager_config, privilege_level=self._config_privilege_level, eager=True ) scrapli_responses.append(eager_config_result) if eager_config_result.failed: msg = \"failed to load the candidate config into the config session\" self.logger.critical(msg) raise LoadConfigError(msg) except LoadConfigError: pass return self._post_load_config( response=response, scrapli_responses=scrapli_responses, ) async def abort_config(self) -> ScrapliCfgResponse: response = self._pre_abort_config(session_or_config_file=self._in_configuration_session) await self.conn._abort_config() # pylint: disable=W0212 self._reset_config_session() return self._post_abort_config(response=response, scrapli_responses=[]) async def commit_config(self, source: str = \"running\") -> ScrapliCfgResponse: response = self._pre_commit_config( source=source, session_or_config_file=self._in_configuration_session ) commit_result = await self.conn.send_config(config=\"commit\") self._reset_config_session() return self._post_commit_config(response=response, scrapli_responses=[commit_result]) async def diff_config(self, source: str = \"running\") -> ScrapliCfgDiffResponse: scrapli_responses = [] device_diff = \"\" source_config = \"\" diff_response = self._pre_diff_config( source=source, session_or_config_file=self._in_configuration_session ) try: diff_result = await self.conn.send_config( config=self._get_diff_command(), privilege_level=self._config_privilege_level ) scrapli_responses.append(diff_response) if diff_result.failed: msg = \"failed generating diff for config session\" self.logger.critical(msg) raise DiffConfigError(msg) device_diff = diff_result.result source_config_result = await self.get_config(source=source) source_config = source_config_result.result if source_config_result.scrapli_responses: scrapli_responses.extend(source_config_result.scrapli_responses) if source_config_result.failed: msg = \"failed fetching source config for diff comparison\" self.logger.critical(msg) raise DiffConfigError(msg) except DiffConfigError: pass source_config, candidate_config = self._normalize_source_candidate_configs( source_config=source_config ) return self._post_diff_config( diff_response=diff_response, scrapli_responses=scrapli_responses, source_config=source_config, candidate_config=candidate_config, device_diff=device_diff, ) Ancestors (in MRO) \u00b6 scrapli_cfg.platform.base.async_platform.AsyncScrapliCfgPlatform abc.ABC scrapli_cfg.platform.base.base_platform.ScrapliCfgBase scrapli_cfg.platform.core.cisco_iosxr.base_platform.ScrapliCfgIOSXRBase Class variables \u00b6 conn: Union[scrapli.driver.network.sync_driver.NetworkDriver, scrapli.driver.network.async_driver.AsyncNetworkDriver] Methods \u00b6 load_config \u00b6 load_config(self, config: str, replace: bool = False, **kwargs: Any) \u2011> scrapli_cfg.response.ScrapliCfgResponse Load configuration to a device Supported kwargs: exclusive: True/False use `configure exclusive` mode Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for iosxr supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A","title":"Async Platform"},{"location":"api_docs/platform/core/cisco_iosxr/async_platform/#module-scrapli_cfgplatformcorecisco_iosxrasync_platform","text":"scrapli_cfg.platform.core.cisco_iosxr.async_platform Expand source code \"\"\"scrapli_cfg.platform.core.cisco_iosxr.async_platform\"\"\" from typing import Any, Callable, List, Optional from scrapli.driver import AsyncNetworkDriver from scrapli_cfg.diff import ScrapliCfgDiffResponse from scrapli_cfg.exceptions import DiffConfigError, LoadConfigError from scrapli_cfg.platform.base.async_platform import AsyncScrapliCfgPlatform from scrapli_cfg.platform.core.cisco_iosxr.base_platform import CONFIG_SOURCES, ScrapliCfgIOSXRBase from scrapli_cfg.response import ScrapliCfgResponse async def async_iosxr_on_open(cls: AsyncScrapliCfgPlatform) -> None: \"\"\" Scrapli CFG IOSXR On open Disable console logging, perhaps more things in the future! Args: cls: ScrapliCfg object Returns: None Raises: N/A \"\"\" await cls.conn.send_configs(configs=[\"no logging console\", \"commit\"]) class AsyncScrapliCfgIOSXR(AsyncScrapliCfgPlatform, ScrapliCfgIOSXRBase): def __init__( self, conn: AsyncNetworkDriver, config_sources: Optional[List[str]] = None, on_open: Optional[Callable[..., Any]] = None, ) -> None: if config_sources is None: config_sources = CONFIG_SOURCES if on_open is None: on_open = async_iosxr_on_open super().__init__(conn=conn, config_sources=config_sources, on_open=on_open) self._replace = False self._in_configuration_session = False self._config_privilege_level = \"configuration\" self._get_version_command = \"show version | i Version\" async def get_config(self, source: str = \"running\") -> ScrapliCfgResponse: response = self._pre_get_config(source=source) if not self._in_configuration_session: config_result = await self.conn.send_command(command=\"show running-config\") else: config_result = await self.conn.send_config( config=\"show running-config\", privilege_level=self._config_privilege_level ) return self._post_get_config( response=response, source=source, scrapli_responses=[config_result], result=config_result.result, ) async def load_config( self, config: str, replace: bool = False, **kwargs: Any ) -> ScrapliCfgResponse: \"\"\" Load configuration to a device Supported kwargs: exclusive: True/False use `configure exclusive` mode Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for iosxr supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" scrapli_responses = [] response = self._pre_load_config(config=config) exclusive = kwargs.get(\"exclusive\", False) config, eager_config = self._prepare_load_config_session_and_payload( config=config, replace=replace, exclusive=exclusive ) try: config_result = await self.conn.send_config( config=config, privilege_level=self._config_privilege_level ) scrapli_responses.append(config_result) if config_result.failed: msg = \"failed to load the candidate config into the config session\" self.logger.critical(msg) raise LoadConfigError(msg) # eager cuz banners and such; perhaps if no banner/macro we can disable eager though.... if eager_config: eager_config_result = await self.conn.send_config( config=eager_config, privilege_level=self._config_privilege_level, eager=True ) scrapli_responses.append(eager_config_result) if eager_config_result.failed: msg = \"failed to load the candidate config into the config session\" self.logger.critical(msg) raise LoadConfigError(msg) except LoadConfigError: pass return self._post_load_config( response=response, scrapli_responses=scrapli_responses, ) async def abort_config(self) -> ScrapliCfgResponse: response = self._pre_abort_config(session_or_config_file=self._in_configuration_session) await self.conn._abort_config() # pylint: disable=W0212 self._reset_config_session() return self._post_abort_config(response=response, scrapli_responses=[]) async def commit_config(self, source: str = \"running\") -> ScrapliCfgResponse: response = self._pre_commit_config( source=source, session_or_config_file=self._in_configuration_session ) commit_result = await self.conn.send_config(config=\"commit\") self._reset_config_session() return self._post_commit_config(response=response, scrapli_responses=[commit_result]) async def diff_config(self, source: str = \"running\") -> ScrapliCfgDiffResponse: scrapli_responses = [] device_diff = \"\" source_config = \"\" diff_response = self._pre_diff_config( source=source, session_or_config_file=self._in_configuration_session ) try: diff_result = await self.conn.send_config( config=self._get_diff_command(), privilege_level=self._config_privilege_level ) scrapli_responses.append(diff_response) if diff_result.failed: msg = \"failed generating diff for config session\" self.logger.critical(msg) raise DiffConfigError(msg) device_diff = diff_result.result source_config_result = await self.get_config(source=source) source_config = source_config_result.result if source_config_result.scrapli_responses: scrapli_responses.extend(source_config_result.scrapli_responses) if source_config_result.failed: msg = \"failed fetching source config for diff comparison\" self.logger.critical(msg) raise DiffConfigError(msg) except DiffConfigError: pass source_config, candidate_config = self._normalize_source_candidate_configs( source_config=source_config ) return self._post_diff_config( diff_response=diff_response, scrapli_responses=scrapli_responses, source_config=source_config, candidate_config=candidate_config, device_diff=device_diff, )","title":"Module scrapli_cfg.platform.core.cisco_iosxr.async_platform"},{"location":"api_docs/platform/core/cisco_iosxr/async_platform/#functions","text":"","title":"Functions"},{"location":"api_docs/platform/core/cisco_iosxr/async_platform/#async_iosxr_on_open","text":"async_iosxr_on_open(cls: scrapli_cfg.platform.base.async_platform.AsyncScrapliCfgPlatform) \u2011> NoneType Scrapli CFG IOSXR On open Disable console logging, perhaps more things in the future! Args: cls: ScrapliCfg object Returns: None Raises: N/A","title":"async_iosxr_on_open"},{"location":"api_docs/platform/core/cisco_iosxr/async_platform/#classes","text":"","title":"Classes"},{"location":"api_docs/platform/core/cisco_iosxr/async_platform/#asyncscraplicfgiosxr","text":"Helper class that provides a standard way to create an ABC using inheritance. Scrapli Config async base class Args: conn: scrapli connection to use config_sources: list of config sources on_open: async callable to run at connection open Returns: None Raises: N/A Expand source code class AsyncScrapliCfgIOSXR(AsyncScrapliCfgPlatform, ScrapliCfgIOSXRBase): def __init__( self, conn: AsyncNetworkDriver, config_sources: Optional[List[str]] = None, on_open: Optional[Callable[..., Any]] = None, ) -> None: if config_sources is None: config_sources = CONFIG_SOURCES if on_open is None: on_open = async_iosxr_on_open super().__init__(conn=conn, config_sources=config_sources, on_open=on_open) self._replace = False self._in_configuration_session = False self._config_privilege_level = \"configuration\" self._get_version_command = \"show version | i Version\" async def get_config(self, source: str = \"running\") -> ScrapliCfgResponse: response = self._pre_get_config(source=source) if not self._in_configuration_session: config_result = await self.conn.send_command(command=\"show running-config\") else: config_result = await self.conn.send_config( config=\"show running-config\", privilege_level=self._config_privilege_level ) return self._post_get_config( response=response, source=source, scrapli_responses=[config_result], result=config_result.result, ) async def load_config( self, config: str, replace: bool = False, **kwargs: Any ) -> ScrapliCfgResponse: \"\"\" Load configuration to a device Supported kwargs: exclusive: True/False use `configure exclusive` mode Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for iosxr supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" scrapli_responses = [] response = self._pre_load_config(config=config) exclusive = kwargs.get(\"exclusive\", False) config, eager_config = self._prepare_load_config_session_and_payload( config=config, replace=replace, exclusive=exclusive ) try: config_result = await self.conn.send_config( config=config, privilege_level=self._config_privilege_level ) scrapli_responses.append(config_result) if config_result.failed: msg = \"failed to load the candidate config into the config session\" self.logger.critical(msg) raise LoadConfigError(msg) # eager cuz banners and such; perhaps if no banner/macro we can disable eager though.... if eager_config: eager_config_result = await self.conn.send_config( config=eager_config, privilege_level=self._config_privilege_level, eager=True ) scrapli_responses.append(eager_config_result) if eager_config_result.failed: msg = \"failed to load the candidate config into the config session\" self.logger.critical(msg) raise LoadConfigError(msg) except LoadConfigError: pass return self._post_load_config( response=response, scrapli_responses=scrapli_responses, ) async def abort_config(self) -> ScrapliCfgResponse: response = self._pre_abort_config(session_or_config_file=self._in_configuration_session) await self.conn._abort_config() # pylint: disable=W0212 self._reset_config_session() return self._post_abort_config(response=response, scrapli_responses=[]) async def commit_config(self, source: str = \"running\") -> ScrapliCfgResponse: response = self._pre_commit_config( source=source, session_or_config_file=self._in_configuration_session ) commit_result = await self.conn.send_config(config=\"commit\") self._reset_config_session() return self._post_commit_config(response=response, scrapli_responses=[commit_result]) async def diff_config(self, source: str = \"running\") -> ScrapliCfgDiffResponse: scrapli_responses = [] device_diff = \"\" source_config = \"\" diff_response = self._pre_diff_config( source=source, session_or_config_file=self._in_configuration_session ) try: diff_result = await self.conn.send_config( config=self._get_diff_command(), privilege_level=self._config_privilege_level ) scrapli_responses.append(diff_response) if diff_result.failed: msg = \"failed generating diff for config session\" self.logger.critical(msg) raise DiffConfigError(msg) device_diff = diff_result.result source_config_result = await self.get_config(source=source) source_config = source_config_result.result if source_config_result.scrapli_responses: scrapli_responses.extend(source_config_result.scrapli_responses) if source_config_result.failed: msg = \"failed fetching source config for diff comparison\" self.logger.critical(msg) raise DiffConfigError(msg) except DiffConfigError: pass source_config, candidate_config = self._normalize_source_candidate_configs( source_config=source_config ) return self._post_diff_config( diff_response=diff_response, scrapli_responses=scrapli_responses, source_config=source_config, candidate_config=candidate_config, device_diff=device_diff, )","title":"AsyncScrapliCfgIOSXR"},{"location":"api_docs/platform/core/cisco_iosxr/async_platform/#ancestors-in-mro","text":"scrapli_cfg.platform.base.async_platform.AsyncScrapliCfgPlatform abc.ABC scrapli_cfg.platform.base.base_platform.ScrapliCfgBase scrapli_cfg.platform.core.cisco_iosxr.base_platform.ScrapliCfgIOSXRBase","title":"Ancestors (in MRO)"},{"location":"api_docs/platform/core/cisco_iosxr/async_platform/#class-variables","text":"conn: Union[scrapli.driver.network.sync_driver.NetworkDriver, scrapli.driver.network.async_driver.AsyncNetworkDriver]","title":"Class variables"},{"location":"api_docs/platform/core/cisco_iosxr/async_platform/#methods","text":"","title":"Methods"},{"location":"api_docs/platform/core/cisco_iosxr/async_platform/#load_config","text":"load_config(self, config: str, replace: bool = False, **kwargs: Any) \u2011> scrapli_cfg.response.ScrapliCfgResponse Load configuration to a device Supported kwargs: exclusive: True/False use `configure exclusive` mode Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for iosxr supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A","title":"load_config"},{"location":"api_docs/platform/core/cisco_iosxr/base_platform/","text":"window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting()) Module scrapli_cfg.platform.core.cisco_iosxr.base_platform \u00b6 scrapli_cfg.platform.core.cisco_iosxr.base_platform Expand source code \"\"\"scrapli_cfg.platform.core.cisco_iosxr.base_platform\"\"\" import re from logging import LoggerAdapter from typing import Tuple from scrapli_cfg.platform.core.cisco_iosxr.patterns import ( BANNER_PATTERN, END_PATTERN, OUTPUT_HEADER_PATTERN, VERSION_PATTERN, ) CONFIG_SOURCES = [ \"running\", ] class ScrapliCfgIOSXRBase: logger: LoggerAdapter _in_configuration_session: bool _config_privilege_level: str _replace: bool candidate_config: str @staticmethod def _parse_version(device_output: str) -> str: \"\"\" Parse version string out of device output Args: device_output: output from show version command Returns: str: device version string Raises: N/A \"\"\" version_string_search = re.search(pattern=VERSION_PATTERN, string=device_output) if not version_string_search: return \"\" version_string = version_string_search.group(0) or \"\" return version_string @staticmethod def _prepare_config_payloads(config: str) -> Tuple[str, str]: \"\"\" Prepare a configuration so it can be nicely sent to the device via scrapli Args: config: configuration to prep Returns: tuple: tuple of \"normal\" config lines and \"eager\" config lines Raises: N/A \"\"\" # remove building config lines config = re.sub(pattern=OUTPUT_HEADER_PATTERN, repl=\"!\", string=config) # remove \"end\" at the end of config if present - if its present it will drop scrapli out # of the config session which we do not want config = re.sub(pattern=END_PATTERN, repl=\"!\", string=config) # find all sections that need to be \"eagerly\" sent eager_config = re.findall(pattern=BANNER_PATTERN, string=config) for eager_section in eager_config: config = config.replace(eager_section, \"!\") joined_eager_config = \"\\n\".join(eager_config) return config, joined_eager_config def _prepare_load_config_session_and_payload( self, config: str, replace: bool, exclusive: bool ) -> Tuple[str, str]: \"\"\" Handle pre \"load_config\" operations for parity between sync and async Args: config: candidate config to load replace: True/False replace the configuration; passed here so it can be set at the class level as we need to stay in config mode and we need to know if we are doing a merge or a replace when we go to diff things exclusive: True/False use exclusive config mode Returns: tuple: tuple containing \"normal\" config elements to send to the device and \"eager\" mode config elements to send to the device (things like banners/macro that require scrapli \"eager=True\") Raises: N/A \"\"\" self.candidate_config = config config, eager_config = self._prepare_config_payloads(config=config) self._in_configuration_session = True self._config_privilege_level = \"configuration_exclusive\" if exclusive else \"configuration\" self._replace = replace return config, eager_config def _reset_config_session(self) -> None: \"\"\" Reset config session info Resets the candidate config and config session name attributes -- when these are \"empty\" we know there is no current config session Args: N/A Returns: None Raises: N/A \"\"\" self.logger.debug(\"resetting candidate config and config session name\") self.candidate_config = \"\" self._in_configuration_session = False self._config_privilege_level = \"configuration\" def _get_diff_command(self) -> str: \"\"\" Generate diff command based on source to diff and filesystem/candidate config name Args: N/A Returns: str: command to use to diff the configuration Raises: N/A \"\"\" if self._replace: return \"show configuration changes diff\" return \"show commit changes diff\" def _normalize_source_candidate_configs(self, source_config: str) -> Tuple[str, str]: \"\"\" Normalize candidate config and source config so that we can easily diff them Args: source_config: current config of the source config store Returns: ScrapliCfgDiff: scrapli cfg diff object Raises: N/A \"\"\" self.logger.debug(\"normalizing source and candidate configs for diff object\") # remove any of the leading timestamp/building config/xr version/last change lines in # both the source and candidate configs so they dont need to be compared source_config = re.sub(pattern=OUTPUT_HEADER_PATTERN, string=source_config, repl=\"\") source_config = \"\\n\".join(line for line in source_config.splitlines() if line) candidate_config = re.sub( pattern=OUTPUT_HEADER_PATTERN, string=self.candidate_config, repl=\"\" ) candidate_config = \"\\n\".join(line for line in candidate_config.splitlines() if line) return source_config, candidate_config Classes \u00b6 ScrapliCfgIOSXRBase \u00b6 Expand source code class ScrapliCfgIOSXRBase: logger: LoggerAdapter _in_configuration_session: bool _config_privilege_level: str _replace: bool candidate_config: str @staticmethod def _parse_version(device_output: str) -> str: \"\"\" Parse version string out of device output Args: device_output: output from show version command Returns: str: device version string Raises: N/A \"\"\" version_string_search = re.search(pattern=VERSION_PATTERN, string=device_output) if not version_string_search: return \"\" version_string = version_string_search.group(0) or \"\" return version_string @staticmethod def _prepare_config_payloads(config: str) -> Tuple[str, str]: \"\"\" Prepare a configuration so it can be nicely sent to the device via scrapli Args: config: configuration to prep Returns: tuple: tuple of \"normal\" config lines and \"eager\" config lines Raises: N/A \"\"\" # remove building config lines config = re.sub(pattern=OUTPUT_HEADER_PATTERN, repl=\"!\", string=config) # remove \"end\" at the end of config if present - if its present it will drop scrapli out # of the config session which we do not want config = re.sub(pattern=END_PATTERN, repl=\"!\", string=config) # find all sections that need to be \"eagerly\" sent eager_config = re.findall(pattern=BANNER_PATTERN, string=config) for eager_section in eager_config: config = config.replace(eager_section, \"!\") joined_eager_config = \"\\n\".join(eager_config) return config, joined_eager_config def _prepare_load_config_session_and_payload( self, config: str, replace: bool, exclusive: bool ) -> Tuple[str, str]: \"\"\" Handle pre \"load_config\" operations for parity between sync and async Args: config: candidate config to load replace: True/False replace the configuration; passed here so it can be set at the class level as we need to stay in config mode and we need to know if we are doing a merge or a replace when we go to diff things exclusive: True/False use exclusive config mode Returns: tuple: tuple containing \"normal\" config elements to send to the device and \"eager\" mode config elements to send to the device (things like banners/macro that require scrapli \"eager=True\") Raises: N/A \"\"\" self.candidate_config = config config, eager_config = self._prepare_config_payloads(config=config) self._in_configuration_session = True self._config_privilege_level = \"configuration_exclusive\" if exclusive else \"configuration\" self._replace = replace return config, eager_config def _reset_config_session(self) -> None: \"\"\" Reset config session info Resets the candidate config and config session name attributes -- when these are \"empty\" we know there is no current config session Args: N/A Returns: None Raises: N/A \"\"\" self.logger.debug(\"resetting candidate config and config session name\") self.candidate_config = \"\" self._in_configuration_session = False self._config_privilege_level = \"configuration\" def _get_diff_command(self) -> str: \"\"\" Generate diff command based on source to diff and filesystem/candidate config name Args: N/A Returns: str: command to use to diff the configuration Raises: N/A \"\"\" if self._replace: return \"show configuration changes diff\" return \"show commit changes diff\" def _normalize_source_candidate_configs(self, source_config: str) -> Tuple[str, str]: \"\"\" Normalize candidate config and source config so that we can easily diff them Args: source_config: current config of the source config store Returns: ScrapliCfgDiff: scrapli cfg diff object Raises: N/A \"\"\" self.logger.debug(\"normalizing source and candidate configs for diff object\") # remove any of the leading timestamp/building config/xr version/last change lines in # both the source and candidate configs so they dont need to be compared source_config = re.sub(pattern=OUTPUT_HEADER_PATTERN, string=source_config, repl=\"\") source_config = \"\\n\".join(line for line in source_config.splitlines() if line) candidate_config = re.sub( pattern=OUTPUT_HEADER_PATTERN, string=self.candidate_config, repl=\"\" ) candidate_config = \"\\n\".join(line for line in candidate_config.splitlines() if line) return source_config, candidate_config Descendants \u00b6 scrapli_cfg.platform.core.cisco_iosxr.async_platform.AsyncScrapliCfgIOSXR scrapli_cfg.platform.core.cisco_iosxr.sync_platform.ScrapliCfgIOSXR Class variables \u00b6 candidate_config: str logger: logging.LoggerAdapter","title":"Base platform"},{"location":"api_docs/platform/core/cisco_iosxr/base_platform/#module-scrapli_cfgplatformcorecisco_iosxrbase_platform","text":"scrapli_cfg.platform.core.cisco_iosxr.base_platform Expand source code \"\"\"scrapli_cfg.platform.core.cisco_iosxr.base_platform\"\"\" import re from logging import LoggerAdapter from typing import Tuple from scrapli_cfg.platform.core.cisco_iosxr.patterns import ( BANNER_PATTERN, END_PATTERN, OUTPUT_HEADER_PATTERN, VERSION_PATTERN, ) CONFIG_SOURCES = [ \"running\", ] class ScrapliCfgIOSXRBase: logger: LoggerAdapter _in_configuration_session: bool _config_privilege_level: str _replace: bool candidate_config: str @staticmethod def _parse_version(device_output: str) -> str: \"\"\" Parse version string out of device output Args: device_output: output from show version command Returns: str: device version string Raises: N/A \"\"\" version_string_search = re.search(pattern=VERSION_PATTERN, string=device_output) if not version_string_search: return \"\" version_string = version_string_search.group(0) or \"\" return version_string @staticmethod def _prepare_config_payloads(config: str) -> Tuple[str, str]: \"\"\" Prepare a configuration so it can be nicely sent to the device via scrapli Args: config: configuration to prep Returns: tuple: tuple of \"normal\" config lines and \"eager\" config lines Raises: N/A \"\"\" # remove building config lines config = re.sub(pattern=OUTPUT_HEADER_PATTERN, repl=\"!\", string=config) # remove \"end\" at the end of config if present - if its present it will drop scrapli out # of the config session which we do not want config = re.sub(pattern=END_PATTERN, repl=\"!\", string=config) # find all sections that need to be \"eagerly\" sent eager_config = re.findall(pattern=BANNER_PATTERN, string=config) for eager_section in eager_config: config = config.replace(eager_section, \"!\") joined_eager_config = \"\\n\".join(eager_config) return config, joined_eager_config def _prepare_load_config_session_and_payload( self, config: str, replace: bool, exclusive: bool ) -> Tuple[str, str]: \"\"\" Handle pre \"load_config\" operations for parity between sync and async Args: config: candidate config to load replace: True/False replace the configuration; passed here so it can be set at the class level as we need to stay in config mode and we need to know if we are doing a merge or a replace when we go to diff things exclusive: True/False use exclusive config mode Returns: tuple: tuple containing \"normal\" config elements to send to the device and \"eager\" mode config elements to send to the device (things like banners/macro that require scrapli \"eager=True\") Raises: N/A \"\"\" self.candidate_config = config config, eager_config = self._prepare_config_payloads(config=config) self._in_configuration_session = True self._config_privilege_level = \"configuration_exclusive\" if exclusive else \"configuration\" self._replace = replace return config, eager_config def _reset_config_session(self) -> None: \"\"\" Reset config session info Resets the candidate config and config session name attributes -- when these are \"empty\" we know there is no current config session Args: N/A Returns: None Raises: N/A \"\"\" self.logger.debug(\"resetting candidate config and config session name\") self.candidate_config = \"\" self._in_configuration_session = False self._config_privilege_level = \"configuration\" def _get_diff_command(self) -> str: \"\"\" Generate diff command based on source to diff and filesystem/candidate config name Args: N/A Returns: str: command to use to diff the configuration Raises: N/A \"\"\" if self._replace: return \"show configuration changes diff\" return \"show commit changes diff\" def _normalize_source_candidate_configs(self, source_config: str) -> Tuple[str, str]: \"\"\" Normalize candidate config and source config so that we can easily diff them Args: source_config: current config of the source config store Returns: ScrapliCfgDiff: scrapli cfg diff object Raises: N/A \"\"\" self.logger.debug(\"normalizing source and candidate configs for diff object\") # remove any of the leading timestamp/building config/xr version/last change lines in # both the source and candidate configs so they dont need to be compared source_config = re.sub(pattern=OUTPUT_HEADER_PATTERN, string=source_config, repl=\"\") source_config = \"\\n\".join(line for line in source_config.splitlines() if line) candidate_config = re.sub( pattern=OUTPUT_HEADER_PATTERN, string=self.candidate_config, repl=\"\" ) candidate_config = \"\\n\".join(line for line in candidate_config.splitlines() if line) return source_config, candidate_config","title":"Module scrapli_cfg.platform.core.cisco_iosxr.base_platform"},{"location":"api_docs/platform/core/cisco_iosxr/base_platform/#classes","text":"","title":"Classes"},{"location":"api_docs/platform/core/cisco_iosxr/base_platform/#scraplicfgiosxrbase","text":"Expand source code class ScrapliCfgIOSXRBase: logger: LoggerAdapter _in_configuration_session: bool _config_privilege_level: str _replace: bool candidate_config: str @staticmethod def _parse_version(device_output: str) -> str: \"\"\" Parse version string out of device output Args: device_output: output from show version command Returns: str: device version string Raises: N/A \"\"\" version_string_search = re.search(pattern=VERSION_PATTERN, string=device_output) if not version_string_search: return \"\" version_string = version_string_search.group(0) or \"\" return version_string @staticmethod def _prepare_config_payloads(config: str) -> Tuple[str, str]: \"\"\" Prepare a configuration so it can be nicely sent to the device via scrapli Args: config: configuration to prep Returns: tuple: tuple of \"normal\" config lines and \"eager\" config lines Raises: N/A \"\"\" # remove building config lines config = re.sub(pattern=OUTPUT_HEADER_PATTERN, repl=\"!\", string=config) # remove \"end\" at the end of config if present - if its present it will drop scrapli out # of the config session which we do not want config = re.sub(pattern=END_PATTERN, repl=\"!\", string=config) # find all sections that need to be \"eagerly\" sent eager_config = re.findall(pattern=BANNER_PATTERN, string=config) for eager_section in eager_config: config = config.replace(eager_section, \"!\") joined_eager_config = \"\\n\".join(eager_config) return config, joined_eager_config def _prepare_load_config_session_and_payload( self, config: str, replace: bool, exclusive: bool ) -> Tuple[str, str]: \"\"\" Handle pre \"load_config\" operations for parity between sync and async Args: config: candidate config to load replace: True/False replace the configuration; passed here so it can be set at the class level as we need to stay in config mode and we need to know if we are doing a merge or a replace when we go to diff things exclusive: True/False use exclusive config mode Returns: tuple: tuple containing \"normal\" config elements to send to the device and \"eager\" mode config elements to send to the device (things like banners/macro that require scrapli \"eager=True\") Raises: N/A \"\"\" self.candidate_config = config config, eager_config = self._prepare_config_payloads(config=config) self._in_configuration_session = True self._config_privilege_level = \"configuration_exclusive\" if exclusive else \"configuration\" self._replace = replace return config, eager_config def _reset_config_session(self) -> None: \"\"\" Reset config session info Resets the candidate config and config session name attributes -- when these are \"empty\" we know there is no current config session Args: N/A Returns: None Raises: N/A \"\"\" self.logger.debug(\"resetting candidate config and config session name\") self.candidate_config = \"\" self._in_configuration_session = False self._config_privilege_level = \"configuration\" def _get_diff_command(self) -> str: \"\"\" Generate diff command based on source to diff and filesystem/candidate config name Args: N/A Returns: str: command to use to diff the configuration Raises: N/A \"\"\" if self._replace: return \"show configuration changes diff\" return \"show commit changes diff\" def _normalize_source_candidate_configs(self, source_config: str) -> Tuple[str, str]: \"\"\" Normalize candidate config and source config so that we can easily diff them Args: source_config: current config of the source config store Returns: ScrapliCfgDiff: scrapli cfg diff object Raises: N/A \"\"\" self.logger.debug(\"normalizing source and candidate configs for diff object\") # remove any of the leading timestamp/building config/xr version/last change lines in # both the source and candidate configs so they dont need to be compared source_config = re.sub(pattern=OUTPUT_HEADER_PATTERN, string=source_config, repl=\"\") source_config = \"\\n\".join(line for line in source_config.splitlines() if line) candidate_config = re.sub( pattern=OUTPUT_HEADER_PATTERN, string=self.candidate_config, repl=\"\" ) candidate_config = \"\\n\".join(line for line in candidate_config.splitlines() if line) return source_config, candidate_config","title":"ScrapliCfgIOSXRBase"},{"location":"api_docs/platform/core/cisco_iosxr/base_platform/#descendants","text":"scrapli_cfg.platform.core.cisco_iosxr.async_platform.AsyncScrapliCfgIOSXR scrapli_cfg.platform.core.cisco_iosxr.sync_platform.ScrapliCfgIOSXR","title":"Descendants"},{"location":"api_docs/platform/core/cisco_iosxr/base_platform/#class-variables","text":"candidate_config: str logger: logging.LoggerAdapter","title":"Class variables"},{"location":"api_docs/platform/core/cisco_iosxr/patterns/","text":"window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting()) Module scrapli_cfg.platform.core.cisco_iosxr.patterns \u00b6 scrapli_cfg.platform.core.cisco_iosxr.patterns Expand source code \"\"\"scrapli_cfg.platform.core.cisco_iosxr.patterns\"\"\" import re VERSION_PATTERN = re.compile(pattern=r\"\\d+\\.\\d+\\.\\d+\", flags=re.I) BANNER_PATTERN = re.compile( pattern=r\"^banner\\s(?:(exec|incoming|login|motd|prompt-timeout|slip-ppp)\\s)\" r\"(?P .{1}).*\\?P=delim\", flags=re.I | re.M | re.S, ) TIMESTAMP_PATTERN = datetime_pattern = re.compile( r\"^(mon|tue|wed|thu|fri|sat|sun)\\s+\" r\"(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)\\s+\" r\"\\d+\\s+\\d+:\\d+:\\d+((\\.\\d+\\s\\w+)|\\s\\d+)$\", flags=re.M | re.I, ) BUILD_CONFIG_PATTERN = re.compile(r\"(^building configuration\\.\\.\\.$)\", flags=re.I | re.M) CONFIG_VERSION_PATTERN = re.compile(r\"(^!! ios xr.*$)\", flags=re.I | re.M) CONFIG_CHANGE_PATTERN = re.compile(r\"(^!! last config.*$)\", flags=re.I | re.M) OUTPUT_HEADER_PATTERN = re.compile( pattern=rf\"{TIMESTAMP_PATTERN.pattern}|\" rf\"{BUILD_CONFIG_PATTERN.pattern}|\" rf\"{CONFIG_VERSION_PATTERN.pattern}|\" rf\"{CONFIG_CHANGE_PATTERN.pattern}\", flags=re.I | re.M, ) END_PATTERN = re.compile(pattern=\"end$\") # pre-canned config section grabber patterns # match all ethernet interfaces w/ or w/out config items below them ETHERNET_INTERFACES = re.compile( pattern=r\"(^interface \\w+ethernet(?:\\d|\\/)+$(?:\\n^\\s{1}.*$)*\\n!\\n)+\", flags=re.I | re.M ) # match mgmteth[numbers, letters, forward slashes] interface and config items below it MANAGEMENT_ONE_INTERFACE = re.compile( pattern=r\"^^interface mgmteth(?:[a-z0-9\\/]+)(?:\\n^\\s.*$)*\\n!\", flags=re.I | re.M )","title":"Patterns"},{"location":"api_docs/platform/core/cisco_iosxr/patterns/#module-scrapli_cfgplatformcorecisco_iosxrpatterns","text":"scrapli_cfg.platform.core.cisco_iosxr.patterns Expand source code \"\"\"scrapli_cfg.platform.core.cisco_iosxr.patterns\"\"\" import re VERSION_PATTERN = re.compile(pattern=r\"\\d+\\.\\d+\\.\\d+\", flags=re.I) BANNER_PATTERN = re.compile( pattern=r\"^banner\\s(?:(exec|incoming|login|motd|prompt-timeout|slip-ppp)\\s)\" r\"(?P .{1}).*\\?P=delim\", flags=re.I | re.M | re.S, ) TIMESTAMP_PATTERN = datetime_pattern = re.compile( r\"^(mon|tue|wed|thu|fri|sat|sun)\\s+\" r\"(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)\\s+\" r\"\\d+\\s+\\d+:\\d+:\\d+((\\.\\d+\\s\\w+)|\\s\\d+)$\", flags=re.M | re.I, ) BUILD_CONFIG_PATTERN = re.compile(r\"(^building configuration\\.\\.\\.$)\", flags=re.I | re.M) CONFIG_VERSION_PATTERN = re.compile(r\"(^!! ios xr.*$)\", flags=re.I | re.M) CONFIG_CHANGE_PATTERN = re.compile(r\"(^!! last config.*$)\", flags=re.I | re.M) OUTPUT_HEADER_PATTERN = re.compile( pattern=rf\"{TIMESTAMP_PATTERN.pattern}|\" rf\"{BUILD_CONFIG_PATTERN.pattern}|\" rf\"{CONFIG_VERSION_PATTERN.pattern}|\" rf\"{CONFIG_CHANGE_PATTERN.pattern}\", flags=re.I | re.M, ) END_PATTERN = re.compile(pattern=\"end$\") # pre-canned config section grabber patterns # match all ethernet interfaces w/ or w/out config items below them ETHERNET_INTERFACES = re.compile( pattern=r\"(^interface \\w+ethernet(?:\\d|\\/)+$(?:\\n^\\s{1}.*$)*\\n!\\n)+\", flags=re.I | re.M ) # match mgmteth[numbers, letters, forward slashes] interface and config items below it MANAGEMENT_ONE_INTERFACE = re.compile( pattern=r\"^^interface mgmteth(?:[a-z0-9\\/]+)(?:\\n^\\s.*$)*\\n!\", flags=re.I | re.M )","title":"Module scrapli_cfg.platform.core.cisco_iosxr.patterns"},{"location":"api_docs/platform/core/cisco_iosxr/sync_platform/","text":"window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting()) Module scrapli_cfg.platform.core.cisco_iosxr.sync_platform \u00b6 scrapli_cfg.platform.core.cisco_iosxr.sync_platform Expand source code \"\"\"scrapli_cfg.platform.core.cisco_iosxr.sync_platform\"\"\" from typing import Any, Callable, List, Optional from scrapli.driver import NetworkDriver from scrapli_cfg.diff import ScrapliCfgDiffResponse from scrapli_cfg.exceptions import DiffConfigError, LoadConfigError from scrapli_cfg.platform.base.sync_platform import ScrapliCfgPlatform from scrapli_cfg.platform.core.cisco_iosxr.base_platform import CONFIG_SOURCES, ScrapliCfgIOSXRBase from scrapli_cfg.response import ScrapliCfgResponse def iosxr_on_open(cls: ScrapliCfgPlatform) -> None: \"\"\" Scrapli CFG IOSXR On open Disable console logging, perhaps more things in the future! Args: cls: ScrapliCfg object Returns: None Raises: N/A \"\"\" cls.conn.send_configs(configs=[\"no logging console\", \"commit\"]) class ScrapliCfgIOSXR(ScrapliCfgPlatform, ScrapliCfgIOSXRBase): def __init__( self, conn: NetworkDriver, config_sources: Optional[List[str]] = None, on_open: Optional[Callable[..., Any]] = None, ) -> None: if config_sources is None: config_sources = CONFIG_SOURCES if on_open is None: on_open = iosxr_on_open super().__init__(conn=conn, config_sources=config_sources, on_open=on_open) self._replace = False self._in_configuration_session = False self._config_privilege_level = \"configuration\" self._get_version_command = \"show version | i Version\" def get_config(self, source: str = \"running\") -> ScrapliCfgResponse: response = self._pre_get_config(source=source) if not self._in_configuration_session: config_result = self.conn.send_command(command=\"show running-config\") else: config_result = self.conn.send_config( config=\"show running-config\", privilege_level=self._config_privilege_level ) return self._post_get_config( response=response, source=source, scrapli_responses=[config_result], result=config_result.result, ) def load_config(self, config: str, replace: bool = False, **kwargs: Any) -> ScrapliCfgResponse: \"\"\" Load configuration to a device Supported kwargs: exclusive: True/False use `configure exclusive` mode Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for iosxr supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" scrapli_responses = [] response = self._pre_load_config(config=config) exclusive = kwargs.get(\"exclusive\", False) config, eager_config = self._prepare_load_config_session_and_payload( config=config, replace=replace, exclusive=exclusive ) try: config_result = self.conn.send_config( config=config, privilege_level=self._config_privilege_level ) scrapli_responses.append(config_result) if config_result.failed: msg = \"failed to load the candidate config into the config session\" self.logger.critical(msg) raise LoadConfigError(msg) # eager cuz banners and such; perhaps if no banner/macro we can disable eager though.... if eager_config: eager_config_result = self.conn.send_config( config=eager_config, privilege_level=self._config_privilege_level, eager=True ) scrapli_responses.append(eager_config_result) if eager_config_result.failed: msg = \"failed to load the candidate config into the config session\" self.logger.critical(msg) raise LoadConfigError(msg) except LoadConfigError: pass return self._post_load_config( response=response, scrapli_responses=scrapli_responses, ) def abort_config(self) -> ScrapliCfgResponse: response = self._pre_abort_config(session_or_config_file=self._in_configuration_session) self.conn._abort_config() # pylint: disable=W0212 self._reset_config_session() return self._post_abort_config(response=response, scrapli_responses=[]) def commit_config(self, source: str = \"running\") -> ScrapliCfgResponse: response = self._pre_commit_config( source=source, session_or_config_file=self._in_configuration_session ) commit_result = self.conn.send_config(config=\"commit\") self._reset_config_session() return self._post_commit_config(response=response, scrapli_responses=[commit_result]) def diff_config(self, source: str = \"running\") -> ScrapliCfgDiffResponse: scrapli_responses = [] device_diff = \"\" source_config = \"\" diff_response = self._pre_diff_config( source=source, session_or_config_file=self._in_configuration_session ) try: diff_result = self.conn.send_config( config=self._get_diff_command(), privilege_level=self._config_privilege_level ) scrapli_responses.append(diff_response) if diff_result.failed: msg = \"failed generating diff for config session\" self.logger.critical(msg) raise DiffConfigError(msg) device_diff = diff_result.result source_config_result = self.get_config(source=source) source_config = source_config_result.result if source_config_result.scrapli_responses: scrapli_responses.extend(source_config_result.scrapli_responses) if source_config_result.failed: msg = \"failed fetching source config for diff comparison\" self.logger.critical(msg) raise DiffConfigError(msg) except DiffConfigError: pass source_config, candidate_config = self._normalize_source_candidate_configs( source_config=source_config ) return self._post_diff_config( diff_response=diff_response, scrapli_responses=scrapli_responses, source_config=source_config, candidate_config=candidate_config, device_diff=device_diff, ) Functions \u00b6 iosxr_on_open \u00b6 iosxr_on_open(cls: scrapli_cfg.platform.base.sync_platform.ScrapliCfgPlatform) \u2011> NoneType Scrapli CFG IOSXR On open Disable console logging, perhaps more things in the future! Args: cls: ScrapliCfg object Returns: None Raises: N/A Classes \u00b6 ScrapliCfgIOSXR \u00b6 Helper class that provides a standard way to create an ABC using inheritance. Scrapli Config base class Args: conn: scrapli connection to use config_sources: list of config sources on_open: async callable to run at connection open Returns: None Raises: N/A Expand source code class ScrapliCfgIOSXR(ScrapliCfgPlatform, ScrapliCfgIOSXRBase): def __init__( self, conn: NetworkDriver, config_sources: Optional[List[str]] = None, on_open: Optional[Callable[..., Any]] = None, ) -> None: if config_sources is None: config_sources = CONFIG_SOURCES if on_open is None: on_open = iosxr_on_open super().__init__(conn=conn, config_sources=config_sources, on_open=on_open) self._replace = False self._in_configuration_session = False self._config_privilege_level = \"configuration\" self._get_version_command = \"show version | i Version\" def get_config(self, source: str = \"running\") -> ScrapliCfgResponse: response = self._pre_get_config(source=source) if not self._in_configuration_session: config_result = self.conn.send_command(command=\"show running-config\") else: config_result = self.conn.send_config( config=\"show running-config\", privilege_level=self._config_privilege_level ) return self._post_get_config( response=response, source=source, scrapli_responses=[config_result], result=config_result.result, ) def load_config(self, config: str, replace: bool = False, **kwargs: Any) -> ScrapliCfgResponse: \"\"\" Load configuration to a device Supported kwargs: exclusive: True/False use `configure exclusive` mode Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for iosxr supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" scrapli_responses = [] response = self._pre_load_config(config=config) exclusive = kwargs.get(\"exclusive\", False) config, eager_config = self._prepare_load_config_session_and_payload( config=config, replace=replace, exclusive=exclusive ) try: config_result = self.conn.send_config( config=config, privilege_level=self._config_privilege_level ) scrapli_responses.append(config_result) if config_result.failed: msg = \"failed to load the candidate config into the config session\" self.logger.critical(msg) raise LoadConfigError(msg) # eager cuz banners and such; perhaps if no banner/macro we can disable eager though.... if eager_config: eager_config_result = self.conn.send_config( config=eager_config, privilege_level=self._config_privilege_level, eager=True ) scrapli_responses.append(eager_config_result) if eager_config_result.failed: msg = \"failed to load the candidate config into the config session\" self.logger.critical(msg) raise LoadConfigError(msg) except LoadConfigError: pass return self._post_load_config( response=response, scrapli_responses=scrapli_responses, ) def abort_config(self) -> ScrapliCfgResponse: response = self._pre_abort_config(session_or_config_file=self._in_configuration_session) self.conn._abort_config() # pylint: disable=W0212 self._reset_config_session() return self._post_abort_config(response=response, scrapli_responses=[]) def commit_config(self, source: str = \"running\") -> ScrapliCfgResponse: response = self._pre_commit_config( source=source, session_or_config_file=self._in_configuration_session ) commit_result = self.conn.send_config(config=\"commit\") self._reset_config_session() return self._post_commit_config(response=response, scrapli_responses=[commit_result]) def diff_config(self, source: str = \"running\") -> ScrapliCfgDiffResponse: scrapli_responses = [] device_diff = \"\" source_config = \"\" diff_response = self._pre_diff_config( source=source, session_or_config_file=self._in_configuration_session ) try: diff_result = self.conn.send_config( config=self._get_diff_command(), privilege_level=self._config_privilege_level ) scrapli_responses.append(diff_response) if diff_result.failed: msg = \"failed generating diff for config session\" self.logger.critical(msg) raise DiffConfigError(msg) device_diff = diff_result.result source_config_result = self.get_config(source=source) source_config = source_config_result.result if source_config_result.scrapli_responses: scrapli_responses.extend(source_config_result.scrapli_responses) if source_config_result.failed: msg = \"failed fetching source config for diff comparison\" self.logger.critical(msg) raise DiffConfigError(msg) except DiffConfigError: pass source_config, candidate_config = self._normalize_source_candidate_configs( source_config=source_config ) return self._post_diff_config( diff_response=diff_response, scrapli_responses=scrapli_responses, source_config=source_config, candidate_config=candidate_config, device_diff=device_diff, ) Ancestors (in MRO) \u00b6 scrapli_cfg.platform.base.sync_platform.ScrapliCfgPlatform abc.ABC scrapli_cfg.platform.base.base_platform.ScrapliCfgBase scrapli_cfg.platform.core.cisco_iosxr.base_platform.ScrapliCfgIOSXRBase Class variables \u00b6 conn: Union[scrapli.driver.network.sync_driver.NetworkDriver, scrapli.driver.network.async_driver.AsyncNetworkDriver] Methods \u00b6 load_config \u00b6 load_config(self, config: str, replace: bool = False, **kwargs: Any) \u2011> scrapli_cfg.response.ScrapliCfgResponse Load configuration to a device Supported kwargs: exclusive: True/False use `configure exclusive` mode Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for iosxr supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A","title":"Sync Platform"},{"location":"api_docs/platform/core/cisco_iosxr/sync_platform/#module-scrapli_cfgplatformcorecisco_iosxrsync_platform","text":"scrapli_cfg.platform.core.cisco_iosxr.sync_platform Expand source code \"\"\"scrapli_cfg.platform.core.cisco_iosxr.sync_platform\"\"\" from typing import Any, Callable, List, Optional from scrapli.driver import NetworkDriver from scrapli_cfg.diff import ScrapliCfgDiffResponse from scrapli_cfg.exceptions import DiffConfigError, LoadConfigError from scrapli_cfg.platform.base.sync_platform import ScrapliCfgPlatform from scrapli_cfg.platform.core.cisco_iosxr.base_platform import CONFIG_SOURCES, ScrapliCfgIOSXRBase from scrapli_cfg.response import ScrapliCfgResponse def iosxr_on_open(cls: ScrapliCfgPlatform) -> None: \"\"\" Scrapli CFG IOSXR On open Disable console logging, perhaps more things in the future! Args: cls: ScrapliCfg object Returns: None Raises: N/A \"\"\" cls.conn.send_configs(configs=[\"no logging console\", \"commit\"]) class ScrapliCfgIOSXR(ScrapliCfgPlatform, ScrapliCfgIOSXRBase): def __init__( self, conn: NetworkDriver, config_sources: Optional[List[str]] = None, on_open: Optional[Callable[..., Any]] = None, ) -> None: if config_sources is None: config_sources = CONFIG_SOURCES if on_open is None: on_open = iosxr_on_open super().__init__(conn=conn, config_sources=config_sources, on_open=on_open) self._replace = False self._in_configuration_session = False self._config_privilege_level = \"configuration\" self._get_version_command = \"show version | i Version\" def get_config(self, source: str = \"running\") -> ScrapliCfgResponse: response = self._pre_get_config(source=source) if not self._in_configuration_session: config_result = self.conn.send_command(command=\"show running-config\") else: config_result = self.conn.send_config( config=\"show running-config\", privilege_level=self._config_privilege_level ) return self._post_get_config( response=response, source=source, scrapli_responses=[config_result], result=config_result.result, ) def load_config(self, config: str, replace: bool = False, **kwargs: Any) -> ScrapliCfgResponse: \"\"\" Load configuration to a device Supported kwargs: exclusive: True/False use `configure exclusive` mode Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for iosxr supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" scrapli_responses = [] response = self._pre_load_config(config=config) exclusive = kwargs.get(\"exclusive\", False) config, eager_config = self._prepare_load_config_session_and_payload( config=config, replace=replace, exclusive=exclusive ) try: config_result = self.conn.send_config( config=config, privilege_level=self._config_privilege_level ) scrapli_responses.append(config_result) if config_result.failed: msg = \"failed to load the candidate config into the config session\" self.logger.critical(msg) raise LoadConfigError(msg) # eager cuz banners and such; perhaps if no banner/macro we can disable eager though.... if eager_config: eager_config_result = self.conn.send_config( config=eager_config, privilege_level=self._config_privilege_level, eager=True ) scrapli_responses.append(eager_config_result) if eager_config_result.failed: msg = \"failed to load the candidate config into the config session\" self.logger.critical(msg) raise LoadConfigError(msg) except LoadConfigError: pass return self._post_load_config( response=response, scrapli_responses=scrapli_responses, ) def abort_config(self) -> ScrapliCfgResponse: response = self._pre_abort_config(session_or_config_file=self._in_configuration_session) self.conn._abort_config() # pylint: disable=W0212 self._reset_config_session() return self._post_abort_config(response=response, scrapli_responses=[]) def commit_config(self, source: str = \"running\") -> ScrapliCfgResponse: response = self._pre_commit_config( source=source, session_or_config_file=self._in_configuration_session ) commit_result = self.conn.send_config(config=\"commit\") self._reset_config_session() return self._post_commit_config(response=response, scrapli_responses=[commit_result]) def diff_config(self, source: str = \"running\") -> ScrapliCfgDiffResponse: scrapli_responses = [] device_diff = \"\" source_config = \"\" diff_response = self._pre_diff_config( source=source, session_or_config_file=self._in_configuration_session ) try: diff_result = self.conn.send_config( config=self._get_diff_command(), privilege_level=self._config_privilege_level ) scrapli_responses.append(diff_response) if diff_result.failed: msg = \"failed generating diff for config session\" self.logger.critical(msg) raise DiffConfigError(msg) device_diff = diff_result.result source_config_result = self.get_config(source=source) source_config = source_config_result.result if source_config_result.scrapli_responses: scrapli_responses.extend(source_config_result.scrapli_responses) if source_config_result.failed: msg = \"failed fetching source config for diff comparison\" self.logger.critical(msg) raise DiffConfigError(msg) except DiffConfigError: pass source_config, candidate_config = self._normalize_source_candidate_configs( source_config=source_config ) return self._post_diff_config( diff_response=diff_response, scrapli_responses=scrapli_responses, source_config=source_config, candidate_config=candidate_config, device_diff=device_diff, )","title":"Module scrapli_cfg.platform.core.cisco_iosxr.sync_platform"},{"location":"api_docs/platform/core/cisco_iosxr/sync_platform/#functions","text":"","title":"Functions"},{"location":"api_docs/platform/core/cisco_iosxr/sync_platform/#iosxr_on_open","text":"iosxr_on_open(cls: scrapli_cfg.platform.base.sync_platform.ScrapliCfgPlatform) \u2011> NoneType Scrapli CFG IOSXR On open Disable console logging, perhaps more things in the future! Args: cls: ScrapliCfg object Returns: None Raises: N/A","title":"iosxr_on_open"},{"location":"api_docs/platform/core/cisco_iosxr/sync_platform/#classes","text":"","title":"Classes"},{"location":"api_docs/platform/core/cisco_iosxr/sync_platform/#scraplicfgiosxr","text":"Helper class that provides a standard way to create an ABC using inheritance. Scrapli Config base class Args: conn: scrapli connection to use config_sources: list of config sources on_open: async callable to run at connection open Returns: None Raises: N/A Expand source code class ScrapliCfgIOSXR(ScrapliCfgPlatform, ScrapliCfgIOSXRBase): def __init__( self, conn: NetworkDriver, config_sources: Optional[List[str]] = None, on_open: Optional[Callable[..., Any]] = None, ) -> None: if config_sources is None: config_sources = CONFIG_SOURCES if on_open is None: on_open = iosxr_on_open super().__init__(conn=conn, config_sources=config_sources, on_open=on_open) self._replace = False self._in_configuration_session = False self._config_privilege_level = \"configuration\" self._get_version_command = \"show version | i Version\" def get_config(self, source: str = \"running\") -> ScrapliCfgResponse: response = self._pre_get_config(source=source) if not self._in_configuration_session: config_result = self.conn.send_command(command=\"show running-config\") else: config_result = self.conn.send_config( config=\"show running-config\", privilege_level=self._config_privilege_level ) return self._post_get_config( response=response, source=source, scrapli_responses=[config_result], result=config_result.result, ) def load_config(self, config: str, replace: bool = False, **kwargs: Any) -> ScrapliCfgResponse: \"\"\" Load configuration to a device Supported kwargs: exclusive: True/False use `configure exclusive` mode Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for iosxr supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" scrapli_responses = [] response = self._pre_load_config(config=config) exclusive = kwargs.get(\"exclusive\", False) config, eager_config = self._prepare_load_config_session_and_payload( config=config, replace=replace, exclusive=exclusive ) try: config_result = self.conn.send_config( config=config, privilege_level=self._config_privilege_level ) scrapli_responses.append(config_result) if config_result.failed: msg = \"failed to load the candidate config into the config session\" self.logger.critical(msg) raise LoadConfigError(msg) # eager cuz banners and such; perhaps if no banner/macro we can disable eager though.... if eager_config: eager_config_result = self.conn.send_config( config=eager_config, privilege_level=self._config_privilege_level, eager=True ) scrapli_responses.append(eager_config_result) if eager_config_result.failed: msg = \"failed to load the candidate config into the config session\" self.logger.critical(msg) raise LoadConfigError(msg) except LoadConfigError: pass return self._post_load_config( response=response, scrapli_responses=scrapli_responses, ) def abort_config(self) -> ScrapliCfgResponse: response = self._pre_abort_config(session_or_config_file=self._in_configuration_session) self.conn._abort_config() # pylint: disable=W0212 self._reset_config_session() return self._post_abort_config(response=response, scrapli_responses=[]) def commit_config(self, source: str = \"running\") -> ScrapliCfgResponse: response = self._pre_commit_config( source=source, session_or_config_file=self._in_configuration_session ) commit_result = self.conn.send_config(config=\"commit\") self._reset_config_session() return self._post_commit_config(response=response, scrapli_responses=[commit_result]) def diff_config(self, source: str = \"running\") -> ScrapliCfgDiffResponse: scrapli_responses = [] device_diff = \"\" source_config = \"\" diff_response = self._pre_diff_config( source=source, session_or_config_file=self._in_configuration_session ) try: diff_result = self.conn.send_config( config=self._get_diff_command(), privilege_level=self._config_privilege_level ) scrapli_responses.append(diff_response) if diff_result.failed: msg = \"failed generating diff for config session\" self.logger.critical(msg) raise DiffConfigError(msg) device_diff = diff_result.result source_config_result = self.get_config(source=source) source_config = source_config_result.result if source_config_result.scrapli_responses: scrapli_responses.extend(source_config_result.scrapli_responses) if source_config_result.failed: msg = \"failed fetching source config for diff comparison\" self.logger.critical(msg) raise DiffConfigError(msg) except DiffConfigError: pass source_config, candidate_config = self._normalize_source_candidate_configs( source_config=source_config ) return self._post_diff_config( diff_response=diff_response, scrapli_responses=scrapli_responses, source_config=source_config, candidate_config=candidate_config, device_diff=device_diff, )","title":"ScrapliCfgIOSXR"},{"location":"api_docs/platform/core/cisco_iosxr/sync_platform/#ancestors-in-mro","text":"scrapli_cfg.platform.base.sync_platform.ScrapliCfgPlatform abc.ABC scrapli_cfg.platform.base.base_platform.ScrapliCfgBase scrapli_cfg.platform.core.cisco_iosxr.base_platform.ScrapliCfgIOSXRBase","title":"Ancestors (in MRO)"},{"location":"api_docs/platform/core/cisco_iosxr/sync_platform/#class-variables","text":"conn: Union[scrapli.driver.network.sync_driver.NetworkDriver, scrapli.driver.network.async_driver.AsyncNetworkDriver]","title":"Class variables"},{"location":"api_docs/platform/core/cisco_iosxr/sync_platform/#methods","text":"","title":"Methods"},{"location":"api_docs/platform/core/cisco_iosxr/sync_platform/#load_config","text":"load_config(self, config: str, replace: bool = False, **kwargs: Any) \u2011> scrapli_cfg.response.ScrapliCfgResponse Load configuration to a device Supported kwargs: exclusive: True/False use `configure exclusive` mode Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for iosxr supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A","title":"load_config"},{"location":"api_docs/platform/core/cisco_nxos/async_platform/","text":"window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting()) Module scrapli_cfg.platform.core.cisco_nxos.async_platform \u00b6 scrapli_cfg.platform.core.cisco_nxos.async_platform Expand source code \"\"\"scrapli_cfg.platform.core.cisco_nxos.async_platform\"\"\" from typing import Any, Callable, List, Optional from scrapli.driver import AsyncNetworkDriver from scrapli.response import Response from scrapli_cfg.diff import ScrapliCfgDiffResponse from scrapli_cfg.exceptions import DiffConfigError, FailedToDetermineDeviceState from scrapli_cfg.platform.base.async_platform import AsyncScrapliCfgPlatform from scrapli_cfg.platform.core.cisco_nxos.base_platform import CONFIG_SOURCES, ScrapliCfgNXOSBase from scrapli_cfg.response import ScrapliCfgResponse async def async_nxos_on_open(cls: AsyncScrapliCfgPlatform) -> None: \"\"\" Scrapli CFG NXOS On open Disable console logging, perhaps more things in the future! Args: cls: ScrapliCfg object Returns: None Raises: N/A \"\"\" await cls.conn.send_config(config=\"no logging monitor\") class AsyncScrapliCfgNXOS(AsyncScrapliCfgPlatform, ScrapliCfgNXOSBase): def __init__( self, conn: AsyncNetworkDriver, config_sources: Optional[List[str]] = None, on_open: Optional[Callable[..., Any]] = None, filesystem: str = \"bootflash:\", cleanup_post_commit: bool = True, ) -> None: if config_sources is None: config_sources = CONFIG_SOURCES if on_open is None: on_open = async_nxos_on_open super().__init__(conn=conn, config_sources=config_sources, on_open=on_open) self.filesystem = filesystem self._filesystem_space_available_buffer_perc = 10 self._replace = False self.candidate_config_filename = \"\" self.cleanup_post_commit = cleanup_post_commit self._get_version_command = 'show version | i \"NXOS: version\"' async def _get_filesystem_space_available(self) -> int: \"\"\" Get available space on filesystem Args: N/A Returns: None Raises: FailedToDetermineDeviceState: if unable to fetch file filesystem bytes available \"\"\" filesystem_size_result = await self.conn.send_command( command=f\"dir {self.filesystem} | i 'bytes free'\" ) if filesystem_size_result.failed: raise FailedToDetermineDeviceState(\"failed to determine space available on filesystem\") return self._post_get_filesystem_space_available(output=filesystem_size_result.result) async def _delete_candidate_config(self) -> Response: \"\"\" Delete candidate config from the filesystem Args: N/A Returns: Response: response from deleting the candidate config Raises: N/A \"\"\" delete_commands = [ \"terminal dont-ask\", f\"delete {self.filesystem}{self.candidate_config_filename}\", ] delete_result = await self.conn.send_commands(commands=delete_commands) return delete_result async def get_checkpoint(self) -> ScrapliCfgResponse: \"\"\" Get device checkpoint file Args: N/A Returns: ScrapliCfgResponse: response object containing string of the target config source as the `result` attribute Raises: N/A \"\"\" response, checkpoint_commands = self._pre_get_checkpoint() checkpoint_results = await self.conn.send_commands(commands=checkpoint_commands) try: checkpoint: str = checkpoint_results[2].result except IndexError: checkpoint = \"\" return self._post_get_config( response=response, source=\"running\", scrapli_responses=checkpoint_results, result=checkpoint, ) async def get_config(self, source: str = \"running\") -> ScrapliCfgResponse: response = self._pre_get_config(source=source) config_result = await self.conn.send_command( command=self._get_config_command(source=source) ) return self._post_get_config( response=response, source=source, scrapli_responses=[config_result], result=config_result.result, ) async def load_config( self, config: str, replace: bool = False, **kwargs: Any ) -> ScrapliCfgResponse: \"\"\" Load configuration to a device Supported kwargs: N/A Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for nxos supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" response = self._pre_load_config(config=config) config = self._prepare_load_config(config=config, replace=replace) filesystem_bytes_available = await self._get_filesystem_space_available() self._space_available(filesystem_bytes_available=filesystem_bytes_available) await self.conn.acquire_priv(desired_priv=\"tclsh\") config_result = await self.conn.send_config(config=config, privilege_level=\"tclsh\") await self.conn.acquire_priv(desired_priv=self.conn.default_desired_privilege_level) return self._post_load_config( response=response, scrapli_responses=[config_result], ) async def abort_config(self) -> ScrapliCfgResponse: response = self._pre_abort_config( session_or_config_file=bool(self.candidate_config_filename) ) abort_result = await self._delete_candidate_config() self._reset_config_session() return self._post_abort_config(response=response, scrapli_responses=[abort_result]) async def commit_config(self, source: str = \"running\") -> ScrapliCfgResponse: scrapli_responses = [] response = self._pre_commit_config( source=source, session_or_config_file=bool(self.candidate_config_filename) ) if self._replace is True: replace_command = ( f\"rollback running-config file {self.filesystem}{self.candidate_config_filename}\" ) commit_result = await self.conn.send_command(command=replace_command) else: merge_command = f\"copy {self.filesystem}{self.candidate_config_filename} running-config\" commit_result = await self.conn.send_command(command=merge_command) scrapli_responses.append(commit_result) save_config_result = await self.conn.send_command( command=\"copy running-config startup-config\" ) scrapli_responses.append(save_config_result) if self.cleanup_post_commit: cleanup_result = await self._delete_candidate_config() scrapli_responses.append(cleanup_result) self._reset_config_session() return self._post_load_config( response=response, scrapli_responses=scrapli_responses, ) async def diff_config(self, source: str = \"running\") -> ScrapliCfgDiffResponse: scrapli_responses = [] device_diff = \"\" source_config = \"\" diff_response = self._pre_diff_config( source=source, session_or_config_file=bool(self.candidate_config_filename) ) try: diff_command = self._get_diff_command(source=source) if diff_command: diff_result = await self.conn.send_command(command=diff_command) scrapli_responses.append(diff_result) if diff_result.failed: msg = \"failed generating diff for config session\" self.logger.critical(msg) raise DiffConfigError(msg) device_diff = diff_result.result else: device_diff = \"\" source_config_result = await self.get_config(source=source) source_config = source_config_result.result if source_config_result.scrapli_responses: scrapli_responses.extend(source_config_result.scrapli_responses) if source_config_result.failed: msg = \"failed fetching source config for diff comparison\" self.logger.critical(msg) raise DiffConfigError(msg) except DiffConfigError: pass source_config, candidate_config = self._normalize_source_candidate_configs( source_config=source_config ) return self._post_diff_config( diff_response=diff_response, scrapli_responses=scrapli_responses, source_config=source_config, candidate_config=candidate_config, device_diff=device_diff, ) Functions \u00b6 async_nxos_on_open \u00b6 async_nxos_on_open(cls: scrapli_cfg.platform.base.async_platform.AsyncScrapliCfgPlatform) \u2011> NoneType Scrapli CFG NXOS On open Disable console logging, perhaps more things in the future! Args: cls: ScrapliCfg object Returns: None Raises: N/A Classes \u00b6 AsyncScrapliCfgNXOS \u00b6 Helper class that provides a standard way to create an ABC using inheritance. Scrapli Config async base class Args: conn: scrapli connection to use config_sources: list of config sources on_open: async callable to run at connection open Returns: None Raises: N/A Expand source code class AsyncScrapliCfgNXOS(AsyncScrapliCfgPlatform, ScrapliCfgNXOSBase): def __init__( self, conn: AsyncNetworkDriver, config_sources: Optional[List[str]] = None, on_open: Optional[Callable[..., Any]] = None, filesystem: str = \"bootflash:\", cleanup_post_commit: bool = True, ) -> None: if config_sources is None: config_sources = CONFIG_SOURCES if on_open is None: on_open = async_nxos_on_open super().__init__(conn=conn, config_sources=config_sources, on_open=on_open) self.filesystem = filesystem self._filesystem_space_available_buffer_perc = 10 self._replace = False self.candidate_config_filename = \"\" self.cleanup_post_commit = cleanup_post_commit self._get_version_command = 'show version | i \"NXOS: version\"' async def _get_filesystem_space_available(self) -> int: \"\"\" Get available space on filesystem Args: N/A Returns: None Raises: FailedToDetermineDeviceState: if unable to fetch file filesystem bytes available \"\"\" filesystem_size_result = await self.conn.send_command( command=f\"dir {self.filesystem} | i 'bytes free'\" ) if filesystem_size_result.failed: raise FailedToDetermineDeviceState(\"failed to determine space available on filesystem\") return self._post_get_filesystem_space_available(output=filesystem_size_result.result) async def _delete_candidate_config(self) -> Response: \"\"\" Delete candidate config from the filesystem Args: N/A Returns: Response: response from deleting the candidate config Raises: N/A \"\"\" delete_commands = [ \"terminal dont-ask\", f\"delete {self.filesystem}{self.candidate_config_filename}\", ] delete_result = await self.conn.send_commands(commands=delete_commands) return delete_result async def get_checkpoint(self) -> ScrapliCfgResponse: \"\"\" Get device checkpoint file Args: N/A Returns: ScrapliCfgResponse: response object containing string of the target config source as the `result` attribute Raises: N/A \"\"\" response, checkpoint_commands = self._pre_get_checkpoint() checkpoint_results = await self.conn.send_commands(commands=checkpoint_commands) try: checkpoint: str = checkpoint_results[2].result except IndexError: checkpoint = \"\" return self._post_get_config( response=response, source=\"running\", scrapli_responses=checkpoint_results, result=checkpoint, ) async def get_config(self, source: str = \"running\") -> ScrapliCfgResponse: response = self._pre_get_config(source=source) config_result = await self.conn.send_command( command=self._get_config_command(source=source) ) return self._post_get_config( response=response, source=source, scrapli_responses=[config_result], result=config_result.result, ) async def load_config( self, config: str, replace: bool = False, **kwargs: Any ) -> ScrapliCfgResponse: \"\"\" Load configuration to a device Supported kwargs: N/A Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for nxos supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" response = self._pre_load_config(config=config) config = self._prepare_load_config(config=config, replace=replace) filesystem_bytes_available = await self._get_filesystem_space_available() self._space_available(filesystem_bytes_available=filesystem_bytes_available) await self.conn.acquire_priv(desired_priv=\"tclsh\") config_result = await self.conn.send_config(config=config, privilege_level=\"tclsh\") await self.conn.acquire_priv(desired_priv=self.conn.default_desired_privilege_level) return self._post_load_config( response=response, scrapli_responses=[config_result], ) async def abort_config(self) -> ScrapliCfgResponse: response = self._pre_abort_config( session_or_config_file=bool(self.candidate_config_filename) ) abort_result = await self._delete_candidate_config() self._reset_config_session() return self._post_abort_config(response=response, scrapli_responses=[abort_result]) async def commit_config(self, source: str = \"running\") -> ScrapliCfgResponse: scrapli_responses = [] response = self._pre_commit_config( source=source, session_or_config_file=bool(self.candidate_config_filename) ) if self._replace is True: replace_command = ( f\"rollback running-config file {self.filesystem}{self.candidate_config_filename}\" ) commit_result = await self.conn.send_command(command=replace_command) else: merge_command = f\"copy {self.filesystem}{self.candidate_config_filename} running-config\" commit_result = await self.conn.send_command(command=merge_command) scrapli_responses.append(commit_result) save_config_result = await self.conn.send_command( command=\"copy running-config startup-config\" ) scrapli_responses.append(save_config_result) if self.cleanup_post_commit: cleanup_result = await self._delete_candidate_config() scrapli_responses.append(cleanup_result) self._reset_config_session() return self._post_load_config( response=response, scrapli_responses=scrapli_responses, ) async def diff_config(self, source: str = \"running\") -> ScrapliCfgDiffResponse: scrapli_responses = [] device_diff = \"\" source_config = \"\" diff_response = self._pre_diff_config( source=source, session_or_config_file=bool(self.candidate_config_filename) ) try: diff_command = self._get_diff_command(source=source) if diff_command: diff_result = await self.conn.send_command(command=diff_command) scrapli_responses.append(diff_result) if diff_result.failed: msg = \"failed generating diff for config session\" self.logger.critical(msg) raise DiffConfigError(msg) device_diff = diff_result.result else: device_diff = \"\" source_config_result = await self.get_config(source=source) source_config = source_config_result.result if source_config_result.scrapli_responses: scrapli_responses.extend(source_config_result.scrapli_responses) if source_config_result.failed: msg = \"failed fetching source config for diff comparison\" self.logger.critical(msg) raise DiffConfigError(msg) except DiffConfigError: pass source_config, candidate_config = self._normalize_source_candidate_configs( source_config=source_config ) return self._post_diff_config( diff_response=diff_response, scrapli_responses=scrapli_responses, source_config=source_config, candidate_config=candidate_config, device_diff=device_diff, ) Ancestors (in MRO) \u00b6 scrapli_cfg.platform.base.async_platform.AsyncScrapliCfgPlatform abc.ABC scrapli_cfg.platform.base.base_platform.ScrapliCfgBase scrapli_cfg.platform.core.cisco_nxos.base_platform.ScrapliCfgNXOSBase Class variables \u00b6 conn: Union[scrapli.driver.network.sync_driver.NetworkDriver, scrapli.driver.network.async_driver.AsyncNetworkDriver] Methods \u00b6 get_checkpoint \u00b6 get_checkpoint(self) \u2011> scrapli_cfg.response.ScrapliCfgResponse Get device checkpoint file Args: N/A Returns: ScrapliCfgResponse: response object containing string of the target config source as the `result` attribute Raises: N/A load_config \u00b6 load_config(self, config: str, replace: bool = False, **kwargs: Any) \u2011> scrapli_cfg.response.ScrapliCfgResponse Load configuration to a device Supported kwargs: N/A Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for nxos supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A","title":"Async Platform"},{"location":"api_docs/platform/core/cisco_nxos/async_platform/#module-scrapli_cfgplatformcorecisco_nxosasync_platform","text":"scrapli_cfg.platform.core.cisco_nxos.async_platform Expand source code \"\"\"scrapli_cfg.platform.core.cisco_nxos.async_platform\"\"\" from typing import Any, Callable, List, Optional from scrapli.driver import AsyncNetworkDriver from scrapli.response import Response from scrapli_cfg.diff import ScrapliCfgDiffResponse from scrapli_cfg.exceptions import DiffConfigError, FailedToDetermineDeviceState from scrapli_cfg.platform.base.async_platform import AsyncScrapliCfgPlatform from scrapli_cfg.platform.core.cisco_nxos.base_platform import CONFIG_SOURCES, ScrapliCfgNXOSBase from scrapli_cfg.response import ScrapliCfgResponse async def async_nxos_on_open(cls: AsyncScrapliCfgPlatform) -> None: \"\"\" Scrapli CFG NXOS On open Disable console logging, perhaps more things in the future! Args: cls: ScrapliCfg object Returns: None Raises: N/A \"\"\" await cls.conn.send_config(config=\"no logging monitor\") class AsyncScrapliCfgNXOS(AsyncScrapliCfgPlatform, ScrapliCfgNXOSBase): def __init__( self, conn: AsyncNetworkDriver, config_sources: Optional[List[str]] = None, on_open: Optional[Callable[..., Any]] = None, filesystem: str = \"bootflash:\", cleanup_post_commit: bool = True, ) -> None: if config_sources is None: config_sources = CONFIG_SOURCES if on_open is None: on_open = async_nxos_on_open super().__init__(conn=conn, config_sources=config_sources, on_open=on_open) self.filesystem = filesystem self._filesystem_space_available_buffer_perc = 10 self._replace = False self.candidate_config_filename = \"\" self.cleanup_post_commit = cleanup_post_commit self._get_version_command = 'show version | i \"NXOS: version\"' async def _get_filesystem_space_available(self) -> int: \"\"\" Get available space on filesystem Args: N/A Returns: None Raises: FailedToDetermineDeviceState: if unable to fetch file filesystem bytes available \"\"\" filesystem_size_result = await self.conn.send_command( command=f\"dir {self.filesystem} | i 'bytes free'\" ) if filesystem_size_result.failed: raise FailedToDetermineDeviceState(\"failed to determine space available on filesystem\") return self._post_get_filesystem_space_available(output=filesystem_size_result.result) async def _delete_candidate_config(self) -> Response: \"\"\" Delete candidate config from the filesystem Args: N/A Returns: Response: response from deleting the candidate config Raises: N/A \"\"\" delete_commands = [ \"terminal dont-ask\", f\"delete {self.filesystem}{self.candidate_config_filename}\", ] delete_result = await self.conn.send_commands(commands=delete_commands) return delete_result async def get_checkpoint(self) -> ScrapliCfgResponse: \"\"\" Get device checkpoint file Args: N/A Returns: ScrapliCfgResponse: response object containing string of the target config source as the `result` attribute Raises: N/A \"\"\" response, checkpoint_commands = self._pre_get_checkpoint() checkpoint_results = await self.conn.send_commands(commands=checkpoint_commands) try: checkpoint: str = checkpoint_results[2].result except IndexError: checkpoint = \"\" return self._post_get_config( response=response, source=\"running\", scrapli_responses=checkpoint_results, result=checkpoint, ) async def get_config(self, source: str = \"running\") -> ScrapliCfgResponse: response = self._pre_get_config(source=source) config_result = await self.conn.send_command( command=self._get_config_command(source=source) ) return self._post_get_config( response=response, source=source, scrapli_responses=[config_result], result=config_result.result, ) async def load_config( self, config: str, replace: bool = False, **kwargs: Any ) -> ScrapliCfgResponse: \"\"\" Load configuration to a device Supported kwargs: N/A Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for nxos supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" response = self._pre_load_config(config=config) config = self._prepare_load_config(config=config, replace=replace) filesystem_bytes_available = await self._get_filesystem_space_available() self._space_available(filesystem_bytes_available=filesystem_bytes_available) await self.conn.acquire_priv(desired_priv=\"tclsh\") config_result = await self.conn.send_config(config=config, privilege_level=\"tclsh\") await self.conn.acquire_priv(desired_priv=self.conn.default_desired_privilege_level) return self._post_load_config( response=response, scrapli_responses=[config_result], ) async def abort_config(self) -> ScrapliCfgResponse: response = self._pre_abort_config( session_or_config_file=bool(self.candidate_config_filename) ) abort_result = await self._delete_candidate_config() self._reset_config_session() return self._post_abort_config(response=response, scrapli_responses=[abort_result]) async def commit_config(self, source: str = \"running\") -> ScrapliCfgResponse: scrapli_responses = [] response = self._pre_commit_config( source=source, session_or_config_file=bool(self.candidate_config_filename) ) if self._replace is True: replace_command = ( f\"rollback running-config file {self.filesystem}{self.candidate_config_filename}\" ) commit_result = await self.conn.send_command(command=replace_command) else: merge_command = f\"copy {self.filesystem}{self.candidate_config_filename} running-config\" commit_result = await self.conn.send_command(command=merge_command) scrapli_responses.append(commit_result) save_config_result = await self.conn.send_command( command=\"copy running-config startup-config\" ) scrapli_responses.append(save_config_result) if self.cleanup_post_commit: cleanup_result = await self._delete_candidate_config() scrapli_responses.append(cleanup_result) self._reset_config_session() return self._post_load_config( response=response, scrapli_responses=scrapli_responses, ) async def diff_config(self, source: str = \"running\") -> ScrapliCfgDiffResponse: scrapli_responses = [] device_diff = \"\" source_config = \"\" diff_response = self._pre_diff_config( source=source, session_or_config_file=bool(self.candidate_config_filename) ) try: diff_command = self._get_diff_command(source=source) if diff_command: diff_result = await self.conn.send_command(command=diff_command) scrapli_responses.append(diff_result) if diff_result.failed: msg = \"failed generating diff for config session\" self.logger.critical(msg) raise DiffConfigError(msg) device_diff = diff_result.result else: device_diff = \"\" source_config_result = await self.get_config(source=source) source_config = source_config_result.result if source_config_result.scrapli_responses: scrapli_responses.extend(source_config_result.scrapli_responses) if source_config_result.failed: msg = \"failed fetching source config for diff comparison\" self.logger.critical(msg) raise DiffConfigError(msg) except DiffConfigError: pass source_config, candidate_config = self._normalize_source_candidate_configs( source_config=source_config ) return self._post_diff_config( diff_response=diff_response, scrapli_responses=scrapli_responses, source_config=source_config, candidate_config=candidate_config, device_diff=device_diff, )","title":"Module scrapli_cfg.platform.core.cisco_nxos.async_platform"},{"location":"api_docs/platform/core/cisco_nxos/async_platform/#functions","text":"","title":"Functions"},{"location":"api_docs/platform/core/cisco_nxos/async_platform/#async_nxos_on_open","text":"async_nxos_on_open(cls: scrapli_cfg.platform.base.async_platform.AsyncScrapliCfgPlatform) \u2011> NoneType Scrapli CFG NXOS On open Disable console logging, perhaps more things in the future! Args: cls: ScrapliCfg object Returns: None Raises: N/A","title":"async_nxos_on_open"},{"location":"api_docs/platform/core/cisco_nxos/async_platform/#classes","text":"","title":"Classes"},{"location":"api_docs/platform/core/cisco_nxos/async_platform/#asyncscraplicfgnxos","text":"Helper class that provides a standard way to create an ABC using inheritance. Scrapli Config async base class Args: conn: scrapli connection to use config_sources: list of config sources on_open: async callable to run at connection open Returns: None Raises: N/A Expand source code class AsyncScrapliCfgNXOS(AsyncScrapliCfgPlatform, ScrapliCfgNXOSBase): def __init__( self, conn: AsyncNetworkDriver, config_sources: Optional[List[str]] = None, on_open: Optional[Callable[..., Any]] = None, filesystem: str = \"bootflash:\", cleanup_post_commit: bool = True, ) -> None: if config_sources is None: config_sources = CONFIG_SOURCES if on_open is None: on_open = async_nxos_on_open super().__init__(conn=conn, config_sources=config_sources, on_open=on_open) self.filesystem = filesystem self._filesystem_space_available_buffer_perc = 10 self._replace = False self.candidate_config_filename = \"\" self.cleanup_post_commit = cleanup_post_commit self._get_version_command = 'show version | i \"NXOS: version\"' async def _get_filesystem_space_available(self) -> int: \"\"\" Get available space on filesystem Args: N/A Returns: None Raises: FailedToDetermineDeviceState: if unable to fetch file filesystem bytes available \"\"\" filesystem_size_result = await self.conn.send_command( command=f\"dir {self.filesystem} | i 'bytes free'\" ) if filesystem_size_result.failed: raise FailedToDetermineDeviceState(\"failed to determine space available on filesystem\") return self._post_get_filesystem_space_available(output=filesystem_size_result.result) async def _delete_candidate_config(self) -> Response: \"\"\" Delete candidate config from the filesystem Args: N/A Returns: Response: response from deleting the candidate config Raises: N/A \"\"\" delete_commands = [ \"terminal dont-ask\", f\"delete {self.filesystem}{self.candidate_config_filename}\", ] delete_result = await self.conn.send_commands(commands=delete_commands) return delete_result async def get_checkpoint(self) -> ScrapliCfgResponse: \"\"\" Get device checkpoint file Args: N/A Returns: ScrapliCfgResponse: response object containing string of the target config source as the `result` attribute Raises: N/A \"\"\" response, checkpoint_commands = self._pre_get_checkpoint() checkpoint_results = await self.conn.send_commands(commands=checkpoint_commands) try: checkpoint: str = checkpoint_results[2].result except IndexError: checkpoint = \"\" return self._post_get_config( response=response, source=\"running\", scrapli_responses=checkpoint_results, result=checkpoint, ) async def get_config(self, source: str = \"running\") -> ScrapliCfgResponse: response = self._pre_get_config(source=source) config_result = await self.conn.send_command( command=self._get_config_command(source=source) ) return self._post_get_config( response=response, source=source, scrapli_responses=[config_result], result=config_result.result, ) async def load_config( self, config: str, replace: bool = False, **kwargs: Any ) -> ScrapliCfgResponse: \"\"\" Load configuration to a device Supported kwargs: N/A Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for nxos supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" response = self._pre_load_config(config=config) config = self._prepare_load_config(config=config, replace=replace) filesystem_bytes_available = await self._get_filesystem_space_available() self._space_available(filesystem_bytes_available=filesystem_bytes_available) await self.conn.acquire_priv(desired_priv=\"tclsh\") config_result = await self.conn.send_config(config=config, privilege_level=\"tclsh\") await self.conn.acquire_priv(desired_priv=self.conn.default_desired_privilege_level) return self._post_load_config( response=response, scrapli_responses=[config_result], ) async def abort_config(self) -> ScrapliCfgResponse: response = self._pre_abort_config( session_or_config_file=bool(self.candidate_config_filename) ) abort_result = await self._delete_candidate_config() self._reset_config_session() return self._post_abort_config(response=response, scrapli_responses=[abort_result]) async def commit_config(self, source: str = \"running\") -> ScrapliCfgResponse: scrapli_responses = [] response = self._pre_commit_config( source=source, session_or_config_file=bool(self.candidate_config_filename) ) if self._replace is True: replace_command = ( f\"rollback running-config file {self.filesystem}{self.candidate_config_filename}\" ) commit_result = await self.conn.send_command(command=replace_command) else: merge_command = f\"copy {self.filesystem}{self.candidate_config_filename} running-config\" commit_result = await self.conn.send_command(command=merge_command) scrapli_responses.append(commit_result) save_config_result = await self.conn.send_command( command=\"copy running-config startup-config\" ) scrapli_responses.append(save_config_result) if self.cleanup_post_commit: cleanup_result = await self._delete_candidate_config() scrapli_responses.append(cleanup_result) self._reset_config_session() return self._post_load_config( response=response, scrapli_responses=scrapli_responses, ) async def diff_config(self, source: str = \"running\") -> ScrapliCfgDiffResponse: scrapli_responses = [] device_diff = \"\" source_config = \"\" diff_response = self._pre_diff_config( source=source, session_or_config_file=bool(self.candidate_config_filename) ) try: diff_command = self._get_diff_command(source=source) if diff_command: diff_result = await self.conn.send_command(command=diff_command) scrapli_responses.append(diff_result) if diff_result.failed: msg = \"failed generating diff for config session\" self.logger.critical(msg) raise DiffConfigError(msg) device_diff = diff_result.result else: device_diff = \"\" source_config_result = await self.get_config(source=source) source_config = source_config_result.result if source_config_result.scrapli_responses: scrapli_responses.extend(source_config_result.scrapli_responses) if source_config_result.failed: msg = \"failed fetching source config for diff comparison\" self.logger.critical(msg) raise DiffConfigError(msg) except DiffConfigError: pass source_config, candidate_config = self._normalize_source_candidate_configs( source_config=source_config ) return self._post_diff_config( diff_response=diff_response, scrapli_responses=scrapli_responses, source_config=source_config, candidate_config=candidate_config, device_diff=device_diff, )","title":"AsyncScrapliCfgNXOS"},{"location":"api_docs/platform/core/cisco_nxos/async_platform/#ancestors-in-mro","text":"scrapli_cfg.platform.base.async_platform.AsyncScrapliCfgPlatform abc.ABC scrapli_cfg.platform.base.base_platform.ScrapliCfgBase scrapli_cfg.platform.core.cisco_nxos.base_platform.ScrapliCfgNXOSBase","title":"Ancestors (in MRO)"},{"location":"api_docs/platform/core/cisco_nxos/async_platform/#class-variables","text":"conn: Union[scrapli.driver.network.sync_driver.NetworkDriver, scrapli.driver.network.async_driver.AsyncNetworkDriver]","title":"Class variables"},{"location":"api_docs/platform/core/cisco_nxos/async_platform/#methods","text":"","title":"Methods"},{"location":"api_docs/platform/core/cisco_nxos/async_platform/#get_checkpoint","text":"get_checkpoint(self) \u2011> scrapli_cfg.response.ScrapliCfgResponse Get device checkpoint file Args: N/A Returns: ScrapliCfgResponse: response object containing string of the target config source as the `result` attribute Raises: N/A","title":"get_checkpoint"},{"location":"api_docs/platform/core/cisco_nxos/async_platform/#load_config","text":"load_config(self, config: str, replace: bool = False, **kwargs: Any) \u2011> scrapli_cfg.response.ScrapliCfgResponse Load configuration to a device Supported kwargs: N/A Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for nxos supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A","title":"load_config"},{"location":"api_docs/platform/core/cisco_nxos/base_platform/","text":"window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting()) Module scrapli_cfg.platform.core.cisco_nxos.base_platform \u00b6 scrapli_cfg.platform.core.cisco_nxos.base_platform Expand source code \"\"\"scrapli_cfg.platform.core.cisco_nxos.base_platform\"\"\" import re from datetime import datetime from logging import LoggerAdapter from typing import List, Tuple from scrapli.driver.network.sync_driver import NetworkDriver from scrapli_cfg.exceptions import ( FailedToFetchSpaceAvailable, GetConfigError, InsufficientSpaceAvailable, ) from scrapli_cfg.platform.core.cisco_nxos.patterns import ( BYTES_FREE, CHECKPOINT_LINE, OUTPUT_HEADER_PATTERN, VERSION_PATTERN, ) from scrapli_cfg.response import ScrapliCfgResponse CONFIG_SOURCES = [ \"running\", \"startup\", ] class ScrapliCfgNXOSBase: logger: LoggerAdapter candidate_config: str candidate_config_filename: str _replace: bool filesystem: str _filesystem_space_available_buffer_perc: int conn: NetworkDriver def _post_get_filesystem_space_available(self, output: str) -> int: \"\"\" Handle post \"get_filesystem_space_available\" operations for parity between sync and async Args: output: output that was fetched from the device Returns: int: bytes of space available on filesystem Raises: FailedToFetchSpaceAvailable: if could not determine space available... duh :) \"\"\" self.logger.info(\"determining space available from device output\") bytes_available_match = re.search(pattern=BYTES_FREE, string=output) if not bytes_available_match: msg = \"could not determine space available on filesystem\" self.logger.critical(msg) raise FailedToFetchSpaceAvailable(msg) return int(bytes_available_match.groupdict()[\"bytes_available\"]) def _space_available(self, filesystem_bytes_available: int) -> None: \"\"\" Space available operations for parity between sync and async It seems that the length of the config is near enough 1:1 to the size it takes up on the disk... so roll w/ that plus a bit of buffer based on the available buffer perc Args: filesystem_bytes_available: bytes available on filesystem Returns: None Raises: InsufficientSpaceAvailable: if... insufficient space available.... \"\"\" if filesystem_bytes_available < ( len(self.candidate_config) / self._filesystem_space_available_buffer_perc ) + len(self.candidate_config): # filesystem has less than candidate config file size + 10% (by default) space, bail out msg = ( f\"insufficient space available for candidate config + \" f\"{self._filesystem_space_available_buffer_perc}% (buffer)\" ) self.logger.critical(msg) raise InsufficientSpaceAvailable(msg) @staticmethod def _parse_version(device_output: str) -> str: \"\"\" Parse version string out of device output Args: device_output: output from show version command Returns: str: device version string Raises: N/A \"\"\" version_string_search = re.search(pattern=VERSION_PATTERN, string=device_output) if not version_string_search: return \"\" version_string = version_string_search.group(0) or \"\" return version_string def _reset_config_session(self) -> None: \"\"\" Reset config session info Resets the candidate config and config session name attributes -- when these are \"empty\" we know there is no current config session Args: N/A Returns: None Raises: N/A \"\"\" self.logger.debug(\"resetting candidate config and config session name\") self.candidate_config = \"\" self.candidate_config_filename = \"\" @staticmethod def _get_config_command(source: str) -> str: \"\"\" Return command to use to get config based on the provided source Args: source: name of the config source, generally running|startup Returns: str: command to use to fetch the requested config Raises: N/A \"\"\" if source == \"running\": return \"show running-config\" return \"show startup-config\" def _get_diff_command(self, source: str) -> str: \"\"\" Generate diff command based on source to diff and filesystem/candidate config name Args: source: config source to gen diff for Returns: str: command to use to diff the configuration Raises: N/A \"\"\" if self._replace: return ( f\"show diff rollback-patch {source}-config file {self.filesystem}\" f\"{self.candidate_config_filename}\" ) return \"\" def _prepare_config_payloads(self, config: str) -> str: \"\"\" Prepare a configuration so it can be nicely sent to the device via scrapli Args: config: configuration to prep Returns: str: string of config lines to write to candidate config file Raises: N/A \"\"\" # with the \"normal\" method (the way iosxe does this) it seems to want to stop at 250ish # lines... so this works but its kinda wonky... the actual lines we want to put in the text # file are enclosed in curly braces for tcl-reasons i guess tclsh_filesystem = f\"/{self.filesystem.strip(':')}/\" tclsh_start_file = f'set fl [open \"{tclsh_filesystem}{self.candidate_config_filename}\" wb+]' tcl_config = \"\\n\".join( [f\"puts -nonewline $fl {{{line}\\r}}\" for line in config.splitlines()] ) tclsh_end_file = \"close $fl\" final_config = \"\\n\".join((tclsh_start_file, tcl_config, tclsh_end_file)) return final_config def _prepare_load_config(self, config: str, replace: bool) -> str: \"\"\" Handle pre \"load_config\" operations for parity between sync and async Args: config: candidate config to load replace: True/False replace the configuration; passed here so it can be set at the class level as we need to stay in config mode and we need to know if we are doing a merge or a replace when we go to diff things Returns: str: string of config to write to candidate config file Raises: N/A \"\"\" self.candidate_config = config if not self.candidate_config_filename: self.candidate_config_filename = f\"scrapli_cfg_{round(datetime.now().timestamp())}\" self.logger.debug( f\"candidate config file name will be '{self.candidate_config_filename}'\" ) config = self._prepare_config_payloads(config=config) self._replace = replace return config def _normalize_source_candidate_configs(self, source_config: str) -> Tuple[str, str]: \"\"\" Normalize candidate config and source config so that we can easily diff them Args: source_config: current config of the source config store Returns: ScrapliCfgDiff: scrapli cfg diff object Raises: N/A \"\"\" self.logger.debug(\"normalizing source and candidate configs for diff object\") source_config = re.sub(pattern=OUTPUT_HEADER_PATTERN, string=source_config, repl=\"\") source_config = \"\\n\".join(line for line in source_config.splitlines() if line) candidate_config = re.sub(pattern=CHECKPOINT_LINE, string=self.candidate_config, repl=\"\") candidate_config = re.sub(pattern=OUTPUT_HEADER_PATTERN, string=candidate_config, repl=\"\") candidate_config = \"\\n\".join(line for line in candidate_config.splitlines() if line) return source_config, candidate_config def _pre_get_checkpoint(self) -> Tuple[ScrapliCfgResponse, List[str]]: \"\"\" Handle pre \"get_checkpoint\" operations for parity between sync and async Args: N/A Returns: list: list of commands needed to generate checkpoint and show it Raises: N/A \"\"\" self.logger.info(\"get_checkpoint requested\") tmp_timestamp = round(datetime.now().timestamp()) checkpoint_commands = [ \"terminal dont-ask\", f\"checkpoint file {self.filesystem}scrapli_cfg_tmp_{tmp_timestamp}\", f\"show file {self.filesystem}scrapli_cfg_tmp_{tmp_timestamp}\", f\"delete {self.filesystem}scrapli_cfg_tmp_{tmp_timestamp}\", ] response = ScrapliCfgResponse( host=self.conn.host, raise_for_status_exception=GetConfigError ) return response, checkpoint_commands Classes \u00b6 ScrapliCfgNXOSBase \u00b6 Expand source code class ScrapliCfgNXOSBase: logger: LoggerAdapter candidate_config: str candidate_config_filename: str _replace: bool filesystem: str _filesystem_space_available_buffer_perc: int conn: NetworkDriver def _post_get_filesystem_space_available(self, output: str) -> int: \"\"\" Handle post \"get_filesystem_space_available\" operations for parity between sync and async Args: output: output that was fetched from the device Returns: int: bytes of space available on filesystem Raises: FailedToFetchSpaceAvailable: if could not determine space available... duh :) \"\"\" self.logger.info(\"determining space available from device output\") bytes_available_match = re.search(pattern=BYTES_FREE, string=output) if not bytes_available_match: msg = \"could not determine space available on filesystem\" self.logger.critical(msg) raise FailedToFetchSpaceAvailable(msg) return int(bytes_available_match.groupdict()[\"bytes_available\"]) def _space_available(self, filesystem_bytes_available: int) -> None: \"\"\" Space available operations for parity between sync and async It seems that the length of the config is near enough 1:1 to the size it takes up on the disk... so roll w/ that plus a bit of buffer based on the available buffer perc Args: filesystem_bytes_available: bytes available on filesystem Returns: None Raises: InsufficientSpaceAvailable: if... insufficient space available.... \"\"\" if filesystem_bytes_available < ( len(self.candidate_config) / self._filesystem_space_available_buffer_perc ) + len(self.candidate_config): # filesystem has less than candidate config file size + 10% (by default) space, bail out msg = ( f\"insufficient space available for candidate config + \" f\"{self._filesystem_space_available_buffer_perc}% (buffer)\" ) self.logger.critical(msg) raise InsufficientSpaceAvailable(msg) @staticmethod def _parse_version(device_output: str) -> str: \"\"\" Parse version string out of device output Args: device_output: output from show version command Returns: str: device version string Raises: N/A \"\"\" version_string_search = re.search(pattern=VERSION_PATTERN, string=device_output) if not version_string_search: return \"\" version_string = version_string_search.group(0) or \"\" return version_string def _reset_config_session(self) -> None: \"\"\" Reset config session info Resets the candidate config and config session name attributes -- when these are \"empty\" we know there is no current config session Args: N/A Returns: None Raises: N/A \"\"\" self.logger.debug(\"resetting candidate config and config session name\") self.candidate_config = \"\" self.candidate_config_filename = \"\" @staticmethod def _get_config_command(source: str) -> str: \"\"\" Return command to use to get config based on the provided source Args: source: name of the config source, generally running|startup Returns: str: command to use to fetch the requested config Raises: N/A \"\"\" if source == \"running\": return \"show running-config\" return \"show startup-config\" def _get_diff_command(self, source: str) -> str: \"\"\" Generate diff command based on source to diff and filesystem/candidate config name Args: source: config source to gen diff for Returns: str: command to use to diff the configuration Raises: N/A \"\"\" if self._replace: return ( f\"show diff rollback-patch {source}-config file {self.filesystem}\" f\"{self.candidate_config_filename}\" ) return \"\" def _prepare_config_payloads(self, config: str) -> str: \"\"\" Prepare a configuration so it can be nicely sent to the device via scrapli Args: config: configuration to prep Returns: str: string of config lines to write to candidate config file Raises: N/A \"\"\" # with the \"normal\" method (the way iosxe does this) it seems to want to stop at 250ish # lines... so this works but its kinda wonky... the actual lines we want to put in the text # file are enclosed in curly braces for tcl-reasons i guess tclsh_filesystem = f\"/{self.filesystem.strip(':')}/\" tclsh_start_file = f'set fl [open \"{tclsh_filesystem}{self.candidate_config_filename}\" wb+]' tcl_config = \"\\n\".join( [f\"puts -nonewline $fl {{{line}\\r}}\" for line in config.splitlines()] ) tclsh_end_file = \"close $fl\" final_config = \"\\n\".join((tclsh_start_file, tcl_config, tclsh_end_file)) return final_config def _prepare_load_config(self, config: str, replace: bool) -> str: \"\"\" Handle pre \"load_config\" operations for parity between sync and async Args: config: candidate config to load replace: True/False replace the configuration; passed here so it can be set at the class level as we need to stay in config mode and we need to know if we are doing a merge or a replace when we go to diff things Returns: str: string of config to write to candidate config file Raises: N/A \"\"\" self.candidate_config = config if not self.candidate_config_filename: self.candidate_config_filename = f\"scrapli_cfg_{round(datetime.now().timestamp())}\" self.logger.debug( f\"candidate config file name will be '{self.candidate_config_filename}'\" ) config = self._prepare_config_payloads(config=config) self._replace = replace return config def _normalize_source_candidate_configs(self, source_config: str) -> Tuple[str, str]: \"\"\" Normalize candidate config and source config so that we can easily diff them Args: source_config: current config of the source config store Returns: ScrapliCfgDiff: scrapli cfg diff object Raises: N/A \"\"\" self.logger.debug(\"normalizing source and candidate configs for diff object\") source_config = re.sub(pattern=OUTPUT_HEADER_PATTERN, string=source_config, repl=\"\") source_config = \"\\n\".join(line for line in source_config.splitlines() if line) candidate_config = re.sub(pattern=CHECKPOINT_LINE, string=self.candidate_config, repl=\"\") candidate_config = re.sub(pattern=OUTPUT_HEADER_PATTERN, string=candidate_config, repl=\"\") candidate_config = \"\\n\".join(line for line in candidate_config.splitlines() if line) return source_config, candidate_config def _pre_get_checkpoint(self) -> Tuple[ScrapliCfgResponse, List[str]]: \"\"\" Handle pre \"get_checkpoint\" operations for parity between sync and async Args: N/A Returns: list: list of commands needed to generate checkpoint and show it Raises: N/A \"\"\" self.logger.info(\"get_checkpoint requested\") tmp_timestamp = round(datetime.now().timestamp()) checkpoint_commands = [ \"terminal dont-ask\", f\"checkpoint file {self.filesystem}scrapli_cfg_tmp_{tmp_timestamp}\", f\"show file {self.filesystem}scrapli_cfg_tmp_{tmp_timestamp}\", f\"delete {self.filesystem}scrapli_cfg_tmp_{tmp_timestamp}\", ] response = ScrapliCfgResponse( host=self.conn.host, raise_for_status_exception=GetConfigError ) return response, checkpoint_commands Descendants \u00b6 scrapli_cfg.platform.core.cisco_nxos.async_platform.AsyncScrapliCfgNXOS scrapli_cfg.platform.core.cisco_nxos.sync_platform.ScrapliCfgNXOS Class variables \u00b6 candidate_config: str candidate_config_filename: str conn: scrapli.driver.network.sync_driver.NetworkDriver filesystem: str logger: logging.LoggerAdapter","title":"Base platform"},{"location":"api_docs/platform/core/cisco_nxos/base_platform/#module-scrapli_cfgplatformcorecisco_nxosbase_platform","text":"scrapli_cfg.platform.core.cisco_nxos.base_platform Expand source code \"\"\"scrapli_cfg.platform.core.cisco_nxos.base_platform\"\"\" import re from datetime import datetime from logging import LoggerAdapter from typing import List, Tuple from scrapli.driver.network.sync_driver import NetworkDriver from scrapli_cfg.exceptions import ( FailedToFetchSpaceAvailable, GetConfigError, InsufficientSpaceAvailable, ) from scrapli_cfg.platform.core.cisco_nxos.patterns import ( BYTES_FREE, CHECKPOINT_LINE, OUTPUT_HEADER_PATTERN, VERSION_PATTERN, ) from scrapli_cfg.response import ScrapliCfgResponse CONFIG_SOURCES = [ \"running\", \"startup\", ] class ScrapliCfgNXOSBase: logger: LoggerAdapter candidate_config: str candidate_config_filename: str _replace: bool filesystem: str _filesystem_space_available_buffer_perc: int conn: NetworkDriver def _post_get_filesystem_space_available(self, output: str) -> int: \"\"\" Handle post \"get_filesystem_space_available\" operations for parity between sync and async Args: output: output that was fetched from the device Returns: int: bytes of space available on filesystem Raises: FailedToFetchSpaceAvailable: if could not determine space available... duh :) \"\"\" self.logger.info(\"determining space available from device output\") bytes_available_match = re.search(pattern=BYTES_FREE, string=output) if not bytes_available_match: msg = \"could not determine space available on filesystem\" self.logger.critical(msg) raise FailedToFetchSpaceAvailable(msg) return int(bytes_available_match.groupdict()[\"bytes_available\"]) def _space_available(self, filesystem_bytes_available: int) -> None: \"\"\" Space available operations for parity between sync and async It seems that the length of the config is near enough 1:1 to the size it takes up on the disk... so roll w/ that plus a bit of buffer based on the available buffer perc Args: filesystem_bytes_available: bytes available on filesystem Returns: None Raises: InsufficientSpaceAvailable: if... insufficient space available.... \"\"\" if filesystem_bytes_available < ( len(self.candidate_config) / self._filesystem_space_available_buffer_perc ) + len(self.candidate_config): # filesystem has less than candidate config file size + 10% (by default) space, bail out msg = ( f\"insufficient space available for candidate config + \" f\"{self._filesystem_space_available_buffer_perc}% (buffer)\" ) self.logger.critical(msg) raise InsufficientSpaceAvailable(msg) @staticmethod def _parse_version(device_output: str) -> str: \"\"\" Parse version string out of device output Args: device_output: output from show version command Returns: str: device version string Raises: N/A \"\"\" version_string_search = re.search(pattern=VERSION_PATTERN, string=device_output) if not version_string_search: return \"\" version_string = version_string_search.group(0) or \"\" return version_string def _reset_config_session(self) -> None: \"\"\" Reset config session info Resets the candidate config and config session name attributes -- when these are \"empty\" we know there is no current config session Args: N/A Returns: None Raises: N/A \"\"\" self.logger.debug(\"resetting candidate config and config session name\") self.candidate_config = \"\" self.candidate_config_filename = \"\" @staticmethod def _get_config_command(source: str) -> str: \"\"\" Return command to use to get config based on the provided source Args: source: name of the config source, generally running|startup Returns: str: command to use to fetch the requested config Raises: N/A \"\"\" if source == \"running\": return \"show running-config\" return \"show startup-config\" def _get_diff_command(self, source: str) -> str: \"\"\" Generate diff command based on source to diff and filesystem/candidate config name Args: source: config source to gen diff for Returns: str: command to use to diff the configuration Raises: N/A \"\"\" if self._replace: return ( f\"show diff rollback-patch {source}-config file {self.filesystem}\" f\"{self.candidate_config_filename}\" ) return \"\" def _prepare_config_payloads(self, config: str) -> str: \"\"\" Prepare a configuration so it can be nicely sent to the device via scrapli Args: config: configuration to prep Returns: str: string of config lines to write to candidate config file Raises: N/A \"\"\" # with the \"normal\" method (the way iosxe does this) it seems to want to stop at 250ish # lines... so this works but its kinda wonky... the actual lines we want to put in the text # file are enclosed in curly braces for tcl-reasons i guess tclsh_filesystem = f\"/{self.filesystem.strip(':')}/\" tclsh_start_file = f'set fl [open \"{tclsh_filesystem}{self.candidate_config_filename}\" wb+]' tcl_config = \"\\n\".join( [f\"puts -nonewline $fl {{{line}\\r}}\" for line in config.splitlines()] ) tclsh_end_file = \"close $fl\" final_config = \"\\n\".join((tclsh_start_file, tcl_config, tclsh_end_file)) return final_config def _prepare_load_config(self, config: str, replace: bool) -> str: \"\"\" Handle pre \"load_config\" operations for parity between sync and async Args: config: candidate config to load replace: True/False replace the configuration; passed here so it can be set at the class level as we need to stay in config mode and we need to know if we are doing a merge or a replace when we go to diff things Returns: str: string of config to write to candidate config file Raises: N/A \"\"\" self.candidate_config = config if not self.candidate_config_filename: self.candidate_config_filename = f\"scrapli_cfg_{round(datetime.now().timestamp())}\" self.logger.debug( f\"candidate config file name will be '{self.candidate_config_filename}'\" ) config = self._prepare_config_payloads(config=config) self._replace = replace return config def _normalize_source_candidate_configs(self, source_config: str) -> Tuple[str, str]: \"\"\" Normalize candidate config and source config so that we can easily diff them Args: source_config: current config of the source config store Returns: ScrapliCfgDiff: scrapli cfg diff object Raises: N/A \"\"\" self.logger.debug(\"normalizing source and candidate configs for diff object\") source_config = re.sub(pattern=OUTPUT_HEADER_PATTERN, string=source_config, repl=\"\") source_config = \"\\n\".join(line for line in source_config.splitlines() if line) candidate_config = re.sub(pattern=CHECKPOINT_LINE, string=self.candidate_config, repl=\"\") candidate_config = re.sub(pattern=OUTPUT_HEADER_PATTERN, string=candidate_config, repl=\"\") candidate_config = \"\\n\".join(line for line in candidate_config.splitlines() if line) return source_config, candidate_config def _pre_get_checkpoint(self) -> Tuple[ScrapliCfgResponse, List[str]]: \"\"\" Handle pre \"get_checkpoint\" operations for parity between sync and async Args: N/A Returns: list: list of commands needed to generate checkpoint and show it Raises: N/A \"\"\" self.logger.info(\"get_checkpoint requested\") tmp_timestamp = round(datetime.now().timestamp()) checkpoint_commands = [ \"terminal dont-ask\", f\"checkpoint file {self.filesystem}scrapli_cfg_tmp_{tmp_timestamp}\", f\"show file {self.filesystem}scrapli_cfg_tmp_{tmp_timestamp}\", f\"delete {self.filesystem}scrapli_cfg_tmp_{tmp_timestamp}\", ] response = ScrapliCfgResponse( host=self.conn.host, raise_for_status_exception=GetConfigError ) return response, checkpoint_commands","title":"Module scrapli_cfg.platform.core.cisco_nxos.base_platform"},{"location":"api_docs/platform/core/cisco_nxos/base_platform/#classes","text":"","title":"Classes"},{"location":"api_docs/platform/core/cisco_nxos/base_platform/#scraplicfgnxosbase","text":"Expand source code class ScrapliCfgNXOSBase: logger: LoggerAdapter candidate_config: str candidate_config_filename: str _replace: bool filesystem: str _filesystem_space_available_buffer_perc: int conn: NetworkDriver def _post_get_filesystem_space_available(self, output: str) -> int: \"\"\" Handle post \"get_filesystem_space_available\" operations for parity between sync and async Args: output: output that was fetched from the device Returns: int: bytes of space available on filesystem Raises: FailedToFetchSpaceAvailable: if could not determine space available... duh :) \"\"\" self.logger.info(\"determining space available from device output\") bytes_available_match = re.search(pattern=BYTES_FREE, string=output) if not bytes_available_match: msg = \"could not determine space available on filesystem\" self.logger.critical(msg) raise FailedToFetchSpaceAvailable(msg) return int(bytes_available_match.groupdict()[\"bytes_available\"]) def _space_available(self, filesystem_bytes_available: int) -> None: \"\"\" Space available operations for parity between sync and async It seems that the length of the config is near enough 1:1 to the size it takes up on the disk... so roll w/ that plus a bit of buffer based on the available buffer perc Args: filesystem_bytes_available: bytes available on filesystem Returns: None Raises: InsufficientSpaceAvailable: if... insufficient space available.... \"\"\" if filesystem_bytes_available < ( len(self.candidate_config) / self._filesystem_space_available_buffer_perc ) + len(self.candidate_config): # filesystem has less than candidate config file size + 10% (by default) space, bail out msg = ( f\"insufficient space available for candidate config + \" f\"{self._filesystem_space_available_buffer_perc}% (buffer)\" ) self.logger.critical(msg) raise InsufficientSpaceAvailable(msg) @staticmethod def _parse_version(device_output: str) -> str: \"\"\" Parse version string out of device output Args: device_output: output from show version command Returns: str: device version string Raises: N/A \"\"\" version_string_search = re.search(pattern=VERSION_PATTERN, string=device_output) if not version_string_search: return \"\" version_string = version_string_search.group(0) or \"\" return version_string def _reset_config_session(self) -> None: \"\"\" Reset config session info Resets the candidate config and config session name attributes -- when these are \"empty\" we know there is no current config session Args: N/A Returns: None Raises: N/A \"\"\" self.logger.debug(\"resetting candidate config and config session name\") self.candidate_config = \"\" self.candidate_config_filename = \"\" @staticmethod def _get_config_command(source: str) -> str: \"\"\" Return command to use to get config based on the provided source Args: source: name of the config source, generally running|startup Returns: str: command to use to fetch the requested config Raises: N/A \"\"\" if source == \"running\": return \"show running-config\" return \"show startup-config\" def _get_diff_command(self, source: str) -> str: \"\"\" Generate diff command based on source to diff and filesystem/candidate config name Args: source: config source to gen diff for Returns: str: command to use to diff the configuration Raises: N/A \"\"\" if self._replace: return ( f\"show diff rollback-patch {source}-config file {self.filesystem}\" f\"{self.candidate_config_filename}\" ) return \"\" def _prepare_config_payloads(self, config: str) -> str: \"\"\" Prepare a configuration so it can be nicely sent to the device via scrapli Args: config: configuration to prep Returns: str: string of config lines to write to candidate config file Raises: N/A \"\"\" # with the \"normal\" method (the way iosxe does this) it seems to want to stop at 250ish # lines... so this works but its kinda wonky... the actual lines we want to put in the text # file are enclosed in curly braces for tcl-reasons i guess tclsh_filesystem = f\"/{self.filesystem.strip(':')}/\" tclsh_start_file = f'set fl [open \"{tclsh_filesystem}{self.candidate_config_filename}\" wb+]' tcl_config = \"\\n\".join( [f\"puts -nonewline $fl {{{line}\\r}}\" for line in config.splitlines()] ) tclsh_end_file = \"close $fl\" final_config = \"\\n\".join((tclsh_start_file, tcl_config, tclsh_end_file)) return final_config def _prepare_load_config(self, config: str, replace: bool) -> str: \"\"\" Handle pre \"load_config\" operations for parity between sync and async Args: config: candidate config to load replace: True/False replace the configuration; passed here so it can be set at the class level as we need to stay in config mode and we need to know if we are doing a merge or a replace when we go to diff things Returns: str: string of config to write to candidate config file Raises: N/A \"\"\" self.candidate_config = config if not self.candidate_config_filename: self.candidate_config_filename = f\"scrapli_cfg_{round(datetime.now().timestamp())}\" self.logger.debug( f\"candidate config file name will be '{self.candidate_config_filename}'\" ) config = self._prepare_config_payloads(config=config) self._replace = replace return config def _normalize_source_candidate_configs(self, source_config: str) -> Tuple[str, str]: \"\"\" Normalize candidate config and source config so that we can easily diff them Args: source_config: current config of the source config store Returns: ScrapliCfgDiff: scrapli cfg diff object Raises: N/A \"\"\" self.logger.debug(\"normalizing source and candidate configs for diff object\") source_config = re.sub(pattern=OUTPUT_HEADER_PATTERN, string=source_config, repl=\"\") source_config = \"\\n\".join(line for line in source_config.splitlines() if line) candidate_config = re.sub(pattern=CHECKPOINT_LINE, string=self.candidate_config, repl=\"\") candidate_config = re.sub(pattern=OUTPUT_HEADER_PATTERN, string=candidate_config, repl=\"\") candidate_config = \"\\n\".join(line for line in candidate_config.splitlines() if line) return source_config, candidate_config def _pre_get_checkpoint(self) -> Tuple[ScrapliCfgResponse, List[str]]: \"\"\" Handle pre \"get_checkpoint\" operations for parity between sync and async Args: N/A Returns: list: list of commands needed to generate checkpoint and show it Raises: N/A \"\"\" self.logger.info(\"get_checkpoint requested\") tmp_timestamp = round(datetime.now().timestamp()) checkpoint_commands = [ \"terminal dont-ask\", f\"checkpoint file {self.filesystem}scrapli_cfg_tmp_{tmp_timestamp}\", f\"show file {self.filesystem}scrapli_cfg_tmp_{tmp_timestamp}\", f\"delete {self.filesystem}scrapli_cfg_tmp_{tmp_timestamp}\", ] response = ScrapliCfgResponse( host=self.conn.host, raise_for_status_exception=GetConfigError ) return response, checkpoint_commands","title":"ScrapliCfgNXOSBase"},{"location":"api_docs/platform/core/cisco_nxos/base_platform/#descendants","text":"scrapli_cfg.platform.core.cisco_nxos.async_platform.AsyncScrapliCfgNXOS scrapli_cfg.platform.core.cisco_nxos.sync_platform.ScrapliCfgNXOS","title":"Descendants"},{"location":"api_docs/platform/core/cisco_nxos/base_platform/#class-variables","text":"candidate_config: str candidate_config_filename: str conn: scrapli.driver.network.sync_driver.NetworkDriver filesystem: str logger: logging.LoggerAdapter","title":"Class variables"},{"location":"api_docs/platform/core/cisco_nxos/patterns/","text":"window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting()) Module scrapli_cfg.platform.core.cisco_nxos.patterns \u00b6 scrapli_cfg.platforms.cisco_nxos.patterns Expand source code \"\"\"scrapli_cfg.platforms.cisco_nxos.patterns\"\"\" import re VERSION_PATTERN = re.compile(pattern=r\"\\d+\\.[a-z0-9\\(\\)\\.]+\", flags=re.I) BYTES_FREE = re.compile(pattern=r\"(?P \\d+)(?: bytes free)\", flags=re.I) BUILD_CONFIG_PATTERN = re.compile(r\"(^!command:.*$)\", flags=re.I | re.M) CONFIG_VERSION_PATTERN = re.compile(r\"(^!running configuration last done.*$)\", flags=re.I | re.M) CONFIG_CHANGE_PATTERN = re.compile(r\"(^!time.*$)\", flags=re.I | re.M) OUTPUT_HEADER_PATTERN = re.compile( pattern=rf\"{BUILD_CONFIG_PATTERN.pattern}|\" rf\"{CONFIG_VERSION_PATTERN.pattern}|\" rf\"{CONFIG_CHANGE_PATTERN.pattern}\", flags=re.I | re.M, ) CHECKPOINT_LINE = re.compile(pattern=r\"^\\s*!#.*$\", flags=re.M)","title":"Patterns"},{"location":"api_docs/platform/core/cisco_nxos/patterns/#module-scrapli_cfgplatformcorecisco_nxospatterns","text":"scrapli_cfg.platforms.cisco_nxos.patterns Expand source code \"\"\"scrapli_cfg.platforms.cisco_nxos.patterns\"\"\" import re VERSION_PATTERN = re.compile(pattern=r\"\\d+\\.[a-z0-9\\(\\)\\.]+\", flags=re.I) BYTES_FREE = re.compile(pattern=r\"(?P \\d+)(?: bytes free)\", flags=re.I) BUILD_CONFIG_PATTERN = re.compile(r\"(^!command:.*$)\", flags=re.I | re.M) CONFIG_VERSION_PATTERN = re.compile(r\"(^!running configuration last done.*$)\", flags=re.I | re.M) CONFIG_CHANGE_PATTERN = re.compile(r\"(^!time.*$)\", flags=re.I | re.M) OUTPUT_HEADER_PATTERN = re.compile( pattern=rf\"{BUILD_CONFIG_PATTERN.pattern}|\" rf\"{CONFIG_VERSION_PATTERN.pattern}|\" rf\"{CONFIG_CHANGE_PATTERN.pattern}\", flags=re.I | re.M, ) CHECKPOINT_LINE = re.compile(pattern=r\"^\\s*!#.*$\", flags=re.M)","title":"Module scrapli_cfg.platform.core.cisco_nxos.patterns"},{"location":"api_docs/platform/core/cisco_nxos/sync_platform/","text":"window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting()) Module scrapli_cfg.platform.core.cisco_nxos.sync_platform \u00b6 scrapli_cfg.platform.core.cisco_nxos.sync_platform Expand source code \"\"\"scrapli_cfg.platform.core.cisco_nxos.sync_platform\"\"\" from typing import Any, Callable, List, Optional from scrapli.driver import NetworkDriver from scrapli.response import Response from scrapli_cfg.diff import ScrapliCfgDiffResponse from scrapli_cfg.exceptions import DiffConfigError, FailedToDetermineDeviceState from scrapli_cfg.platform.base.sync_platform import ScrapliCfgPlatform from scrapli_cfg.platform.core.cisco_nxos.base_platform import CONFIG_SOURCES, ScrapliCfgNXOSBase from scrapli_cfg.response import ScrapliCfgResponse def nxos_on_open(cls: ScrapliCfgPlatform) -> None: \"\"\" Scrapli CFG NXOS On open Disable console logging, perhaps more things in the future! Args: cls: ScrapliCfg object Returns: None Raises: N/A \"\"\" cls.conn.send_config(config=\"no logging monitor\") class ScrapliCfgNXOS(ScrapliCfgNXOSBase, ScrapliCfgPlatform): def __init__( self, conn: NetworkDriver, config_sources: Optional[List[str]] = None, on_open: Optional[Callable[..., Any]] = None, filesystem: str = \"bootflash:\", cleanup_post_commit: bool = True, ) -> None: if config_sources is None: config_sources = CONFIG_SOURCES if on_open is None: on_open = nxos_on_open super().__init__(conn=conn, config_sources=config_sources, on_open=on_open) self.filesystem = filesystem self._filesystem_space_available_buffer_perc = 10 self._replace = False self.candidate_config_filename = \"\" self.cleanup_post_commit = cleanup_post_commit self._get_version_command = 'show version | i \"NXOS: version\"' def _get_filesystem_space_available(self) -> int: \"\"\" Get available space on filesystem Args: N/A Returns: None Raises: FailedToDetermineDeviceState: if unable to fetch file filesystem bytes available \"\"\" filesystem_size_result = self.conn.send_command( command=f\"dir {self.filesystem} | i 'bytes free'\" ) if filesystem_size_result.failed: raise FailedToDetermineDeviceState(\"failed to determine space available on filesystem\") return self._post_get_filesystem_space_available(output=filesystem_size_result.result) def _delete_candidate_config(self) -> Response: \"\"\" Delete candidate config from the filesystem Args: N/A Returns: Response: response from deleting the candidate config Raises: N/A \"\"\" delete_commands = [ \"terminal dont-ask\", f\"delete {self.filesystem}{self.candidate_config_filename}\", ] delete_result = self.conn.send_commands(commands=delete_commands) return delete_result def get_checkpoint(self) -> ScrapliCfgResponse: \"\"\" Get device checkpoint file Args: N/A Returns: ScrapliCfgResponse: response object containing string of the target config source as the `result` attribute Raises: N/A \"\"\" response, checkpoint_commands = self._pre_get_checkpoint() checkpoint_results = self.conn.send_commands(commands=checkpoint_commands) try: checkpoint: str = checkpoint_results[2].result except IndexError: checkpoint = \"\" return self._post_get_config( response=response, source=\"running\", scrapli_responses=checkpoint_results, result=checkpoint, ) def get_config(self, source: str = \"running\") -> ScrapliCfgResponse: response = self._pre_get_config(source=source) config_result = self.conn.send_command(command=self._get_config_command(source=source)) return self._post_get_config( response=response, source=source, scrapli_responses=[config_result], result=config_result.result, ) def load_config(self, config: str, replace: bool = False, **kwargs: Any) -> ScrapliCfgResponse: \"\"\" Load configuration to a device Supported kwargs: N/A Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for nxos supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" response = self._pre_load_config(config=config) config = self._prepare_load_config(config=config, replace=replace) filesystem_bytes_available = self._get_filesystem_space_available() self._space_available(filesystem_bytes_available=filesystem_bytes_available) self.conn.acquire_priv(desired_priv=\"tclsh\") config_result = self.conn.send_config(config=config, privilege_level=\"tclsh\") self.conn.acquire_priv(desired_priv=self.conn.default_desired_privilege_level) return self._post_load_config( response=response, scrapli_responses=[config_result], ) def abort_config(self) -> ScrapliCfgResponse: response = self._pre_abort_config( session_or_config_file=bool(self.candidate_config_filename) ) abort_result = self._delete_candidate_config() self._reset_config_session() return self._post_abort_config(response=response, scrapli_responses=[abort_result]) def commit_config(self, source: str = \"running\") -> ScrapliCfgResponse: scrapli_responses = [] response = self._pre_commit_config( source=source, session_or_config_file=bool(self.candidate_config_filename) ) if self._replace is True: replace_command = ( f\"rollback running-config file {self.filesystem}{self.candidate_config_filename}\" ) commit_result = self.conn.send_command(command=replace_command) else: merge_command = f\"copy {self.filesystem}{self.candidate_config_filename} running-config\" commit_result = self.conn.send_command(command=merge_command) scrapli_responses.append(commit_result) save_config_result = self.conn.send_command(command=\"copy running-config startup-config\") scrapli_responses.append(save_config_result) if self.cleanup_post_commit: cleanup_result = self._delete_candidate_config() scrapli_responses.append(cleanup_result) self._reset_config_session() return self._post_load_config( response=response, scrapli_responses=scrapli_responses, ) def diff_config(self, source: str = \"running\") -> ScrapliCfgDiffResponse: scrapli_responses = [] device_diff = \"\" source_config = \"\" diff_response = self._pre_diff_config( source=source, session_or_config_file=bool(self.candidate_config_filename) ) try: diff_command = self._get_diff_command(source=source) if diff_command: diff_result = self.conn.send_command(command=diff_command) scrapli_responses.append(diff_result) if diff_result.failed: msg = \"failed generating diff for config session\" self.logger.critical(msg) raise DiffConfigError(msg) device_diff = diff_result.result else: device_diff = \"\" source_config_result = self.get_config(source=source) source_config = source_config_result.result if source_config_result.scrapli_responses: scrapli_responses.extend(source_config_result.scrapli_responses) if source_config_result.failed: msg = \"failed fetching source config for diff comparison\" self.logger.critical(msg) raise DiffConfigError(msg) except DiffConfigError: pass source_config, candidate_config = self._normalize_source_candidate_configs( source_config=source_config ) return self._post_diff_config( diff_response=diff_response, scrapli_responses=scrapli_responses, source_config=source_config, candidate_config=candidate_config, device_diff=device_diff, ) Functions \u00b6 nxos_on_open \u00b6 nxos_on_open(cls: scrapli_cfg.platform.base.sync_platform.ScrapliCfgPlatform) \u2011> NoneType Scrapli CFG NXOS On open Disable console logging, perhaps more things in the future! Args: cls: ScrapliCfg object Returns: None Raises: N/A Classes \u00b6 ScrapliCfgNXOS \u00b6 Helper class that provides a standard way to create an ABC using inheritance. Expand source code class ScrapliCfgNXOS(ScrapliCfgNXOSBase, ScrapliCfgPlatform): def __init__( self, conn: NetworkDriver, config_sources: Optional[List[str]] = None, on_open: Optional[Callable[..., Any]] = None, filesystem: str = \"bootflash:\", cleanup_post_commit: bool = True, ) -> None: if config_sources is None: config_sources = CONFIG_SOURCES if on_open is None: on_open = nxos_on_open super().__init__(conn=conn, config_sources=config_sources, on_open=on_open) self.filesystem = filesystem self._filesystem_space_available_buffer_perc = 10 self._replace = False self.candidate_config_filename = \"\" self.cleanup_post_commit = cleanup_post_commit self._get_version_command = 'show version | i \"NXOS: version\"' def _get_filesystem_space_available(self) -> int: \"\"\" Get available space on filesystem Args: N/A Returns: None Raises: FailedToDetermineDeviceState: if unable to fetch file filesystem bytes available \"\"\" filesystem_size_result = self.conn.send_command( command=f\"dir {self.filesystem} | i 'bytes free'\" ) if filesystem_size_result.failed: raise FailedToDetermineDeviceState(\"failed to determine space available on filesystem\") return self._post_get_filesystem_space_available(output=filesystem_size_result.result) def _delete_candidate_config(self) -> Response: \"\"\" Delete candidate config from the filesystem Args: N/A Returns: Response: response from deleting the candidate config Raises: N/A \"\"\" delete_commands = [ \"terminal dont-ask\", f\"delete {self.filesystem}{self.candidate_config_filename}\", ] delete_result = self.conn.send_commands(commands=delete_commands) return delete_result def get_checkpoint(self) -> ScrapliCfgResponse: \"\"\" Get device checkpoint file Args: N/A Returns: ScrapliCfgResponse: response object containing string of the target config source as the `result` attribute Raises: N/A \"\"\" response, checkpoint_commands = self._pre_get_checkpoint() checkpoint_results = self.conn.send_commands(commands=checkpoint_commands) try: checkpoint: str = checkpoint_results[2].result except IndexError: checkpoint = \"\" return self._post_get_config( response=response, source=\"running\", scrapli_responses=checkpoint_results, result=checkpoint, ) def get_config(self, source: str = \"running\") -> ScrapliCfgResponse: response = self._pre_get_config(source=source) config_result = self.conn.send_command(command=self._get_config_command(source=source)) return self._post_get_config( response=response, source=source, scrapli_responses=[config_result], result=config_result.result, ) def load_config(self, config: str, replace: bool = False, **kwargs: Any) -> ScrapliCfgResponse: \"\"\" Load configuration to a device Supported kwargs: N/A Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for nxos supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" response = self._pre_load_config(config=config) config = self._prepare_load_config(config=config, replace=replace) filesystem_bytes_available = self._get_filesystem_space_available() self._space_available(filesystem_bytes_available=filesystem_bytes_available) self.conn.acquire_priv(desired_priv=\"tclsh\") config_result = self.conn.send_config(config=config, privilege_level=\"tclsh\") self.conn.acquire_priv(desired_priv=self.conn.default_desired_privilege_level) return self._post_load_config( response=response, scrapli_responses=[config_result], ) def abort_config(self) -> ScrapliCfgResponse: response = self._pre_abort_config( session_or_config_file=bool(self.candidate_config_filename) ) abort_result = self._delete_candidate_config() self._reset_config_session() return self._post_abort_config(response=response, scrapli_responses=[abort_result]) def commit_config(self, source: str = \"running\") -> ScrapliCfgResponse: scrapli_responses = [] response = self._pre_commit_config( source=source, session_or_config_file=bool(self.candidate_config_filename) ) if self._replace is True: replace_command = ( f\"rollback running-config file {self.filesystem}{self.candidate_config_filename}\" ) commit_result = self.conn.send_command(command=replace_command) else: merge_command = f\"copy {self.filesystem}{self.candidate_config_filename} running-config\" commit_result = self.conn.send_command(command=merge_command) scrapli_responses.append(commit_result) save_config_result = self.conn.send_command(command=\"copy running-config startup-config\") scrapli_responses.append(save_config_result) if self.cleanup_post_commit: cleanup_result = self._delete_candidate_config() scrapli_responses.append(cleanup_result) self._reset_config_session() return self._post_load_config( response=response, scrapli_responses=scrapli_responses, ) def diff_config(self, source: str = \"running\") -> ScrapliCfgDiffResponse: scrapli_responses = [] device_diff = \"\" source_config = \"\" diff_response = self._pre_diff_config( source=source, session_or_config_file=bool(self.candidate_config_filename) ) try: diff_command = self._get_diff_command(source=source) if diff_command: diff_result = self.conn.send_command(command=diff_command) scrapli_responses.append(diff_result) if diff_result.failed: msg = \"failed generating diff for config session\" self.logger.critical(msg) raise DiffConfigError(msg) device_diff = diff_result.result else: device_diff = \"\" source_config_result = self.get_config(source=source) source_config = source_config_result.result if source_config_result.scrapli_responses: scrapli_responses.extend(source_config_result.scrapli_responses) if source_config_result.failed: msg = \"failed fetching source config for diff comparison\" self.logger.critical(msg) raise DiffConfigError(msg) except DiffConfigError: pass source_config, candidate_config = self._normalize_source_candidate_configs( source_config=source_config ) return self._post_diff_config( diff_response=diff_response, scrapli_responses=scrapli_responses, source_config=source_config, candidate_config=candidate_config, device_diff=device_diff, ) Ancestors (in MRO) \u00b6 scrapli_cfg.platform.core.cisco_nxos.base_platform.ScrapliCfgNXOSBase scrapli_cfg.platform.base.sync_platform.ScrapliCfgPlatform abc.ABC scrapli_cfg.platform.base.base_platform.ScrapliCfgBase Class variables \u00b6 candidate_config: str candidate_config_filename: str conn: scrapli.driver.network.sync_driver.NetworkDriver filesystem: str logger: logging.LoggerAdapter Methods \u00b6 get_checkpoint \u00b6 get_checkpoint(self) \u2011> scrapli_cfg.response.ScrapliCfgResponse Get device checkpoint file Args: N/A Returns: ScrapliCfgResponse: response object containing string of the target config source as the `result` attribute Raises: N/A load_config \u00b6 load_config(self, config: str, replace: bool = False, **kwargs: Any) \u2011> scrapli_cfg.response.ScrapliCfgResponse Load configuration to a device Supported kwargs: N/A Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for nxos supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A","title":"Sync Platform"},{"location":"api_docs/platform/core/cisco_nxos/sync_platform/#module-scrapli_cfgplatformcorecisco_nxossync_platform","text":"scrapli_cfg.platform.core.cisco_nxos.sync_platform Expand source code \"\"\"scrapli_cfg.platform.core.cisco_nxos.sync_platform\"\"\" from typing import Any, Callable, List, Optional from scrapli.driver import NetworkDriver from scrapli.response import Response from scrapli_cfg.diff import ScrapliCfgDiffResponse from scrapli_cfg.exceptions import DiffConfigError, FailedToDetermineDeviceState from scrapli_cfg.platform.base.sync_platform import ScrapliCfgPlatform from scrapli_cfg.platform.core.cisco_nxos.base_platform import CONFIG_SOURCES, ScrapliCfgNXOSBase from scrapli_cfg.response import ScrapliCfgResponse def nxos_on_open(cls: ScrapliCfgPlatform) -> None: \"\"\" Scrapli CFG NXOS On open Disable console logging, perhaps more things in the future! Args: cls: ScrapliCfg object Returns: None Raises: N/A \"\"\" cls.conn.send_config(config=\"no logging monitor\") class ScrapliCfgNXOS(ScrapliCfgNXOSBase, ScrapliCfgPlatform): def __init__( self, conn: NetworkDriver, config_sources: Optional[List[str]] = None, on_open: Optional[Callable[..., Any]] = None, filesystem: str = \"bootflash:\", cleanup_post_commit: bool = True, ) -> None: if config_sources is None: config_sources = CONFIG_SOURCES if on_open is None: on_open = nxos_on_open super().__init__(conn=conn, config_sources=config_sources, on_open=on_open) self.filesystem = filesystem self._filesystem_space_available_buffer_perc = 10 self._replace = False self.candidate_config_filename = \"\" self.cleanup_post_commit = cleanup_post_commit self._get_version_command = 'show version | i \"NXOS: version\"' def _get_filesystem_space_available(self) -> int: \"\"\" Get available space on filesystem Args: N/A Returns: None Raises: FailedToDetermineDeviceState: if unable to fetch file filesystem bytes available \"\"\" filesystem_size_result = self.conn.send_command( command=f\"dir {self.filesystem} | i 'bytes free'\" ) if filesystem_size_result.failed: raise FailedToDetermineDeviceState(\"failed to determine space available on filesystem\") return self._post_get_filesystem_space_available(output=filesystem_size_result.result) def _delete_candidate_config(self) -> Response: \"\"\" Delete candidate config from the filesystem Args: N/A Returns: Response: response from deleting the candidate config Raises: N/A \"\"\" delete_commands = [ \"terminal dont-ask\", f\"delete {self.filesystem}{self.candidate_config_filename}\", ] delete_result = self.conn.send_commands(commands=delete_commands) return delete_result def get_checkpoint(self) -> ScrapliCfgResponse: \"\"\" Get device checkpoint file Args: N/A Returns: ScrapliCfgResponse: response object containing string of the target config source as the `result` attribute Raises: N/A \"\"\" response, checkpoint_commands = self._pre_get_checkpoint() checkpoint_results = self.conn.send_commands(commands=checkpoint_commands) try: checkpoint: str = checkpoint_results[2].result except IndexError: checkpoint = \"\" return self._post_get_config( response=response, source=\"running\", scrapli_responses=checkpoint_results, result=checkpoint, ) def get_config(self, source: str = \"running\") -> ScrapliCfgResponse: response = self._pre_get_config(source=source) config_result = self.conn.send_command(command=self._get_config_command(source=source)) return self._post_get_config( response=response, source=source, scrapli_responses=[config_result], result=config_result.result, ) def load_config(self, config: str, replace: bool = False, **kwargs: Any) -> ScrapliCfgResponse: \"\"\" Load configuration to a device Supported kwargs: N/A Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for nxos supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" response = self._pre_load_config(config=config) config = self._prepare_load_config(config=config, replace=replace) filesystem_bytes_available = self._get_filesystem_space_available() self._space_available(filesystem_bytes_available=filesystem_bytes_available) self.conn.acquire_priv(desired_priv=\"tclsh\") config_result = self.conn.send_config(config=config, privilege_level=\"tclsh\") self.conn.acquire_priv(desired_priv=self.conn.default_desired_privilege_level) return self._post_load_config( response=response, scrapli_responses=[config_result], ) def abort_config(self) -> ScrapliCfgResponse: response = self._pre_abort_config( session_or_config_file=bool(self.candidate_config_filename) ) abort_result = self._delete_candidate_config() self._reset_config_session() return self._post_abort_config(response=response, scrapli_responses=[abort_result]) def commit_config(self, source: str = \"running\") -> ScrapliCfgResponse: scrapli_responses = [] response = self._pre_commit_config( source=source, session_or_config_file=bool(self.candidate_config_filename) ) if self._replace is True: replace_command = ( f\"rollback running-config file {self.filesystem}{self.candidate_config_filename}\" ) commit_result = self.conn.send_command(command=replace_command) else: merge_command = f\"copy {self.filesystem}{self.candidate_config_filename} running-config\" commit_result = self.conn.send_command(command=merge_command) scrapli_responses.append(commit_result) save_config_result = self.conn.send_command(command=\"copy running-config startup-config\") scrapli_responses.append(save_config_result) if self.cleanup_post_commit: cleanup_result = self._delete_candidate_config() scrapli_responses.append(cleanup_result) self._reset_config_session() return self._post_load_config( response=response, scrapli_responses=scrapli_responses, ) def diff_config(self, source: str = \"running\") -> ScrapliCfgDiffResponse: scrapli_responses = [] device_diff = \"\" source_config = \"\" diff_response = self._pre_diff_config( source=source, session_or_config_file=bool(self.candidate_config_filename) ) try: diff_command = self._get_diff_command(source=source) if diff_command: diff_result = self.conn.send_command(command=diff_command) scrapli_responses.append(diff_result) if diff_result.failed: msg = \"failed generating diff for config session\" self.logger.critical(msg) raise DiffConfigError(msg) device_diff = diff_result.result else: device_diff = \"\" source_config_result = self.get_config(source=source) source_config = source_config_result.result if source_config_result.scrapli_responses: scrapli_responses.extend(source_config_result.scrapli_responses) if source_config_result.failed: msg = \"failed fetching source config for diff comparison\" self.logger.critical(msg) raise DiffConfigError(msg) except DiffConfigError: pass source_config, candidate_config = self._normalize_source_candidate_configs( source_config=source_config ) return self._post_diff_config( diff_response=diff_response, scrapli_responses=scrapli_responses, source_config=source_config, candidate_config=candidate_config, device_diff=device_diff, )","title":"Module scrapli_cfg.platform.core.cisco_nxos.sync_platform"},{"location":"api_docs/platform/core/cisco_nxos/sync_platform/#functions","text":"","title":"Functions"},{"location":"api_docs/platform/core/cisco_nxos/sync_platform/#nxos_on_open","text":"nxos_on_open(cls: scrapli_cfg.platform.base.sync_platform.ScrapliCfgPlatform) \u2011> NoneType Scrapli CFG NXOS On open Disable console logging, perhaps more things in the future! Args: cls: ScrapliCfg object Returns: None Raises: N/A","title":"nxos_on_open"},{"location":"api_docs/platform/core/cisco_nxos/sync_platform/#classes","text":"","title":"Classes"},{"location":"api_docs/platform/core/cisco_nxos/sync_platform/#scraplicfgnxos","text":"Helper class that provides a standard way to create an ABC using inheritance. Expand source code class ScrapliCfgNXOS(ScrapliCfgNXOSBase, ScrapliCfgPlatform): def __init__( self, conn: NetworkDriver, config_sources: Optional[List[str]] = None, on_open: Optional[Callable[..., Any]] = None, filesystem: str = \"bootflash:\", cleanup_post_commit: bool = True, ) -> None: if config_sources is None: config_sources = CONFIG_SOURCES if on_open is None: on_open = nxos_on_open super().__init__(conn=conn, config_sources=config_sources, on_open=on_open) self.filesystem = filesystem self._filesystem_space_available_buffer_perc = 10 self._replace = False self.candidate_config_filename = \"\" self.cleanup_post_commit = cleanup_post_commit self._get_version_command = 'show version | i \"NXOS: version\"' def _get_filesystem_space_available(self) -> int: \"\"\" Get available space on filesystem Args: N/A Returns: None Raises: FailedToDetermineDeviceState: if unable to fetch file filesystem bytes available \"\"\" filesystem_size_result = self.conn.send_command( command=f\"dir {self.filesystem} | i 'bytes free'\" ) if filesystem_size_result.failed: raise FailedToDetermineDeviceState(\"failed to determine space available on filesystem\") return self._post_get_filesystem_space_available(output=filesystem_size_result.result) def _delete_candidate_config(self) -> Response: \"\"\" Delete candidate config from the filesystem Args: N/A Returns: Response: response from deleting the candidate config Raises: N/A \"\"\" delete_commands = [ \"terminal dont-ask\", f\"delete {self.filesystem}{self.candidate_config_filename}\", ] delete_result = self.conn.send_commands(commands=delete_commands) return delete_result def get_checkpoint(self) -> ScrapliCfgResponse: \"\"\" Get device checkpoint file Args: N/A Returns: ScrapliCfgResponse: response object containing string of the target config source as the `result` attribute Raises: N/A \"\"\" response, checkpoint_commands = self._pre_get_checkpoint() checkpoint_results = self.conn.send_commands(commands=checkpoint_commands) try: checkpoint: str = checkpoint_results[2].result except IndexError: checkpoint = \"\" return self._post_get_config( response=response, source=\"running\", scrapli_responses=checkpoint_results, result=checkpoint, ) def get_config(self, source: str = \"running\") -> ScrapliCfgResponse: response = self._pre_get_config(source=source) config_result = self.conn.send_command(command=self._get_config_command(source=source)) return self._post_get_config( response=response, source=source, scrapli_responses=[config_result], result=config_result.result, ) def load_config(self, config: str, replace: bool = False, **kwargs: Any) -> ScrapliCfgResponse: \"\"\" Load configuration to a device Supported kwargs: N/A Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for nxos supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" response = self._pre_load_config(config=config) config = self._prepare_load_config(config=config, replace=replace) filesystem_bytes_available = self._get_filesystem_space_available() self._space_available(filesystem_bytes_available=filesystem_bytes_available) self.conn.acquire_priv(desired_priv=\"tclsh\") config_result = self.conn.send_config(config=config, privilege_level=\"tclsh\") self.conn.acquire_priv(desired_priv=self.conn.default_desired_privilege_level) return self._post_load_config( response=response, scrapli_responses=[config_result], ) def abort_config(self) -> ScrapliCfgResponse: response = self._pre_abort_config( session_or_config_file=bool(self.candidate_config_filename) ) abort_result = self._delete_candidate_config() self._reset_config_session() return self._post_abort_config(response=response, scrapli_responses=[abort_result]) def commit_config(self, source: str = \"running\") -> ScrapliCfgResponse: scrapli_responses = [] response = self._pre_commit_config( source=source, session_or_config_file=bool(self.candidate_config_filename) ) if self._replace is True: replace_command = ( f\"rollback running-config file {self.filesystem}{self.candidate_config_filename}\" ) commit_result = self.conn.send_command(command=replace_command) else: merge_command = f\"copy {self.filesystem}{self.candidate_config_filename} running-config\" commit_result = self.conn.send_command(command=merge_command) scrapli_responses.append(commit_result) save_config_result = self.conn.send_command(command=\"copy running-config startup-config\") scrapli_responses.append(save_config_result) if self.cleanup_post_commit: cleanup_result = self._delete_candidate_config() scrapli_responses.append(cleanup_result) self._reset_config_session() return self._post_load_config( response=response, scrapli_responses=scrapli_responses, ) def diff_config(self, source: str = \"running\") -> ScrapliCfgDiffResponse: scrapli_responses = [] device_diff = \"\" source_config = \"\" diff_response = self._pre_diff_config( source=source, session_or_config_file=bool(self.candidate_config_filename) ) try: diff_command = self._get_diff_command(source=source) if diff_command: diff_result = self.conn.send_command(command=diff_command) scrapli_responses.append(diff_result) if diff_result.failed: msg = \"failed generating diff for config session\" self.logger.critical(msg) raise DiffConfigError(msg) device_diff = diff_result.result else: device_diff = \"\" source_config_result = self.get_config(source=source) source_config = source_config_result.result if source_config_result.scrapli_responses: scrapli_responses.extend(source_config_result.scrapli_responses) if source_config_result.failed: msg = \"failed fetching source config for diff comparison\" self.logger.critical(msg) raise DiffConfigError(msg) except DiffConfigError: pass source_config, candidate_config = self._normalize_source_candidate_configs( source_config=source_config ) return self._post_diff_config( diff_response=diff_response, scrapli_responses=scrapli_responses, source_config=source_config, candidate_config=candidate_config, device_diff=device_diff, )","title":"ScrapliCfgNXOS"},{"location":"api_docs/platform/core/cisco_nxos/sync_platform/#ancestors-in-mro","text":"scrapli_cfg.platform.core.cisco_nxos.base_platform.ScrapliCfgNXOSBase scrapli_cfg.platform.base.sync_platform.ScrapliCfgPlatform abc.ABC scrapli_cfg.platform.base.base_platform.ScrapliCfgBase","title":"Ancestors (in MRO)"},{"location":"api_docs/platform/core/cisco_nxos/sync_platform/#class-variables","text":"candidate_config: str candidate_config_filename: str conn: scrapli.driver.network.sync_driver.NetworkDriver filesystem: str logger: logging.LoggerAdapter","title":"Class variables"},{"location":"api_docs/platform/core/cisco_nxos/sync_platform/#methods","text":"","title":"Methods"},{"location":"api_docs/platform/core/cisco_nxos/sync_platform/#get_checkpoint","text":"get_checkpoint(self) \u2011> scrapli_cfg.response.ScrapliCfgResponse Get device checkpoint file Args: N/A Returns: ScrapliCfgResponse: response object containing string of the target config source as the `result` attribute Raises: N/A","title":"get_checkpoint"},{"location":"api_docs/platform/core/cisco_nxos/sync_platform/#load_config","text":"load_config(self, config: str, replace: bool = False, **kwargs: Any) \u2011> scrapli_cfg.response.ScrapliCfgResponse Load configuration to a device Supported kwargs: N/A Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for nxos supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A","title":"load_config"},{"location":"more_scrapli/nornir_scrapli/","text":"Nornir scrapli \u00b6 If you want to use scrapli, but don't want to deal with handling concurrency yourself, there is great news! The nornir_scrapli plugin allows you to use scrapli (and scrapli netconf) within the Nornir framework!","title":"Nornir Scrapli"},{"location":"more_scrapli/nornir_scrapli/#nornir-scrapli","text":"If you want to use scrapli, but don't want to deal with handling concurrency yourself, there is great news! The nornir_scrapli plugin allows you to use scrapli (and scrapli netconf) within the Nornir framework!","title":"Nornir scrapli"},{"location":"more_scrapli/scrapli/","text":"scrapli \u00b6 scrapli ( docs ) is the \"parent\" library on which scrapli_cfg is built. Check it out if you need to connect to devices with telnet or ssh!","title":"Scrapli"},{"location":"more_scrapli/scrapli/#scrapli","text":"scrapli ( docs ) is the \"parent\" library on which scrapli_cfg is built. Check it out if you need to connect to devices with telnet or ssh!","title":"scrapli"},{"location":"more_scrapli/scrapli_community/","text":"scrapli Community \u00b6 If you would like to use scrapli, but the platform(s) that you work with are not supported in the \"core\" scrapli platforms, you should check out scrapli_community ! This is the place for users to share \"non-core\" scrapli platforms.","title":"Scrapli Community"},{"location":"more_scrapli/scrapli_community/#scrapli-community","text":"If you would like to use scrapli, but the platform(s) that you work with are not supported in the \"core\" scrapli platforms, you should check out scrapli_community ! This is the place for users to share \"non-core\" scrapli platforms.","title":"scrapli Community"},{"location":"more_scrapli/scrapli_netconf/","text":"scrapli Netconf \u00b6 scrapli_netconf ( docs ) is a netconf driver built on top of scrapli. The purpose of scrapli_netconf is to provide a fast, flexible, thoroughly tested, well typed, well documented, simple API that supports both synchronous and asynchronous usage. Working together scrapli and scrapli_netconf aim to provide a consistent (as is practical) look and feel when automating devices over telnet, SSH, or netconf (over SSH).","title":"Scrapli Netconf"},{"location":"more_scrapli/scrapli_netconf/#scrapli-netconf","text":"scrapli_netconf ( docs ) is a netconf driver built on top of scrapli. The purpose of scrapli_netconf is to provide a fast, flexible, thoroughly tested, well typed, well documented, simple API that supports both synchronous and asynchronous usage. Working together scrapli and scrapli_netconf aim to provide a consistent (as is practical) look and feel when automating devices over telnet, SSH, or netconf (over SSH).","title":"scrapli Netconf"},{"location":"more_scrapli/scrapli_stubs/","text":"scrapli Stubs \u00b6 Do you REALLY love typing and scrapli? Great news, type stubs for scrapli are generated periodically and updated here , enjoy!","title":"Scrapli Stubs"},{"location":"more_scrapli/scrapli_stubs/#scrapli-stubs","text":"Do you REALLY love typing and scrapli? Great news, type stubs for scrapli are generated periodically and updated here , enjoy!","title":"scrapli Stubs"},{"location":"user_guide/basic_usage/","text":"Basic Usage \u00b6 Picking the right Driver \u00b6 When using scrapli_cfg, you will need to ensure that you are building a scrapli_cfg object specific to the target device. You can create your connection object directly from the appropriate scrapli_cfg class, i.e., ScrapliCfgIOSXE , or you can use the \"factory\" function to appropriately dispatch the class type based on a provided platform string argument. A simple example of creating a scrapli_cfg object by both methods is below: from scrapli import Scrapli from scrapli_cfg.platform.core.cisco_iosxe import ScrapliCfgIOSXE from scrapli_cfg import ScrapliCfg device = { \"host\" : \"172.18.0.11\" , \"auth_username\" : \"vrnetlab\" , \"auth_password\" : \"VR-netlab9\" , \"auth_strict_key\" : False , \"platform\" : \"cisco_iosxe\" } conn = Scrapli ( ** device ) cfg_conn_from_specific_platform_class = ScrapliCfgIOSXE ( conn = conn ) cfg_conn_from_factory = ScrapliCfg ( platform = \"cisco_iosxe\" , conn = conn ) The available platform names are: arista_eos cisco_iosxe cisco_iosxr cisco_nxos juniper_junos (coming soon!) Driver Arguments \u00b6 scrapli_cfg doesn't have a lot of options/arguments that you need to worry about! The most important argument is the conn argument -- which is expecting a scrapli connection that is built from the NetworkDriver . This connection must be from one of the \"core\" scrapli platforms (EOS, IOSXE, IOSXR, NXOS, JunOS). There are no additional required arguments for creating a scrapli_cfg object (unless using the factory, then you need to pass a \"platform\" argument as well), though each platform may have other optional arguments as necessary -- check the docs/class for those. scrapli_cfg Methods \u00b6 scrapli_cfg methods are mostly intended at managing device configuration, though there are a few extra methods in there as well. The following sections provide a brief description and example of how to use all of the main public methods. Note that nearly all public methods in scrapli_cfg will return a ScrapliCfgResponse object that will contain a result attribute of the result of the given task, as well as the underlying scrapli Response object, and the usual scrapli attributes like start/finish/elapsed time, a failed attribute, and a raise_for_status method. Get Version \u00b6 The get_version method does exactly what you would expect it to -- it fetches the version string from the target device. scrapli_cfg very intentionally has no \"getters\" (in the NAPALM-sense) except for get_version and get_config -- this is because there is no desire to maintain support for getters across a huge variety of versions/platforms. That said, the get_version method was implemented in order to (obviously) fetch device versions to (in the future) be used to validate the target device version supports all features that scrapli_cfg needs in order to manage the configurations. A simple example of fetching and printing the device version: from scrapli import Scrapli from scrapli_cfg import ScrapliCfg device = { \"host\" : \"172.18.0.11\" , \"auth_username\" : \"vrnetlab\" , \"auth_password\" : \"VR-netlab9\" , \"auth_strict_key\" : False , \"platform\" : \"cisco_iosxe\" } conn = Scrapli ( ** device ) cfg_conn = ScrapliCfg ( platform = \"cisco_iosxe\" , conn = conn ) cfg_conn . open () version_result = cfg_conn . get_version () print ( version_result . result ) Get Config \u00b6 The get_config method does exactly what you would think it does, it fetches the device configuration as a string. This method supports a source argument to which you can provide a string representing the source config you would like to get -- generally this will be either \"startup\" or \"running\". A simple example of fetching and printing the device startup configuration: from scrapli import Scrapli from scrapli_cfg import ScrapliCfg device = { \"host\" : \"172.18.0.11\" , \"auth_username\" : \"vrnetlab\" , \"auth_password\" : \"VR-netlab9\" , \"auth_strict_key\" : False , \"platform\" : \"cisco_iosxe\" } conn = Scrapli ( ** device ) cfg_conn = ScrapliCfg ( platform = \"cisco_iosxe\" , conn = conn ) cfg_conn . open () cfg_result = cfg_conn . get_config ( source = \"startup\" ) print ( cfg_result . result ) Get Checkpoint (NXOS Only) \u00b6 NXOS can be a little... difficult with configuration replacement operations. It expects to be fed \"checkpoint\" files instead of \"normal\" configuration text. In order to make life a bit easier the NXOS platform supports a get_checkpoint method that fetches a checkpoint file from the device. This is basically the same overall behavior as get_config , just resulting in fetching a checkpoint file. Some details about checkpoints can be found here . A simple example of fetching and printing a checkpoint file from an NXOS device: from scrapli import Scrapli from scrapli_cfg import ScrapliCfg device = { \"host\" : \"172.18.0.12\" , \"auth_username\" : \"vrnetlab\" , \"auth_password\" : \"VR-netlab9\" , \"auth_strict_key\" : False , \"platform\" : \"cisco_nxos\" } conn = Scrapli ( ** device ) cfg_conn = ScrapliCfg ( platform = \"cisco_nxos\" , conn = conn ) cfg_conn . open () chkpoint_result = cfg_conn . get_checkpoint () print ( chkpoint_result . result ) Load Config \u00b6 Another, hopefully very obviously named method! load_config does what it sounds like. load_config accepts a configuration to load (as a string; note that if you are doing config replace with NXOS you should use a checkpoint file!), optionally a bool indicating if the operation is a \"replace\" operation (default is False it is a merge operation), and lastly some optional keyword arguments that vary from platform to platform. If replace is False (default) then the config will be loaded as a merge candidate, otherwise it will be loaded as a full replace candidate. from scrapli import Scrapli from scrapli_cfg import ScrapliCfg with open ( \"config\" , \"r\" ) as f : my_config = f . read () device = { \"host\" : \"172.18.0.11\" , \"auth_username\" : \"vrnetlab\" , \"auth_password\" : \"VR-netlab9\" , \"auth_strict_key\" : False , \"platform\" : \"cisco_iosxe\" } conn = Scrapli ( ** device ) cfg_conn = ScrapliCfg ( platform = \"cisco_iosxe\" , conn = conn ) cfg_conn . open () load_result = cfg_conn . load_config ( config = my_config , replace = True ) print ( load_result ) Note that loading a configuration does not apply the configuration! This simply will create a configuration session or a file on the device (depending on the specific platform type) that can be used to merge/replace the config. Abort Config \u00b6 If you've loaded a configuration but don't want to commit it, you can call abort_config which will delete the candidate config/delete config sessions used to load the config. from scrapli import Scrapli from scrapli_cfg import ScrapliCfg with open ( \"config\" , \"r\" ) as f : my_config = f . read () device = { \"host\" : \"172.18.0.11\" , \"auth_username\" : \"vrnetlab\" , \"auth_password\" : \"VR-netlab9\" , \"auth_strict_key\" : False , \"platform\" : \"cisco_iosxe\" } conn = Scrapli ( ** device ) cfg_conn = ScrapliCfg ( platform = \"cisco_iosxe\" , conn = conn ) cfg_conn . open () load_result = cfg_conn . load_config ( config = my_config , replace = True ) print ( load_result ) abort_result = cfg_conn . abort_config () print ( abort_result ) Commit Config \u00b6 If you've loaded a config and want to save/commit it you can do so with the commit_config method: from scrapli import Scrapli from scrapli_cfg import ScrapliCfg with open ( \"config\" , \"r\" ) as f : my_config = f . read () device = { \"host\" : \"172.18.0.11\" , \"auth_username\" : \"vrnetlab\" , \"auth_password\" : \"VR-netlab9\" , \"auth_strict_key\" : False , \"platform\" : \"cisco_iosxe\" } conn = Scrapli ( ** device ) cfg_conn = ScrapliCfg ( platform = \"cisco_iosxe\" , conn = conn ) cfg_conn . open () load_result = cfg_conn . load_config ( config = my_config , replace = True ) print ( load_result ) commit_result = cfg_conn . commit_config () print ( commit_result ) Diff Config \u00b6 Perhaps the most interesting/handy method of all: diff_config ! Just like the other methods, this method does exactly what it sounds like it would. There is one important difference between this method and the others, however; the diff_config method returns a ScrapliCfgDiffResponse object instead of a ScrapliCfgResponse object. The ScrapliCfgDiffResponse object is mostly the same as a normal scrapli_cfg response, but it also contains some properties that contain the diff output. scrapli_cfg always tries to get a diff from the device itself -- from whatever means are available on box, but also builds some basic diffs of its own. The diffs that scrapli_cfg builds are fairly simple and will show the difference between the candidate config and the target config, but will have no context about merge vs replace operations, so the diff will always show the \"full\" configuration diff (with colorful output though!). You can see each of the diffs like so: from scrapli import Scrapli from scrapli_cfg import ScrapliCfg with open ( \"config\" , \"r\" ) as f : my_config = f . read () device = { \"host\" : \"172.18.0.11\" , \"auth_username\" : \"vrnetlab\" , \"auth_password\" : \"VR-netlab9\" , \"auth_strict_key\" : False , \"platform\" : \"cisco_iosxe\" } conn = Scrapli ( ** device ) cfg_conn = ScrapliCfg ( platform = \"cisco_iosxe\" , conn = conn ) cfg_conn . open () load_result = cfg_conn . load_config ( config = my_config , replace = True ) print ( load_result ) diff_result = cfg_conn . diff_config () print ( diff_result . device_diff ) print ( diff_result . unified_diff ) print ( diff_result . side_by_side_diff ) Render Substituted Config \u00b6 The render_substituted_config method is used to (based on user provided regex) auto merge a candidate configuration with sections of the current device configuration. This is meant to allow users an easy-ish way to start doing config replace operations, without having to have a template that covers all aspects of the device configuration. For example, let's say you want to manage everything on a switch except the interfaces. Maybe you want to do this because managing loads of templates for all the different types of interfaces/platforms is a pain, or maybe a different team manages that part of the config... whatever the case you want to be able to do full config replaces, but leave that part of the config completely untouched. This is what the render_substitued_config method is designed to help you with. Here is an example of using this method: from scrapli import Scrapli from scrapli_cfg import ScrapliCfg from scrapli_cfg.platform.core.arista_eos.patterns import ETHERNET_INTERFACES with open ( \"config\" , \"r\" ) as f : my_config = f . read () device = { \"host\" : \"172.18.0.14\" , \"auth_username\" : \"vrnetlab\" , \"auth_password\" : \"VR-netlab9\" , \"auth_strict_key\" : False , \"platform\" : \"arista_eos\" } conn = Scrapli ( ** device ) cfg_conn = ScrapliCfg ( platform = \"arista_eos\" , conn = conn ) cfg_conn . open () rendered_config = cfg_conn . render_substituted_config ( config_template = my_config , substitutes = [( \"ethernet_interfaces\" , ETHERNET_INTERFACES )] ) load_result = cfg_conn . load_config ( config = my_config , replace = True ) print ( load_result ) In the above example we have a fairly \"normal\" scrapli_cfg setup -- create a connection and open it. Once the connection is opened we call the render_substituted_config and we pass a config_template and a list of substitutes to it. The config template is what it sounds like -- a template (that looks like a jinja2 template). In this case, this template has a variable ethernet_interfaces in the file where the ethernet interfaces would go, so instead of something like this: username vrnetlab role network-admin secret sha512 $6$8zrJ4ESW2fqG2QqH$9u768TvLXXDeUJmG2Std71EX1ip6q4MoJrMwDng1cmpuSYc9ECWytRjvXpMH7C3dzSdoEv0MxAUiAZeeTre3h. ! interface Ethernet 1 description tacocat ! << SNIP >> interface Management1 We have something like this: username vrnetlab role network-admin secret sha512 $6$8zrJ4ESW2fqG2QqH$9u768TvLXXDeUJmG2Std71EX1ip6q4MoJrMwDng1cmpuSYc9ECWytRjvXpMH7C3dzSdoEv0MxAUiAZeeTre3h. ! {{ ethernet_interfaces }} interface Management1 The substitutes we passed into the render_substituted_config method is a list of tuples, where the first item in the tuple is the variable we want to replace ( ethernet_interfaces in this case) and the second value is a regular expression that matches the section of the real running config that we want to put into this variable. Ultimately, using this example, if we had a \"real\" running configuration containing the following interface section (just using one interface to keep things simple) that looked like this: username vrnetlab role network-admin secret sha512 $6$8zrJ4ESW2fqG2QqH$9u768TvLXXDeUJmG2Std71EX1ip6q4MoJrMwDng1cmpuSYc9ECWytRjvXpMH7C3dzSdoEv0MxAUiAZeeTre3h. ! interface Ethernet 1 description tacocat ! interface Management1 Our rendered template would end up looking just like that. Again, the point of this method is to allow you to more easily do configuration replaces without having to fully template out device configs. The obvious downside to this method is that it may require fairly complicated regular expressions in order to properly slice and dice the real config.","title":"Basic Usage"},{"location":"user_guide/basic_usage/#basic-usage","text":"","title":"Basic Usage"},{"location":"user_guide/basic_usage/#picking-the-right-driver","text":"When using scrapli_cfg, you will need to ensure that you are building a scrapli_cfg object specific to the target device. You can create your connection object directly from the appropriate scrapli_cfg class, i.e., ScrapliCfgIOSXE , or you can use the \"factory\" function to appropriately dispatch the class type based on a provided platform string argument. A simple example of creating a scrapli_cfg object by both methods is below: from scrapli import Scrapli from scrapli_cfg.platform.core.cisco_iosxe import ScrapliCfgIOSXE from scrapli_cfg import ScrapliCfg device = { \"host\" : \"172.18.0.11\" , \"auth_username\" : \"vrnetlab\" , \"auth_password\" : \"VR-netlab9\" , \"auth_strict_key\" : False , \"platform\" : \"cisco_iosxe\" } conn = Scrapli ( ** device ) cfg_conn_from_specific_platform_class = ScrapliCfgIOSXE ( conn = conn ) cfg_conn_from_factory = ScrapliCfg ( platform = \"cisco_iosxe\" , conn = conn ) The available platform names are: arista_eos cisco_iosxe cisco_iosxr cisco_nxos juniper_junos (coming soon!)","title":"Picking the right Driver"},{"location":"user_guide/basic_usage/#driver-arguments","text":"scrapli_cfg doesn't have a lot of options/arguments that you need to worry about! The most important argument is the conn argument -- which is expecting a scrapli connection that is built from the NetworkDriver . This connection must be from one of the \"core\" scrapli platforms (EOS, IOSXE, IOSXR, NXOS, JunOS). There are no additional required arguments for creating a scrapli_cfg object (unless using the factory, then you need to pass a \"platform\" argument as well), though each platform may have other optional arguments as necessary -- check the docs/class for those.","title":"Driver Arguments"},{"location":"user_guide/basic_usage/#scrapli_cfg-methods","text":"scrapli_cfg methods are mostly intended at managing device configuration, though there are a few extra methods in there as well. The following sections provide a brief description and example of how to use all of the main public methods. Note that nearly all public methods in scrapli_cfg will return a ScrapliCfgResponse object that will contain a result attribute of the result of the given task, as well as the underlying scrapli Response object, and the usual scrapli attributes like start/finish/elapsed time, a failed attribute, and a raise_for_status method.","title":"scrapli_cfg Methods"},{"location":"user_guide/basic_usage/#get-version","text":"The get_version method does exactly what you would expect it to -- it fetches the version string from the target device. scrapli_cfg very intentionally has no \"getters\" (in the NAPALM-sense) except for get_version and get_config -- this is because there is no desire to maintain support for getters across a huge variety of versions/platforms. That said, the get_version method was implemented in order to (obviously) fetch device versions to (in the future) be used to validate the target device version supports all features that scrapli_cfg needs in order to manage the configurations. A simple example of fetching and printing the device version: from scrapli import Scrapli from scrapli_cfg import ScrapliCfg device = { \"host\" : \"172.18.0.11\" , \"auth_username\" : \"vrnetlab\" , \"auth_password\" : \"VR-netlab9\" , \"auth_strict_key\" : False , \"platform\" : \"cisco_iosxe\" } conn = Scrapli ( ** device ) cfg_conn = ScrapliCfg ( platform = \"cisco_iosxe\" , conn = conn ) cfg_conn . open () version_result = cfg_conn . get_version () print ( version_result . result )","title":"Get Version"},{"location":"user_guide/basic_usage/#get-config","text":"The get_config method does exactly what you would think it does, it fetches the device configuration as a string. This method supports a source argument to which you can provide a string representing the source config you would like to get -- generally this will be either \"startup\" or \"running\". A simple example of fetching and printing the device startup configuration: from scrapli import Scrapli from scrapli_cfg import ScrapliCfg device = { \"host\" : \"172.18.0.11\" , \"auth_username\" : \"vrnetlab\" , \"auth_password\" : \"VR-netlab9\" , \"auth_strict_key\" : False , \"platform\" : \"cisco_iosxe\" } conn = Scrapli ( ** device ) cfg_conn = ScrapliCfg ( platform = \"cisco_iosxe\" , conn = conn ) cfg_conn . open () cfg_result = cfg_conn . get_config ( source = \"startup\" ) print ( cfg_result . result )","title":"Get Config"},{"location":"user_guide/basic_usage/#get-checkpoint-nxos-only","text":"NXOS can be a little... difficult with configuration replacement operations. It expects to be fed \"checkpoint\" files instead of \"normal\" configuration text. In order to make life a bit easier the NXOS platform supports a get_checkpoint method that fetches a checkpoint file from the device. This is basically the same overall behavior as get_config , just resulting in fetching a checkpoint file. Some details about checkpoints can be found here . A simple example of fetching and printing a checkpoint file from an NXOS device: from scrapli import Scrapli from scrapli_cfg import ScrapliCfg device = { \"host\" : \"172.18.0.12\" , \"auth_username\" : \"vrnetlab\" , \"auth_password\" : \"VR-netlab9\" , \"auth_strict_key\" : False , \"platform\" : \"cisco_nxos\" } conn = Scrapli ( ** device ) cfg_conn = ScrapliCfg ( platform = \"cisco_nxos\" , conn = conn ) cfg_conn . open () chkpoint_result = cfg_conn . get_checkpoint () print ( chkpoint_result . result )","title":"Get Checkpoint (NXOS Only)"},{"location":"user_guide/basic_usage/#load-config","text":"Another, hopefully very obviously named method! load_config does what it sounds like. load_config accepts a configuration to load (as a string; note that if you are doing config replace with NXOS you should use a checkpoint file!), optionally a bool indicating if the operation is a \"replace\" operation (default is False it is a merge operation), and lastly some optional keyword arguments that vary from platform to platform. If replace is False (default) then the config will be loaded as a merge candidate, otherwise it will be loaded as a full replace candidate. from scrapli import Scrapli from scrapli_cfg import ScrapliCfg with open ( \"config\" , \"r\" ) as f : my_config = f . read () device = { \"host\" : \"172.18.0.11\" , \"auth_username\" : \"vrnetlab\" , \"auth_password\" : \"VR-netlab9\" , \"auth_strict_key\" : False , \"platform\" : \"cisco_iosxe\" } conn = Scrapli ( ** device ) cfg_conn = ScrapliCfg ( platform = \"cisco_iosxe\" , conn = conn ) cfg_conn . open () load_result = cfg_conn . load_config ( config = my_config , replace = True ) print ( load_result ) Note that loading a configuration does not apply the configuration! This simply will create a configuration session or a file on the device (depending on the specific platform type) that can be used to merge/replace the config.","title":"Load Config"},{"location":"user_guide/basic_usage/#abort-config","text":"If you've loaded a configuration but don't want to commit it, you can call abort_config which will delete the candidate config/delete config sessions used to load the config. from scrapli import Scrapli from scrapli_cfg import ScrapliCfg with open ( \"config\" , \"r\" ) as f : my_config = f . read () device = { \"host\" : \"172.18.0.11\" , \"auth_username\" : \"vrnetlab\" , \"auth_password\" : \"VR-netlab9\" , \"auth_strict_key\" : False , \"platform\" : \"cisco_iosxe\" } conn = Scrapli ( ** device ) cfg_conn = ScrapliCfg ( platform = \"cisco_iosxe\" , conn = conn ) cfg_conn . open () load_result = cfg_conn . load_config ( config = my_config , replace = True ) print ( load_result ) abort_result = cfg_conn . abort_config () print ( abort_result )","title":"Abort Config"},{"location":"user_guide/basic_usage/#commit-config","text":"If you've loaded a config and want to save/commit it you can do so with the commit_config method: from scrapli import Scrapli from scrapli_cfg import ScrapliCfg with open ( \"config\" , \"r\" ) as f : my_config = f . read () device = { \"host\" : \"172.18.0.11\" , \"auth_username\" : \"vrnetlab\" , \"auth_password\" : \"VR-netlab9\" , \"auth_strict_key\" : False , \"platform\" : \"cisco_iosxe\" } conn = Scrapli ( ** device ) cfg_conn = ScrapliCfg ( platform = \"cisco_iosxe\" , conn = conn ) cfg_conn . open () load_result = cfg_conn . load_config ( config = my_config , replace = True ) print ( load_result ) commit_result = cfg_conn . commit_config () print ( commit_result )","title":"Commit Config"},{"location":"user_guide/basic_usage/#diff-config","text":"Perhaps the most interesting/handy method of all: diff_config ! Just like the other methods, this method does exactly what it sounds like it would. There is one important difference between this method and the others, however; the diff_config method returns a ScrapliCfgDiffResponse object instead of a ScrapliCfgResponse object. The ScrapliCfgDiffResponse object is mostly the same as a normal scrapli_cfg response, but it also contains some properties that contain the diff output. scrapli_cfg always tries to get a diff from the device itself -- from whatever means are available on box, but also builds some basic diffs of its own. The diffs that scrapli_cfg builds are fairly simple and will show the difference between the candidate config and the target config, but will have no context about merge vs replace operations, so the diff will always show the \"full\" configuration diff (with colorful output though!). You can see each of the diffs like so: from scrapli import Scrapli from scrapli_cfg import ScrapliCfg with open ( \"config\" , \"r\" ) as f : my_config = f . read () device = { \"host\" : \"172.18.0.11\" , \"auth_username\" : \"vrnetlab\" , \"auth_password\" : \"VR-netlab9\" , \"auth_strict_key\" : False , \"platform\" : \"cisco_iosxe\" } conn = Scrapli ( ** device ) cfg_conn = ScrapliCfg ( platform = \"cisco_iosxe\" , conn = conn ) cfg_conn . open () load_result = cfg_conn . load_config ( config = my_config , replace = True ) print ( load_result ) diff_result = cfg_conn . diff_config () print ( diff_result . device_diff ) print ( diff_result . unified_diff ) print ( diff_result . side_by_side_diff )","title":"Diff Config"},{"location":"user_guide/basic_usage/#render-substituted-config","text":"The render_substituted_config method is used to (based on user provided regex) auto merge a candidate configuration with sections of the current device configuration. This is meant to allow users an easy-ish way to start doing config replace operations, without having to have a template that covers all aspects of the device configuration. For example, let's say you want to manage everything on a switch except the interfaces. Maybe you want to do this because managing loads of templates for all the different types of interfaces/platforms is a pain, or maybe a different team manages that part of the config... whatever the case you want to be able to do full config replaces, but leave that part of the config completely untouched. This is what the render_substitued_config method is designed to help you with. Here is an example of using this method: from scrapli import Scrapli from scrapli_cfg import ScrapliCfg from scrapli_cfg.platform.core.arista_eos.patterns import ETHERNET_INTERFACES with open ( \"config\" , \"r\" ) as f : my_config = f . read () device = { \"host\" : \"172.18.0.14\" , \"auth_username\" : \"vrnetlab\" , \"auth_password\" : \"VR-netlab9\" , \"auth_strict_key\" : False , \"platform\" : \"arista_eos\" } conn = Scrapli ( ** device ) cfg_conn = ScrapliCfg ( platform = \"arista_eos\" , conn = conn ) cfg_conn . open () rendered_config = cfg_conn . render_substituted_config ( config_template = my_config , substitutes = [( \"ethernet_interfaces\" , ETHERNET_INTERFACES )] ) load_result = cfg_conn . load_config ( config = my_config , replace = True ) print ( load_result ) In the above example we have a fairly \"normal\" scrapli_cfg setup -- create a connection and open it. Once the connection is opened we call the render_substituted_config and we pass a config_template and a list of substitutes to it. The config template is what it sounds like -- a template (that looks like a jinja2 template). In this case, this template has a variable ethernet_interfaces in the file where the ethernet interfaces would go, so instead of something like this: username vrnetlab role network-admin secret sha512 $6$8zrJ4ESW2fqG2QqH$9u768TvLXXDeUJmG2Std71EX1ip6q4MoJrMwDng1cmpuSYc9ECWytRjvXpMH7C3dzSdoEv0MxAUiAZeeTre3h. ! interface Ethernet 1 description tacocat ! << SNIP >> interface Management1 We have something like this: username vrnetlab role network-admin secret sha512 $6$8zrJ4ESW2fqG2QqH$9u768TvLXXDeUJmG2Std71EX1ip6q4MoJrMwDng1cmpuSYc9ECWytRjvXpMH7C3dzSdoEv0MxAUiAZeeTre3h. ! {{ ethernet_interfaces }} interface Management1 The substitutes we passed into the render_substituted_config method is a list of tuples, where the first item in the tuple is the variable we want to replace ( ethernet_interfaces in this case) and the second value is a regular expression that matches the section of the real running config that we want to put into this variable. Ultimately, using this example, if we had a \"real\" running configuration containing the following interface section (just using one interface to keep things simple) that looked like this: username vrnetlab role network-admin secret sha512 $6$8zrJ4ESW2fqG2QqH$9u768TvLXXDeUJmG2Std71EX1ip6q4MoJrMwDng1cmpuSYc9ECWytRjvXpMH7C3dzSdoEv0MxAUiAZeeTre3h. ! interface Ethernet 1 description tacocat ! interface Management1 Our rendered template would end up looking just like that. Again, the point of this method is to allow you to more easily do configuration replaces without having to fully template out device configs. The obvious downside to this method is that it may require fairly complicated regular expressions in order to properly slice and dice the real config.","title":"Render Substituted Config"},{"location":"user_guide/installation/","text":"Installation \u00b6 Standard Installation \u00b6 As outlined in the quick start, you should be able to pip install scrapli \"normally\": pip install scrapli-cfg Installing current master branch \u00b6 To install from the source repositories master branch: pip install git+https://github.com/scrapli/scrapli_cfg Installing current develop branch \u00b6 To install from the source repositories develop branch: pip install - e git + https : // github . com / scrapli / scrapli_cfg . git @develop #egg = scrapli_cfg Installation from Source \u00b6 To install from source: git clone https://github.com/scrapli/scrapli_cfg cd scrapli_cfg python setup.py install Supported Platforms \u00b6 As for platforms to run scrapli on -- it has and will be tested on MacOS and Ubuntu regularly and should work on any POSIX system. Windows at one point was being tested very minimally via GitHub Actions builds, however this is no longer the case as it is just not worth the effort. While scrapli should work on Windows when using the paramiko or ssh2-python transport drivers, it is not \"officially\" supported. It is strongly recommended/preferred for folks to use WSL/Cygwin instead of Windows.","title":"Installation"},{"location":"user_guide/installation/#installation","text":"","title":"Installation"},{"location":"user_guide/installation/#standard-installation","text":"As outlined in the quick start, you should be able to pip install scrapli \"normally\": pip install scrapli-cfg","title":"Standard Installation"},{"location":"user_guide/installation/#installing-current-master-branch","text":"To install from the source repositories master branch: pip install git+https://github.com/scrapli/scrapli_cfg","title":"Installing current master branch"},{"location":"user_guide/installation/#installing-current-develop-branch","text":"To install from the source repositories develop branch: pip install - e git + https : // github . com / scrapli / scrapli_cfg . git @develop #egg = scrapli_cfg","title":"Installing current develop branch"},{"location":"user_guide/installation/#installation-from-source","text":"To install from source: git clone https://github.com/scrapli/scrapli_cfg cd scrapli_cfg python setup.py install","title":"Installation from Source"},{"location":"user_guide/installation/#supported-platforms","text":"As for platforms to run scrapli on -- it has and will be tested on MacOS and Ubuntu regularly and should work on any POSIX system. Windows at one point was being tested very minimally via GitHub Actions builds, however this is no longer the case as it is just not worth the effort. While scrapli should work on Windows when using the paramiko or ssh2-python transport drivers, it is not \"officially\" supported. It is strongly recommended/preferred for folks to use WSL/Cygwin instead of Windows.","title":"Supported Platforms"},{"location":"user_guide/project_details/","text":"Project Details \u00b6 What is scrapli_cfg \u00b6 scrapli_cfg is a library that sits \"on top\" of scrapli \"core\" and makes merging or replacing device configurations over Telnet or SSH easy. Why over Telnet or SSH? Because you pretty much will always have one of these options available to you, whereas you may not have eAPI or NETCONF ready and enabled (think day zero provisioning, or crazy security requirements locking down ports). So its like NAPALM? \u00b6 If you are familiar with the configuration management abilities of the excellent NAPALM library then you are already generally familiar with what scrapli_cfg is capable of. The primary differences between scrapli_cfg and NAPALM are as follows: scrapli_cfg has, and never will (unless I change my mind), have \"getters\" outside the \"get_config\" and \"get_version\" getters. This means there will not be anything like \"get_interfaces\" in scrapli_cfg. scrapli_cfg has no dependency on any APIs being available -- configurations are all handled via Telnet or SSH. This may sound \"bad\" because the cli is so \"bad\", but it means that there are no requirements for additional ports to be opened or services to be enabled (i.e. eAPI or NETCONF), it even means (with a bit of work) you could use scrapli_cfg to fully manage device configuration over console connections. scrapli_cfg has no Python dependencies other than scrapli -- this means there are no vendor libraries necessary, no eznc, no pyeapi, and no pyiosxr. Fewer dependencies isn't a huge deal, but it does mean that the scrapli community is fully \"in control\" of all requirements which is pretty nice! scrapli_cfg, just like \"normal\" scrapli provides supports both synchronous and asynchronous code with the same API scrapli_cfg, provides a render_substituted_config method that helps you easily merge templated configurations with real device configuration -- so you can do \"full config replace\" without having to template out every last line of config! Supported Platforms \u00b6 Just like scrapli \"core\", scrapli_cfg covers the \"core\" NAPALM platforms -- Cisco IOS-XE, IOS-XR, NX-OS, Arista EOS, and Juniper JunOS (eventually, no JunOS support just yet). Below are the core driver platforms and regularly tested version. Cisco IOS-XE (tested on: 16.12.03) Cisco NX-OS (tested on: 9.2.4) Juniper JunOS (tested on: 17.3R2.10) Cisco IOS-XR (tested on: 6.5.3) Arista EOS (tested on: 4.22.1F) Specific platform support requirements are listed below. Arista EOS \u00b6 scrapli_cfg uses configuration sessions in EOS, this feature was added somewhere around the 4.14 release. Early versions of EOS that support configuration sessions did not allow configuration sessions to be aborted from privilege exec, the clear_config_sessions will not work on these versions, however all other scrapli_cfg features should work. Cisco IOSXE \u00b6 IOSXE behavior is very similar to NAPALM, using the archive feature to help with config management and diffs, as such scrapli_cfg requires IOS versions > 12.4(20)T -- all IOSXE versions should be supported (please open an issue or find me on Slack/Twitter if this is incorrect!). Cisco IOSXR \u00b6 scrapli_cfg has worked on every IOSXR version that it has been tested on -- due to IOSXR natively supporting configuration merging/replacing this should work on most IOSXR devices. Cisco NXOS \u00b6 scrapli_cfg should work on most versions of NXOS, there is no requirement for NX-API, instead scrapli_cfg simply relies on the tclsh. Juniper JunOS \u00b6 JunOS is not supported... yet ... this section will updated when support is added!","title":"Project Details"},{"location":"user_guide/project_details/#project-details","text":"","title":"Project Details"},{"location":"user_guide/project_details/#what-is-scrapli_cfg","text":"scrapli_cfg is a library that sits \"on top\" of scrapli \"core\" and makes merging or replacing device configurations over Telnet or SSH easy. Why over Telnet or SSH? Because you pretty much will always have one of these options available to you, whereas you may not have eAPI or NETCONF ready and enabled (think day zero provisioning, or crazy security requirements locking down ports).","title":"What is scrapli_cfg"},{"location":"user_guide/project_details/#so-its-like-napalm","text":"If you are familiar with the configuration management abilities of the excellent NAPALM library then you are already generally familiar with what scrapli_cfg is capable of. The primary differences between scrapli_cfg and NAPALM are as follows: scrapli_cfg has, and never will (unless I change my mind), have \"getters\" outside the \"get_config\" and \"get_version\" getters. This means there will not be anything like \"get_interfaces\" in scrapli_cfg. scrapli_cfg has no dependency on any APIs being available -- configurations are all handled via Telnet or SSH. This may sound \"bad\" because the cli is so \"bad\", but it means that there are no requirements for additional ports to be opened or services to be enabled (i.e. eAPI or NETCONF), it even means (with a bit of work) you could use scrapli_cfg to fully manage device configuration over console connections. scrapli_cfg has no Python dependencies other than scrapli -- this means there are no vendor libraries necessary, no eznc, no pyeapi, and no pyiosxr. Fewer dependencies isn't a huge deal, but it does mean that the scrapli community is fully \"in control\" of all requirements which is pretty nice! scrapli_cfg, just like \"normal\" scrapli provides supports both synchronous and asynchronous code with the same API scrapli_cfg, provides a render_substituted_config method that helps you easily merge templated configurations with real device configuration -- so you can do \"full config replace\" without having to template out every last line of config!","title":"So its like NAPALM?"},{"location":"user_guide/project_details/#supported-platforms","text":"Just like scrapli \"core\", scrapli_cfg covers the \"core\" NAPALM platforms -- Cisco IOS-XE, IOS-XR, NX-OS, Arista EOS, and Juniper JunOS (eventually, no JunOS support just yet). Below are the core driver platforms and regularly tested version. Cisco IOS-XE (tested on: 16.12.03) Cisco NX-OS (tested on: 9.2.4) Juniper JunOS (tested on: 17.3R2.10) Cisco IOS-XR (tested on: 6.5.3) Arista EOS (tested on: 4.22.1F) Specific platform support requirements are listed below.","title":"Supported Platforms"},{"location":"user_guide/project_details/#arista-eos","text":"scrapli_cfg uses configuration sessions in EOS, this feature was added somewhere around the 4.14 release. Early versions of EOS that support configuration sessions did not allow configuration sessions to be aborted from privilege exec, the clear_config_sessions will not work on these versions, however all other scrapli_cfg features should work.","title":"Arista EOS"},{"location":"user_guide/project_details/#cisco-iosxe","text":"IOSXE behavior is very similar to NAPALM, using the archive feature to help with config management and diffs, as such scrapli_cfg requires IOS versions > 12.4(20)T -- all IOSXE versions should be supported (please open an issue or find me on Slack/Twitter if this is incorrect!).","title":"Cisco IOSXE"},{"location":"user_guide/project_details/#cisco-iosxr","text":"scrapli_cfg has worked on every IOSXR version that it has been tested on -- due to IOSXR natively supporting configuration merging/replacing this should work on most IOSXR devices.","title":"Cisco IOSXR"},{"location":"user_guide/project_details/#cisco-nxos","text":"scrapli_cfg should work on most versions of NXOS, there is no requirement for NX-API, instead scrapli_cfg simply relies on the tclsh.","title":"Cisco NXOS"},{"location":"user_guide/project_details/#juniper-junos","text":"JunOS is not supported... yet ... this section will updated when support is added!","title":"Juniper JunOS"},{"location":"user_guide/quickstart/","text":"Quick Start Guide \u00b6 Installation \u00b6 In most cases installation via pip is the simplest and best way to install scrapli_cfg. See here for advanced installation details. pip install scrapli-cfg A Simple Example \u00b6 from scrapli import Scrapli from scrapli_cfg import ScrapliCfg device = { \"host\" : \"172.18.0.11\" , \"auth_username\" : \"vrnetlab\" , \"auth_password\" : \"VR-netlab9\" , \"auth_strict_key\" : False , \"platform\" : \"cisco_iosxe\" } with open ( \"myconfig\" , \"r\" ) as f : my_config = f . read () conn = Scrapli ( ** device ) cfg_conn = ScrapliCfg ( platform = conn [ \"platform\" ], conn = conn ) cfg_conn . open () cfg_conn . load_config ( config = my_config , replace = True ) diff = cfg_conn . diff_config () print ( diff . side_by_side_diff ) cfg_conn . commit_config () cfg_conn . close () More Examples \u00b6 Basic Usage Selective Configuration Replace","title":"Quick Start Guide"},{"location":"user_guide/quickstart/#quick-start-guide","text":"","title":"Quick Start Guide"},{"location":"user_guide/quickstart/#installation","text":"In most cases installation via pip is the simplest and best way to install scrapli_cfg. See here for advanced installation details. pip install scrapli-cfg","title":"Installation"},{"location":"user_guide/quickstart/#a-simple-example","text":"from scrapli import Scrapli from scrapli_cfg import ScrapliCfg device = { \"host\" : \"172.18.0.11\" , \"auth_username\" : \"vrnetlab\" , \"auth_password\" : \"VR-netlab9\" , \"auth_strict_key\" : False , \"platform\" : \"cisco_iosxe\" } with open ( \"myconfig\" , \"r\" ) as f : my_config = f . read () conn = Scrapli ( ** device ) cfg_conn = ScrapliCfg ( platform = conn [ \"platform\" ], conn = conn ) cfg_conn . open () cfg_conn . load_config ( config = my_config , replace = True ) diff = cfg_conn . diff_config () print ( diff . side_by_side_diff ) cfg_conn . commit_config () cfg_conn . close ()","title":"A Simple Example"},{"location":"user_guide/quickstart/#more-examples","text":"Basic Usage Selective Configuration Replace","title":"More Examples"},{"location":"user_guide/versioning/","text":"Versioning \u00b6 Just like scrapli, scrapli_cfg uses the CalVer versioning standard. All release versions follow the format YYYY.MM.DD , however PyPi will shorten/standardize this to remove leading zeros. The reason for choosing CalVer is simply to make it very clear how old a given release of scrapli is. While there are clearly some potential challenges around indicating when a \"breaking\" change occurs due to there not being the concept of a \"major\" version, this is hopefully not too big a deal for scrapli, and thus far the \"core\" API has been very stable -- there are only so many things you can/need to do over SSH after all! Please also note that the CHANGELOG contains notes about each version (and is updated in develop branch while updates are happening). Releases will be made semi-yearly; if you need a feature between releases, there will be periodic pre-releases cut so that folks can easily pip install the prerelease versions for testing and getting any new features/fixes. A final note regarding versioning: scrapli updates are released as often as necessary/there are things to update . This means you should ALWAYS PIN YOUR REQUIREMENTS when using scrapli!! As stated, the \"core\" API has been very stable, but things will change over time -- always pin your requirements, and keep an eye on the changelog/api docs -- you can \"watch\" this repository to ensure you are notified of any releases.","title":"Versioning"},{"location":"user_guide/versioning/#versioning","text":"Just like scrapli, scrapli_cfg uses the CalVer versioning standard. All release versions follow the format YYYY.MM.DD , however PyPi will shorten/standardize this to remove leading zeros. The reason for choosing CalVer is simply to make it very clear how old a given release of scrapli is. While there are clearly some potential challenges around indicating when a \"breaking\" change occurs due to there not being the concept of a \"major\" version, this is hopefully not too big a deal for scrapli, and thus far the \"core\" API has been very stable -- there are only so many things you can/need to do over SSH after all! Please also note that the CHANGELOG contains notes about each version (and is updated in develop branch while updates are happening). Releases will be made semi-yearly; if you need a feature between releases, there will be periodic pre-releases cut so that folks can easily pip install the prerelease versions for testing and getting any new features/fixes. A final note regarding versioning: scrapli updates are released as often as necessary/there are things to update . This means you should ALWAYS PIN YOUR REQUIREMENTS when using scrapli!! As stated, the \"core\" API has been very stable, but things will change over time -- always pin your requirements, and keep an eye on the changelog/api docs -- you can \"watch\" this repository to ensure you are notified of any releases.","title":"Versioning"}]}