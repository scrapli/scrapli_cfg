{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"scrapli_cfg","text":"<p>scrapli_cfg makes merging or replacing device configurations over Telnet or SSH easy. Why over Telnet or SSH?  Because you pretty much will always have one of these options available to you, whereas you may not have eAPI or  NETCONF ready and enabled (think day zero provisioning, or crazy security requirements locking down ports).</p> <p>scrapli_cfg is built on top of scrapli \"core\" and continues the \"look and feel\" of scrapli into the config  management side of things.</p>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#20220730","title":"2022.07.30","text":"<ul> <li>Fix from @WillIrvine to sort a very bad (carl's fault) regex overly aggressive matching -- see #41</li> </ul>"},{"location":"changelog/#20220130","title":"2022.01.30","text":"<ul> <li>Revised juniper abort config to remove candidate config file after rollback 0 to avoid issues where junos would    prompt for confirmation when exiting config mode to go delete the candidate config file prompting timeouts.</li> <li>Dropped Python3.6 support as it is now EOL! Of course, scrapli probably still works just fine with 3.6 (if you    install the old 3.6 requirements), but we won't test/support it anymore.</li> <li>Wow, pretty empty here... guess that's a good sign things have been working :p</li> </ul>"},{"location":"changelog/#20210730","title":"2021.07.30","text":"<ul> <li>Initial release!</li> </ul>"},{"location":"about/code_of_conduct/","title":"Code of Conduct","text":"<p>Be excellent to each other!</p>"},{"location":"about/contributing/","title":"Contributing","text":"<p>Thanks for thinking about contributing! Contributions are not expected, but are quite welcome.</p> <p>Contributions of all kinds are welcomed -- typos, doc updates, adding examples, bug fixes, and feature adds.</p> <p>Some notes on contributing:</p> <ul> <li>Please open a GitHub discussion topic for any potential feature adds/changes to discuss them prior to opening a PR,   this way everyone has a chance to chime in and make sure we're all on the same page!</li> <li>Please open an issue to discuss any bugs/bug fixes prior to opening a PR.</li> <li>Once we all have discussed any adds/changes, pull requests are very much welcome and appreciated!</li> <li>All PRs should pass tests/CI linting -- checkout the Makefile for some shortcuts for linting and testing.</li> <li>Please include tests! Even simple/basic tests are better than nothing -- it helps make sure changes in the future    don't break functionality or make things act in unexpected ways!</li> </ul>"},{"location":"api_docs/diff/","title":"Diff","text":"window.addEventListener('DOMContentLoaded', () =&gt; hljs.initHighlighting())"},{"location":"api_docs/diff/#module-scrapli_cfgdiff","title":"Module scrapli_cfg.diff","text":"<p>scrapli_cfg.diff</p> Expand source code <pre>\n        <code>\n\"\"\"scrapli_cfg.diff\"\"\"\nimport difflib\nimport shutil\nfrom typing import List, Tuple\n\nfrom scrapli_cfg.exceptions import DiffConfigError\nfrom scrapli_cfg.response import ScrapliCfgResponse\n\nGREEN = \"\\033[92m\"\nRED = \"\\033[91m\"\nYELLOW = \"\\033[93m\"\nEND_COLOR = \"\\033[0m\"\n\n\nclass ScrapliCfgDiffResponse(ScrapliCfgResponse):\n    def __init__(\n        self, host: str, source: str, colorize: bool = True, side_by_side_diff_width: int = 0\n    ) -&gt; None:\n        \"\"\"\n        Scrapli config diff object\n\n        Args:\n            host: host the diff is for\n            source: source config store from the device, typically running|startup\n            colorize: True/False colorize diff output\n            side_by_side_diff_width: width to use to generate the side-by-side diff, if not provided\n                will fetch the current terminal width\n\n        Returns:\n            N/A\n\n        Raises:\n            N/A\n\n        \"\"\"\n        super().__init__(host=host, raise_for_status_exception=DiffConfigError)\n\n        self.colorize = colorize\n        self.side_by_side_diff_width = side_by_side_diff_width\n\n        self.source = source\n        self.source_config = \"\"\n        self.candidate_config = \"\"\n        self.device_diff = \"\"\n\n        self._difflines: List[str] = []\n        self.additions = \"\"\n        self.subtractions = \"\"\n\n        self._unified_diff = \"\"\n        self._side_by_side_diff = \"\"\n\n    def __repr__(self) -&gt; str:\n        \"\"\"\n        Magic repr method for ScrapliCfgResponse class\n\n        Args:\n            N/A\n\n        Returns:\n            str: repr for class object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        return f\"ScrapliCfgDiffResponse \"\n\n    def __str__(self) -&gt; str:\n        \"\"\"\n        Magic str method for ScrapliCfgDiffResponse class\n\n        Args:\n            N/A\n\n        Returns:\n            str: str for class object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        return f\"ScrapliCfgDiffResponse \"\n\n    def record_diff_response(\n        self, source_config: str, candidate_config: str, device_diff: str\n    ) -&gt; None:\n        \"\"\"\n        Scrapli config diff object\n\n        Args:\n            source_config: the actual contents of the source config\n            candidate_config: the scrapli_cfg candidate config\n            device_diff: diff generated by the device itself (if applicable)\n\n        Returns:\n            N/A\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.source_config = source_config\n        self.candidate_config = candidate_config\n        self.device_diff = device_diff\n\n        _differ = difflib.Differ()\n        self._difflines = list(\n            _differ.compare(\n                self.source_config.splitlines(keepends=True),\n                self.candidate_config.splitlines(keepends=True),\n            )\n        )\n\n        self.additions = \"\".join([line[2:] for line in self._difflines if line[:2] == \"+ \"])\n        self.subtractions = \"\".join([line[2:] for line in self._difflines if line[:2] == \"- \"])\n\n    def _generate_colors(self) -&gt; Tuple[str, str, str, str]:\n        \"\"\"\n        Generate the necessary strings for colorizing or not output\n\n        Args:\n            N/A\n\n        Returns:\n            tuple: tuple of strings for colorizing (or not) output\n\n        Raises:\n            N/A\n\n        \"\"\"\n        yellow = YELLOW if self.colorize else \"? \"\n        red = RED if self.colorize else \"- \"\n        green = GREEN if self.colorize else \"+ \"\n        end = END_COLOR if self.colorize else \"\"\n        return yellow, red, green, end\n\n    @property\n    def side_by_side_diff(self) -&gt; str:\n        \"\"\"\n        Generate a side-by-side diff of source vs candidate\n\n        Args:\n            N/A\n\n        Returns:\n            str: unified diff text\n\n        Raises:\n            N/A\n\n        \"\"\"\n        if self._side_by_side_diff:\n            return self._side_by_side_diff\n\n        yellow, red, green, end = self._generate_colors()\n\n        term_width = self.side_by_side_diff_width or shutil.get_terminal_size().columns\n        half_term_width = int(term_width / 2)\n        diff_side_width = int(half_term_width - 5)\n\n        side_by_side_diff_lines = []\n        for line in self._difflines:\n            if line[:2] == \"? \":\n                current = (\n                    yellow + f\"{line[2:][:diff_side_width].rstrip() : &lt;{half_term_width}}\" + end\n                )\n                candidate = yellow + f\"{line[2:][:diff_side_width].rstrip()}\" + end\n            elif line[:2] == \"- \":\n                current = red + f\"{line[2:][:diff_side_width].rstrip() : &lt;{half_term_width}}\" + end\n                candidate = \"\"\n            elif line[:2] == \"+ \":\n                current = f\"{'' : &lt;{half_term_width}}\"\n                candidate = green + f\"{line[2:][:diff_side_width].rstrip()}\" + end\n            else:\n                current = f\"{line[2:][:diff_side_width].rstrip() : &lt;{half_term_width}}\"\n                candidate = f\"{line[2:][:diff_side_width].rstrip()}\"\n\n            side_by_side_diff_lines.append(current + candidate)\n\n        joined_side_by_side_diff = \"\\n\".join(side_by_side_diff_lines)\n\n        self._side_by_side_diff = joined_side_by_side_diff\n\n        return self._side_by_side_diff\n\n    @property\n    def unified_diff(self) -&gt; str:\n        \"\"\"\n        Generate a unified diff of source vs candidate\n\n        Args:\n            N/A\n\n        Returns:\n            str: unified diff text\n\n        Raises:\n            N/A\n\n        \"\"\"\n        if self._unified_diff:\n            return self._unified_diff\n\n        yellow, red, green, end = self._generate_colors()\n\n        unified_diff = [\n            yellow + line[2:] + end\n            if line[:2] == \"? \"\n            else red + line[2:] + end\n            if line[:2] == \"- \"\n            else green + line[2:] + end\n            if line[:2] == \"+ \"\n            else line[2:]\n            for line in self._difflines\n        ]\n        joined_unified_diff = \"\".join(unified_diff)\n\n        self._unified_diff = joined_unified_diff\n\n        return self._unified_diff"},{"location":"api_docs/diff/#classes","title":"Classes","text":""},{"location":"api_docs/diff/#scraplicfgdiffresponse","title":"ScrapliCfgDiffResponse","text":"<pre><code>Scrapli config diff object\n\nArgs:\n    host: host the diff is for\n    source: source config store from the device, typically running|startup\n    colorize: True/False colorize diff output\n    side_by_side_diff_width: width to use to generate the side-by-side diff, if not provided\n        will fetch the current terminal width\n\nReturns:\n    N/A\n\nRaises:\n    N/A\n</code></pre>\nExpand source code\n    <pre>\n        <code>\nclass ScrapliCfgDiffResponse(ScrapliCfgResponse):\n    def __init__(\n        self, host: str, source: str, colorize: bool = True, side_by_side_diff_width: int = 0\n    ) -&gt; None:\n        \"\"\"\n        Scrapli config diff object\n\n        Args:\n            host: host the diff is for\n            source: source config store from the device, typically running|startup\n            colorize: True/False colorize diff output\n            side_by_side_diff_width: width to use to generate the side-by-side diff, if not provided\n                will fetch the current terminal width\n\n        Returns:\n            N/A\n\n        Raises:\n            N/A\n\n        \"\"\"\n        super().__init__(host=host, raise_for_status_exception=DiffConfigError)\n\n        self.colorize = colorize\n        self.side_by_side_diff_width = side_by_side_diff_width\n\n        self.source = source\n        self.source_config = \"\"\n        self.candidate_config = \"\"\n        self.device_diff = \"\"\n\n        self._difflines: List[str] = []\n        self.additions = \"\"\n        self.subtractions = \"\"\n\n        self._unified_diff = \"\"\n        self._side_by_side_diff = \"\"\n\n    def __repr__(self) -&gt; str:\n        \"\"\"\n        Magic repr method for ScrapliCfgResponse class\n\n        Args:\n            N/A\n\n        Returns:\n            str: repr for class object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        return f\"ScrapliCfgDiffResponse \"\n\n    def __str__(self) -&gt; str:\n        \"\"\"\n        Magic str method for ScrapliCfgDiffResponse class\n\n        Args:\n            N/A\n\n        Returns:\n            str: str for class object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        return f\"ScrapliCfgDiffResponse \"\n\n    def record_diff_response(\n        self, source_config: str, candidate_config: str, device_diff: str\n    ) -&gt; None:\n        \"\"\"\n        Scrapli config diff object\n\n        Args:\n            source_config: the actual contents of the source config\n            candidate_config: the scrapli_cfg candidate config\n            device_diff: diff generated by the device itself (if applicable)\n\n        Returns:\n            N/A\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.source_config = source_config\n        self.candidate_config = candidate_config\n        self.device_diff = device_diff\n\n        _differ = difflib.Differ()\n        self._difflines = list(\n            _differ.compare(\n                self.source_config.splitlines(keepends=True),\n                self.candidate_config.splitlines(keepends=True),\n            )\n        )\n\n        self.additions = \"\".join([line[2:] for line in self._difflines if line[:2] == \"+ \"])\n        self.subtractions = \"\".join([line[2:] for line in self._difflines if line[:2] == \"- \"])\n\n    def _generate_colors(self) -&gt; Tuple[str, str, str, str]:\n        \"\"\"\n        Generate the necessary strings for colorizing or not output\n\n        Args:\n            N/A\n\n        Returns:\n            tuple: tuple of strings for colorizing (or not) output\n\n        Raises:\n            N/A\n\n        \"\"\"\n        yellow = YELLOW if self.colorize else \"? \"\n        red = RED if self.colorize else \"- \"\n        green = GREEN if self.colorize else \"+ \"\n        end = END_COLOR if self.colorize else \"\"\n        return yellow, red, green, end\n\n    @property\n    def side_by_side_diff(self) -&gt; str:\n        \"\"\"\n        Generate a side-by-side diff of source vs candidate\n\n        Args:\n            N/A\n\n        Returns:\n            str: unified diff text\n\n        Raises:\n            N/A\n\n        \"\"\"\n        if self._side_by_side_diff:\n            return self._side_by_side_diff\n\n        yellow, red, green, end = self._generate_colors()\n\n        term_width = self.side_by_side_diff_width or shutil.get_terminal_size().columns\n        half_term_width = int(term_width / 2)\n        diff_side_width = int(half_term_width - 5)\n\n        side_by_side_diff_lines = []\n        for line in self._difflines:\n            if line[:2] == \"? \":\n                current = (\n                    yellow + f\"{line[2:][:diff_side_width].rstrip() : &lt;{half_term_width}}\" + end\n                )\n                candidate = yellow + f\"{line[2:][:diff_side_width].rstrip()}\" + end\n            elif line[:2] == \"- \":\n                current = red + f\"{line[2:][:diff_side_width].rstrip() : &lt;{half_term_width}}\" + end\n                candidate = \"\"\n            elif line[:2] == \"+ \":\n                current = f\"{'' : &lt;{half_term_width}}\"\n                candidate = green + f\"{line[2:][:diff_side_width].rstrip()}\" + end\n            else:\n                current = f\"{line[2:][:diff_side_width].rstrip() : &lt;{half_term_width}}\"\n                candidate = f\"{line[2:][:diff_side_width].rstrip()}\"\n\n            side_by_side_diff_lines.append(current + candidate)\n\n        joined_side_by_side_diff = \"\\n\".join(side_by_side_diff_lines)\n\n        self._side_by_side_diff = joined_side_by_side_diff\n\n        return self._side_by_side_diff\n\n    @property\n    def unified_diff(self) -&gt; str:\n        \"\"\"\n        Generate a unified diff of source vs candidate\n\n        Args:\n            N/A\n\n        Returns:\n            str: unified diff text\n\n        Raises:\n            N/A\n\n        \"\"\"\n        if self._unified_diff:\n            return self._unified_diff\n\n        yellow, red, green, end = self._generate_colors()\n\n        unified_diff = [\n            yellow + line[2:] + end\n            if line[:2] == \"? \"\n            else red + line[2:] + end\n            if line[:2] == \"- \"\n            else green + line[2:] + end\n            if line[:2] == \"+ \"\n            else line[2:]\n            for line in self._difflines\n        ]\n        joined_unified_diff = \"\".join(unified_diff)\n\n        self._unified_diff = joined_unified_diff\n\n        return self._unified_diff"},{"location":"api_docs/diff/#ancestors-in-mro","title":"Ancestors (in MRO)","text":"<ul>\n<li>scrapli_cfg.response.ScrapliCfgResponse</li>\n</ul>"},{"location":"api_docs/diff/#instance-variables","title":"Instance variables","text":"<p><code>side_by_side_diff: str</code></p>\n<pre><code>Generate a side-by-side diff of source vs candidate\n\nArgs:\n    N/A\n\nReturns:\n    str: unified diff text\n\nRaises:\n    N/A\n</code></pre>\n<p><code>unified_diff: str</code></p>\n<pre><code>Generate a unified diff of source vs candidate\n\nArgs:\n    N/A\n\nReturns:\n    str: unified diff text\n\nRaises:\n    N/A\n</code></pre>"},{"location":"api_docs/diff/#methods","title":"Methods","text":""},{"location":"api_docs/diff/#record_diff_response","title":"record_diff_response","text":"<p><code>record_diff_response(self, source_config:\u00a0str, candidate_config:\u00a0str, device_diff:\u00a0str) \u2011&gt; None</code></p>\n<pre><code>Scrapli config diff object\n\nArgs:\n    source_config: the actual contents of the source config\n    candidate_config: the scrapli_cfg candidate config\n    device_diff: diff generated by the device itself (if applicable)\n\nReturns:\n    N/A\n\nRaises:\n    N/A\n</code></pre>"},{"location":"api_docs/exceptions/","title":"Exceptions","text":"window.addEventListener('DOMContentLoaded', () =&gt; hljs.initHighlighting())"},{"location":"api_docs/exceptions/#module-scrapli_cfgexceptions","title":"Module scrapli_cfg.exceptions","text":"<p>scrapli_cfg.exceptions</p> Expand source code <pre>\n        <code>\n\"\"\"scrapli_cfg.exceptions\"\"\"\nfrom scrapli.exceptions import ScrapliException\n\n\nclass ScrapliCfgException(ScrapliException):\n    \"\"\"Base scrapli_cfg exception\"\"\"\n\n\nclass PrepareNotCalled(ScrapliCfgException):\n    \"\"\"\n    Raised when the `prepare` method has not been called\n\n    This will only be raised in two scenarios:\n    1) an `on_prepare` callable has been provided, yet `prepare` was not called\n    2) `ignore_version` is False and `prepare` was not called\n\n    If using a context manager this should never be raised as the enter method will handle things\n    for you\n    \"\"\"\n\n\nclass TemplateError(ScrapliCfgException):\n    \"\"\"For errors relating to configuration templates\"\"\"\n\n\nclass FailedToDetermineDeviceState(ScrapliCfgException):\n    \"\"\"For issues determining device state (i.e. what mode is file prompt in, etc.)\"\"\"\n\n\nclass VersionError(ScrapliCfgException):\n    \"\"\"For errors related to getting/parsing/invalid versions\"\"\"\n\n\nclass ConfigError(ScrapliCfgException):\n    \"\"\"For configuration operation related errors\"\"\"\n\n\nclass InvalidConfigTarget(ConfigError):\n    \"\"\"User has provided an invalid configuration target\"\"\"\n\n\nclass FailedToFetchSpaceAvailable(ConfigError):\n    \"\"\"Unable to determine space available on filesystem\"\"\"\n\n\nclass InsufficientSpaceAvailable(ConfigError):\n    \"\"\"If space available on filesystem is insufficient\"\"\"\n\n\nclass GetConfigError(ConfigError):\n    \"\"\"For errors getting configuration from a device\"\"\"\n\n\nclass LoadConfigError(ConfigError):\n    \"\"\"For errors loading a configuration\"\"\"\n\n\nclass DiffConfigError(ConfigError):\n    \"\"\"For errors diffing a configuration\"\"\"\n\n\nclass AbortConfigError(ConfigError):\n    \"\"\"For errors aborting a configuration\"\"\"\n\n\nclass CommitConfigError(ConfigError):\n    \"\"\"For errors committing a configuration\"\"\"\n\n\nclass CleanupError(ScrapliCfgException):\n    \"\"\"For errors during cleanup (i.e. removing candidate config, etc.)\"\"\"\n        </code>\n    </pre>"},{"location":"api_docs/exceptions/#classes","title":"Classes","text":""},{"location":"api_docs/exceptions/#abortconfigerror","title":"AbortConfigError","text":"<pre><code>For errors aborting a configuration\n</code></pre> Expand source code <pre>\n        <code>\nclass AbortConfigError(ConfigError):\n    \"\"\"For errors aborting a configuration\"\"\"\n        </code>\n    </pre>"},{"location":"api_docs/exceptions/#ancestors-in-mro","title":"Ancestors (in MRO)","text":"<ul> <li>scrapli_cfg.exceptions.ConfigError</li> <li>scrapli_cfg.exceptions.ScrapliCfgException</li> <li>scrapli.exceptions.ScrapliException</li> <li>builtins.Exception</li> <li>builtins.BaseException</li> </ul>"},{"location":"api_docs/exceptions/#cleanuperror","title":"CleanupError","text":"<pre><code>For errors during cleanup (i.e. removing candidate config, etc.)\n</code></pre> Expand source code <pre>\n        <code>\nclass CleanupError(ScrapliCfgException):\n    \"\"\"For errors during cleanup (i.e. removing candidate config, etc.)\"\"\"\n        </code>\n    </pre>"},{"location":"api_docs/exceptions/#ancestors-in-mro_1","title":"Ancestors (in MRO)","text":"<ul> <li>scrapli_cfg.exceptions.ScrapliCfgException</li> <li>scrapli.exceptions.ScrapliException</li> <li>builtins.Exception</li> <li>builtins.BaseException</li> </ul>"},{"location":"api_docs/exceptions/#commitconfigerror","title":"CommitConfigError","text":"<pre><code>For errors committing a configuration\n</code></pre> Expand source code <pre>\n        <code>\nclass CommitConfigError(ConfigError):\n    \"\"\"For errors committing a configuration\"\"\"\n        </code>\n    </pre>"},{"location":"api_docs/exceptions/#ancestors-in-mro_2","title":"Ancestors (in MRO)","text":"<ul> <li>scrapli_cfg.exceptions.ConfigError</li> <li>scrapli_cfg.exceptions.ScrapliCfgException</li> <li>scrapli.exceptions.ScrapliException</li> <li>builtins.Exception</li> <li>builtins.BaseException</li> </ul>"},{"location":"api_docs/exceptions/#configerror","title":"ConfigError","text":"<pre><code>For configuration operation related errors\n</code></pre> Expand source code <pre>\n        <code>\nclass ConfigError(ScrapliCfgException):\n    \"\"\"For configuration operation related errors\"\"\"\n        </code>\n    </pre>"},{"location":"api_docs/exceptions/#ancestors-in-mro_3","title":"Ancestors (in MRO)","text":"<ul> <li>scrapli_cfg.exceptions.ScrapliCfgException</li> <li>scrapli.exceptions.ScrapliException</li> <li>builtins.Exception</li> <li>builtins.BaseException</li> </ul>"},{"location":"api_docs/exceptions/#descendants","title":"Descendants","text":"<ul> <li>scrapli_cfg.exceptions.AbortConfigError</li> <li>scrapli_cfg.exceptions.CommitConfigError</li> <li>scrapli_cfg.exceptions.DiffConfigError</li> <li>scrapli_cfg.exceptions.FailedToFetchSpaceAvailable</li> <li>scrapli_cfg.exceptions.GetConfigError</li> <li>scrapli_cfg.exceptions.InsufficientSpaceAvailable</li> <li>scrapli_cfg.exceptions.InvalidConfigTarget</li> <li>scrapli_cfg.exceptions.LoadConfigError</li> </ul>"},{"location":"api_docs/exceptions/#diffconfigerror","title":"DiffConfigError","text":"<pre><code>For errors diffing a configuration\n</code></pre> Expand source code <pre>\n        <code>\nclass DiffConfigError(ConfigError):\n    \"\"\"For errors diffing a configuration\"\"\"\n        </code>\n    </pre>"},{"location":"api_docs/exceptions/#ancestors-in-mro_4","title":"Ancestors (in MRO)","text":"<ul> <li>scrapli_cfg.exceptions.ConfigError</li> <li>scrapli_cfg.exceptions.ScrapliCfgException</li> <li>scrapli.exceptions.ScrapliException</li> <li>builtins.Exception</li> <li>builtins.BaseException</li> </ul>"},{"location":"api_docs/exceptions/#failedtodeterminedevicestate","title":"FailedToDetermineDeviceState","text":"<pre><code>For issues determining device state (i.e. what mode is file prompt in, etc.)\n</code></pre> Expand source code <pre>\n        <code>\nclass FailedToDetermineDeviceState(ScrapliCfgException):\n    \"\"\"For issues determining device state (i.e. what mode is file prompt in, etc.)\"\"\"\n        </code>\n    </pre>"},{"location":"api_docs/exceptions/#ancestors-in-mro_5","title":"Ancestors (in MRO)","text":"<ul> <li>scrapli_cfg.exceptions.ScrapliCfgException</li> <li>scrapli.exceptions.ScrapliException</li> <li>builtins.Exception</li> <li>builtins.BaseException</li> </ul>"},{"location":"api_docs/exceptions/#failedtofetchspaceavailable","title":"FailedToFetchSpaceAvailable","text":"<pre><code>Unable to determine space available on filesystem\n</code></pre> Expand source code <pre>\n        <code>\nclass FailedToFetchSpaceAvailable(ConfigError):\n    \"\"\"Unable to determine space available on filesystem\"\"\"\n        </code>\n    </pre>"},{"location":"api_docs/exceptions/#ancestors-in-mro_6","title":"Ancestors (in MRO)","text":"<ul> <li>scrapli_cfg.exceptions.ConfigError</li> <li>scrapli_cfg.exceptions.ScrapliCfgException</li> <li>scrapli.exceptions.ScrapliException</li> <li>builtins.Exception</li> <li>builtins.BaseException</li> </ul>"},{"location":"api_docs/exceptions/#getconfigerror","title":"GetConfigError","text":"<pre><code>For errors getting configuration from a device\n</code></pre> Expand source code <pre>\n        <code>\nclass GetConfigError(ConfigError):\n    \"\"\"For errors getting configuration from a device\"\"\"\n        </code>\n    </pre>"},{"location":"api_docs/exceptions/#ancestors-in-mro_7","title":"Ancestors (in MRO)","text":"<ul> <li>scrapli_cfg.exceptions.ConfigError</li> <li>scrapli_cfg.exceptions.ScrapliCfgException</li> <li>scrapli.exceptions.ScrapliException</li> <li>builtins.Exception</li> <li>builtins.BaseException</li> </ul>"},{"location":"api_docs/exceptions/#insufficientspaceavailable","title":"InsufficientSpaceAvailable","text":"<pre><code>If space available on filesystem is insufficient\n</code></pre> Expand source code <pre>\n        <code>\nclass InsufficientSpaceAvailable(ConfigError):\n    \"\"\"If space available on filesystem is insufficient\"\"\"\n        </code>\n    </pre>"},{"location":"api_docs/exceptions/#ancestors-in-mro_8","title":"Ancestors (in MRO)","text":"<ul> <li>scrapli_cfg.exceptions.ConfigError</li> <li>scrapli_cfg.exceptions.ScrapliCfgException</li> <li>scrapli.exceptions.ScrapliException</li> <li>builtins.Exception</li> <li>builtins.BaseException</li> </ul>"},{"location":"api_docs/exceptions/#invalidconfigtarget","title":"InvalidConfigTarget","text":"<pre><code>User has provided an invalid configuration target\n</code></pre> Expand source code <pre>\n        <code>\nclass InvalidConfigTarget(ConfigError):\n    \"\"\"User has provided an invalid configuration target\"\"\"\n        </code>\n    </pre>"},{"location":"api_docs/exceptions/#ancestors-in-mro_9","title":"Ancestors (in MRO)","text":"<ul> <li>scrapli_cfg.exceptions.ConfigError</li> <li>scrapli_cfg.exceptions.ScrapliCfgException</li> <li>scrapli.exceptions.ScrapliException</li> <li>builtins.Exception</li> <li>builtins.BaseException</li> </ul>"},{"location":"api_docs/exceptions/#loadconfigerror","title":"LoadConfigError","text":"<pre><code>For errors loading a configuration\n</code></pre> Expand source code <pre>\n        <code>\nclass LoadConfigError(ConfigError):\n    \"\"\"For errors loading a configuration\"\"\"\n        </code>\n    </pre>"},{"location":"api_docs/exceptions/#ancestors-in-mro_10","title":"Ancestors (in MRO)","text":"<ul> <li>scrapli_cfg.exceptions.ConfigError</li> <li>scrapli_cfg.exceptions.ScrapliCfgException</li> <li>scrapli.exceptions.ScrapliException</li> <li>builtins.Exception</li> <li>builtins.BaseException</li> </ul>"},{"location":"api_docs/exceptions/#preparenotcalled","title":"PrepareNotCalled","text":"<pre><code>Raised when the `prepare` method has not been called\n\nThis will only be raised in two scenarios:\n1) an `on_prepare` callable has been provided, yet `prepare` was not called\n2) `ignore_version` is False and `prepare` was not called\n\nIf using a context manager this should never be raised as the enter method will handle things\nfor you\n</code></pre> Expand source code <pre>\n        <code>\nclass PrepareNotCalled(ScrapliCfgException):\n    \"\"\"\n    Raised when the `prepare` method has not been called\n\n    This will only be raised in two scenarios:\n    1) an `on_prepare` callable has been provided, yet `prepare` was not called\n    2) `ignore_version` is False and `prepare` was not called\n\n    If using a context manager this should never be raised as the enter method will handle things\n    for you\n    \"\"\"\n        </code>\n    </pre>"},{"location":"api_docs/exceptions/#ancestors-in-mro_11","title":"Ancestors (in MRO)","text":"<ul> <li>scrapli_cfg.exceptions.ScrapliCfgException</li> <li>scrapli.exceptions.ScrapliException</li> <li>builtins.Exception</li> <li>builtins.BaseException</li> </ul>"},{"location":"api_docs/exceptions/#scraplicfgexception","title":"ScrapliCfgException","text":"<pre><code>Base scrapli_cfg exception\n</code></pre> Expand source code <pre>\n        <code>\nclass ScrapliCfgException(ScrapliException):\n    \"\"\"Base scrapli_cfg exception\"\"\"\n        </code>\n    </pre>"},{"location":"api_docs/exceptions/#ancestors-in-mro_12","title":"Ancestors (in MRO)","text":"<ul> <li>scrapli.exceptions.ScrapliException</li> <li>builtins.Exception</li> <li>builtins.BaseException</li> </ul>"},{"location":"api_docs/exceptions/#descendants_1","title":"Descendants","text":"<ul> <li>scrapli_cfg.exceptions.CleanupError</li> <li>scrapli_cfg.exceptions.ConfigError</li> <li>scrapli_cfg.exceptions.FailedToDetermineDeviceState</li> <li>scrapli_cfg.exceptions.PrepareNotCalled</li> <li>scrapli_cfg.exceptions.TemplateError</li> <li>scrapli_cfg.exceptions.VersionError</li> </ul>"},{"location":"api_docs/exceptions/#templateerror","title":"TemplateError","text":"<pre><code>For errors relating to configuration templates\n</code></pre> Expand source code <pre>\n        <code>\nclass TemplateError(ScrapliCfgException):\n    \"\"\"For errors relating to configuration templates\"\"\"\n        </code>\n    </pre>"},{"location":"api_docs/exceptions/#ancestors-in-mro_13","title":"Ancestors (in MRO)","text":"<ul> <li>scrapli_cfg.exceptions.ScrapliCfgException</li> <li>scrapli.exceptions.ScrapliException</li> <li>builtins.Exception</li> <li>builtins.BaseException</li> </ul>"},{"location":"api_docs/exceptions/#versionerror","title":"VersionError","text":"<pre><code>For errors related to getting/parsing/invalid versions\n</code></pre> Expand source code <pre>\n        <code>\nclass VersionError(ScrapliCfgException):\n    \"\"\"For errors related to getting/parsing/invalid versions\"\"\"\n        </code>\n    </pre>"},{"location":"api_docs/exceptions/#ancestors-in-mro_14","title":"Ancestors (in MRO)","text":"<ul> <li>scrapli_cfg.exceptions.ScrapliCfgException</li> <li>scrapli.exceptions.ScrapliException</li> <li>builtins.Exception</li> <li>builtins.BaseException</li> </ul>"},{"location":"api_docs/factory/","title":"Factory","text":"window.addEventListener('DOMContentLoaded', () =&gt; hljs.initHighlighting())"},{"location":"api_docs/factory/#module-scrapli_cfgfactory","title":"Module scrapli_cfg.factory","text":"<p>scrapli_cfg.factory</p> Expand source code <pre>\n        <code>\n\"\"\"scrapli_cfg.factory\"\"\"\nfrom typing import TYPE_CHECKING, Any, Callable, List, Optional\n\nfrom scrapli.driver.core import (\n    AsyncEOSDriver,\n    AsyncIOSXEDriver,\n    AsyncIOSXRDriver,\n    AsyncJunosDriver,\n    AsyncNXOSDriver,\n    EOSDriver,\n    IOSXEDriver,\n    IOSXRDriver,\n    JunosDriver,\n    NXOSDriver,\n)\nfrom scrapli.driver.network import AsyncNetworkDriver, NetworkDriver\nfrom scrapli_cfg.exceptions import ScrapliCfgException\nfrom scrapli_cfg.logging import logger\nfrom scrapli_cfg.platform.core.arista_eos import AsyncScrapliCfgEOS, ScrapliCfgEOS\nfrom scrapli_cfg.platform.core.cisco_iosxe import AsyncScrapliCfgIOSXE, ScrapliCfgIOSXE\nfrom scrapli_cfg.platform.core.cisco_iosxr import AsyncScrapliCfgIOSXR, ScrapliCfgIOSXR\nfrom scrapli_cfg.platform.core.cisco_nxos import AsyncScrapliCfgNXOS, ScrapliCfgNXOS\nfrom scrapli_cfg.platform.core.juniper_junos import AsyncScrapliCfgJunos, ScrapliCfgJunos\n\nif TYPE_CHECKING:\n    from scrapli_cfg.platform.base.async_platform import AsyncScrapliCfgPlatform  # pragma: no cover\n    from scrapli_cfg.platform.base.sync_platform import ScrapliCfgPlatform  # pragma: no cover\n\nASYNC_CORE_PLATFORM_MAP = {\n    AsyncEOSDriver: AsyncScrapliCfgEOS,\n    AsyncIOSXEDriver: AsyncScrapliCfgIOSXE,\n    AsyncIOSXRDriver: AsyncScrapliCfgIOSXR,\n    AsyncNXOSDriver: AsyncScrapliCfgNXOS,\n    AsyncJunosDriver: AsyncScrapliCfgJunos,\n}\nSYNC_CORE_PLATFORM_MAP = {\n    EOSDriver: ScrapliCfgEOS,\n    IOSXEDriver: ScrapliCfgIOSXE,\n    IOSXRDriver: ScrapliCfgIOSXR,\n    NXOSDriver: ScrapliCfgNXOS,\n    JunosDriver: ScrapliCfgJunos,\n}\n\n\ndef ScrapliCfg(\n    conn: NetworkDriver,\n    *,\n    config_sources: Optional[List[str]] = None,\n    on_prepare: Optional[Callable[..., Any]] = None,\n    dedicated_connection: bool = False,\n    ignore_version: bool = False,\n    **kwargs: Any,\n) -&gt; \"ScrapliCfgPlatform\":\n    \"\"\"\n    Scrapli Config Sync Factory\n\n    Return a sync scrapli config object for the provided platform. Prefer to use factory classes\n    just so that the naming convention (w/ upper case things) is \"right\", but given that the class\n    version inherited from the base ScrapliCfgPlatform and did not implement the abstract methods\n    this felt like a better move.\n\n    Args:\n        conn: scrapli connection to use\n        config_sources: list of config sources\n        on_prepare: optional callable to run at connection `prepare`\n        dedicated_connection: if `False` (default value) scrapli cfg will not open or close the\n            underlying scrapli connection and will raise an exception if the scrapli connection\n            is not open. If `True` will automatically open and close the scrapli connection when\n            using with a context manager, `prepare` will open the scrapli connection (if not\n            already open), and `close` will close the scrapli connection.\n        ignore_version: ignore checking device version support; currently this just means that\n            scrapli-cfg will not fetch the device version during the prepare phase, however this\n            will (hopefully) be used in the future to limit what methods can be used against a\n            target device. For example, for EOS devices we need &gt; 4.14 to load configs; so if a\n            device is encountered at 4.13 the version check would raise an exception rather than\n            just failing in a potentially awkward fashion.\n        kwargs: keyword args to pass to the scrapli_cfg object (for things like iosxe 'filesystem'\n            argument)\n\n    Returns:\n        ScrapliCfg: sync scrapli cfg object\n\n    Raises:\n        ScrapliCfgException: if provided connection object is async\n        ScrapliCfgException: if provided connection object is sync but is not a supported (\"core\")\n            platform type\n\n    \"\"\"\n    logger.debug(\"ScrapliCfg factory initialized\")\n\n    if isinstance(conn, AsyncNetworkDriver):\n        raise ScrapliCfgException(\n            \"provided scrapli connection is sync but using 'AsyncScrapliCfg' -- you must use an \"\n            \"async connection with 'AsyncScrapliCfg'!\"\n        )\n\n    platform_class = SYNC_CORE_PLATFORM_MAP.get(type(conn))\n    if not platform_class:\n        raise ScrapliCfgException(\n            f\"scrapli connection object type '{type(conn)}' not a supported scrapli-cfg type\"\n        )\n\n    final_platform: \"ScrapliCfgPlatform\" = platform_class(\n        conn=conn,\n        config_sources=config_sources,\n        on_prepare=on_prepare,\n        dedicated_connection=dedicated_connection,\n        ignore_version=ignore_version,\n        **kwargs,\n    )\n\n    return final_platform\n\n\ndef AsyncScrapliCfg(\n    conn: AsyncNetworkDriver,\n    *,\n    config_sources: Optional[List[str]] = None,\n    on_prepare: Optional[Callable[..., Any]] = None,\n    dedicated_connection: bool = False,\n    ignore_version: bool = False,\n    **kwargs: Any,\n) -&gt; \"AsyncScrapliCfgPlatform\":\n    \"\"\"\n    Scrapli Config Async Factory\n\n    Return a async scrapli config object for the provided platform. Prefer to use factory classes\n    just so that the naming convention (w/ upper case things) is \"right\", but given that the class\n    version inherited from the base ScrapliCfgPlatform and did not implement the abstract methods\n    this felt like a better move.\n\n    Args:\n        conn: scrapli connection to use\n        config_sources: list of config sources\n        on_prepare: optional callable to run at connection `prepare`\n        dedicated_connection: if `False` (default value) scrapli cfg will not open or close the\n            underlying scrapli connection and will raise an exception if the scrapli connection\n            is not open. If `True` will automatically open and close the scrapli connection when\n            using with a context manager, `prepare` will open the scrapli connection (if not\n            already open), and `close` will close the scrapli connection.\n        ignore_version: ignore checking device version support; currently this just means that\n            scrapli-cfg will not fetch the device version during the prepare phase, however this\n            will (hopefully) be used in the future to limit what methods can be used against a\n            target device. For example, for EOS devices we need &gt; 4.14 to load configs; so if a\n            device is encountered at 4.13 the version check would raise an exception rather than\n            just failing in a potentially awkward fashion.\n        kwargs: keyword args to pass to the scrapli_cfg object (for things like iosxe 'filesystem'\n            argument)\n\n    Returns:\n        AsyncScrapliCfg: async scrapli cfg object\n\n    Raises:\n        ScrapliCfgException: if provided connection object is sync\n        ScrapliCfgException: if provided connection object is async but is not a supported (\"core\")\n            platform type\n\n    \"\"\"\n    logger.debug(\"AsyncScrapliCfg factory initialized\")\n\n    if isinstance(conn, NetworkDriver):\n        raise ScrapliCfgException(\n            \"provided scrapli connection is sync but using 'AsyncScrapliCfg' -- you must use an \"\n            \"async connection with 'AsyncScrapliCfg'!\"\n        )\n\n    platform_class = ASYNC_CORE_PLATFORM_MAP.get(type(conn))\n    if not platform_class:\n        raise ScrapliCfgException(\n            f\"scrapli connection object type '{type(conn)}' not a supported scrapli-cfg type\"\n        )\n\n    final_platform: \"AsyncScrapliCfgPlatform\" = platform_class(\n        conn=conn,\n        config_sources=config_sources,\n        on_prepare=on_prepare,\n        dedicated_connection=dedicated_connection,\n        ignore_version=ignore_version,\n        **kwargs,\n    )\n\n    return final_platform\n        </code>\n    </pre>"},{"location":"api_docs/factory/#functions","title":"Functions","text":""},{"location":"api_docs/factory/#asyncscraplicfg","title":"AsyncScrapliCfg","text":"<p><code>AsyncScrapliCfg(conn:\u00a0scrapli.driver.network.async_driver.AsyncNetworkDriver, *, config_sources:\u00a0Optional[List[str]]\u00a0=\u00a0None, on_prepare:\u00a0Optional[Callable[...,\u00a0Any]]\u00a0=\u00a0None, dedicated_connection:\u00a0bool\u00a0=\u00a0False, ignore_version:\u00a0bool\u00a0=\u00a0False, **kwargs:\u00a0Any) \u2011&gt; AsyncScrapliCfgPlatform</code></p> <pre><code>Scrapli Config Async Factory\n\nReturn a async scrapli config object for the provided platform. Prefer to use factory classes\njust so that the naming convention (w/ upper case things) is \"right\", but given that the class\nversion inherited from the base ScrapliCfgPlatform and did not implement the abstract methods\nthis felt like a better move.\n\nArgs:\n    conn: scrapli connection to use\n    config_sources: list of config sources\n    on_prepare: optional callable to run at connection `prepare`\n    dedicated_connection: if `False` (default value) scrapli cfg will not open or close the\n        underlying scrapli connection and will raise an exception if the scrapli connection\n        is not open. If `True` will automatically open and close the scrapli connection when\n        using with a context manager, `prepare` will open the scrapli connection (if not\n        already open), and `close` will close the scrapli connection.\n    ignore_version: ignore checking device version support; currently this just means that\n        scrapli-cfg will not fetch the device version during the prepare phase, however this\n        will (hopefully) be used in the future to limit what methods can be used against a\n        target device. For example, for EOS devices we need &gt; 4.14 to load configs; so if a\n        device is encountered at 4.13 the version check would raise an exception rather than\n        just failing in a potentially awkward fashion.\n    kwargs: keyword args to pass to the scrapli_cfg object (for things like iosxe 'filesystem'\n        argument)\n\nReturns:\n    AsyncScrapliCfg: async scrapli cfg object\n\nRaises:\n    ScrapliCfgException: if provided connection object is sync\n    ScrapliCfgException: if provided connection object is async but is not a supported (\"core\")\n        platform type\n</code></pre>"},{"location":"api_docs/factory/#scraplicfg","title":"ScrapliCfg","text":"<p><code>ScrapliCfg(conn:\u00a0scrapli.driver.network.sync_driver.NetworkDriver, *, config_sources:\u00a0Optional[List[str]]\u00a0=\u00a0None, on_prepare:\u00a0Optional[Callable[...,\u00a0Any]]\u00a0=\u00a0None, dedicated_connection:\u00a0bool\u00a0=\u00a0False, ignore_version:\u00a0bool\u00a0=\u00a0False, **kwargs:\u00a0Any) \u2011&gt; ScrapliCfgPlatform</code></p> <pre><code>Scrapli Config Sync Factory\n\nReturn a sync scrapli config object for the provided platform. Prefer to use factory classes\njust so that the naming convention (w/ upper case things) is \"right\", but given that the class\nversion inherited from the base ScrapliCfgPlatform and did not implement the abstract methods\nthis felt like a better move.\n\nArgs:\n    conn: scrapli connection to use\n    config_sources: list of config sources\n    on_prepare: optional callable to run at connection `prepare`\n    dedicated_connection: if `False` (default value) scrapli cfg will not open or close the\n        underlying scrapli connection and will raise an exception if the scrapli connection\n        is not open. If `True` will automatically open and close the scrapli connection when\n        using with a context manager, `prepare` will open the scrapli connection (if not\n        already open), and `close` will close the scrapli connection.\n    ignore_version: ignore checking device version support; currently this just means that\n        scrapli-cfg will not fetch the device version during the prepare phase, however this\n        will (hopefully) be used in the future to limit what methods can be used against a\n        target device. For example, for EOS devices we need &gt; 4.14 to load configs; so if a\n        device is encountered at 4.13 the version check would raise an exception rather than\n        just failing in a potentially awkward fashion.\n    kwargs: keyword args to pass to the scrapli_cfg object (for things like iosxe 'filesystem'\n        argument)\n\nReturns:\n    ScrapliCfg: sync scrapli cfg object\n\nRaises:\n    ScrapliCfgException: if provided connection object is async\n    ScrapliCfgException: if provided connection object is sync but is not a supported (\"core\")\n        platform type\n</code></pre>"},{"location":"api_docs/logging/","title":"Logging","text":"window.addEventListener('DOMContentLoaded', () =&gt; hljs.initHighlighting())"},{"location":"api_docs/logging/#module-scrapli_cfglogging","title":"Module scrapli_cfg.logging","text":"<p>scrapli_cfg.logging</p> Expand source code <pre>\n        <code>\n\"\"\"scrapli_cfg.logging\"\"\"\nfrom logging import FileHandler, NullHandler, getLogger\nfrom typing import Union\n\nfrom scrapli.logging import ScrapliFileHandler, ScrapliFormatter\n\n\ndef enable_basic_logging(\n    file: Union[str, bool] = False,\n    level: str = \"info\",\n    caller_info: bool = False,\n    buffer_log: bool = True,\n) -&gt; None:\n    \"\"\"\n    Enable opinionated logging for scrapli_cfg\n\n    Uses scrapli \"core\" formatter/file handler\n\n    Args:\n        file: True to output to default log path (\"scrapli.log\"), otherwise string path to write log\n            file to\n        level: string name of logging level to use, i.e. \"info\", \"debug\", etc.\n        caller_info: add info about module/function/line in the log entry\n        buffer_log: buffer log read outputs\n\n    Returns:\n        None\n\n    Raises:\n        N/A\n\n    \"\"\"\n    logger.propagate = False\n    logger.setLevel(level=level.upper())\n\n    scrapli_formatter = ScrapliFormatter(caller_info=caller_info)\n\n    if file:\n        if isinstance(file, bool):\n            filename = \"scrapli_cfg.log\"\n        else:\n            filename = file\n\n        if not buffer_log:\n            fh = FileHandler(filename=filename, mode=\"w\")\n        else:\n            fh = ScrapliFileHandler(filename=filename, mode=\"w\")\n\n        fh.setFormatter(scrapli_formatter)\n\n        logger.addHandler(fh)\n\n\nlogger = getLogger(\"scrapli_cfg\")\nlogger.addHandler(NullHandler())\n        </code>\n    </pre>"},{"location":"api_docs/logging/#functions","title":"Functions","text":""},{"location":"api_docs/logging/#enable_basic_logging","title":"enable_basic_logging","text":"<p><code>enable_basic_logging(file:\u00a0Union[str,\u00a0bool]\u00a0=\u00a0False, level:\u00a0str\u00a0=\u00a0'info', caller_info:\u00a0bool\u00a0=\u00a0False, buffer_log:\u00a0bool\u00a0=\u00a0True) \u2011&gt; None</code></p> <pre><code>Enable opinionated logging for scrapli_cfg\n\nUses scrapli \"core\" formatter/file handler\n\nArgs:\n    file: True to output to default log path (\"scrapli.log\"), otherwise string path to write log\n        file to\n    level: string name of logging level to use, i.e. \"info\", \"debug\", etc.\n    caller_info: add info about module/function/line in the log entry\n    buffer_log: buffer log read outputs\n\nReturns:\n    None\n\nRaises:\n    N/A\n</code></pre>"},{"location":"api_docs/response/","title":"Response","text":"window.addEventListener('DOMContentLoaded', () =&gt; hljs.initHighlighting())"},{"location":"api_docs/response/#module-scrapli_cfgresponse","title":"Module scrapli_cfg.response","text":"<p>scrapli_cfg.response</p> Expand source code <pre>\n        <code>\n\"\"\"scrapli_cfg.response\"\"\"\nfrom datetime import datetime\nfrom typing import Iterable, List, Optional, Type, Union\n\nfrom scrapli.response import MultiResponse, Response\nfrom scrapli_cfg.exceptions import ScrapliCfgException\n\n\nclass ScrapliCfgResponse:\n    def __init__(\n        self, host: str, raise_for_status_exception: Type[Exception] = ScrapliCfgException\n    ) -&gt; None:\n        \"\"\"\n        Scrapli CFG Response object\n\n        Args:\n            host: host that was operated on\n            raise_for_status_exception: exception to raise if response is failed and user calls\n                `raise_for_status`\n\n        Returns:\n            N/A\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.host = host\n        self.start_time = datetime.now()\n        self.finish_time: Optional[datetime] = None\n        self.elapsed_time: Optional[float] = None\n\n        # scrapli_responses is a \"flattened\" list of responses from all operations that were\n        # performed; meaning that if we used any plural operations like send_commands we'll flatten\n        # the MultiResponse bits into a list of singular response objects and store them here\n        self.scrapli_responses: List[Response] = []\n        self.result: str = \"\"\n\n        self.raise_for_status_exception = raise_for_status_exception\n        self.failed = True\n\n    def __bool__(self) -&gt; bool:\n        \"\"\"\n        Magic bool method based on operation being failed or not\n\n        Args:\n            N/A\n\n        Returns:\n            bool: True/False if channel_input failed\n\n        Raises:\n            N/A\n\n        \"\"\"\n        return self.failed\n\n    def __repr__(self) -&gt; str:\n        \"\"\"\n        Magic repr method for ScrapliCfgResponse class\n\n        Args:\n            N/A\n\n        Returns:\n            str: repr for class object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        return f\"ScrapliCfgResponse \"\n\n    def __str__(self) -&gt; str:\n        \"\"\"\n        Magic str method for ScrapliCfgResponse class\n\n        Args:\n            N/A\n\n        Returns:\n            str: str for class object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        return f\"ScrapliCfgResponse \"\n\n    def record_response(\n        self, scrapli_responses: Iterable[Union[Response, MultiResponse]], result: str = \"\"\n    ) -&gt; None:\n        \"\"\"\n        Record channel_input results and elapsed time of channel input/reading output\n\n        Args:\n            scrapli_responses: list of scrapli response/multiresponse objects\n            result: string to assign to final result for the scrapli cfg response object\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.finish_time = datetime.now()\n        self.elapsed_time = (self.finish_time - self.start_time).total_seconds()\n\n        for response in scrapli_responses:\n            if isinstance(response, Response):\n                self.scrapli_responses.append(response)\n            elif isinstance(response, MultiResponse):\n                for sub_response in response:\n                    self.scrapli_responses.append(sub_response)\n\n        self.result = result\n\n        if not any(response.failed for response in self.scrapli_responses):\n            self.failed = False\n\n    def raise_for_status(self) -&gt; None:\n        \"\"\"\n        Raise a `ScrapliCommandFailure` if command/config failed\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            raise_for_status_exception: exception raised is dependent on the type of response object\n\n        \"\"\"\n        if self.failed:\n            raise self.raise_for_status_exception()"},{"location":"api_docs/response/#classes","title":"Classes","text":""},{"location":"api_docs/response/#scraplicfgresponse","title":"ScrapliCfgResponse","text":"<pre><code>Scrapli CFG Response object\n\nArgs:\n    host: host that was operated on\n    raise_for_status_exception: exception to raise if response is failed and user calls\n        `raise_for_status`\n\nReturns:\n    N/A\n\nRaises:\n    N/A\n</code></pre>\nExpand source code\n    <pre>\n        <code>\nclass ScrapliCfgResponse:\n    def __init__(\n        self, host: str, raise_for_status_exception: Type[Exception] = ScrapliCfgException\n    ) -&gt; None:\n        \"\"\"\n        Scrapli CFG Response object\n\n        Args:\n            host: host that was operated on\n            raise_for_status_exception: exception to raise if response is failed and user calls\n                `raise_for_status`\n\n        Returns:\n            N/A\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.host = host\n        self.start_time = datetime.now()\n        self.finish_time: Optional[datetime] = None\n        self.elapsed_time: Optional[float] = None\n\n        # scrapli_responses is a \"flattened\" list of responses from all operations that were\n        # performed; meaning that if we used any plural operations like send_commands we'll flatten\n        # the MultiResponse bits into a list of singular response objects and store them here\n        self.scrapli_responses: List[Response] = []\n        self.result: str = \"\"\n\n        self.raise_for_status_exception = raise_for_status_exception\n        self.failed = True\n\n    def __bool__(self) -&gt; bool:\n        \"\"\"\n        Magic bool method based on operation being failed or not\n\n        Args:\n            N/A\n\n        Returns:\n            bool: True/False if channel_input failed\n\n        Raises:\n            N/A\n\n        \"\"\"\n        return self.failed\n\n    def __repr__(self) -&gt; str:\n        \"\"\"\n        Magic repr method for ScrapliCfgResponse class\n\n        Args:\n            N/A\n\n        Returns:\n            str: repr for class object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        return f\"ScrapliCfgResponse \"\n\n    def __str__(self) -&gt; str:\n        \"\"\"\n        Magic str method for ScrapliCfgResponse class\n\n        Args:\n            N/A\n\n        Returns:\n            str: str for class object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        return f\"ScrapliCfgResponse \"\n\n    def record_response(\n        self, scrapli_responses: Iterable[Union[Response, MultiResponse]], result: str = \"\"\n    ) -&gt; None:\n        \"\"\"\n        Record channel_input results and elapsed time of channel input/reading output\n\n        Args:\n            scrapli_responses: list of scrapli response/multiresponse objects\n            result: string to assign to final result for the scrapli cfg response object\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.finish_time = datetime.now()\n        self.elapsed_time = (self.finish_time - self.start_time).total_seconds()\n\n        for response in scrapli_responses:\n            if isinstance(response, Response):\n                self.scrapli_responses.append(response)\n            elif isinstance(response, MultiResponse):\n                for sub_response in response:\n                    self.scrapli_responses.append(sub_response)\n\n        self.result = result\n\n        if not any(response.failed for response in self.scrapli_responses):\n            self.failed = False\n\n    def raise_for_status(self) -&gt; None:\n        \"\"\"\n        Raise a `ScrapliCommandFailure` if command/config failed\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            raise_for_status_exception: exception raised is dependent on the type of response object\n\n        \"\"\"\n        if self.failed:\n            raise self.raise_for_status_exception()"},{"location":"api_docs/response/#descendants","title":"Descendants","text":"<ul>\n<li>scrapli_cfg.diff.ScrapliCfgDiffResponse</li>\n</ul>"},{"location":"api_docs/response/#methods","title":"Methods","text":""},{"location":"api_docs/response/#raise_for_status","title":"raise_for_status","text":"<p><code>raise_for_status(self) \u2011&gt; None</code></p>\n<pre><code>Raise a `ScrapliCommandFailure` if command/config failed\n\nArgs:\n    N/A\n\nReturns:\n    None\n\nRaises:\n    raise_for_status_exception: exception raised is dependent on the type of response object\n</code></pre>"},{"location":"api_docs/response/#record_response","title":"record_response","text":"<p><code>record_response(self, scrapli_responses:\u00a0Iterable[Union[scrapli.response.Response,\u00a0scrapli.response.MultiResponse]], result:\u00a0str\u00a0=\u00a0'') \u2011&gt; None</code></p>\n<pre><code>Record channel_input results and elapsed time of channel input/reading output\n\nArgs:\n    scrapli_responses: list of scrapli response/multiresponse objects\n    result: string to assign to final result for the scrapli cfg response object\n\nReturns:\n    None\n\nRaises:\n    N/A\n</code></pre>"},{"location":"api_docs/platform/base/async_platform/","title":"Async Platform","text":"window.addEventListener('DOMContentLoaded', () =&gt; hljs.initHighlighting())"},{"location":"api_docs/platform/base/async_platform/#module-scrapli_cfgplatformbaseasync_platform","title":"Module scrapli_cfg.platform.base.async_platform","text":"<p>scrapli_cfg.platform.async_platform</p> Expand source code <pre>\n        <code>\n\"\"\"scrapli_cfg.platform.async_platform\"\"\"\nfrom abc import ABC, abstractmethod\nfrom types import TracebackType\nfrom typing import Any, Callable, List, Optional, Pattern, Tuple, Type\n\nfrom scrapli.driver import AsyncNetworkDriver\nfrom scrapli_cfg.diff import ScrapliCfgDiffResponse\nfrom scrapli_cfg.exceptions import ScrapliCfgException\nfrom scrapli_cfg.platform.base.base_platform import ScrapliCfgBase\nfrom scrapli_cfg.response import ScrapliCfgResponse\n\n\nclass AsyncScrapliCfgPlatform(ABC, ScrapliCfgBase):\n    def __init__(\n        self,\n        conn: AsyncNetworkDriver,\n        config_sources: List[str],\n        on_prepare: Optional[Callable[..., Any]],\n        dedicated_connection: bool,\n        ignore_version: bool,\n    ) -&gt; None:\n        \"\"\"\n        Scrapli Config async base class\n\n        Args:\n            conn: scrapli connection to use\n            config_sources: list of config sources\n            on_prepare: optional callable to run at connection `prepare`\n            dedicated_connection: if `False` (default value) scrapli cfg will not open or close the\n                underlying scrapli connection and will raise an exception if the scrapli connection\n                is not open. If `True` will automatically open and close the scrapli connection when\n                using with a context manager, `prepare` will open the scrapli connection (if not\n                already open), and `close` will close the scrapli connection.\n            ignore_version: ignore checking device version support; currently this just means that\n                scrapli-cfg will not fetch the device version during the prepare phase, however this\n                will (hopefully) be used in the future to limit what methods can be used against a\n                target device. For example, for EOS devices we need &gt; 4.14 to load configs; so if a\n                device is encountered at 4.13 the version check would raise an exception rather than\n                just failing in a potentially awkward fashion.\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.conn: AsyncNetworkDriver = conn\n        self.dedicated_connection = dedicated_connection\n\n        self.on_prepare = on_prepare\n\n        super().__init__(config_sources=config_sources, ignore_version=ignore_version)\n\n    async def __aenter__(self) -&gt; \"AsyncScrapliCfgPlatform\":\n        \"\"\"\n        Enter method for async context manager\n\n        Args:\n            N/A\n\n        Returns:\n            AsyncScrapliCfg: opened AsyncScrapliCfg object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        await self.prepare()\n        return self\n\n    async def __aexit__(\n        self,\n        exception_type: Optional[Type[BaseException]],\n        exception_value: Optional[BaseException],\n        traceback: Optional[TracebackType],\n    ) -&gt; None:\n        \"\"\"\n        Exit method to cleanup for async context manager\n\n        Args:\n            exception_type: exception type being raised\n            exception_value: message from exception being raised\n            traceback: traceback from exception being raised\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        await self.cleanup()\n\n    async def _open(self) -&gt; None:\n        \"\"\"\n        Handle opening (or raising exception if not open) of underlying scrapli connection\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            ScrapliCfgException: if scrapli connection is not open and auto_open_connection is False\n\n        \"\"\"\n        if self.conn.isalive():\n            return\n\n        if self.dedicated_connection:\n            self.logger.info(\n                \"underlying scrapli connection is not alive... opening scrapli connection\"\n            )\n            await self.conn.open()\n            return\n\n        raise ScrapliCfgException(\n            \"underlying scrapli connection is not open and `dedicated_connection` is False, \"\n            \"cannot continue!\"\n        )\n\n    async def _close(self) -&gt; None:\n        \"\"\"\n        Close the scrapli connection\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        if self.dedicated_connection is True and self.conn.isalive():\n            self.logger.info(\"dedicated_connection is True, closing scrapli connection\")\n            await self.conn.close()\n\n    async def prepare(self) -&gt; None:\n        \"\"\"\n        Prepare connection for scrapli_cfg operations\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.logger.info(\"preparing scrapli_cfg connection\")\n\n        await self._open()\n\n        if self.ignore_version is False:\n            self.logger.debug(\"ignore_version is False, fetching device version\")\n            version_response = await self.get_version()\n            self._validate_and_set_version(version_response=version_response)\n\n        if self.on_prepare is not None:\n            self.logger.debug(\"on_prepare provided, executing now\")\n            await self.on_prepare(self)\n\n        self._prepared = True\n\n    async def cleanup(self) -&gt; None:\n        \"\"\"\n        Cleanup after scrapli-cfg operations\n\n        Generally this can be skipped, however it will be executed if using a context manager. The\n        purpose of this method is to close the underlying scrapli connection (if in\n        \"dedicated_connection\" mode), and to reset the internally used `_version_string`, attribute.\n        All this is done so that this cfg connection, if re-used later (as in later in that script\n        using the same object) starts with a fresh slate.\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        await self._close()\n\n        # reset the version string/prepare flag so we know we need to re-fetch/re-run if user\n        # re-opens connection\n        self._version_string = \"\"\n        self._prepared = False\n\n        # this has *probably* been reset already, but reset it just in case user re-opens connection\n        # we can have a clean slate to work with\n        try:\n            self._reset_config_session()  # type: ignore\n        except AttributeError:\n            pass\n\n    @abstractmethod\n    async def get_version(self) -&gt; ScrapliCfgResponse:\n        \"\"\"\n        Get device version string\n\n        Args:\n            N/A\n\n        Returns:\n            ScrapliCfgResponse: response object where result is the string of the primary version\n                (as in the \"main\" os version) of the device\n\n        Raises:\n            N/A\n\n        \"\"\"\n\n    @abstractmethod\n    async def get_config(self, source: str = \"running\") -&gt; ScrapliCfgResponse:\n        \"\"\"\n        Get device configuration\n\n        Args:\n            source: name of the config source, generally running|startup\n\n        Returns:\n            ScrapliCfgResponse: response object containing string of the target config source as the\n                `result` attribute\n\n        Raises:\n            N/A\n\n        \"\"\"\n\n    @abstractmethod\n    async def load_config(\n        self, config: str, replace: bool = False, **kwargs: Any\n    ) -&gt; ScrapliCfgResponse:\n        \"\"\"\n        Load configuration to a device\n\n        Args:\n            config: string of the configuration to load\n            replace: replace the configuration or not, if false configuration will be loaded as a\n                merge operation\n            kwargs: additional kwargs that the implementing classes may need for their platform,\n                see your specific platform for details\n\n        Returns:\n            ScrapliCfgResponse: response object\n\n        Raises:\n            N/A\n\n        \"\"\"\n\n    @abstractmethod\n    async def abort_config(self) -&gt; ScrapliCfgResponse:\n        \"\"\"\n        Abort a configuration -- discards any loaded config\n\n        Args:\n            N/A\n\n        Returns:\n            ScrapliCfgResponse: response object\n\n        Raises:\n            N/A\n\n        \"\"\"\n\n    @abstractmethod\n    async def commit_config(self, source: str = \"running\") -&gt; ScrapliCfgResponse:\n        \"\"\"\n        Commit a loaded configuration\n\n        Args:\n            source: name of the config source to commit against, generally running|startup\n\n        Returns:\n            ScrapliCfgResponse: response object\n\n        Raises:\n            N/A\n\n        \"\"\"\n\n    @abstractmethod\n    async def diff_config(self, source: str = \"running\") -&gt; ScrapliCfgDiffResponse:\n        \"\"\"\n        Diff a loaded configuration against the source config store\n\n        Args:\n            source: name of the config source to diff against, generally running|startup -- device\n                diffs will generally not care about this argument, but the built in scrapli differ\n                will\n\n        Returns:\n            ScrapliCfgDiffResponse: scrapli cfg diff object\n\n        Raises:\n            N/A\n\n        \"\"\"\n\n    async def render_substituted_config(\n        self,\n        config_template: str,\n        substitutes: List[Tuple[str, Pattern[str]]],\n        source: str = \"running\",\n    ) -&gt; str:\n        \"\"\"\n        Render a substituted configuration file\n\n        Renders a configuration based on a user template, substitutes, and a target config from the\n        device.\n\n        Args:\n            config_template: config file to use as the base for substitutions -- should contain\n                jinja2-like variables that will be replaced with data fetched from the source config\n                by the substitutes patterns\n            substitutes: tuple of name, pattern -- where name matches the jinja2-like variable in\n                the config_template file, and pattern is a compiled regular expression pattern to be\n                used to fetch that section from the source config\n            source: config source to use for the substitution efforts, typically running|startup\n\n        Returns:\n            str: substituted/rendered config\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.logger.info(\"fetching configuration and replacing with provided substitutes\")\n\n        source_config = await self.get_config(source=source)\n        return self._render_substituted_config(\n            config_template=config_template,\n            substitutes=substitutes,\n            source_config=source_config.result,\n        )\n        </code>\n    </pre>"},{"location":"api_docs/platform/base/async_platform/#classes","title":"Classes","text":""},{"location":"api_docs/platform/base/async_platform/#asyncscraplicfgplatform","title":"AsyncScrapliCfgPlatform","text":"<pre><code>Helper class that provides a standard way to create an ABC using\ninheritance.\n\nScrapli Config async base class\n\nArgs:\n    conn: scrapli connection to use\n    config_sources: list of config sources\n    on_prepare: optional callable to run at connection `prepare`\n    dedicated_connection: if `False` (default value) scrapli cfg will not open or close the\n        underlying scrapli connection and will raise an exception if the scrapli connection\n        is not open. If `True` will automatically open and close the scrapli connection when\n        using with a context manager, `prepare` will open the scrapli connection (if not\n        already open), and `close` will close the scrapli connection.\n    ignore_version: ignore checking device version support; currently this just means that\n        scrapli-cfg will not fetch the device version during the prepare phase, however this\n        will (hopefully) be used in the future to limit what methods can be used against a\n        target device. For example, for EOS devices we need &gt; 4.14 to load configs; so if a\n        device is encountered at 4.13 the version check would raise an exception rather than\n        just failing in a potentially awkward fashion.\n\nReturns:\n    None\n\nRaises:\n    N/A\n</code></pre> Expand source code <pre>\n        <code>\nclass AsyncScrapliCfgPlatform(ABC, ScrapliCfgBase):\n    def __init__(\n        self,\n        conn: AsyncNetworkDriver,\n        config_sources: List[str],\n        on_prepare: Optional[Callable[..., Any]],\n        dedicated_connection: bool,\n        ignore_version: bool,\n    ) -&gt; None:\n        \"\"\"\n        Scrapli Config async base class\n\n        Args:\n            conn: scrapli connection to use\n            config_sources: list of config sources\n            on_prepare: optional callable to run at connection `prepare`\n            dedicated_connection: if `False` (default value) scrapli cfg will not open or close the\n                underlying scrapli connection and will raise an exception if the scrapli connection\n                is not open. If `True` will automatically open and close the scrapli connection when\n                using with a context manager, `prepare` will open the scrapli connection (if not\n                already open), and `close` will close the scrapli connection.\n            ignore_version: ignore checking device version support; currently this just means that\n                scrapli-cfg will not fetch the device version during the prepare phase, however this\n                will (hopefully) be used in the future to limit what methods can be used against a\n                target device. For example, for EOS devices we need &gt; 4.14 to load configs; so if a\n                device is encountered at 4.13 the version check would raise an exception rather than\n                just failing in a potentially awkward fashion.\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.conn: AsyncNetworkDriver = conn\n        self.dedicated_connection = dedicated_connection\n\n        self.on_prepare = on_prepare\n\n        super().__init__(config_sources=config_sources, ignore_version=ignore_version)\n\n    async def __aenter__(self) -&gt; \"AsyncScrapliCfgPlatform\":\n        \"\"\"\n        Enter method for async context manager\n\n        Args:\n            N/A\n\n        Returns:\n            AsyncScrapliCfg: opened AsyncScrapliCfg object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        await self.prepare()\n        return self\n\n    async def __aexit__(\n        self,\n        exception_type: Optional[Type[BaseException]],\n        exception_value: Optional[BaseException],\n        traceback: Optional[TracebackType],\n    ) -&gt; None:\n        \"\"\"\n        Exit method to cleanup for async context manager\n\n        Args:\n            exception_type: exception type being raised\n            exception_value: message from exception being raised\n            traceback: traceback from exception being raised\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        await self.cleanup()\n\n    async def _open(self) -&gt; None:\n        \"\"\"\n        Handle opening (or raising exception if not open) of underlying scrapli connection\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            ScrapliCfgException: if scrapli connection is not open and auto_open_connection is False\n\n        \"\"\"\n        if self.conn.isalive():\n            return\n\n        if self.dedicated_connection:\n            self.logger.info(\n                \"underlying scrapli connection is not alive... opening scrapli connection\"\n            )\n            await self.conn.open()\n            return\n\n        raise ScrapliCfgException(\n            \"underlying scrapli connection is not open and `dedicated_connection` is False, \"\n            \"cannot continue!\"\n        )\n\n    async def _close(self) -&gt; None:\n        \"\"\"\n        Close the scrapli connection\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        if self.dedicated_connection is True and self.conn.isalive():\n            self.logger.info(\"dedicated_connection is True, closing scrapli connection\")\n            await self.conn.close()\n\n    async def prepare(self) -&gt; None:\n        \"\"\"\n        Prepare connection for scrapli_cfg operations\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.logger.info(\"preparing scrapli_cfg connection\")\n\n        await self._open()\n\n        if self.ignore_version is False:\n            self.logger.debug(\"ignore_version is False, fetching device version\")\n            version_response = await self.get_version()\n            self._validate_and_set_version(version_response=version_response)\n\n        if self.on_prepare is not None:\n            self.logger.debug(\"on_prepare provided, executing now\")\n            await self.on_prepare(self)\n\n        self._prepared = True\n\n    async def cleanup(self) -&gt; None:\n        \"\"\"\n        Cleanup after scrapli-cfg operations\n\n        Generally this can be skipped, however it will be executed if using a context manager. The\n        purpose of this method is to close the underlying scrapli connection (if in\n        \"dedicated_connection\" mode), and to reset the internally used `_version_string`, attribute.\n        All this is done so that this cfg connection, if re-used later (as in later in that script\n        using the same object) starts with a fresh slate.\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        await self._close()\n\n        # reset the version string/prepare flag so we know we need to re-fetch/re-run if user\n        # re-opens connection\n        self._version_string = \"\"\n        self._prepared = False\n\n        # this has *probably* been reset already, but reset it just in case user re-opens connection\n        # we can have a clean slate to work with\n        try:\n            self._reset_config_session()  # type: ignore\n        except AttributeError:\n            pass\n\n    @abstractmethod\n    async def get_version(self) -&gt; ScrapliCfgResponse:\n        \"\"\"\n        Get device version string\n\n        Args:\n            N/A\n\n        Returns:\n            ScrapliCfgResponse: response object where result is the string of the primary version\n                (as in the \"main\" os version) of the device\n\n        Raises:\n            N/A\n\n        \"\"\"\n\n    @abstractmethod\n    async def get_config(self, source: str = \"running\") -&gt; ScrapliCfgResponse:\n        \"\"\"\n        Get device configuration\n\n        Args:\n            source: name of the config source, generally running|startup\n\n        Returns:\n            ScrapliCfgResponse: response object containing string of the target config source as the\n                `result` attribute\n\n        Raises:\n            N/A\n\n        \"\"\"\n\n    @abstractmethod\n    async def load_config(\n        self, config: str, replace: bool = False, **kwargs: Any\n    ) -&gt; ScrapliCfgResponse:\n        \"\"\"\n        Load configuration to a device\n\n        Args:\n            config: string of the configuration to load\n            replace: replace the configuration or not, if false configuration will be loaded as a\n                merge operation\n            kwargs: additional kwargs that the implementing classes may need for their platform,\n                see your specific platform for details\n\n        Returns:\n            ScrapliCfgResponse: response object\n\n        Raises:\n            N/A\n\n        \"\"\"\n\n    @abstractmethod\n    async def abort_config(self) -&gt; ScrapliCfgResponse:\n        \"\"\"\n        Abort a configuration -- discards any loaded config\n\n        Args:\n            N/A\n\n        Returns:\n            ScrapliCfgResponse: response object\n\n        Raises:\n            N/A\n\n        \"\"\"\n\n    @abstractmethod\n    async def commit_config(self, source: str = \"running\") -&gt; ScrapliCfgResponse:\n        \"\"\"\n        Commit a loaded configuration\n\n        Args:\n            source: name of the config source to commit against, generally running|startup\n\n        Returns:\n            ScrapliCfgResponse: response object\n\n        Raises:\n            N/A\n\n        \"\"\"\n\n    @abstractmethod\n    async def diff_config(self, source: str = \"running\") -&gt; ScrapliCfgDiffResponse:\n        \"\"\"\n        Diff a loaded configuration against the source config store\n\n        Args:\n            source: name of the config source to diff against, generally running|startup -- device\n                diffs will generally not care about this argument, but the built in scrapli differ\n                will\n\n        Returns:\n            ScrapliCfgDiffResponse: scrapli cfg diff object\n\n        Raises:\n            N/A\n\n        \"\"\"\n\n    async def render_substituted_config(\n        self,\n        config_template: str,\n        substitutes: List[Tuple[str, Pattern[str]]],\n        source: str = \"running\",\n    ) -&gt; str:\n        \"\"\"\n        Render a substituted configuration file\n\n        Renders a configuration based on a user template, substitutes, and a target config from the\n        device.\n\n        Args:\n            config_template: config file to use as the base for substitutions -- should contain\n                jinja2-like variables that will be replaced with data fetched from the source config\n                by the substitutes patterns\n            substitutes: tuple of name, pattern -- where name matches the jinja2-like variable in\n                the config_template file, and pattern is a compiled regular expression pattern to be\n                used to fetch that section from the source config\n            source: config source to use for the substitution efforts, typically running|startup\n\n        Returns:\n            str: substituted/rendered config\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.logger.info(\"fetching configuration and replacing with provided substitutes\")\n\n        source_config = await self.get_config(source=source)\n        return self._render_substituted_config(\n            config_template=config_template,\n            substitutes=substitutes,\n            source_config=source_config.result,\n        )\n        </code>\n    </pre>"},{"location":"api_docs/platform/base/async_platform/#ancestors-in-mro","title":"Ancestors (in MRO)","text":"<ul> <li>abc.ABC</li> <li>scrapli_cfg.platform.base.base_platform.ScrapliCfgBase</li> </ul>"},{"location":"api_docs/platform/base/async_platform/#descendants","title":"Descendants","text":"<ul> <li>scrapli_cfg.platform.core.arista_eos.async_platform.AsyncScrapliCfgEOS</li> <li>scrapli_cfg.platform.core.cisco_iosxe.async_platform.AsyncScrapliCfgIOSXE</li> <li>scrapli_cfg.platform.core.cisco_iosxr.async_platform.AsyncScrapliCfgIOSXR</li> <li>scrapli_cfg.platform.core.cisco_nxos.async_platform.AsyncScrapliCfgNXOS</li> <li>scrapli_cfg.platform.core.juniper_junos.async_platform.AsyncScrapliCfgJunos</li> </ul>"},{"location":"api_docs/platform/base/async_platform/#class-variables","title":"Class variables","text":"<p><code>conn: Union[scrapli.driver.network.sync_driver.NetworkDriver,\u00a0scrapli.driver.network.async_driver.AsyncNetworkDriver]</code></p>"},{"location":"api_docs/platform/base/async_platform/#methods","title":"Methods","text":""},{"location":"api_docs/platform/base/async_platform/#abort_config","title":"abort_config","text":"<p><code>abort_config(self) \u2011&gt; scrapli_cfg.response.ScrapliCfgResponse</code></p> <pre><code>Abort a configuration -- discards any loaded config\n\nArgs:\n    N/A\n\nReturns:\n    ScrapliCfgResponse: response object\n\nRaises:\n    N/A\n</code></pre>"},{"location":"api_docs/platform/base/async_platform/#cleanup","title":"cleanup","text":"<p><code>cleanup(self) \u2011&gt; None</code></p> <pre><code>Cleanup after scrapli-cfg operations\n\nGenerally this can be skipped, however it will be executed if using a context manager. The\npurpose of this method is to close the underlying scrapli connection (if in\n\"dedicated_connection\" mode), and to reset the internally used `_version_string`, attribute.\nAll this is done so that this cfg connection, if re-used later (as in later in that script\nusing the same object) starts with a fresh slate.\n\nArgs:\n    N/A\n\nReturns:\n    None\n\nRaises:\n    N/A\n</code></pre>"},{"location":"api_docs/platform/base/async_platform/#commit_config","title":"commit_config","text":"<p><code>commit_config(self, source:\u00a0str\u00a0=\u00a0'running') \u2011&gt; scrapli_cfg.response.ScrapliCfgResponse</code></p> <pre><code>Commit a loaded configuration\n\nArgs:\n    source: name of the config source to commit against, generally running|startup\n\nReturns:\n    ScrapliCfgResponse: response object\n\nRaises:\n    N/A\n</code></pre>"},{"location":"api_docs/platform/base/async_platform/#diff_config","title":"diff_config","text":"<p><code>diff_config(self, source:\u00a0str\u00a0=\u00a0'running') \u2011&gt; scrapli_cfg.diff.ScrapliCfgDiffResponse</code></p> <pre><code>Diff a loaded configuration against the source config store\n\nArgs:\n    source: name of the config source to diff against, generally running|startup -- device\n        diffs will generally not care about this argument, but the built in scrapli differ\n        will\n\nReturns:\n    ScrapliCfgDiffResponse: scrapli cfg diff object\n\nRaises:\n    N/A\n</code></pre>"},{"location":"api_docs/platform/base/async_platform/#get_config","title":"get_config","text":"<p><code>get_config(self, source:\u00a0str\u00a0=\u00a0'running') \u2011&gt; scrapli_cfg.response.ScrapliCfgResponse</code></p> <pre><code>Get device configuration\n\nArgs:\n    source: name of the config source, generally running|startup\n\nReturns:\n    ScrapliCfgResponse: response object containing string of the target config source as the\n        `result` attribute\n\nRaises:\n    N/A\n</code></pre>"},{"location":"api_docs/platform/base/async_platform/#get_version","title":"get_version","text":"<p><code>get_version(self) \u2011&gt; scrapli_cfg.response.ScrapliCfgResponse</code></p> <pre><code>Get device version string\n\nArgs:\n    N/A\n\nReturns:\n    ScrapliCfgResponse: response object where result is the string of the primary version\n        (as in the \"main\" os version) of the device\n\nRaises:\n    N/A\n</code></pre>"},{"location":"api_docs/platform/base/async_platform/#load_config","title":"load_config","text":"<p><code>load_config(self, config:\u00a0str, replace:\u00a0bool\u00a0=\u00a0False, **kwargs:\u00a0Any) \u2011&gt; scrapli_cfg.response.ScrapliCfgResponse</code></p> <pre><code>Load configuration to a device\n\nArgs:\n    config: string of the configuration to load\n    replace: replace the configuration or not, if false configuration will be loaded as a\n        merge operation\n    kwargs: additional kwargs that the implementing classes may need for their platform,\n        see your specific platform for details\n\nReturns:\n    ScrapliCfgResponse: response object\n\nRaises:\n    N/A\n</code></pre>"},{"location":"api_docs/platform/base/async_platform/#prepare","title":"prepare","text":"<p><code>prepare(self) \u2011&gt; None</code></p> <pre><code>Prepare connection for scrapli_cfg operations\n\nArgs:\n    N/A\n\nReturns:\n    None\n\nRaises:\n    N/A\n</code></pre>"},{"location":"api_docs/platform/base/async_platform/#render_substituted_config","title":"render_substituted_config","text":"<p><code>render_substituted_config(self, config_template:\u00a0str, substitutes:\u00a0List[Tuple[str,\u00a0Pattern[str]]], source:\u00a0str\u00a0=\u00a0'running') \u2011&gt; str</code></p> <pre><code>Render a substituted configuration file\n\nRenders a configuration based on a user template, substitutes, and a target config from the\ndevice.\n\nArgs:\n    config_template: config file to use as the base for substitutions -- should contain\n        jinja2-like variables that will be replaced with data fetched from the source config\n        by the substitutes patterns\n    substitutes: tuple of name, pattern -- where name matches the jinja2-like variable in\n        the config_template file, and pattern is a compiled regular expression pattern to be\n        used to fetch that section from the source config\n    source: config source to use for the substitution efforts, typically running|startup\n\nReturns:\n    str: substituted/rendered config\n\nRaises:\n    N/A\n</code></pre>"},{"location":"api_docs/platform/base/base_platform/","title":"Base platform","text":"window.addEventListener('DOMContentLoaded', () =&gt; hljs.initHighlighting())"},{"location":"api_docs/platform/base/base_platform/#module-scrapli_cfgplatformbasebase_platform","title":"Module scrapli_cfg.platform.base.base_platform","text":"<p>scrapli_cfg.platforms.base_platform</p> Expand source code <pre>\n        <code>\n\"\"\"scrapli_cfg.platforms.base_platform\"\"\"\nimport re\nfrom typing import List, Pattern, Tuple, Union\n\nfrom scrapli.driver import AsyncNetworkDriver, NetworkDriver\nfrom scrapli.logging import get_instance_logger\nfrom scrapli.response import MultiResponse, Response\nfrom scrapli_cfg.diff import ScrapliCfgDiffResponse\nfrom scrapli_cfg.exceptions import (\n    AbortConfigError,\n    CommitConfigError,\n    DiffConfigError,\n    GetConfigError,\n    InvalidConfigTarget,\n    LoadConfigError,\n    PrepareNotCalled,\n    TemplateError,\n    VersionError,\n)\nfrom scrapli_cfg.response import ScrapliCfgResponse\n\n\nclass ScrapliCfgBase:\n    conn: Union[NetworkDriver, AsyncNetworkDriver]\n\n    def __init__(self, config_sources: List[str], ignore_version: bool = False) -&gt; None:\n        \"\"\"\n        Base class for all CFG platforms\n\n        Args:\n            config_sources: list of allowed config sources\n            ignore_version: ignore platform version check or not\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.logger = get_instance_logger(\n            instance_name=\"scrapli_cfg.platform\", host=self.conn.host, port=self.conn.port\n        )\n\n        self.config_sources = config_sources\n        self.candidate_config = \"\"\n\n        self.ignore_version = ignore_version\n        self._get_version_command = \"\"\n        self._version_string = \"\"\n\n        # bool indicated if a `on_prepare` callable has been executed or not\n        self._prepared = False\n\n    def _render_substituted_config(\n        self, config_template: str, substitutes: List[Tuple[str, Pattern[str]]], source_config: str\n    ) -&gt; str:\n        \"\"\"\n        Render a substituted configuration file\n\n        Renders a configuration based on a user template, substitutes, and a target config from the\n        device.\n\n        Args:\n            config_template: config file to use as the base for substitutions -- should contain\n                jinja2-like variables that will be replaced with data fetched from the source config\n                by the substitutes patterns\n            substitutes: tuple of name, pattern -- where name matches the jinja2-like variable in\n                the config_template file, and pattern is a compiled regular expression pattern to be\n                used to fetch that section from the source config\n            source_config: current source config to use in substitution process\n\n        Returns:\n            None\n\n        Raises:\n            TemplateError: if no substitute sections are provided\n            TemplateError: if one or more of the substitute sections is missing in the template\n            TemplateError: if a substitute pattern is not found in the config template\n\n        \"\"\"\n        self.logger.debug(\"rendering substituted config\")\n\n        if not substitutes:\n            msg = \"no substitutes provided...\"\n            self.logger.critical(msg)\n            raise TemplateError(msg)\n\n        if not all(f\"{{{{ {name} }}}}\" in config_template for name, _ in substitutes):\n            msg = \"missing one or more of the provided substitutions from the config template\"\n            self.logger.critical(msg)\n            raise TemplateError(msg)\n\n        replace_sections = [\n            (name, re.search(pattern=pattern, string=source_config))\n            for name, pattern in substitutes\n        ]\n\n        rendered_config = \"\"\n        for name, replace_section in replace_sections:\n            if not replace_section:\n                msg = (\n                    f\"substitution pattern {name} was unable to find a match in the target config\"\n                    \" source\"\n                )\n                self.logger.critical(msg)\n                raise TemplateError(msg)\n\n            replace_group = replace_section.group()\n            rendered_config = config_template.replace(f\"{{{{ {name} }}}}\", replace_group)\n\n        # remove any totally empty lines (from bad regex, or just device spitting out lines w/\n        # nothing on it\n        rendered_config = \"\\n\".join(line for line in rendered_config.splitlines() if line)\n\n        self.logger.debug(\"rendering substituted config complete\")\n\n        return rendered_config\n\n    def _validate_and_set_version(self, version_response: ScrapliCfgResponse) -&gt; None:\n        \"\"\"\n        Ensure version was fetched successfully and set internal version attribute\n\n        Args:\n            version_response: scrapli cfg response from get version operation\n\n        Returns:\n            None\n\n        Raises:\n            VersionError: if fetching version failed or failed to parse version\n\n        \"\"\"\n        if version_response.failed:\n            msg = \"failed getting version from device\"\n            self.logger.critical(msg)\n            raise VersionError(msg)\n        if not version_response.result:\n            msg = \"failed parsing version string from device output\"\n            self.logger.critical(msg)\n            raise VersionError(msg)\n        self._version_string = version_response.result\n\n    def _prepare_ok(self) -&gt; None:\n        \"\"\"\n        Determine if prepare is \"OK\" for a given operation\n\n        Checks if an `on_prepare` callable has been provided, and if so, if it has been executed.\n        This is meant to help force users into calling `prepare` or using the context manager prior\n        to running any methods.\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            PrepareNotCalled: if `on_prepare` is not None and `_prepared` is False\n\n        \"\"\"\n        # ignoring type/complaints as `on_prepare` will always be set in the sync/async classes;\n        # but is not set here since in one its a coroutine and the other not\n        _on_prepare = self.on_prepare  # type: ignore  # noqa\n        if _on_prepare is not None and self._prepared is False:\n            raise PrepareNotCalled(\n                \"on_prepare callable provided, but prepare method not called. call prepare method \"\n                \"or use context manager to ensure it is called for you\"\n            )\n\n    def _version_ok(self) -&gt; None:\n        \"\"\"\n        Determine if version is \"OK\" for a given operation\n\n        Should be overridden and super'd to by platforms that implement version constraints, will\n        simply check that if `ignore_version` is `False` we have set the internal `_version_string`\n        attribute, if not, will raise `PrepareNotCalled` exception.\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            PrepareNotCalled: if ignore version is False and _version_string not set\n\n        \"\"\"\n        if self.ignore_version is False and not self._version_string:\n            raise PrepareNotCalled(\n                \"ignore_version is False, but version has not yet been fetched. call prepare method\"\n                \" or use context manager to ensure that version is properly gathered\"\n            )\n\n    def _operation_ok(self) -&gt; None:\n        \"\"\"\n        Determine if all values are \"OK\" for a given operation\n\n        Checks if version and prepare are ok. Convenience func to just have one thing to call in the\n        `_pre` operation methods.\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self._prepare_ok()\n        self._version_ok()\n\n    def _pre_get_version(self) -&gt; ScrapliCfgResponse:\n        \"\"\"\n        Handle pre \"get_version\" operations for parity between sync and async\n\n        Args:\n            N/A\n\n        Returns:\n            ScrapliCfgResponse: new response object to update w/ get results\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.logger.info(\"get_version requested\")\n\n        response = ScrapliCfgResponse(host=self.conn.host, raise_for_status_exception=VersionError)\n\n        return response\n\n    def _post_get_version(\n        self,\n        response: ScrapliCfgResponse,\n        scrapli_responses: List[Response],\n        result: str,\n    ) -&gt; ScrapliCfgResponse:\n        \"\"\"\n        Handle post \"get_version\" operations for parity between sync and async\n\n        Args:\n            response: response object to update\n            scrapli_responses: list of scrapli response objects from fetching the version\n            result: final version string of the device\n\n        Returns:\n            ScrapliCfgResponse: response object containing string of the version as the `result`\n                attribute\n\n        Raises:\n            N/A\n\n        \"\"\"\n        response.record_response(scrapli_responses=scrapli_responses, result=result)\n\n        if response.failed:\n            msg = \"failed to get version from device\"\n            self.logger.critical(msg)\n\n        return response\n\n    def _pre_get_config(self, source: str) -&gt; ScrapliCfgResponse:\n        \"\"\"\n        Handle pre \"get_config\" operations for parity between sync and async\n\n        Args:\n            source: name of the config source, generally running|startup\n\n        Returns:\n            ScrapliCfgResponse: new response object to update w/ get results\n\n        Raises:\n            InvalidConfigTarget: if the requested config source is not valid\n\n        \"\"\"\n        self.logger.info(f\"get_config for config source '{source}' requested\")\n\n        self._operation_ok()\n\n        if source not in self.config_sources:\n            msg = (\n                f\"provided config source '{source}' not valid, must be one of {self.config_sources}\"\n            )\n            self.logger.critical(msg)\n            raise InvalidConfigTarget(msg)\n\n        response = ScrapliCfgResponse(\n            host=self.conn.host, raise_for_status_exception=GetConfigError\n        )\n\n        return response\n\n    def _post_get_config(\n        self,\n        response: ScrapliCfgResponse,\n        source: str,\n        scrapli_responses: List[Union[Response, MultiResponse]],\n        result: str,\n    ) -&gt; ScrapliCfgResponse:\n        \"\"\"\n        Handle post \"get_config\" operations for parity between sync and async\n\n        Args:\n            response: response object to update\n            source: name of the config source, generally running|startup\n            scrapli_responses: list of scrapli response objects from fetching the config\n            result: final string of the \"get_config\" result\n\n        Returns:\n            ScrapliCfgResponse: response object containing string of the target config source as the\n                `result` attribute\n\n        Raises:\n            N/A\n\n        \"\"\"\n        response.record_response(scrapli_responses=scrapli_responses, result=result)\n\n        if response.failed:\n            msg = f\"failed to get {source} config\"\n            self.logger.critical(msg)\n\n        return response\n\n    def _pre_load_config(self, config: str) -&gt; ScrapliCfgResponse:\n        \"\"\"\n        Handle pre \"load_config\" operations for parity between sync and async\n\n        Args:\n            config: candidate config to load\n\n        Returns:\n            ScrapliCfgResponse: new response object for load operation\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.logger.info(\"load_config requested\")\n\n        self._operation_ok()\n\n        self.candidate_config = config\n\n        response = ScrapliCfgResponse(\n            host=self.conn.host, raise_for_status_exception=LoadConfigError\n        )\n\n        return response\n\n    def _post_load_config(\n        self,\n        response: ScrapliCfgResponse,\n        scrapli_responses: List[Response],\n    ) -&gt; ScrapliCfgResponse:\n        \"\"\"\n        Handle post \"get_config\" operations for parity between sync and async\n\n        Args:\n            response: response object to update\n            scrapli_responses: list of scrapli response objects from fetching the config\n\n        Returns:\n            ScrapliCfgResponse: response object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        response.record_response(scrapli_responses=scrapli_responses)\n\n        if response.failed:\n            msg = \"failed to load candidate config\"\n            self.logger.critical(msg)\n\n        return response\n\n    def _pre_abort_config(self, session_or_config_file: bool) -&gt; ScrapliCfgResponse:\n        \"\"\"\n        Handle pre \"abort_config\" operations for parity between sync and async\n\n        Args:\n            session_or_config_file: bool indicating if a session or candidate config file has been\n                loaded -- in other words, is there anything to abort right now\n\n        Returns:\n            ScrapliCfgResponse: response object for abort operation\n\n        Raises:\n            AbortConfigError: if no config session or config file exists then we have no config to\n                abort!\n\n        \"\"\"\n        self.logger.info(\"abort_config requested\")\n\n        self._operation_ok()\n\n        if session_or_config_file is False:\n            msg = (\n                \"no configuration session or candidate configuration file exists, you must load a \"\n                \"config in order to abort it!\"\n            )\n            self.logger.critical(msg)\n            raise AbortConfigError(msg)\n\n        response = ScrapliCfgResponse(\n            host=self.conn.host, raise_for_status_exception=AbortConfigError\n        )\n\n        return response\n\n    def _post_abort_config(\n        self,\n        response: ScrapliCfgResponse,\n        scrapli_responses: List[Union[Response, MultiResponse]],\n    ) -&gt; ScrapliCfgResponse:\n        \"\"\"\n        Handle post \"abort_config\" operations for parity between sync and async\n\n        Args:\n            response: response object to update\n            scrapli_responses: list of scrapli response objects from aborting the config\n\n        Returns:\n            ScrapliCfgResponse: response object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        response.record_response(scrapli_responses=scrapli_responses)\n\n        if response.failed:\n            msg = \"failed to abort config\"\n            self.logger.critical(msg)\n\n        return response\n\n    def _pre_commit_config(self, source: str, session_or_config_file: bool) -&gt; ScrapliCfgResponse:\n        \"\"\"\n        Handle pre \"commit_config\" operations for parity between sync and async\n\n        Args:\n            source: name of the config source, generally running|startup\n            session_or_config_file: bool indicating if a session or candidate config file has been\n                loaded -- in other words, is there anything to commit right now\n\n        Returns:\n            ScrapliCfgResponse: new response object to update w/ commit results\n\n        Raises:\n            InvalidConfigTarget: if the requested config source is not valid\n            CommitConfigError: if no config session/file exists to commit\n\n        \"\"\"\n        self.logger.info(f\"get_config for config source '{source}' requested\")\n\n        self._operation_ok()\n\n        if source not in self.config_sources:\n            msg = (\n                f\"provided config source '{source}' not valid, must be one of {self.config_sources}\"\n            )\n            self.logger.critical(msg)\n            raise InvalidConfigTarget(msg)\n\n        if session_or_config_file is False:\n            msg = (\n                \"no configuration session or candidate configuration file exists, you must load a \"\n                \"config in order to commit it!\"\n            )\n            self.logger.critical(msg)\n            raise CommitConfigError(msg)\n\n        response = ScrapliCfgResponse(\n            host=self.conn.host, raise_for_status_exception=CommitConfigError\n        )\n\n        return response\n\n    def _post_commit_config(\n        self,\n        response: ScrapliCfgResponse,\n        scrapli_responses: List[Union[Response, MultiResponse]],\n    ) -&gt; ScrapliCfgResponse:\n        \"\"\"\n        Handle post \"commit_config\" operations for parity between sync and async\n\n        Args:\n            response: response object to update\n            scrapli_responses: list of scrapli response objects from committing the config\n\n        Returns:\n            ScrapliCfgResponse: response object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        response.record_response(scrapli_responses=scrapli_responses)\n\n        if response.failed:\n            msg = \"failed to commit config\"\n            self.logger.critical(msg)\n\n        return response\n\n    def _pre_diff_config(self, source: str, session_or_config_file: bool) -&gt; ScrapliCfgDiffResponse:\n        \"\"\"\n        Handle pre \"diff_config\" operations for parity between sync and async\n\n        Args:\n            source: config source to diff against\n            session_or_config_file: bool of config_session_name or candidate_config_filename\n\n        Returns:\n            ScrapliCfgDiffResponse: diff object for diff operation\n\n        Raises:\n            InvalidConfigTarget: if trying to diff against an invalid config target\n            DiffConfigError: if no config session or config file exists then we have no config to\n                diff!\n\n        \"\"\"\n        self.logger.info(\"diff_config requested\")\n\n        self._operation_ok()\n\n        if source not in self.config_sources:\n            msg = (\n                f\"provided config source '{source}' not valid, must be one of {self.config_sources}\"\n            )\n            self.logger.critical(msg)\n            raise InvalidConfigTarget(msg)\n\n        if session_or_config_file is False:\n            msg = (\n                \"no configuration session or candidate configuration file exists, you must load a \"\n                \"config in order to diff it!\"\n            )\n            self.logger.critical(msg)\n            raise DiffConfigError(msg)\n\n        diff_response = ScrapliCfgDiffResponse(host=self.conn.host, source=source)\n\n        return diff_response\n\n    def _post_diff_config(\n        self,\n        diff_response: ScrapliCfgDiffResponse,\n        scrapli_responses: List[Response],\n        source_config: str,\n        candidate_config: str,\n        device_diff: str,\n    ) -&gt; ScrapliCfgDiffResponse:\n        \"\"\"\n        Handle post \"diff_config\" operations for parity between sync and async\n\n        Args:\n            diff_response: response object to update\n            scrapli_responses: list of scrapli response objects from committing the config\n            source_config: previous source config from the device\n            candidate_config: user provided configuration\n            device_diff: diff generated from the device itself\n\n        Returns:\n            ScrapliCfgDiffResponse: diff object for diff operation\n\n        Raises:\n            N/A\n\n        \"\"\"\n        diff_response.record_response(scrapli_responses=scrapli_responses)\n        diff_response.record_diff_response(\n            source_config=source_config + \"\\n\",\n            candidate_config=candidate_config + \"\\n\",\n            device_diff=device_diff,\n        )\n\n        if diff_response.failed:\n            msg = \"failed to diff config\"\n            self.logger.critical(msg)\n\n        return diff_response\n        </code>\n    </pre>"},{"location":"api_docs/platform/base/base_platform/#classes","title":"Classes","text":""},{"location":"api_docs/platform/base/base_platform/#scraplicfgbase","title":"ScrapliCfgBase","text":"<pre><code>Base class for all CFG platforms\n\nArgs:\n    config_sources: list of allowed config sources\n    ignore_version: ignore platform version check or not\n\nReturns:\n    None\n\nRaises:\n    N/A\n</code></pre> Expand source code <pre>\n        <code>\nclass ScrapliCfgBase:\n    conn: Union[NetworkDriver, AsyncNetworkDriver]\n\n    def __init__(self, config_sources: List[str], ignore_version: bool = False) -&gt; None:\n        \"\"\"\n        Base class for all CFG platforms\n\n        Args:\n            config_sources: list of allowed config sources\n            ignore_version: ignore platform version check or not\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.logger = get_instance_logger(\n            instance_name=\"scrapli_cfg.platform\", host=self.conn.host, port=self.conn.port\n        )\n\n        self.config_sources = config_sources\n        self.candidate_config = \"\"\n\n        self.ignore_version = ignore_version\n        self._get_version_command = \"\"\n        self._version_string = \"\"\n\n        # bool indicated if a `on_prepare` callable has been executed or not\n        self._prepared = False\n\n    def _render_substituted_config(\n        self, config_template: str, substitutes: List[Tuple[str, Pattern[str]]], source_config: str\n    ) -&gt; str:\n        \"\"\"\n        Render a substituted configuration file\n\n        Renders a configuration based on a user template, substitutes, and a target config from the\n        device.\n\n        Args:\n            config_template: config file to use as the base for substitutions -- should contain\n                jinja2-like variables that will be replaced with data fetched from the source config\n                by the substitutes patterns\n            substitutes: tuple of name, pattern -- where name matches the jinja2-like variable in\n                the config_template file, and pattern is a compiled regular expression pattern to be\n                used to fetch that section from the source config\n            source_config: current source config to use in substitution process\n\n        Returns:\n            None\n\n        Raises:\n            TemplateError: if no substitute sections are provided\n            TemplateError: if one or more of the substitute sections is missing in the template\n            TemplateError: if a substitute pattern is not found in the config template\n\n        \"\"\"\n        self.logger.debug(\"rendering substituted config\")\n\n        if not substitutes:\n            msg = \"no substitutes provided...\"\n            self.logger.critical(msg)\n            raise TemplateError(msg)\n\n        if not all(f\"{{{{ {name} }}}}\" in config_template for name, _ in substitutes):\n            msg = \"missing one or more of the provided substitutions from the config template\"\n            self.logger.critical(msg)\n            raise TemplateError(msg)\n\n        replace_sections = [\n            (name, re.search(pattern=pattern, string=source_config))\n            for name, pattern in substitutes\n        ]\n\n        rendered_config = \"\"\n        for name, replace_section in replace_sections:\n            if not replace_section:\n                msg = (\n                    f\"substitution pattern {name} was unable to find a match in the target config\"\n                    \" source\"\n                )\n                self.logger.critical(msg)\n                raise TemplateError(msg)\n\n            replace_group = replace_section.group()\n            rendered_config = config_template.replace(f\"{{{{ {name} }}}}\", replace_group)\n\n        # remove any totally empty lines (from bad regex, or just device spitting out lines w/\n        # nothing on it\n        rendered_config = \"\\n\".join(line for line in rendered_config.splitlines() if line)\n\n        self.logger.debug(\"rendering substituted config complete\")\n\n        return rendered_config\n\n    def _validate_and_set_version(self, version_response: ScrapliCfgResponse) -&gt; None:\n        \"\"\"\n        Ensure version was fetched successfully and set internal version attribute\n\n        Args:\n            version_response: scrapli cfg response from get version operation\n\n        Returns:\n            None\n\n        Raises:\n            VersionError: if fetching version failed or failed to parse version\n\n        \"\"\"\n        if version_response.failed:\n            msg = \"failed getting version from device\"\n            self.logger.critical(msg)\n            raise VersionError(msg)\n        if not version_response.result:\n            msg = \"failed parsing version string from device output\"\n            self.logger.critical(msg)\n            raise VersionError(msg)\n        self._version_string = version_response.result\n\n    def _prepare_ok(self) -&gt; None:\n        \"\"\"\n        Determine if prepare is \"OK\" for a given operation\n\n        Checks if an `on_prepare` callable has been provided, and if so, if it has been executed.\n        This is meant to help force users into calling `prepare` or using the context manager prior\n        to running any methods.\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            PrepareNotCalled: if `on_prepare` is not None and `_prepared` is False\n\n        \"\"\"\n        # ignoring type/complaints as `on_prepare` will always be set in the sync/async classes;\n        # but is not set here since in one its a coroutine and the other not\n        _on_prepare = self.on_prepare  # type: ignore  # noqa\n        if _on_prepare is not None and self._prepared is False:\n            raise PrepareNotCalled(\n                \"on_prepare callable provided, but prepare method not called. call prepare method \"\n                \"or use context manager to ensure it is called for you\"\n            )\n\n    def _version_ok(self) -&gt; None:\n        \"\"\"\n        Determine if version is \"OK\" for a given operation\n\n        Should be overridden and super'd to by platforms that implement version constraints, will\n        simply check that if `ignore_version` is `False` we have set the internal `_version_string`\n        attribute, if not, will raise `PrepareNotCalled` exception.\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            PrepareNotCalled: if ignore version is False and _version_string not set\n\n        \"\"\"\n        if self.ignore_version is False and not self._version_string:\n            raise PrepareNotCalled(\n                \"ignore_version is False, but version has not yet been fetched. call prepare method\"\n                \" or use context manager to ensure that version is properly gathered\"\n            )\n\n    def _operation_ok(self) -&gt; None:\n        \"\"\"\n        Determine if all values are \"OK\" for a given operation\n\n        Checks if version and prepare are ok. Convenience func to just have one thing to call in the\n        `_pre` operation methods.\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self._prepare_ok()\n        self._version_ok()\n\n    def _pre_get_version(self) -&gt; ScrapliCfgResponse:\n        \"\"\"\n        Handle pre \"get_version\" operations for parity between sync and async\n\n        Args:\n            N/A\n\n        Returns:\n            ScrapliCfgResponse: new response object to update w/ get results\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.logger.info(\"get_version requested\")\n\n        response = ScrapliCfgResponse(host=self.conn.host, raise_for_status_exception=VersionError)\n\n        return response\n\n    def _post_get_version(\n        self,\n        response: ScrapliCfgResponse,\n        scrapli_responses: List[Response],\n        result: str,\n    ) -&gt; ScrapliCfgResponse:\n        \"\"\"\n        Handle post \"get_version\" operations for parity between sync and async\n\n        Args:\n            response: response object to update\n            scrapli_responses: list of scrapli response objects from fetching the version\n            result: final version string of the device\n\n        Returns:\n            ScrapliCfgResponse: response object containing string of the version as the `result`\n                attribute\n\n        Raises:\n            N/A\n\n        \"\"\"\n        response.record_response(scrapli_responses=scrapli_responses, result=result)\n\n        if response.failed:\n            msg = \"failed to get version from device\"\n            self.logger.critical(msg)\n\n        return response\n\n    def _pre_get_config(self, source: str) -&gt; ScrapliCfgResponse:\n        \"\"\"\n        Handle pre \"get_config\" operations for parity between sync and async\n\n        Args:\n            source: name of the config source, generally running|startup\n\n        Returns:\n            ScrapliCfgResponse: new response object to update w/ get results\n\n        Raises:\n            InvalidConfigTarget: if the requested config source is not valid\n\n        \"\"\"\n        self.logger.info(f\"get_config for config source '{source}' requested\")\n\n        self._operation_ok()\n\n        if source not in self.config_sources:\n            msg = (\n                f\"provided config source '{source}' not valid, must be one of {self.config_sources}\"\n            )\n            self.logger.critical(msg)\n            raise InvalidConfigTarget(msg)\n\n        response = ScrapliCfgResponse(\n            host=self.conn.host, raise_for_status_exception=GetConfigError\n        )\n\n        return response\n\n    def _post_get_config(\n        self,\n        response: ScrapliCfgResponse,\n        source: str,\n        scrapli_responses: List[Union[Response, MultiResponse]],\n        result: str,\n    ) -&gt; ScrapliCfgResponse:\n        \"\"\"\n        Handle post \"get_config\" operations for parity between sync and async\n\n        Args:\n            response: response object to update\n            source: name of the config source, generally running|startup\n            scrapli_responses: list of scrapli response objects from fetching the config\n            result: final string of the \"get_config\" result\n\n        Returns:\n            ScrapliCfgResponse: response object containing string of the target config source as the\n                `result` attribute\n\n        Raises:\n            N/A\n\n        \"\"\"\n        response.record_response(scrapli_responses=scrapli_responses, result=result)\n\n        if response.failed:\n            msg = f\"failed to get {source} config\"\n            self.logger.critical(msg)\n\n        return response\n\n    def _pre_load_config(self, config: str) -&gt; ScrapliCfgResponse:\n        \"\"\"\n        Handle pre \"load_config\" operations for parity between sync and async\n\n        Args:\n            config: candidate config to load\n\n        Returns:\n            ScrapliCfgResponse: new response object for load operation\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.logger.info(\"load_config requested\")\n\n        self._operation_ok()\n\n        self.candidate_config = config\n\n        response = ScrapliCfgResponse(\n            host=self.conn.host, raise_for_status_exception=LoadConfigError\n        )\n\n        return response\n\n    def _post_load_config(\n        self,\n        response: ScrapliCfgResponse,\n        scrapli_responses: List[Response],\n    ) -&gt; ScrapliCfgResponse:\n        \"\"\"\n        Handle post \"get_config\" operations for parity between sync and async\n\n        Args:\n            response: response object to update\n            scrapli_responses: list of scrapli response objects from fetching the config\n\n        Returns:\n            ScrapliCfgResponse: response object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        response.record_response(scrapli_responses=scrapli_responses)\n\n        if response.failed:\n            msg = \"failed to load candidate config\"\n            self.logger.critical(msg)\n\n        return response\n\n    def _pre_abort_config(self, session_or_config_file: bool) -&gt; ScrapliCfgResponse:\n        \"\"\"\n        Handle pre \"abort_config\" operations for parity between sync and async\n\n        Args:\n            session_or_config_file: bool indicating if a session or candidate config file has been\n                loaded -- in other words, is there anything to abort right now\n\n        Returns:\n            ScrapliCfgResponse: response object for abort operation\n\n        Raises:\n            AbortConfigError: if no config session or config file exists then we have no config to\n                abort!\n\n        \"\"\"\n        self.logger.info(\"abort_config requested\")\n\n        self._operation_ok()\n\n        if session_or_config_file is False:\n            msg = (\n                \"no configuration session or candidate configuration file exists, you must load a \"\n                \"config in order to abort it!\"\n            )\n            self.logger.critical(msg)\n            raise AbortConfigError(msg)\n\n        response = ScrapliCfgResponse(\n            host=self.conn.host, raise_for_status_exception=AbortConfigError\n        )\n\n        return response\n\n    def _post_abort_config(\n        self,\n        response: ScrapliCfgResponse,\n        scrapli_responses: List[Union[Response, MultiResponse]],\n    ) -&gt; ScrapliCfgResponse:\n        \"\"\"\n        Handle post \"abort_config\" operations for parity between sync and async\n\n        Args:\n            response: response object to update\n            scrapli_responses: list of scrapli response objects from aborting the config\n\n        Returns:\n            ScrapliCfgResponse: response object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        response.record_response(scrapli_responses=scrapli_responses)\n\n        if response.failed:\n            msg = \"failed to abort config\"\n            self.logger.critical(msg)\n\n        return response\n\n    def _pre_commit_config(self, source: str, session_or_config_file: bool) -&gt; ScrapliCfgResponse:\n        \"\"\"\n        Handle pre \"commit_config\" operations for parity between sync and async\n\n        Args:\n            source: name of the config source, generally running|startup\n            session_or_config_file: bool indicating if a session or candidate config file has been\n                loaded -- in other words, is there anything to commit right now\n\n        Returns:\n            ScrapliCfgResponse: new response object to update w/ commit results\n\n        Raises:\n            InvalidConfigTarget: if the requested config source is not valid\n            CommitConfigError: if no config session/file exists to commit\n\n        \"\"\"\n        self.logger.info(f\"get_config for config source '{source}' requested\")\n\n        self._operation_ok()\n\n        if source not in self.config_sources:\n            msg = (\n                f\"provided config source '{source}' not valid, must be one of {self.config_sources}\"\n            )\n            self.logger.critical(msg)\n            raise InvalidConfigTarget(msg)\n\n        if session_or_config_file is False:\n            msg = (\n                \"no configuration session or candidate configuration file exists, you must load a \"\n                \"config in order to commit it!\"\n            )\n            self.logger.critical(msg)\n            raise CommitConfigError(msg)\n\n        response = ScrapliCfgResponse(\n            host=self.conn.host, raise_for_status_exception=CommitConfigError\n        )\n\n        return response\n\n    def _post_commit_config(\n        self,\n        response: ScrapliCfgResponse,\n        scrapli_responses: List[Union[Response, MultiResponse]],\n    ) -&gt; ScrapliCfgResponse:\n        \"\"\"\n        Handle post \"commit_config\" operations for parity between sync and async\n\n        Args:\n            response: response object to update\n            scrapli_responses: list of scrapli response objects from committing the config\n\n        Returns:\n            ScrapliCfgResponse: response object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        response.record_response(scrapli_responses=scrapli_responses)\n\n        if response.failed:\n            msg = \"failed to commit config\"\n            self.logger.critical(msg)\n\n        return response\n\n    def _pre_diff_config(self, source: str, session_or_config_file: bool) -&gt; ScrapliCfgDiffResponse:\n        \"\"\"\n        Handle pre \"diff_config\" operations for parity between sync and async\n\n        Args:\n            source: config source to diff against\n            session_or_config_file: bool of config_session_name or candidate_config_filename\n\n        Returns:\n            ScrapliCfgDiffResponse: diff object for diff operation\n\n        Raises:\n            InvalidConfigTarget: if trying to diff against an invalid config target\n            DiffConfigError: if no config session or config file exists then we have no config to\n                diff!\n\n        \"\"\"\n        self.logger.info(\"diff_config requested\")\n\n        self._operation_ok()\n\n        if source not in self.config_sources:\n            msg = (\n                f\"provided config source '{source}' not valid, must be one of {self.config_sources}\"\n            )\n            self.logger.critical(msg)\n            raise InvalidConfigTarget(msg)\n\n        if session_or_config_file is False:\n            msg = (\n                \"no configuration session or candidate configuration file exists, you must load a \"\n                \"config in order to diff it!\"\n            )\n            self.logger.critical(msg)\n            raise DiffConfigError(msg)\n\n        diff_response = ScrapliCfgDiffResponse(host=self.conn.host, source=source)\n\n        return diff_response\n\n    def _post_diff_config(\n        self,\n        diff_response: ScrapliCfgDiffResponse,\n        scrapli_responses: List[Response],\n        source_config: str,\n        candidate_config: str,\n        device_diff: str,\n    ) -&gt; ScrapliCfgDiffResponse:\n        \"\"\"\n        Handle post \"diff_config\" operations for parity between sync and async\n\n        Args:\n            diff_response: response object to update\n            scrapli_responses: list of scrapli response objects from committing the config\n            source_config: previous source config from the device\n            candidate_config: user provided configuration\n            device_diff: diff generated from the device itself\n\n        Returns:\n            ScrapliCfgDiffResponse: diff object for diff operation\n\n        Raises:\n            N/A\n\n        \"\"\"\n        diff_response.record_response(scrapli_responses=scrapli_responses)\n        diff_response.record_diff_response(\n            source_config=source_config + \"\\n\",\n            candidate_config=candidate_config + \"\\n\",\n            device_diff=device_diff,\n        )\n\n        if diff_response.failed:\n            msg = \"failed to diff config\"\n            self.logger.critical(msg)\n\n        return diff_response\n        </code>\n    </pre>"},{"location":"api_docs/platform/base/base_platform/#descendants","title":"Descendants","text":"<ul> <li>scrapli_cfg.platform.base.async_platform.AsyncScrapliCfgPlatform</li> <li>scrapli_cfg.platform.base.sync_platform.ScrapliCfgPlatform</li> </ul>"},{"location":"api_docs/platform/base/base_platform/#class-variables","title":"Class variables","text":"<p><code>conn: Union[scrapli.driver.network.sync_driver.NetworkDriver,\u00a0scrapli.driver.network.async_driver.AsyncNetworkDriver]</code></p>"},{"location":"api_docs/platform/base/sync_platform/","title":"Sync Platform","text":"window.addEventListener('DOMContentLoaded', () =&gt; hljs.initHighlighting())"},{"location":"api_docs/platform/base/sync_platform/#module-scrapli_cfgplatformbasesync_platform","title":"Module scrapli_cfg.platform.base.sync_platform","text":"<p>scrapli_cfg.platform.sync_platform</p> Expand source code <pre>\n        <code>\n\"\"\"scrapli_cfg.platform.sync_platform\"\"\"\nfrom abc import ABC, abstractmethod\nfrom types import TracebackType\nfrom typing import Any, Callable, List, Optional, Pattern, Tuple, Type\n\nfrom scrapli.driver import NetworkDriver\nfrom scrapli_cfg.diff import ScrapliCfgDiffResponse\nfrom scrapli_cfg.exceptions import ScrapliCfgException\nfrom scrapli_cfg.platform.base.base_platform import ScrapliCfgBase\nfrom scrapli_cfg.response import ScrapliCfgResponse\n\n\nclass ScrapliCfgPlatform(ABC, ScrapliCfgBase):\n    def __init__(\n        self,\n        conn: NetworkDriver,\n        config_sources: List[str],\n        on_prepare: Optional[Callable[..., Any]],\n        dedicated_connection: bool,\n        ignore_version: bool,\n    ) -&gt; None:\n        \"\"\"\n        Scrapli Config base class\n\n        Args:\n            conn: scrapli connection to use\n            config_sources: list of config sources\n            on_prepare: optional callable to run at connection `prepare`\n            dedicated_connection: if `False` (default value) scrapli cfg will not open or close the\n                underlying scrapli connection and will raise an exception if the scrapli connection\n                is not open. If `True` will automatically open and close the scrapli connection when\n                using with a context manager, `prepare` will open the scrapli connection (if not\n                already open), and `close` will close the scrapli connection.\n            ignore_version: ignore checking device version support; currently this just means that\n                scrapli-cfg will not fetch the device version during the prepare phase, however this\n                will (hopefully) be used in the future to limit what methods can be used against a\n                target device. For example, for EOS devices we need &gt; 4.14 to load configs; so if a\n                device is encountered at 4.13 the version check would raise an exception rather than\n                just failing in a potentially awkward fashion.\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.conn: NetworkDriver = conn\n        self.dedicated_connection = dedicated_connection\n\n        self.on_prepare = on_prepare\n\n        super().__init__(config_sources=config_sources, ignore_version=ignore_version)\n\n    def __enter__(self) -&gt; \"ScrapliCfgPlatform\":\n        \"\"\"\n        Enter method for context manager\n\n        Args:\n            N/A\n\n        Returns:\n            ScrapliCfg: opened ScrapliCfg object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.prepare()\n        return self\n\n    def __exit__(\n        self,\n        exception_type: Optional[Type[BaseException]],\n        exception_value: Optional[BaseException],\n        traceback: Optional[TracebackType],\n    ) -&gt; None:\n        \"\"\"\n        Exit method to cleanup for context manager\n\n        Args:\n            exception_type: exception type being raised\n            exception_value: message from exception being raised\n            traceback: traceback from exception being raised\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.cleanup()\n\n    def _open(self) -&gt; None:\n        \"\"\"\n        Handle opening (or raising exception if not open) of underlying scrapli connection\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            ScrapliCfgException: if scrapli connection is not open and auto_open_connection is False\n\n        \"\"\"\n        if self.conn.isalive():\n            return\n\n        if self.dedicated_connection:\n            self.logger.info(\n                \"underlying scrapli connection is not alive... opening scrapli connection\"\n            )\n            self.conn.open()\n            return\n\n        raise ScrapliCfgException(\n            \"underlying scrapli connection is not open and `dedicated_connection` is False, \"\n            \"cannot continue!\"\n        )\n\n    def _close(self) -&gt; None:\n        \"\"\"\n        Close the scrapli connection\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        if self.dedicated_connection is True and self.conn.isalive():\n            self.logger.info(\"dedicated_connection is True, closing scrapli connection\")\n            self.conn.close()\n\n    def prepare(self) -&gt; None:\n        \"\"\"\n        Prepare connection for scrapli_cfg operations\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.logger.info(\"preparing scrapli_cfg connection\")\n\n        self._open()\n\n        if self.ignore_version is False:\n            self.logger.debug(\"ignore_version is False, fetching device version\")\n            version_response = self.get_version()\n            self._validate_and_set_version(version_response=version_response)\n\n        if self.on_prepare is not None:\n            self.logger.debug(\"on_prepare provided, executing now\")\n            self.on_prepare(self)\n\n        self._prepared = True\n\n    def cleanup(self) -&gt; None:\n        \"\"\"\n        Cleanup after scrapli-cfg operations\n\n\n        Generally this can be skipped, however it will be executed if using a context manager. The\n        purpose of this method is to close the underlying scrapli connection (if in\n        \"dedicated_connection\" mode), and to reset the internally used `_version_string`, attribute.\n        All this is done so that this cfg connection, if re-used later (as in later in that script\n        using the same object) starts with a fresh slate.\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self._close()\n\n        # reset the version string/prepare flag so we know we need to re-fetch/re-run if user\n        # re-opens connection\n        self._version_string = \"\"\n        self._prepared = False\n\n        # this has *probably* been reset already, but reset it just in case user re-opens connection\n        # we can have a clean slate to work with\n        try:\n            self._reset_config_session()  # type: ignore\n        except AttributeError:\n            pass\n\n    @abstractmethod\n    def get_version(self) -&gt; ScrapliCfgResponse:\n        \"\"\"\n        Get device version string\n\n        Args:\n            N/A\n\n        Returns:\n            ScrapliCfgResponse: response object where result is the string of the primary version\n                (as in the \"main\" os version) of the device\n\n        Raises:\n            N/A\n\n        \"\"\"\n\n    @abstractmethod\n    def get_config(self, source: str = \"running\") -&gt; ScrapliCfgResponse:\n        \"\"\"\n        Get device configuration\n\n        Args:\n            source: name of the config source, generally running|startup\n\n        Returns:\n            ScrapliCfgResponse: response object containing string of the target config source as the\n                `result` attribute\n\n        Raises:\n            N/A\n\n        \"\"\"\n\n    @abstractmethod\n    def load_config(self, config: str, replace: bool = False, **kwargs: Any) -&gt; ScrapliCfgResponse:\n        \"\"\"\n        Load configuration to a device\n\n        Args:\n            config: string of the configuration to load\n            replace: replace the configuration or not, if false configuration will be loaded as a\n                merge operation\n            kwargs: additional kwargs that the implementing classes may need for their platform,\n                see your specific platform for details\n\n        Returns:\n            ScrapliCfgResponse: response object\n\n        Raises:\n            N/A\n\n        \"\"\"\n\n    @abstractmethod\n    def abort_config(self) -&gt; ScrapliCfgResponse:\n        \"\"\"\n        Abort a configuration -- discards any loaded config\n\n        Args:\n            N/A\n\n        Returns:\n            ScrapliCfgResponse: response object\n\n        Raises:\n            N/A\n\n        \"\"\"\n\n    @abstractmethod\n    def commit_config(self, source: str = \"running\") -&gt; ScrapliCfgResponse:\n        \"\"\"\n        Commit a loaded configuration\n\n        Args:\n            source: name of the config source to commit against, generally running|startup\n\n        Returns:\n            ScrapliCfgResponse: response object\n\n        Raises:\n            N/A\n\n        \"\"\"\n\n    @abstractmethod\n    def diff_config(self, source: str = \"running\") -&gt; ScrapliCfgDiffResponse:\n        \"\"\"\n        Diff a loaded configuration against the source config store\n\n        Args:\n            source: name of the config source to diff against, generally running|startup -- device\n                diffs will generally not care about this argument, but the built in scrapli differ\n                will\n\n        Returns:\n            ScrapliCfgDiffResponse: scrapli cfg diff object\n\n        Raises:\n            N/A\n\n        \"\"\"\n\n    def render_substituted_config(\n        self,\n        config_template: str,\n        substitutes: List[Tuple[str, Pattern[str]]],\n        source: str = \"running\",\n    ) -&gt; str:\n        \"\"\"\n        Render a substituted configuration file\n\n        Renders a configuration based on a user template, substitutes, and a target config from the\n        device.\n\n        Args:\n            config_template: config file to use as the base for substitutions -- should contain\n                jinja2-like variables that will be replaced with data fetched from the source config\n                by the substitutes patterns\n            substitutes: tuple of name, pattern -- where name matches the jinja2-like variable in\n                the config_template file, and pattern is a compiled regular expression pattern to be\n                used to fetch that section from the source config\n            source: config source to use for the substitution efforts, typically running|startup\n\n        Returns:\n            str: substituted/rendered config\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.logger.info(\"fetching configuration and replacing with provided substitutes\")\n\n        source_config = self.get_config(source=source)\n        return self._render_substituted_config(\n            config_template=config_template,\n            substitutes=substitutes,\n            source_config=source_config.result,\n        )\n        </code>\n    </pre>"},{"location":"api_docs/platform/base/sync_platform/#classes","title":"Classes","text":""},{"location":"api_docs/platform/base/sync_platform/#scraplicfgplatform","title":"ScrapliCfgPlatform","text":"<pre><code>Helper class that provides a standard way to create an ABC using\ninheritance.\n\nScrapli Config base class\n\nArgs:\n    conn: scrapli connection to use\n    config_sources: list of config sources\n    on_prepare: optional callable to run at connection `prepare`\n    dedicated_connection: if `False` (default value) scrapli cfg will not open or close the\n        underlying scrapli connection and will raise an exception if the scrapli connection\n        is not open. If `True` will automatically open and close the scrapli connection when\n        using with a context manager, `prepare` will open the scrapli connection (if not\n        already open), and `close` will close the scrapli connection.\n    ignore_version: ignore checking device version support; currently this just means that\n        scrapli-cfg will not fetch the device version during the prepare phase, however this\n        will (hopefully) be used in the future to limit what methods can be used against a\n        target device. For example, for EOS devices we need &gt; 4.14 to load configs; so if a\n        device is encountered at 4.13 the version check would raise an exception rather than\n        just failing in a potentially awkward fashion.\n\nReturns:\n    None\n\nRaises:\n    N/A\n</code></pre> Expand source code <pre>\n        <code>\nclass ScrapliCfgPlatform(ABC, ScrapliCfgBase):\n    def __init__(\n        self,\n        conn: NetworkDriver,\n        config_sources: List[str],\n        on_prepare: Optional[Callable[..., Any]],\n        dedicated_connection: bool,\n        ignore_version: bool,\n    ) -&gt; None:\n        \"\"\"\n        Scrapli Config base class\n\n        Args:\n            conn: scrapli connection to use\n            config_sources: list of config sources\n            on_prepare: optional callable to run at connection `prepare`\n            dedicated_connection: if `False` (default value) scrapli cfg will not open or close the\n                underlying scrapli connection and will raise an exception if the scrapli connection\n                is not open. If `True` will automatically open and close the scrapli connection when\n                using with a context manager, `prepare` will open the scrapli connection (if not\n                already open), and `close` will close the scrapli connection.\n            ignore_version: ignore checking device version support; currently this just means that\n                scrapli-cfg will not fetch the device version during the prepare phase, however this\n                will (hopefully) be used in the future to limit what methods can be used against a\n                target device. For example, for EOS devices we need &gt; 4.14 to load configs; so if a\n                device is encountered at 4.13 the version check would raise an exception rather than\n                just failing in a potentially awkward fashion.\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.conn: NetworkDriver = conn\n        self.dedicated_connection = dedicated_connection\n\n        self.on_prepare = on_prepare\n\n        super().__init__(config_sources=config_sources, ignore_version=ignore_version)\n\n    def __enter__(self) -&gt; \"ScrapliCfgPlatform\":\n        \"\"\"\n        Enter method for context manager\n\n        Args:\n            N/A\n\n        Returns:\n            ScrapliCfg: opened ScrapliCfg object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.prepare()\n        return self\n\n    def __exit__(\n        self,\n        exception_type: Optional[Type[BaseException]],\n        exception_value: Optional[BaseException],\n        traceback: Optional[TracebackType],\n    ) -&gt; None:\n        \"\"\"\n        Exit method to cleanup for context manager\n\n        Args:\n            exception_type: exception type being raised\n            exception_value: message from exception being raised\n            traceback: traceback from exception being raised\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.cleanup()\n\n    def _open(self) -&gt; None:\n        \"\"\"\n        Handle opening (or raising exception if not open) of underlying scrapli connection\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            ScrapliCfgException: if scrapli connection is not open and auto_open_connection is False\n\n        \"\"\"\n        if self.conn.isalive():\n            return\n\n        if self.dedicated_connection:\n            self.logger.info(\n                \"underlying scrapli connection is not alive... opening scrapli connection\"\n            )\n            self.conn.open()\n            return\n\n        raise ScrapliCfgException(\n            \"underlying scrapli connection is not open and `dedicated_connection` is False, \"\n            \"cannot continue!\"\n        )\n\n    def _close(self) -&gt; None:\n        \"\"\"\n        Close the scrapli connection\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        if self.dedicated_connection is True and self.conn.isalive():\n            self.logger.info(\"dedicated_connection is True, closing scrapli connection\")\n            self.conn.close()\n\n    def prepare(self) -&gt; None:\n        \"\"\"\n        Prepare connection for scrapli_cfg operations\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.logger.info(\"preparing scrapli_cfg connection\")\n\n        self._open()\n\n        if self.ignore_version is False:\n            self.logger.debug(\"ignore_version is False, fetching device version\")\n            version_response = self.get_version()\n            self._validate_and_set_version(version_response=version_response)\n\n        if self.on_prepare is not None:\n            self.logger.debug(\"on_prepare provided, executing now\")\n            self.on_prepare(self)\n\n        self._prepared = True\n\n    def cleanup(self) -&gt; None:\n        \"\"\"\n        Cleanup after scrapli-cfg operations\n\n\n        Generally this can be skipped, however it will be executed if using a context manager. The\n        purpose of this method is to close the underlying scrapli connection (if in\n        \"dedicated_connection\" mode), and to reset the internally used `_version_string`, attribute.\n        All this is done so that this cfg connection, if re-used later (as in later in that script\n        using the same object) starts with a fresh slate.\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self._close()\n\n        # reset the version string/prepare flag so we know we need to re-fetch/re-run if user\n        # re-opens connection\n        self._version_string = \"\"\n        self._prepared = False\n\n        # this has *probably* been reset already, but reset it just in case user re-opens connection\n        # we can have a clean slate to work with\n        try:\n            self._reset_config_session()  # type: ignore\n        except AttributeError:\n            pass\n\n    @abstractmethod\n    def get_version(self) -&gt; ScrapliCfgResponse:\n        \"\"\"\n        Get device version string\n\n        Args:\n            N/A\n\n        Returns:\n            ScrapliCfgResponse: response object where result is the string of the primary version\n                (as in the \"main\" os version) of the device\n\n        Raises:\n            N/A\n\n        \"\"\"\n\n    @abstractmethod\n    def get_config(self, source: str = \"running\") -&gt; ScrapliCfgResponse:\n        \"\"\"\n        Get device configuration\n\n        Args:\n            source: name of the config source, generally running|startup\n\n        Returns:\n            ScrapliCfgResponse: response object containing string of the target config source as the\n                `result` attribute\n\n        Raises:\n            N/A\n\n        \"\"\"\n\n    @abstractmethod\n    def load_config(self, config: str, replace: bool = False, **kwargs: Any) -&gt; ScrapliCfgResponse:\n        \"\"\"\n        Load configuration to a device\n\n        Args:\n            config: string of the configuration to load\n            replace: replace the configuration or not, if false configuration will be loaded as a\n                merge operation\n            kwargs: additional kwargs that the implementing classes may need for their platform,\n                see your specific platform for details\n\n        Returns:\n            ScrapliCfgResponse: response object\n\n        Raises:\n            N/A\n\n        \"\"\"\n\n    @abstractmethod\n    def abort_config(self) -&gt; ScrapliCfgResponse:\n        \"\"\"\n        Abort a configuration -- discards any loaded config\n\n        Args:\n            N/A\n\n        Returns:\n            ScrapliCfgResponse: response object\n\n        Raises:\n            N/A\n\n        \"\"\"\n\n    @abstractmethod\n    def commit_config(self, source: str = \"running\") -&gt; ScrapliCfgResponse:\n        \"\"\"\n        Commit a loaded configuration\n\n        Args:\n            source: name of the config source to commit against, generally running|startup\n\n        Returns:\n            ScrapliCfgResponse: response object\n\n        Raises:\n            N/A\n\n        \"\"\"\n\n    @abstractmethod\n    def diff_config(self, source: str = \"running\") -&gt; ScrapliCfgDiffResponse:\n        \"\"\"\n        Diff a loaded configuration against the source config store\n\n        Args:\n            source: name of the config source to diff against, generally running|startup -- device\n                diffs will generally not care about this argument, but the built in scrapli differ\n                will\n\n        Returns:\n            ScrapliCfgDiffResponse: scrapli cfg diff object\n\n        Raises:\n            N/A\n\n        \"\"\"\n\n    def render_substituted_config(\n        self,\n        config_template: str,\n        substitutes: List[Tuple[str, Pattern[str]]],\n        source: str = \"running\",\n    ) -&gt; str:\n        \"\"\"\n        Render a substituted configuration file\n\n        Renders a configuration based on a user template, substitutes, and a target config from the\n        device.\n\n        Args:\n            config_template: config file to use as the base for substitutions -- should contain\n                jinja2-like variables that will be replaced with data fetched from the source config\n                by the substitutes patterns\n            substitutes: tuple of name, pattern -- where name matches the jinja2-like variable in\n                the config_template file, and pattern is a compiled regular expression pattern to be\n                used to fetch that section from the source config\n            source: config source to use for the substitution efforts, typically running|startup\n\n        Returns:\n            str: substituted/rendered config\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.logger.info(\"fetching configuration and replacing with provided substitutes\")\n\n        source_config = self.get_config(source=source)\n        return self._render_substituted_config(\n            config_template=config_template,\n            substitutes=substitutes,\n            source_config=source_config.result,\n        )\n        </code>\n    </pre>"},{"location":"api_docs/platform/base/sync_platform/#ancestors-in-mro","title":"Ancestors (in MRO)","text":"<ul> <li>abc.ABC</li> <li>scrapli_cfg.platform.base.base_platform.ScrapliCfgBase</li> </ul>"},{"location":"api_docs/platform/base/sync_platform/#descendants","title":"Descendants","text":"<ul> <li>scrapli_cfg.platform.core.arista_eos.sync_platform.ScrapliCfgEOS</li> <li>scrapli_cfg.platform.core.cisco_iosxe.sync_platform.ScrapliCfgIOSXE</li> <li>scrapli_cfg.platform.core.cisco_iosxr.sync_platform.ScrapliCfgIOSXR</li> <li>scrapli_cfg.platform.core.cisco_nxos.sync_platform.ScrapliCfgNXOS</li> <li>scrapli_cfg.platform.core.juniper_junos.sync_platform.ScrapliCfgJunos</li> </ul>"},{"location":"api_docs/platform/base/sync_platform/#class-variables","title":"Class variables","text":"<p><code>conn: Union[scrapli.driver.network.sync_driver.NetworkDriver,\u00a0scrapli.driver.network.async_driver.AsyncNetworkDriver]</code></p>"},{"location":"api_docs/platform/base/sync_platform/#methods","title":"Methods","text":""},{"location":"api_docs/platform/base/sync_platform/#abort_config","title":"abort_config","text":"<p><code>abort_config(self) \u2011&gt; scrapli_cfg.response.ScrapliCfgResponse</code></p> <pre><code>Abort a configuration -- discards any loaded config\n\nArgs:\n    N/A\n\nReturns:\n    ScrapliCfgResponse: response object\n\nRaises:\n    N/A\n</code></pre>"},{"location":"api_docs/platform/base/sync_platform/#cleanup","title":"cleanup","text":"<p><code>cleanup(self) \u2011&gt; None</code></p> <pre><code>Cleanup after scrapli-cfg operations\n\n\nGenerally this can be skipped, however it will be executed if using a context manager. The\npurpose of this method is to close the underlying scrapli connection (if in\n\"dedicated_connection\" mode), and to reset the internally used `_version_string`, attribute.\nAll this is done so that this cfg connection, if re-used later (as in later in that script\nusing the same object) starts with a fresh slate.\n\nArgs:\n    N/A\n\nReturns:\n    None\n\nRaises:\n    N/A\n</code></pre>"},{"location":"api_docs/platform/base/sync_platform/#commit_config","title":"commit_config","text":"<p><code>commit_config(self, source:\u00a0str\u00a0=\u00a0'running') \u2011&gt; scrapli_cfg.response.ScrapliCfgResponse</code></p> <pre><code>Commit a loaded configuration\n\nArgs:\n    source: name of the config source to commit against, generally running|startup\n\nReturns:\n    ScrapliCfgResponse: response object\n\nRaises:\n    N/A\n</code></pre>"},{"location":"api_docs/platform/base/sync_platform/#diff_config","title":"diff_config","text":"<p><code>diff_config(self, source:\u00a0str\u00a0=\u00a0'running') \u2011&gt; scrapli_cfg.diff.ScrapliCfgDiffResponse</code></p> <pre><code>Diff a loaded configuration against the source config store\n\nArgs:\n    source: name of the config source to diff against, generally running|startup -- device\n        diffs will generally not care about this argument, but the built in scrapli differ\n        will\n\nReturns:\n    ScrapliCfgDiffResponse: scrapli cfg diff object\n\nRaises:\n    N/A\n</code></pre>"},{"location":"api_docs/platform/base/sync_platform/#get_config","title":"get_config","text":"<p><code>get_config(self, source:\u00a0str\u00a0=\u00a0'running') \u2011&gt; scrapli_cfg.response.ScrapliCfgResponse</code></p> <pre><code>Get device configuration\n\nArgs:\n    source: name of the config source, generally running|startup\n\nReturns:\n    ScrapliCfgResponse: response object containing string of the target config source as the\n        `result` attribute\n\nRaises:\n    N/A\n</code></pre>"},{"location":"api_docs/platform/base/sync_platform/#get_version","title":"get_version","text":"<p><code>get_version(self) \u2011&gt; scrapli_cfg.response.ScrapliCfgResponse</code></p> <pre><code>Get device version string\n\nArgs:\n    N/A\n\nReturns:\n    ScrapliCfgResponse: response object where result is the string of the primary version\n        (as in the \"main\" os version) of the device\n\nRaises:\n    N/A\n</code></pre>"},{"location":"api_docs/platform/base/sync_platform/#load_config","title":"load_config","text":"<p><code>load_config(self, config:\u00a0str, replace:\u00a0bool\u00a0=\u00a0False, **kwargs:\u00a0Any) \u2011&gt; scrapli_cfg.response.ScrapliCfgResponse</code></p> <pre><code>Load configuration to a device\n\nArgs:\n    config: string of the configuration to load\n    replace: replace the configuration or not, if false configuration will be loaded as a\n        merge operation\n    kwargs: additional kwargs that the implementing classes may need for their platform,\n        see your specific platform for details\n\nReturns:\n    ScrapliCfgResponse: response object\n\nRaises:\n    N/A\n</code></pre>"},{"location":"api_docs/platform/base/sync_platform/#prepare","title":"prepare","text":"<p><code>prepare(self) \u2011&gt; None</code></p> <pre><code>Prepare connection for scrapli_cfg operations\n\nArgs:\n    N/A\n\nReturns:\n    None\n\nRaises:\n    N/A\n</code></pre>"},{"location":"api_docs/platform/base/sync_platform/#render_substituted_config","title":"render_substituted_config","text":"<p><code>render_substituted_config(self, config_template:\u00a0str, substitutes:\u00a0List[Tuple[str,\u00a0Pattern[str]]], source:\u00a0str\u00a0=\u00a0'running') \u2011&gt; str</code></p> <pre><code>Render a substituted configuration file\n\nRenders a configuration based on a user template, substitutes, and a target config from the\ndevice.\n\nArgs:\n    config_template: config file to use as the base for substitutions -- should contain\n        jinja2-like variables that will be replaced with data fetched from the source config\n        by the substitutes patterns\n    substitutes: tuple of name, pattern -- where name matches the jinja2-like variable in\n        the config_template file, and pattern is a compiled regular expression pattern to be\n        used to fetch that section from the source config\n    source: config source to use for the substitution efforts, typically running|startup\n\nReturns:\n    str: substituted/rendered config\n\nRaises:\n    N/A\n</code></pre>"},{"location":"api_docs/platform/core/arista_eos/async_platform/","title":"Async Platform","text":"window.addEventListener('DOMContentLoaded', () =&gt; hljs.initHighlighting())"},{"location":"api_docs/platform/core/arista_eos/async_platform/#module-scrapli_cfgplatformcorearista_eosasync_platform","title":"Module scrapli_cfg.platform.core.arista_eos.async_platform","text":"<p>scrapli_cfg.platform.core.arista_eos.async_platform</p> Expand source code <pre>\n        <code>\n\"\"\"scrapli_cfg.platform.core.arista_eos.async_platform\"\"\"\nfrom typing import Any, Callable, List, Optional\n\nfrom scrapli.driver.core import AsyncEOSDriver\nfrom scrapli.response import MultiResponse, Response\nfrom scrapli_cfg.diff import ScrapliCfgDiffResponse\nfrom scrapli_cfg.exceptions import DiffConfigError, LoadConfigError, ScrapliCfgException\nfrom scrapli_cfg.platform.base.async_platform import AsyncScrapliCfgPlatform\nfrom scrapli_cfg.platform.core.arista_eos.base_platform import CONFIG_SOURCES, ScrapliCfgEOSBase\nfrom scrapli_cfg.response import ScrapliCfgResponse\n\n\nclass AsyncScrapliCfgEOS(AsyncScrapliCfgPlatform, ScrapliCfgEOSBase):\n    def __init__(\n        self,\n        conn: AsyncEOSDriver,\n        *,\n        config_sources: Optional[List[str]] = None,\n        on_prepare: Optional[Callable[..., Any]] = None,\n        dedicated_connection: bool = False,\n        ignore_version: bool = False,\n    ) -&gt; None:\n        if config_sources is None:\n            config_sources = CONFIG_SOURCES\n\n        super().__init__(\n            conn=conn,\n            config_sources=config_sources,\n            on_prepare=on_prepare,\n            dedicated_connection=dedicated_connection,\n            ignore_version=ignore_version,\n        )\n\n        self.conn: AsyncEOSDriver\n\n        self.config_session_name = \"\"\n\n    async def _clear_config_session(self, session_name: str) -&gt; Response:\n        \"\"\"\n        Clear a configuration session\n\n        Args:\n            session_name: name of session to clear\n\n        Returns:\n            Response: scrapli response from clearing the session\n\n        Raises:\n            N/A\n\n        \"\"\"\n        # Note, early versions of eos supporting config sessions cant be aborted like this, but\n        # i dont want to register a config session for each session we want to delete so we'll just\n        # roll w/ this for now\n        return await self.conn.send_command(command=f\"configure session {session_name} abort\")\n\n    async def clear_config_sessions(\n        self, session_name: str = \"\", session_prefix: str = \"\"\n    ) -&gt; ScrapliCfgResponse:\n        \"\"\"\n        Clear a specific config session or all sessions with a prefix (ex: scrapli_cfg_)\n\n        Args:\n            session_name: name of specific config session to clear\n            session_prefix: prefix of session(s) to clear -- ignored if session_name is provided\n\n        Returns:\n            ScrapliCfgResponse: response object containing string of the target config source as the\n                `result` attribute\n\n        Raises:\n            N/A\n\n        \"\"\"\n        scrapli_responses = []\n        response = self._pre_clear_config_sessions()\n\n        try:\n            get_config_sessions_result = await self.conn.send_command(\n                command=\"show config sessions | json\"\n            )\n            scrapli_responses.append(get_config_sessions_result)\n            if get_config_sessions_result.failed:\n                msg = \"failed to show current config sessions\"\n                self.logger.critical(msg)\n                raise ScrapliCfgException(msg)\n\n            config_session_names = self._parse_config_sessions(\n                device_output=get_config_sessions_result.result\n            )\n            for config_session in config_session_names:\n                if session_name:\n                    if config_session == session_name:\n                        clear_config_session_result = await self._clear_config_session(\n                            session_name=session_name\n                        )\n                        scrapli_responses.append(clear_config_session_result)\n                else:\n                    if config_session.startswith(session_prefix):\n                        clear_config_session_result = await self._clear_config_session(\n                            session_name=session_name\n                        )\n                        scrapli_responses.append(clear_config_session_result)\n\n        except ScrapliCfgException:\n            pass\n\n        return self._post_clear_config_sessions(\n            response=response, scrapli_responses=scrapli_responses\n        )\n\n    async def get_version(self) -&gt; ScrapliCfgResponse:\n        response = self._pre_get_version()\n\n        version_result = await self.conn.send_command(\n            command=\"show version | i Software image version\"\n        )\n\n        return self._post_get_version(\n            response=response,\n            scrapli_responses=[version_result],\n            result=self._parse_version(device_output=version_result.result),\n        )\n\n    async def get_config(self, source: str = \"running\") -&gt; ScrapliCfgResponse:\n        response = self._pre_get_config(source=source)\n\n        config_result = await self.conn.send_command(\n            command=self._get_config_command(source=source)\n        )\n\n        return self._post_get_config(\n            response=response,\n            source=source,\n            scrapli_responses=[config_result],\n            result=config_result.result,\n        )\n\n    async def load_config(\n        self, config: str, replace: bool = False, **kwargs: Any\n    ) -&gt; ScrapliCfgResponse:\n        \"\"\"\n        Load configuration to a device\n\n        Supported kwargs:\n            N/A\n\n        Args:\n            config: string of the configuration to load\n            replace: replace the configuration or not, if false configuration will be loaded as a\n                merge operation\n            kwargs: additional kwargs that the implementing classes may need for their platform,\n                see above for eos supported kwargs\n\n        Returns:\n            ScrapliCfgResponse: response object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        scrapli_responses = []\n        response = self._pre_load_config(config=config)\n        (\n            config,\n            eager_config,\n            register_config_session,\n        ) = self._prepare_load_config_session_and_payload(config=config)\n\n        if register_config_session:\n            # only need to register a session if we havent -- we will reset session to an empty\n            # string after any commits/aborts so we know if we are doing \"new\" operations\n            self.conn.register_configuration_session(session_name=self.config_session_name)\n\n        try:\n            if replace:\n                # default the config session - we only need to do this if we are doing a REPLACE\n                rollback_clean_config_result = await self.conn.send_config(\n                    config=\"rollback clean-config\", privilege_level=self.config_session_name\n                )\n                if rollback_clean_config_result.failed:\n                    msg = \"failed to load clean config in configuration session\"\n                    self.logger.critical(msg)\n                    raise LoadConfigError(msg)\n\n            config_result = await self.conn.send_config(\n                config=config, privilege_level=self.config_session_name\n            )\n            scrapli_responses.append(config_result)\n            if config_result.failed:\n                msg = \"failed to load the candidate config into the config session\"\n                self.logger.critical(msg)\n                raise LoadConfigError(msg)\n\n            # eager cuz banners and such; perhaps if no banner/macro we can disable eager though....\n            if eager_config:\n                eager_config_result = await self.conn.send_config(\n                    config=eager_config, privilege_level=self.config_session_name, eager=True\n                )\n                scrapli_responses.append(eager_config_result)\n                if eager_config_result.failed:\n                    msg = \"failed to load the candidate config into the config session\"\n                    self.logger.critical(msg)\n                    raise LoadConfigError(msg)\n\n        except LoadConfigError:\n            # we catch our own exception so we dont need to do any if failed checks along the way\n            # as soon as we hit this (or when we are done w/ the try block) we are done loading the\n            # config and can build and return a response object\n            pass\n\n        return self._post_load_config(\n            response=response,\n            scrapli_responses=scrapli_responses,\n        )\n\n    async def abort_config(self) -&gt; ScrapliCfgResponse:\n        response = self._pre_abort_config(session_or_config_file=bool(self.config_session_name))\n\n        await self.conn.acquire_priv(desired_priv=self.config_session_name)\n        await self.conn._abort_config()  # pylint: disable=W0212\n        self._reset_config_session()\n\n        return self._post_abort_config(\n            response=response,\n            scrapli_responses=[],\n        )\n\n    async def commit_config(self, source: str = \"running\") -&gt; ScrapliCfgResponse:\n        response = self._pre_commit_config(\n            source=source, session_or_config_file=bool(self.config_session_name)\n        )\n\n        commit_results = await self.conn.send_commands(\n            commands=[\n                f\"configure session {self.config_session_name} commit\",\n                \"copy running-config startup-config\",\n            ]\n        )\n        self._reset_config_session()\n\n        return self._post_commit_config(response=response, scrapli_responses=[commit_results])\n\n    async def diff_config(self, source: str = \"running\") -&gt; ScrapliCfgDiffResponse:\n        scrapli_responses = []\n        device_diff = \"\"\n        source_config = \"\"\n\n        diff_response = self._pre_diff_config(\n            source=source, session_or_config_file=bool(self.config_session_name)\n        )\n\n        try:\n            diff_result = await self.conn.send_config(\n                config=\"show session-config diffs\", privilege_level=self.config_session_name\n            )\n            scrapli_responses.append(diff_result)\n            if diff_result.failed:\n                msg = \"failed generating diff for config session\"\n                self.logger.critical(msg)\n                raise DiffConfigError(msg)\n\n            device_diff = diff_result.result\n\n            source_config_result = await self.get_config(source=source)\n            source_config = source_config_result.result\n\n            if isinstance(source_config_result.scrapli_responses, MultiResponse):\n                # in this case this will always be a multiresponse or nothing (failure) but mypy\n                # doesnt know that, hence the isinstance check\n                scrapli_responses.extend(source_config_result.scrapli_responses)\n\n            if source_config_result.failed:\n                msg = \"failed fetching source config for diff comparison\"\n                self.logger.critical(msg)\n                raise DiffConfigError(msg)\n\n        except DiffConfigError:\n            pass\n\n        return self._post_diff_config(\n            diff_response=diff_response,\n            scrapli_responses=scrapli_responses,\n            source_config=self.clean_config(source_config),\n            candidate_config=self.clean_config(self.candidate_config),\n            device_diff=device_diff,\n        )\n        </code>\n    </pre>"},{"location":"api_docs/platform/core/arista_eos/async_platform/#classes","title":"Classes","text":""},{"location":"api_docs/platform/core/arista_eos/async_platform/#asyncscraplicfgeos","title":"AsyncScrapliCfgEOS","text":"<pre><code>Helper class that provides a standard way to create an ABC using\ninheritance.\n\nScrapli Config async base class\n\nArgs:\n    conn: scrapli connection to use\n    config_sources: list of config sources\n    on_prepare: optional callable to run at connection `prepare`\n    dedicated_connection: if `False` (default value) scrapli cfg will not open or close the\n        underlying scrapli connection and will raise an exception if the scrapli connection\n        is not open. If `True` will automatically open and close the scrapli connection when\n        using with a context manager, `prepare` will open the scrapli connection (if not\n        already open), and `close` will close the scrapli connection.\n    ignore_version: ignore checking device version support; currently this just means that\n        scrapli-cfg will not fetch the device version during the prepare phase, however this\n        will (hopefully) be used in the future to limit what methods can be used against a\n        target device. For example, for EOS devices we need &gt; 4.14 to load configs; so if a\n        device is encountered at 4.13 the version check would raise an exception rather than\n        just failing in a potentially awkward fashion.\n\nReturns:\n    None\n\nRaises:\n    N/A\n</code></pre> Expand source code <pre>\n        <code>\nclass AsyncScrapliCfgEOS(AsyncScrapliCfgPlatform, ScrapliCfgEOSBase):\n    def __init__(\n        self,\n        conn: AsyncEOSDriver,\n        *,\n        config_sources: Optional[List[str]] = None,\n        on_prepare: Optional[Callable[..., Any]] = None,\n        dedicated_connection: bool = False,\n        ignore_version: bool = False,\n    ) -&gt; None:\n        if config_sources is None:\n            config_sources = CONFIG_SOURCES\n\n        super().__init__(\n            conn=conn,\n            config_sources=config_sources,\n            on_prepare=on_prepare,\n            dedicated_connection=dedicated_connection,\n            ignore_version=ignore_version,\n        )\n\n        self.conn: AsyncEOSDriver\n\n        self.config_session_name = \"\"\n\n    async def _clear_config_session(self, session_name: str) -&gt; Response:\n        \"\"\"\n        Clear a configuration session\n\n        Args:\n            session_name: name of session to clear\n\n        Returns:\n            Response: scrapli response from clearing the session\n\n        Raises:\n            N/A\n\n        \"\"\"\n        # Note, early versions of eos supporting config sessions cant be aborted like this, but\n        # i dont want to register a config session for each session we want to delete so we'll just\n        # roll w/ this for now\n        return await self.conn.send_command(command=f\"configure session {session_name} abort\")\n\n    async def clear_config_sessions(\n        self, session_name: str = \"\", session_prefix: str = \"\"\n    ) -&gt; ScrapliCfgResponse:\n        \"\"\"\n        Clear a specific config session or all sessions with a prefix (ex: scrapli_cfg_)\n\n        Args:\n            session_name: name of specific config session to clear\n            session_prefix: prefix of session(s) to clear -- ignored if session_name is provided\n\n        Returns:\n            ScrapliCfgResponse: response object containing string of the target config source as the\n                `result` attribute\n\n        Raises:\n            N/A\n\n        \"\"\"\n        scrapli_responses = []\n        response = self._pre_clear_config_sessions()\n\n        try:\n            get_config_sessions_result = await self.conn.send_command(\n                command=\"show config sessions | json\"\n            )\n            scrapli_responses.append(get_config_sessions_result)\n            if get_config_sessions_result.failed:\n                msg = \"failed to show current config sessions\"\n                self.logger.critical(msg)\n                raise ScrapliCfgException(msg)\n\n            config_session_names = self._parse_config_sessions(\n                device_output=get_config_sessions_result.result\n            )\n            for config_session in config_session_names:\n                if session_name:\n                    if config_session == session_name:\n                        clear_config_session_result = await self._clear_config_session(\n                            session_name=session_name\n                        )\n                        scrapli_responses.append(clear_config_session_result)\n                else:\n                    if config_session.startswith(session_prefix):\n                        clear_config_session_result = await self._clear_config_session(\n                            session_name=session_name\n                        )\n                        scrapli_responses.append(clear_config_session_result)\n\n        except ScrapliCfgException:\n            pass\n\n        return self._post_clear_config_sessions(\n            response=response, scrapli_responses=scrapli_responses\n        )\n\n    async def get_version(self) -&gt; ScrapliCfgResponse:\n        response = self._pre_get_version()\n\n        version_result = await self.conn.send_command(\n            command=\"show version | i Software image version\"\n        )\n\n        return self._post_get_version(\n            response=response,\n            scrapli_responses=[version_result],\n            result=self._parse_version(device_output=version_result.result),\n        )\n\n    async def get_config(self, source: str = \"running\") -&gt; ScrapliCfgResponse:\n        response = self._pre_get_config(source=source)\n\n        config_result = await self.conn.send_command(\n            command=self._get_config_command(source=source)\n        )\n\n        return self._post_get_config(\n            response=response,\n            source=source,\n            scrapli_responses=[config_result],\n            result=config_result.result,\n        )\n\n    async def load_config(\n        self, config: str, replace: bool = False, **kwargs: Any\n    ) -&gt; ScrapliCfgResponse:\n        \"\"\"\n        Load configuration to a device\n\n        Supported kwargs:\n            N/A\n\n        Args:\n            config: string of the configuration to load\n            replace: replace the configuration or not, if false configuration will be loaded as a\n                merge operation\n            kwargs: additional kwargs that the implementing classes may need for their platform,\n                see above for eos supported kwargs\n\n        Returns:\n            ScrapliCfgResponse: response object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        scrapli_responses = []\n        response = self._pre_load_config(config=config)\n        (\n            config,\n            eager_config,\n            register_config_session,\n        ) = self._prepare_load_config_session_and_payload(config=config)\n\n        if register_config_session:\n            # only need to register a session if we havent -- we will reset session to an empty\n            # string after any commits/aborts so we know if we are doing \"new\" operations\n            self.conn.register_configuration_session(session_name=self.config_session_name)\n\n        try:\n            if replace:\n                # default the config session - we only need to do this if we are doing a REPLACE\n                rollback_clean_config_result = await self.conn.send_config(\n                    config=\"rollback clean-config\", privilege_level=self.config_session_name\n                )\n                if rollback_clean_config_result.failed:\n                    msg = \"failed to load clean config in configuration session\"\n                    self.logger.critical(msg)\n                    raise LoadConfigError(msg)\n\n            config_result = await self.conn.send_config(\n                config=config, privilege_level=self.config_session_name\n            )\n            scrapli_responses.append(config_result)\n            if config_result.failed:\n                msg = \"failed to load the candidate config into the config session\"\n                self.logger.critical(msg)\n                raise LoadConfigError(msg)\n\n            # eager cuz banners and such; perhaps if no banner/macro we can disable eager though....\n            if eager_config:\n                eager_config_result = await self.conn.send_config(\n                    config=eager_config, privilege_level=self.config_session_name, eager=True\n                )\n                scrapli_responses.append(eager_config_result)\n                if eager_config_result.failed:\n                    msg = \"failed to load the candidate config into the config session\"\n                    self.logger.critical(msg)\n                    raise LoadConfigError(msg)\n\n        except LoadConfigError:\n            # we catch our own exception so we dont need to do any if failed checks along the way\n            # as soon as we hit this (or when we are done w/ the try block) we are done loading the\n            # config and can build and return a response object\n            pass\n\n        return self._post_load_config(\n            response=response,\n            scrapli_responses=scrapli_responses,\n        )\n\n    async def abort_config(self) -&gt; ScrapliCfgResponse:\n        response = self._pre_abort_config(session_or_config_file=bool(self.config_session_name))\n\n        await self.conn.acquire_priv(desired_priv=self.config_session_name)\n        await self.conn._abort_config()  # pylint: disable=W0212\n        self._reset_config_session()\n\n        return self._post_abort_config(\n            response=response,\n            scrapli_responses=[],\n        )\n\n    async def commit_config(self, source: str = \"running\") -&gt; ScrapliCfgResponse:\n        response = self._pre_commit_config(\n            source=source, session_or_config_file=bool(self.config_session_name)\n        )\n\n        commit_results = await self.conn.send_commands(\n            commands=[\n                f\"configure session {self.config_session_name} commit\",\n                \"copy running-config startup-config\",\n            ]\n        )\n        self._reset_config_session()\n\n        return self._post_commit_config(response=response, scrapli_responses=[commit_results])\n\n    async def diff_config(self, source: str = \"running\") -&gt; ScrapliCfgDiffResponse:\n        scrapli_responses = []\n        device_diff = \"\"\n        source_config = \"\"\n\n        diff_response = self._pre_diff_config(\n            source=source, session_or_config_file=bool(self.config_session_name)\n        )\n\n        try:\n            diff_result = await self.conn.send_config(\n                config=\"show session-config diffs\", privilege_level=self.config_session_name\n            )\n            scrapli_responses.append(diff_result)\n            if diff_result.failed:\n                msg = \"failed generating diff for config session\"\n                self.logger.critical(msg)\n                raise DiffConfigError(msg)\n\n            device_diff = diff_result.result\n\n            source_config_result = await self.get_config(source=source)\n            source_config = source_config_result.result\n\n            if isinstance(source_config_result.scrapli_responses, MultiResponse):\n                # in this case this will always be a multiresponse or nothing (failure) but mypy\n                # doesnt know that, hence the isinstance check\n                scrapli_responses.extend(source_config_result.scrapli_responses)\n\n            if source_config_result.failed:\n                msg = \"failed fetching source config for diff comparison\"\n                self.logger.critical(msg)\n                raise DiffConfigError(msg)\n\n        except DiffConfigError:\n            pass\n\n        return self._post_diff_config(\n            diff_response=diff_response,\n            scrapli_responses=scrapli_responses,\n            source_config=self.clean_config(source_config),\n            candidate_config=self.clean_config(self.candidate_config),\n            device_diff=device_diff,\n        )\n        </code>\n    </pre>"},{"location":"api_docs/platform/core/arista_eos/async_platform/#ancestors-in-mro","title":"Ancestors (in MRO)","text":"<ul> <li>scrapli_cfg.platform.base.async_platform.AsyncScrapliCfgPlatform</li> <li>abc.ABC</li> <li>scrapli_cfg.platform.base.base_platform.ScrapliCfgBase</li> <li>scrapli_cfg.platform.core.arista_eos.base_platform.ScrapliCfgEOSBase</li> </ul>"},{"location":"api_docs/platform/core/arista_eos/async_platform/#class-variables","title":"Class variables","text":"<p><code>conn: Union[scrapli.driver.network.sync_driver.NetworkDriver,\u00a0scrapli.driver.network.async_driver.AsyncNetworkDriver]</code></p>"},{"location":"api_docs/platform/core/arista_eos/async_platform/#methods","title":"Methods","text":""},{"location":"api_docs/platform/core/arista_eos/async_platform/#clear_config_sessions","title":"clear_config_sessions","text":"<p><code>clear_config_sessions(self, session_name:\u00a0str\u00a0=\u00a0'', session_prefix:\u00a0str\u00a0=\u00a0'') \u2011&gt; scrapli_cfg.response.ScrapliCfgResponse</code></p> <pre><code>Clear a specific config session or all sessions with a prefix (ex: scrapli_cfg_)\n\nArgs:\n    session_name: name of specific config session to clear\n    session_prefix: prefix of session(s) to clear -- ignored if session_name is provided\n\nReturns:\n    ScrapliCfgResponse: response object containing string of the target config source as the\n        `result` attribute\n\nRaises:\n    N/A\n</code></pre>"},{"location":"api_docs/platform/core/arista_eos/async_platform/#load_config","title":"load_config","text":"<p><code>load_config(self, config:\u00a0str, replace:\u00a0bool\u00a0=\u00a0False, **kwargs:\u00a0Any) \u2011&gt; scrapli_cfg.response.ScrapliCfgResponse</code></p> <pre><code>Load configuration to a device\n\nSupported kwargs:\n    N/A\n\nArgs:\n    config: string of the configuration to load\n    replace: replace the configuration or not, if false configuration will be loaded as a\n        merge operation\n    kwargs: additional kwargs that the implementing classes may need for their platform,\n        see above for eos supported kwargs\n\nReturns:\n    ScrapliCfgResponse: response object\n\nRaises:\n    N/A\n</code></pre>"},{"location":"api_docs/platform/core/arista_eos/base_platform/","title":"Base platform","text":"window.addEventListener('DOMContentLoaded', () =&gt; hljs.initHighlighting())"},{"location":"api_docs/platform/core/arista_eos/base_platform/#module-scrapli_cfgplatformcorearista_eosbase_platform","title":"Module scrapli_cfg.platform.core.arista_eos.base_platform","text":"<p>scrapli_cfg.platform.core.arista_eos.base</p> Expand source code <pre>\n        <code>\n\"\"\"scrapli_cfg.platform.core.arista_eos.base\"\"\"\nimport json\nimport re\nfrom datetime import datetime\nfrom logging import Logger, LoggerAdapter\nfrom typing import TYPE_CHECKING, Iterable, List, Tuple, Union\n\nfrom scrapli.driver import AsyncNetworkDriver, NetworkDriver\nfrom scrapli.response import Response\nfrom scrapli_cfg.exceptions import ScrapliCfgException\nfrom scrapli_cfg.helper import strip_blank_lines\nfrom scrapli_cfg.platform.core.arista_eos.patterns import (\n    BANNER_PATTERN,\n    END_PATTERN,\n    GLOBAL_COMMENT_LINE_PATTERN,\n    VERSION_PATTERN,\n)\nfrom scrapli_cfg.response import ScrapliCfgResponse\n\nif TYPE_CHECKING:\n    LoggerAdapterT = LoggerAdapter[Logger]  # pylint:disable=E1136\nelse:\n    LoggerAdapterT = LoggerAdapter\n\n\nCONFIG_SOURCES = [\n    \"running\",\n    \"startup\",\n]\n\n\nclass ScrapliCfgEOSBase:\n    conn: Union[NetworkDriver, AsyncNetworkDriver]\n    logger: LoggerAdapterT\n    config_sources: List[str]\n    config_session_name: str\n    candidate_config: str\n\n    @staticmethod\n    def _parse_version(device_output: str) -&gt; str:\n        \"\"\"\n        Parse version string out of device output\n\n        Args:\n            device_output: output from show version command\n\n        Returns:\n            str: device version string\n\n        Raises:\n            N/A\n\n        \"\"\"\n        version_string_search = re.search(pattern=VERSION_PATTERN, string=device_output)\n\n        if not version_string_search:\n            return \"\"\n\n        version_string = version_string_search.group(0) or \"\"\n        return version_string\n\n    @staticmethod\n    def _parse_config_sessions(device_output: str) -&gt; List[str]:\n        \"\"\"\n        Parse config session names out of device output\n\n        Args:\n            device_output: output from show version command\n\n        Returns:\n            list[str]: config session names\n\n        Raises:\n            N/A\n\n        \"\"\"\n        try:\n            config_session_dict = json.loads(device_output)\n        except json.JSONDecodeError:\n            return []\n\n        sessions = list(config_session_dict.get(\"sessions\", {}))\n        return sessions\n\n    @staticmethod\n    def _get_config_command(source: str) -&gt; str:\n        \"\"\"\n        Return command to use to get config based on the provided source\n\n        Args:\n            source: name of the config source, generally running|startup\n\n        Returns:\n            str: command to use to fetch the requested config\n\n        Raises:\n            N/A\n\n        \"\"\"\n        if source == \"running\":\n            return \"show running-config\"\n        return \"show startup-config\"\n\n    @staticmethod\n    def _prepare_config_payloads(config: str) -&gt; Tuple[str, str]:\n        \"\"\"\n        Prepare a configuration so it can be nicely sent to the device via scrapli\n\n        Args:\n            config: configuration to prep\n\n        Returns:\n            tuple: tuple of \"normal\" config lines and \"eager\" config lines\n\n        Raises:\n            N/A\n\n        \"\"\"\n        # remove comment lines\n        config = re.sub(pattern=GLOBAL_COMMENT_LINE_PATTERN, repl=\"!\", string=config)\n\n        # remove \"end\" at the end of config if present - if its present it will drop scrapli out\n        # of the config session which we do not want\n        config = re.sub(pattern=END_PATTERN, repl=\"!\", string=config)\n\n        # find all sections that need to be \"eagerly\" sent\n        eager_config = re.findall(pattern=BANNER_PATTERN, string=config)\n        for eager_section in eager_config:\n            config = config.replace(eager_section, \"!\")\n\n        joined_eager_config = \"\\n\".join(captured_section for captured_section in eager_config)\n\n        return config, joined_eager_config\n\n    def _prepare_load_config_session_and_payload(self, config: str) -&gt; Tuple[str, str, bool]:\n        \"\"\"\n        Prepare the normal and eager payloads and decide if we need to register a config session\n\n        Args:\n            config: candidate config to load\n\n        Returns:\n            tuple: tuple containing \"normal\" config elements to send to the device and \"eager\" mode\n                config elements to send to the device (things like banners/macro that require\n                scrapli \"eager=True\"), and lastly a bool indicating if the config session needs to\n                be registered on the device\n\n        Raises:\n            N/A\n\n        \"\"\"\n        config, eager_config = self._prepare_config_payloads(config=config)\n\n        register_config_session = False\n        if not self.config_session_name:\n            self.config_session_name = f\"scrapli_cfg_{round(datetime.now().timestamp())}\"\n            self.logger.debug(f\"configuration session name will be '{self.config_session_name}'\")\n            register_config_session = True\n\n        return config, eager_config, register_config_session\n\n    def _reset_config_session(self) -&gt; None:\n        \"\"\"\n        Reset config session info\n\n        Resets the candidate config and config session name attributes -- when these are \"empty\" we\n        know there is no current config session\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.logger.debug(\"resetting candidate config and config session name\")\n        self.candidate_config = \"\"\n        self.config_session_name = \"\"\n\n    def clean_config(self, config: str) -&gt; str:\n        \"\"\"\n        Clean a configuration file of unwanted lines\n\n        Args:\n            config: configuration string to \"clean\";  remove all comment lines from both the source\n                and candidate configs -- this is only done here pre-diff, so we dont modify the user\n                provided candidate config which can totally have those comment lines - we only\n                remove \"global\" (top level) comments though... user comments attached to interfaces\n                and the stuff will remain\n\n        Returns:\n            str: cleaned configuration string\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.logger.debug(\"cleaning config file\")\n\n        return strip_blank_lines(\n            config=re.sub(pattern=GLOBAL_COMMENT_LINE_PATTERN, string=config, repl=\"\")\n        )\n\n    def _pre_clear_config_sessions(self) -&gt; ScrapliCfgResponse:\n        \"\"\"\n        Handle pre \"clear_config_sessions\" operations for parity between sync and async\n\n        Args:\n            N/A\n\n        Returns:\n            ScrapliCfgResponse: new response object to update w/ get results\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.logger.info(\"clear_config_sessions requested\")\n\n        response = ScrapliCfgResponse(\n            host=self.conn.host, raise_for_status_exception=ScrapliCfgException\n        )\n\n        return response\n\n    def _post_clear_config_sessions(\n        self,\n        response: ScrapliCfgResponse,\n        scrapli_responses: Iterable[Response],\n    ) -&gt; ScrapliCfgResponse:\n        \"\"\"\n        Handle post \"clear_config_sessions\" operations for parity between sync and async\n\n        Args:\n            response: response object to update\n            scrapli_responses: list of scrapli response objects from fetching the version\n\n        Returns:\n            ScrapliCfgResponse: response object containing string of the version as the `result`\n                attribute\n\n        Raises:\n            N/A\n\n        \"\"\"\n        response.record_response(scrapli_responses=scrapli_responses)\n\n        if response.failed:\n            msg = \"failed to clear device configuration session(s)\"\n            self.logger.critical(msg)\n            response.result = msg\n        else:\n            response.result = \"configuration session(s) cleared\"\n\n        return response\n        </code>\n    </pre>"},{"location":"api_docs/platform/core/arista_eos/base_platform/#classes","title":"Classes","text":""},{"location":"api_docs/platform/core/arista_eos/base_platform/#scraplicfgeosbase","title":"ScrapliCfgEOSBase","text":"Expand source code <pre>\n        <code>\nclass ScrapliCfgEOSBase:\n    conn: Union[NetworkDriver, AsyncNetworkDriver]\n    logger: LoggerAdapterT\n    config_sources: List[str]\n    config_session_name: str\n    candidate_config: str\n\n    @staticmethod\n    def _parse_version(device_output: str) -&gt; str:\n        \"\"\"\n        Parse version string out of device output\n\n        Args:\n            device_output: output from show version command\n\n        Returns:\n            str: device version string\n\n        Raises:\n            N/A\n\n        \"\"\"\n        version_string_search = re.search(pattern=VERSION_PATTERN, string=device_output)\n\n        if not version_string_search:\n            return \"\"\n\n        version_string = version_string_search.group(0) or \"\"\n        return version_string\n\n    @staticmethod\n    def _parse_config_sessions(device_output: str) -&gt; List[str]:\n        \"\"\"\n        Parse config session names out of device output\n\n        Args:\n            device_output: output from show version command\n\n        Returns:\n            list[str]: config session names\n\n        Raises:\n            N/A\n\n        \"\"\"\n        try:\n            config_session_dict = json.loads(device_output)\n        except json.JSONDecodeError:\n            return []\n\n        sessions = list(config_session_dict.get(\"sessions\", {}))\n        return sessions\n\n    @staticmethod\n    def _get_config_command(source: str) -&gt; str:\n        \"\"\"\n        Return command to use to get config based on the provided source\n\n        Args:\n            source: name of the config source, generally running|startup\n\n        Returns:\n            str: command to use to fetch the requested config\n\n        Raises:\n            N/A\n\n        \"\"\"\n        if source == \"running\":\n            return \"show running-config\"\n        return \"show startup-config\"\n\n    @staticmethod\n    def _prepare_config_payloads(config: str) -&gt; Tuple[str, str]:\n        \"\"\"\n        Prepare a configuration so it can be nicely sent to the device via scrapli\n\n        Args:\n            config: configuration to prep\n\n        Returns:\n            tuple: tuple of \"normal\" config lines and \"eager\" config lines\n\n        Raises:\n            N/A\n\n        \"\"\"\n        # remove comment lines\n        config = re.sub(pattern=GLOBAL_COMMENT_LINE_PATTERN, repl=\"!\", string=config)\n\n        # remove \"end\" at the end of config if present - if its present it will drop scrapli out\n        # of the config session which we do not want\n        config = re.sub(pattern=END_PATTERN, repl=\"!\", string=config)\n\n        # find all sections that need to be \"eagerly\" sent\n        eager_config = re.findall(pattern=BANNER_PATTERN, string=config)\n        for eager_section in eager_config:\n            config = config.replace(eager_section, \"!\")\n\n        joined_eager_config = \"\\n\".join(captured_section for captured_section in eager_config)\n\n        return config, joined_eager_config\n\n    def _prepare_load_config_session_and_payload(self, config: str) -&gt; Tuple[str, str, bool]:\n        \"\"\"\n        Prepare the normal and eager payloads and decide if we need to register a config session\n\n        Args:\n            config: candidate config to load\n\n        Returns:\n            tuple: tuple containing \"normal\" config elements to send to the device and \"eager\" mode\n                config elements to send to the device (things like banners/macro that require\n                scrapli \"eager=True\"), and lastly a bool indicating if the config session needs to\n                be registered on the device\n\n        Raises:\n            N/A\n\n        \"\"\"\n        config, eager_config = self._prepare_config_payloads(config=config)\n\n        register_config_session = False\n        if not self.config_session_name:\n            self.config_session_name = f\"scrapli_cfg_{round(datetime.now().timestamp())}\"\n            self.logger.debug(f\"configuration session name will be '{self.config_session_name}'\")\n            register_config_session = True\n\n        return config, eager_config, register_config_session\n\n    def _reset_config_session(self) -&gt; None:\n        \"\"\"\n        Reset config session info\n\n        Resets the candidate config and config session name attributes -- when these are \"empty\" we\n        know there is no current config session\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.logger.debug(\"resetting candidate config and config session name\")\n        self.candidate_config = \"\"\n        self.config_session_name = \"\"\n\n    def clean_config(self, config: str) -&gt; str:\n        \"\"\"\n        Clean a configuration file of unwanted lines\n\n        Args:\n            config: configuration string to \"clean\";  remove all comment lines from both the source\n                and candidate configs -- this is only done here pre-diff, so we dont modify the user\n                provided candidate config which can totally have those comment lines - we only\n                remove \"global\" (top level) comments though... user comments attached to interfaces\n                and the stuff will remain\n\n        Returns:\n            str: cleaned configuration string\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.logger.debug(\"cleaning config file\")\n\n        return strip_blank_lines(\n            config=re.sub(pattern=GLOBAL_COMMENT_LINE_PATTERN, string=config, repl=\"\")\n        )\n\n    def _pre_clear_config_sessions(self) -&gt; ScrapliCfgResponse:\n        \"\"\"\n        Handle pre \"clear_config_sessions\" operations for parity between sync and async\n\n        Args:\n            N/A\n\n        Returns:\n            ScrapliCfgResponse: new response object to update w/ get results\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.logger.info(\"clear_config_sessions requested\")\n\n        response = ScrapliCfgResponse(\n            host=self.conn.host, raise_for_status_exception=ScrapliCfgException\n        )\n\n        return response\n\n    def _post_clear_config_sessions(\n        self,\n        response: ScrapliCfgResponse,\n        scrapli_responses: Iterable[Response],\n    ) -&gt; ScrapliCfgResponse:\n        \"\"\"\n        Handle post \"clear_config_sessions\" operations for parity between sync and async\n\n        Args:\n            response: response object to update\n            scrapli_responses: list of scrapli response objects from fetching the version\n\n        Returns:\n            ScrapliCfgResponse: response object containing string of the version as the `result`\n                attribute\n\n        Raises:\n            N/A\n\n        \"\"\"\n        response.record_response(scrapli_responses=scrapli_responses)\n\n        if response.failed:\n            msg = \"failed to clear device configuration session(s)\"\n            self.logger.critical(msg)\n            response.result = msg\n        else:\n            response.result = \"configuration session(s) cleared\"\n\n        return response\n        </code>\n    </pre>"},{"location":"api_docs/platform/core/arista_eos/base_platform/#descendants","title":"Descendants","text":"<ul> <li>scrapli_cfg.platform.core.arista_eos.async_platform.AsyncScrapliCfgEOS</li> <li>scrapli_cfg.platform.core.arista_eos.sync_platform.ScrapliCfgEOS</li> </ul>"},{"location":"api_docs/platform/core/arista_eos/base_platform/#class-variables","title":"Class variables","text":"<p><code>candidate_config: str</code></p> <p><code>config_session_name: str</code></p> <p><code>config_sources: List[str]</code></p> <p><code>conn: Union[scrapli.driver.network.sync_driver.NetworkDriver,\u00a0scrapli.driver.network.async_driver.AsyncNetworkDriver]</code></p> <p><code>logger: logging.LoggerAdapter</code></p>"},{"location":"api_docs/platform/core/arista_eos/base_platform/#methods","title":"Methods","text":""},{"location":"api_docs/platform/core/arista_eos/base_platform/#clean_config","title":"clean_config","text":"<p><code>clean_config(self, config:\u00a0str) \u2011&gt; str</code></p> <pre><code>Clean a configuration file of unwanted lines\n\nArgs:\n    config: configuration string to \"clean\";  remove all comment lines from both the source\n        and candidate configs -- this is only done here pre-diff, so we dont modify the user\n        provided candidate config which can totally have those comment lines - we only\n        remove \"global\" (top level) comments though... user comments attached to interfaces\n        and the stuff will remain\n\nReturns:\n    str: cleaned configuration string\n\nRaises:\n    N/A\n</code></pre>"},{"location":"api_docs/platform/core/arista_eos/patterns/","title":"Patterns","text":"window.addEventListener('DOMContentLoaded', () =&gt; hljs.initHighlighting())"},{"location":"api_docs/platform/core/arista_eos/patterns/#module-scrapli_cfgplatformcorearista_eospatterns","title":"Module scrapli_cfg.platform.core.arista_eos.patterns","text":"<p>scrapli_cfg.platform.core.arista_eos.patterns</p> Expand source code <pre>\n        <code>\n\"\"\"scrapli_cfg.platform.core.arista_eos.patterns\"\"\"\nimport re\n\nVERSION_PATTERN = re.compile(pattern=r\"\\d+\\.\\d+\\.[a-z0-9\\-]+(\\.\\d+[a-z]{0,1})?\", flags=re.I)\nGLOBAL_COMMENT_LINE_PATTERN = re.compile(pattern=r\"^\\! .*$\", flags=re.I | re.M)\nBANNER_PATTERN = re.compile(pattern=r\"^banner.*EOF$\", flags=re.I | re.M | re.S)\nEND_PATTERN = re.compile(pattern=\"end$\")\n\n# pre-canned config section grabber patterns\n\n# match all ethernet interfaces w/ or w/out config items below them\nETHERNET_INTERFACES = re.compile(\n    pattern=r\"(^interface ethernet\\d+$(?:\\n^\\s{3}.*$)*\\n!\\n)+\", flags=re.I | re.M\n)\n# match management1 interface and config items below it\nMANAGEMENT_ONE_INTERFACE = re.compile(\n    pattern=r\"^interface management1$(?:\\n^\\s{3}.*$)*\\n!\", flags=re.I | re.M\n)\n        </code>\n    </pre>"},{"location":"api_docs/platform/core/arista_eos/sync_platform/","title":"Sync Platform","text":"window.addEventListener('DOMContentLoaded', () =&gt; hljs.initHighlighting())"},{"location":"api_docs/platform/core/arista_eos/sync_platform/#module-scrapli_cfgplatformcorearista_eossync_platform","title":"Module scrapli_cfg.platform.core.arista_eos.sync_platform","text":"<p>scrapli_cfg.platform.core.arista_eos.sync</p> Expand source code <pre>\n        <code>\n\"\"\"scrapli_cfg.platform.core.arista_eos.sync\"\"\"\nfrom typing import Any, Callable, List, Optional\n\nfrom scrapli.driver.core import EOSDriver\nfrom scrapli.response import MultiResponse, Response\nfrom scrapli_cfg.diff import ScrapliCfgDiffResponse\nfrom scrapli_cfg.exceptions import DiffConfigError, LoadConfigError, ScrapliCfgException\nfrom scrapli_cfg.platform.base.sync_platform import ScrapliCfgPlatform\nfrom scrapli_cfg.platform.core.arista_eos.base_platform import CONFIG_SOURCES, ScrapliCfgEOSBase\nfrom scrapli_cfg.response import ScrapliCfgResponse\n\n\nclass ScrapliCfgEOS(ScrapliCfgPlatform, ScrapliCfgEOSBase):\n    def __init__(\n        self,\n        conn: EOSDriver,\n        *,\n        config_sources: Optional[List[str]] = None,\n        on_prepare: Optional[Callable[..., Any]] = None,\n        dedicated_connection: bool = False,\n        ignore_version: bool = False,\n    ) -&gt; None:\n        if config_sources is None:\n            config_sources = CONFIG_SOURCES\n\n        super().__init__(\n            conn=conn,\n            config_sources=config_sources,\n            on_prepare=on_prepare,\n            dedicated_connection=dedicated_connection,\n            ignore_version=ignore_version,\n        )\n\n        self.conn: EOSDriver\n\n        self.config_session_name = \"\"\n\n    def _clear_config_session(self, session_name: str) -&gt; Response:\n        \"\"\"\n        Clear a configuration session\n\n        Args:\n            session_name: name of session to clear\n\n        Returns:\n            Response: scrapli response from clearing the session\n\n        Raises:\n            N/A\n\n        \"\"\"\n        # Note, early versions of eos supporting config sessions cant be aborted like this, but\n        # i dont want to register a config session for each session we want to delete so we'll just\n        # roll w/ this for now\n        return self.conn.send_command(command=f\"configure session {session_name} abort\")\n\n    def clear_config_sessions(\n        self, session_name: str = \"\", session_prefix: str = \"\"\n    ) -&gt; ScrapliCfgResponse:\n        \"\"\"\n        Clear a specific config session or all sessions with a prefix (ex: scrapli_cfg_)\n\n        Args:\n            session_name: name of specific config session to clear\n            session_prefix: prefix of session(s) to clear -- ignored if session_name is provided\n\n        Returns:\n            ScrapliCfgResponse: response object containing string of the target config source as the\n                `result` attribute\n\n        Raises:\n            N/A\n\n        \"\"\"\n        scrapli_responses = []\n        response = self._pre_clear_config_sessions()\n\n        try:\n            get_config_sessions_result = self.conn.send_command(\n                command=\"show config sessions | json\"\n            )\n            scrapli_responses.append(get_config_sessions_result)\n            if get_config_sessions_result.failed:\n                msg = \"failed to show current config sessions\"\n                self.logger.critical(msg)\n                raise ScrapliCfgException(msg)\n\n            config_session_names = self._parse_config_sessions(\n                device_output=get_config_sessions_result.result\n            )\n            for config_session in config_session_names:\n                if session_name:\n                    if config_session == session_name:\n                        clear_config_session_result = self._clear_config_session(\n                            session_name=session_name\n                        )\n                        scrapli_responses.append(clear_config_session_result)\n                else:\n                    if config_session.startswith(session_prefix):\n                        clear_config_session_result = self._clear_config_session(\n                            session_name=session_name\n                        )\n                        scrapli_responses.append(clear_config_session_result)\n\n        except ScrapliCfgException:\n            pass\n\n        return self._post_clear_config_sessions(\n            response=response, scrapli_responses=scrapli_responses\n        )\n\n    def get_version(self) -&gt; ScrapliCfgResponse:\n        response = self._pre_get_version()\n\n        version_result = self.conn.send_command(command=\"show version | i Software image version\")\n\n        return self._post_get_version(\n            response=response,\n            scrapli_responses=[version_result],\n            result=self._parse_version(device_output=version_result.result),\n        )\n\n    def get_config(self, source: str = \"running\") -&gt; ScrapliCfgResponse:\n        response = self._pre_get_config(source=source)\n\n        config_result = self.conn.send_command(command=self._get_config_command(source=source))\n\n        return self._post_get_config(\n            response=response,\n            source=source,\n            scrapli_responses=[config_result],\n            result=config_result.result,\n        )\n\n    def load_config(self, config: str, replace: bool = False, **kwargs: Any) -&gt; ScrapliCfgResponse:\n        \"\"\"\n        Load configuration to a device\n\n        Supported kwargs:\n            N/A\n\n        Args:\n            config: string of the configuration to load\n            replace: replace the configuration or not, if false configuration will be loaded as a\n                merge operation\n            kwargs: additional kwargs that the implementing classes may need for their platform,\n                see above for eos supported kwargs\n\n        Returns:\n            ScrapliCfgResponse: response object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        scrapli_responses = []\n        response = self._pre_load_config(config=config)\n        (\n            config,\n            eager_config,\n            register_config_session,\n        ) = self._prepare_load_config_session_and_payload(config=config)\n\n        if register_config_session is True:\n            # only need to register a session if we havent -- we will reset session to an empty\n            # string after any commits/aborts so we know if we are doing \"new\" operations\n            self.conn.register_configuration_session(session_name=self.config_session_name)\n\n        try:\n            if replace:\n                # default the config session - we only need to do this if we are doing a REPLACE\n                rollback_clean_config_result = self.conn.send_config(\n                    config=\"rollback clean-config\", privilege_level=self.config_session_name\n                )\n                scrapli_responses.append(rollback_clean_config_result)\n                if rollback_clean_config_result.failed:\n                    msg = \"failed to load clean config in configuration session\"\n                    self.logger.critical(msg)\n                    raise LoadConfigError(msg)\n\n            config_result = self.conn.send_config(\n                config=config, privilege_level=self.config_session_name\n            )\n            scrapli_responses.append(config_result)\n            if config_result.failed:\n                msg = \"failed to load the candidate config into the config session\"\n                self.logger.critical(msg)\n                raise LoadConfigError(msg)\n\n            # eager cuz banners and such; perhaps if no banner/macro we can disable eager though....\n            if eager_config:\n                eager_config_result = self.conn.send_config(\n                    config=eager_config, privilege_level=self.config_session_name, eager=True\n                )\n                scrapli_responses.append(eager_config_result)\n                if eager_config_result.failed:\n                    msg = \"failed to load the candidate config into the config session\"\n                    self.logger.critical(msg)\n                    raise LoadConfigError(msg)\n\n        except LoadConfigError:\n            # we catch our own exception so we dont need to do any if failed checks along the way\n            # as soon as we hit this (or when we are done w/ the try block) we are done loading the\n            # config and can build and return a response object\n            pass\n\n        return self._post_load_config(\n            response=response,\n            scrapli_responses=scrapli_responses,\n        )\n\n    def abort_config(self) -&gt; ScrapliCfgResponse:\n        response = self._pre_abort_config(session_or_config_file=bool(self.config_session_name))\n\n        self.conn.acquire_priv(desired_priv=self.config_session_name)\n        self.conn._abort_config()  # pylint: disable=W0212\n        self._reset_config_session()\n\n        return self._post_abort_config(response=response, scrapli_responses=[])\n\n    def commit_config(self, source: str = \"running\") -&gt; ScrapliCfgResponse:\n        response = self._pre_commit_config(\n            source=source, session_or_config_file=bool(self.config_session_name)\n        )\n\n        commit_results = self.conn.send_commands(\n            commands=[\n                f\"configure session {self.config_session_name} commit\",\n                \"copy running-config startup-config\",\n            ]\n        )\n        self._reset_config_session()\n\n        return self._post_commit_config(response=response, scrapli_responses=[commit_results])\n\n    def diff_config(self, source: str = \"running\") -&gt; ScrapliCfgDiffResponse:\n        scrapli_responses = []\n        device_diff = \"\"\n        source_config = \"\"\n\n        diff_response = self._pre_diff_config(\n            source=source, session_or_config_file=bool(self.config_session_name)\n        )\n\n        try:\n            diff_result = self.conn.send_config(\n                config=\"show session-config diffs\", privilege_level=self.config_session_name\n            )\n            scrapli_responses.append(diff_result)\n            if diff_result.failed:\n                msg = \"failed generating diff for config session\"\n                self.logger.critical(msg)\n                raise DiffConfigError(msg)\n\n            device_diff = diff_result.result\n\n            source_config_result = self.get_config(source=source)\n            source_config = source_config_result.result\n\n            if isinstance(source_config_result.scrapli_responses, MultiResponse):\n                # in this case this will always be a multiresponse or nothing (failure) but mypy\n                # doesnt know that, hence the isinstance check\n                scrapli_responses.extend(source_config_result.scrapli_responses)\n\n            if source_config_result.failed:\n                msg = \"failed fetching source config for diff comparison\"\n                self.logger.critical(msg)\n                raise DiffConfigError(msg)\n\n        except DiffConfigError:\n            pass\n\n        return self._post_diff_config(\n            diff_response=diff_response,\n            scrapli_responses=scrapli_responses,\n            source_config=self.clean_config(source_config),\n            candidate_config=self.clean_config(self.candidate_config),\n            device_diff=device_diff,\n        )\n        </code>\n    </pre>"},{"location":"api_docs/platform/core/arista_eos/sync_platform/#classes","title":"Classes","text":""},{"location":"api_docs/platform/core/arista_eos/sync_platform/#scraplicfgeos","title":"ScrapliCfgEOS","text":"<pre><code>Helper class that provides a standard way to create an ABC using\ninheritance.\n\nScrapli Config base class\n\nArgs:\n    conn: scrapli connection to use\n    config_sources: list of config sources\n    on_prepare: optional callable to run at connection `prepare`\n    dedicated_connection: if `False` (default value) scrapli cfg will not open or close the\n        underlying scrapli connection and will raise an exception if the scrapli connection\n        is not open. If `True` will automatically open and close the scrapli connection when\n        using with a context manager, `prepare` will open the scrapli connection (if not\n        already open), and `close` will close the scrapli connection.\n    ignore_version: ignore checking device version support; currently this just means that\n        scrapli-cfg will not fetch the device version during the prepare phase, however this\n        will (hopefully) be used in the future to limit what methods can be used against a\n        target device. For example, for EOS devices we need &gt; 4.14 to load configs; so if a\n        device is encountered at 4.13 the version check would raise an exception rather than\n        just failing in a potentially awkward fashion.\n\nReturns:\n    None\n\nRaises:\n    N/A\n</code></pre> Expand source code <pre>\n        <code>\nclass ScrapliCfgEOS(ScrapliCfgPlatform, ScrapliCfgEOSBase):\n    def __init__(\n        self,\n        conn: EOSDriver,\n        *,\n        config_sources: Optional[List[str]] = None,\n        on_prepare: Optional[Callable[..., Any]] = None,\n        dedicated_connection: bool = False,\n        ignore_version: bool = False,\n    ) -&gt; None:\n        if config_sources is None:\n            config_sources = CONFIG_SOURCES\n\n        super().__init__(\n            conn=conn,\n            config_sources=config_sources,\n            on_prepare=on_prepare,\n            dedicated_connection=dedicated_connection,\n            ignore_version=ignore_version,\n        )\n\n        self.conn: EOSDriver\n\n        self.config_session_name = \"\"\n\n    def _clear_config_session(self, session_name: str) -&gt; Response:\n        \"\"\"\n        Clear a configuration session\n\n        Args:\n            session_name: name of session to clear\n\n        Returns:\n            Response: scrapli response from clearing the session\n\n        Raises:\n            N/A\n\n        \"\"\"\n        # Note, early versions of eos supporting config sessions cant be aborted like this, but\n        # i dont want to register a config session for each session we want to delete so we'll just\n        # roll w/ this for now\n        return self.conn.send_command(command=f\"configure session {session_name} abort\")\n\n    def clear_config_sessions(\n        self, session_name: str = \"\", session_prefix: str = \"\"\n    ) -&gt; ScrapliCfgResponse:\n        \"\"\"\n        Clear a specific config session or all sessions with a prefix (ex: scrapli_cfg_)\n\n        Args:\n            session_name: name of specific config session to clear\n            session_prefix: prefix of session(s) to clear -- ignored if session_name is provided\n\n        Returns:\n            ScrapliCfgResponse: response object containing string of the target config source as the\n                `result` attribute\n\n        Raises:\n            N/A\n\n        \"\"\"\n        scrapli_responses = []\n        response = self._pre_clear_config_sessions()\n\n        try:\n            get_config_sessions_result = self.conn.send_command(\n                command=\"show config sessions | json\"\n            )\n            scrapli_responses.append(get_config_sessions_result)\n            if get_config_sessions_result.failed:\n                msg = \"failed to show current config sessions\"\n                self.logger.critical(msg)\n                raise ScrapliCfgException(msg)\n\n            config_session_names = self._parse_config_sessions(\n                device_output=get_config_sessions_result.result\n            )\n            for config_session in config_session_names:\n                if session_name:\n                    if config_session == session_name:\n                        clear_config_session_result = self._clear_config_session(\n                            session_name=session_name\n                        )\n                        scrapli_responses.append(clear_config_session_result)\n                else:\n                    if config_session.startswith(session_prefix):\n                        clear_config_session_result = self._clear_config_session(\n                            session_name=session_name\n                        )\n                        scrapli_responses.append(clear_config_session_result)\n\n        except ScrapliCfgException:\n            pass\n\n        return self._post_clear_config_sessions(\n            response=response, scrapli_responses=scrapli_responses\n        )\n\n    def get_version(self) -&gt; ScrapliCfgResponse:\n        response = self._pre_get_version()\n\n        version_result = self.conn.send_command(command=\"show version | i Software image version\")\n\n        return self._post_get_version(\n            response=response,\n            scrapli_responses=[version_result],\n            result=self._parse_version(device_output=version_result.result),\n        )\n\n    def get_config(self, source: str = \"running\") -&gt; ScrapliCfgResponse:\n        response = self._pre_get_config(source=source)\n\n        config_result = self.conn.send_command(command=self._get_config_command(source=source))\n\n        return self._post_get_config(\n            response=response,\n            source=source,\n            scrapli_responses=[config_result],\n            result=config_result.result,\n        )\n\n    def load_config(self, config: str, replace: bool = False, **kwargs: Any) -&gt; ScrapliCfgResponse:\n        \"\"\"\n        Load configuration to a device\n\n        Supported kwargs:\n            N/A\n\n        Args:\n            config: string of the configuration to load\n            replace: replace the configuration or not, if false configuration will be loaded as a\n                merge operation\n            kwargs: additional kwargs that the implementing classes may need for their platform,\n                see above for eos supported kwargs\n\n        Returns:\n            ScrapliCfgResponse: response object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        scrapli_responses = []\n        response = self._pre_load_config(config=config)\n        (\n            config,\n            eager_config,\n            register_config_session,\n        ) = self._prepare_load_config_session_and_payload(config=config)\n\n        if register_config_session is True:\n            # only need to register a session if we havent -- we will reset session to an empty\n            # string after any commits/aborts so we know if we are doing \"new\" operations\n            self.conn.register_configuration_session(session_name=self.config_session_name)\n\n        try:\n            if replace:\n                # default the config session - we only need to do this if we are doing a REPLACE\n                rollback_clean_config_result = self.conn.send_config(\n                    config=\"rollback clean-config\", privilege_level=self.config_session_name\n                )\n                scrapli_responses.append(rollback_clean_config_result)\n                if rollback_clean_config_result.failed:\n                    msg = \"failed to load clean config in configuration session\"\n                    self.logger.critical(msg)\n                    raise LoadConfigError(msg)\n\n            config_result = self.conn.send_config(\n                config=config, privilege_level=self.config_session_name\n            )\n            scrapli_responses.append(config_result)\n            if config_result.failed:\n                msg = \"failed to load the candidate config into the config session\"\n                self.logger.critical(msg)\n                raise LoadConfigError(msg)\n\n            # eager cuz banners and such; perhaps if no banner/macro we can disable eager though....\n            if eager_config:\n                eager_config_result = self.conn.send_config(\n                    config=eager_config, privilege_level=self.config_session_name, eager=True\n                )\n                scrapli_responses.append(eager_config_result)\n                if eager_config_result.failed:\n                    msg = \"failed to load the candidate config into the config session\"\n                    self.logger.critical(msg)\n                    raise LoadConfigError(msg)\n\n        except LoadConfigError:\n            # we catch our own exception so we dont need to do any if failed checks along the way\n            # as soon as we hit this (or when we are done w/ the try block) we are done loading the\n            # config and can build and return a response object\n            pass\n\n        return self._post_load_config(\n            response=response,\n            scrapli_responses=scrapli_responses,\n        )\n\n    def abort_config(self) -&gt; ScrapliCfgResponse:\n        response = self._pre_abort_config(session_or_config_file=bool(self.config_session_name))\n\n        self.conn.acquire_priv(desired_priv=self.config_session_name)\n        self.conn._abort_config()  # pylint: disable=W0212\n        self._reset_config_session()\n\n        return self._post_abort_config(response=response, scrapli_responses=[])\n\n    def commit_config(self, source: str = \"running\") -&gt; ScrapliCfgResponse:\n        response = self._pre_commit_config(\n            source=source, session_or_config_file=bool(self.config_session_name)\n        )\n\n        commit_results = self.conn.send_commands(\n            commands=[\n                f\"configure session {self.config_session_name} commit\",\n                \"copy running-config startup-config\",\n            ]\n        )\n        self._reset_config_session()\n\n        return self._post_commit_config(response=response, scrapli_responses=[commit_results])\n\n    def diff_config(self, source: str = \"running\") -&gt; ScrapliCfgDiffResponse:\n        scrapli_responses = []\n        device_diff = \"\"\n        source_config = \"\"\n\n        diff_response = self._pre_diff_config(\n            source=source, session_or_config_file=bool(self.config_session_name)\n        )\n\n        try:\n            diff_result = self.conn.send_config(\n                config=\"show session-config diffs\", privilege_level=self.config_session_name\n            )\n            scrapli_responses.append(diff_result)\n            if diff_result.failed:\n                msg = \"failed generating diff for config session\"\n                self.logger.critical(msg)\n                raise DiffConfigError(msg)\n\n            device_diff = diff_result.result\n\n            source_config_result = self.get_config(source=source)\n            source_config = source_config_result.result\n\n            if isinstance(source_config_result.scrapli_responses, MultiResponse):\n                # in this case this will always be a multiresponse or nothing (failure) but mypy\n                # doesnt know that, hence the isinstance check\n                scrapli_responses.extend(source_config_result.scrapli_responses)\n\n            if source_config_result.failed:\n                msg = \"failed fetching source config for diff comparison\"\n                self.logger.critical(msg)\n                raise DiffConfigError(msg)\n\n        except DiffConfigError:\n            pass\n\n        return self._post_diff_config(\n            diff_response=diff_response,\n            scrapli_responses=scrapli_responses,\n            source_config=self.clean_config(source_config),\n            candidate_config=self.clean_config(self.candidate_config),\n            device_diff=device_diff,\n        )\n        </code>\n    </pre>"},{"location":"api_docs/platform/core/arista_eos/sync_platform/#ancestors-in-mro","title":"Ancestors (in MRO)","text":"<ul> <li>scrapli_cfg.platform.base.sync_platform.ScrapliCfgPlatform</li> <li>abc.ABC</li> <li>scrapli_cfg.platform.base.base_platform.ScrapliCfgBase</li> <li>scrapli_cfg.platform.core.arista_eos.base_platform.ScrapliCfgEOSBase</li> </ul>"},{"location":"api_docs/platform/core/arista_eos/sync_platform/#class-variables","title":"Class variables","text":"<p><code>conn: Union[scrapli.driver.network.sync_driver.NetworkDriver,\u00a0scrapli.driver.network.async_driver.AsyncNetworkDriver]</code></p>"},{"location":"api_docs/platform/core/arista_eos/sync_platform/#methods","title":"Methods","text":""},{"location":"api_docs/platform/core/arista_eos/sync_platform/#clear_config_sessions","title":"clear_config_sessions","text":"<p><code>clear_config_sessions(self, session_name:\u00a0str\u00a0=\u00a0'', session_prefix:\u00a0str\u00a0=\u00a0'') \u2011&gt; scrapli_cfg.response.ScrapliCfgResponse</code></p> <pre><code>Clear a specific config session or all sessions with a prefix (ex: scrapli_cfg_)\n\nArgs:\n    session_name: name of specific config session to clear\n    session_prefix: prefix of session(s) to clear -- ignored if session_name is provided\n\nReturns:\n    ScrapliCfgResponse: response object containing string of the target config source as the\n        `result` attribute\n\nRaises:\n    N/A\n</code></pre>"},{"location":"api_docs/platform/core/arista_eos/sync_platform/#load_config","title":"load_config","text":"<p><code>load_config(self, config:\u00a0str, replace:\u00a0bool\u00a0=\u00a0False, **kwargs:\u00a0Any) \u2011&gt; scrapli_cfg.response.ScrapliCfgResponse</code></p> <pre><code>Load configuration to a device\n\nSupported kwargs:\n    N/A\n\nArgs:\n    config: string of the configuration to load\n    replace: replace the configuration or not, if false configuration will be loaded as a\n        merge operation\n    kwargs: additional kwargs that the implementing classes may need for their platform,\n        see above for eos supported kwargs\n\nReturns:\n    ScrapliCfgResponse: response object\n\nRaises:\n    N/A\n</code></pre>"},{"location":"api_docs/platform/core/cisco_iosxe/async_platform/","title":"Async Platform","text":"window.addEventListener('DOMContentLoaded', () =&gt; hljs.initHighlighting())"},{"location":"api_docs/platform/core/cisco_iosxe/async_platform/#module-scrapli_cfgplatformcorecisco_iosxeasync_platform","title":"Module scrapli_cfg.platform.core.cisco_iosxe.async_platform","text":"<p>scrapli_cfg.platform.core.cisco_iosxe.async_platform</p> Expand source code <pre>\n        <code>\n\"\"\"scrapli_cfg.platform.core.cisco_iosxe.async_platform\"\"\"\nfrom typing import Any, Callable, List, Optional\n\nfrom scrapli.driver import AsyncNetworkDriver\nfrom scrapli.response import Response\nfrom scrapli_cfg.diff import ScrapliCfgDiffResponse\nfrom scrapli_cfg.exceptions import DiffConfigError, FailedToDetermineDeviceState\nfrom scrapli_cfg.platform.base.async_platform import AsyncScrapliCfgPlatform\nfrom scrapli_cfg.platform.core.cisco_iosxe.base_platform import (\n    CONFIG_SOURCES,\n    FilePromptMode,\n    ScrapliCfgIOSXEBase,\n)\nfrom scrapli_cfg.response import ScrapliCfgResponse\n\n\nclass AsyncScrapliCfgIOSXE(AsyncScrapliCfgPlatform, ScrapliCfgIOSXEBase):\n    def __init__(\n        self,\n        conn: AsyncNetworkDriver,\n        *,\n        config_sources: Optional[List[str]] = None,\n        on_prepare: Optional[Callable[..., Any]] = None,\n        filesystem: str = \"flash:\",\n        cleanup_post_commit: bool = True,\n        dedicated_connection: bool = False,\n        ignore_version: bool = False,\n    ) -&gt; None:\n        if config_sources is None:\n            config_sources = CONFIG_SOURCES\n\n        super().__init__(\n            conn=conn,\n            config_sources=config_sources,\n            on_prepare=on_prepare,\n            dedicated_connection=dedicated_connection,\n            ignore_version=ignore_version,\n        )\n\n        self.filesystem = filesystem\n        self._filesystem_space_available_buffer_perc = 10\n\n        self._replace = False\n\n        self.candidate_config_filename = \"\"\n\n        self.cleanup_post_commit = cleanup_post_commit\n\n    async def _get_filesystem_space_available(self) -&gt; int:\n        \"\"\"\n        Abort a configuration -- discards any loaded config\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            FailedToDetermineDeviceState: if unable to fetch file filesystem bytes available\n\n        \"\"\"\n        filesystem_size_result = await self.conn.send_command(\n            command=f\"dir {self.filesystem} | i bytes\"\n        )\n        if filesystem_size_result.failed:\n            raise FailedToDetermineDeviceState(\"failed to determine space available on filesystem\")\n\n        return self._post_get_filesystem_space_available(output=filesystem_size_result.result)\n\n    async def _determine_file_prompt_mode(self) -&gt; FilePromptMode:\n        \"\"\"\n        Determine the device file prompt mode\n\n        Args:\n            N/A\n\n        Returns:\n            FilePromptMode: enum representing file prompt mode\n\n        Raises:\n            FailedToDetermineDeviceState: if unable to fetch file prompt mode\n\n        \"\"\"\n        file_prompt_mode_result = await self.conn.send_command(command=\"show run | i file prompt\")\n        if file_prompt_mode_result.failed:\n            raise FailedToDetermineDeviceState(\"failed to determine file prompt mode\")\n\n        return self._post_determine_file_prompt_mode(output=file_prompt_mode_result.result)\n\n    async def _delete_candidate_config(self) -&gt; Response:\n        \"\"\"\n        Delete candidate config from the filesystem\n\n        Args:\n            N/A\n\n        Returns:\n            Response: response from deleting the candidate config\n\n        Raises:\n            N/A\n\n        \"\"\"\n        # have to check again because the candidate config may have changed this!\n        file_prompt_mode = await self._determine_file_prompt_mode()\n        if file_prompt_mode in (FilePromptMode.ALERT, FilePromptMode.NOISY):\n            delete_events = [\n                (\n                    f\"delete {self.filesystem}{self.candidate_config_filename}\",\n                    \"Delete filename\",\n                ),\n                (\n                    \"\",\n                    \"[confirm]\",\n                ),\n                (\"\", \"\"),\n            ]\n        else:\n            delete_events = [\n                (f\"delete {self.filesystem}{self.candidate_config_filename}\", \"[confirm]\"),\n                (\"\", \"\"),\n            ]\n        delete_result = await self.conn.send_interactive(interact_events=delete_events)\n        return delete_result\n\n    async def get_version(self) -&gt; ScrapliCfgResponse:\n        response = self._pre_get_version()\n\n        version_result = await self.conn.send_command(command=\"show version | i Version\")\n\n        return self._post_get_version(\n            response=response,\n            scrapli_responses=[version_result],\n            result=self._parse_version(device_output=version_result.result),\n        )\n\n    async def get_config(self, source: str = \"running\") -&gt; ScrapliCfgResponse:\n        response = self._pre_get_config(source=source)\n\n        config_result = await self.conn.send_command(\n            command=self._get_config_command(source=source)\n        )\n\n        return self._post_get_config(\n            response=response,\n            source=source,\n            scrapli_responses=[config_result],\n            result=config_result.result,\n        )\n\n    async def load_config(\n        self, config: str, replace: bool = False, **kwargs: Any\n    ) -&gt; ScrapliCfgResponse:\n        \"\"\"\n        Load configuration to a device\n\n        Supported kwargs:\n            N/A\n\n        Args:\n            config: string of the configuration to load\n            replace: replace the configuration or not, if false configuration will be loaded as a\n                merge operation\n            kwargs: additional kwargs that the implementing classes may need for their platform,\n                see above for iosxe supported kwargs\n\n        Returns:\n            ScrapliCfgResponse: response object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        response = self._pre_load_config(config=config)\n\n        config = self._prepare_load_config(config=config, replace=replace)\n\n        filesystem_bytes_available = await self._get_filesystem_space_available()\n        self._space_available(filesystem_bytes_available=filesystem_bytes_available)\n\n        # when in tcl command mode or whatever it is, tcl wants \\r for return char, so stash the\n        # original return char and sub in \\r for a bit\n        original_return_char = self.conn.comms_return_char\n        tcl_comms_return_char = \"\\r\"\n\n        # pop into tclsh before swapping the return char just to be safe -- \\r or \\n should both be\n        # fine for up to here but who knows... :)\n        await self.conn.acquire_priv(desired_priv=\"tclsh\")\n        self.conn.comms_return_char = tcl_comms_return_char\n        config_result = await self.conn.send_config(config=config, privilege_level=\"tclsh\")\n\n        # reset the return char to the \"normal\" one and drop into whatever is the \"default\" priv\n        await self.conn.acquire_priv(desired_priv=self.conn.default_desired_privilege_level)\n        self.conn.comms_return_char = original_return_char\n\n        return self._post_load_config(\n            response=response,\n            scrapli_responses=[config_result],\n        )\n\n    async def abort_config(self) -&gt; ScrapliCfgResponse:\n        response = self._pre_abort_config(\n            session_or_config_file=bool(self.candidate_config_filename)\n        )\n\n        abort_result = await self._delete_candidate_config()\n        self._reset_config_session()\n\n        return self._post_abort_config(response=response, scrapli_responses=[abort_result])\n\n    async def save_config(self) -&gt; Response:\n        \"\"\"\n        Save the config -- \"copy run start\"!\n\n        Args:\n             N/A\n\n        Returns:\n            Response: scrapli response object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        # we always re-check file prompt mode because it could have changed!\n        file_prompt_mode = await self._determine_file_prompt_mode()\n\n        if file_prompt_mode == FilePromptMode.ALERT:\n            save_events = [\n                (\n                    \"copy running-config startup-config\",\n                    \"Destination filename\",\n                ),\n                (\"\", \"\"),\n            ]\n        elif file_prompt_mode == FilePromptMode.NOISY:\n            save_events = [\n                (\n                    \"copy running-config startup-config\",\n                    \"Source filename\",\n                ),\n                (\n                    \"\",\n                    \"Destination filename\",\n                ),\n                (\"\", \"\"),\n            ]\n        else:\n            save_events = [(\"copy running-config startup-config\", \"\")]\n\n        save_result = await self.conn.send_interactive(interact_events=save_events)\n        return save_result\n\n    async def _commit_config_merge(\n        self, file_prompt_mode: Optional[FilePromptMode] = None\n    ) -&gt; Response:\n        \"\"\"\n        Commit the configuration in merge mode\n\n        Args:\n             file_prompt_mode: optionally provide the file prompt mode, if its None we will fetch it\n                 to decide if we need to use interactive mode or not\n\n        Returns:\n            Response: scrapli response object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        if file_prompt_mode is None:\n            file_prompt_mode = await self._determine_file_prompt_mode()\n\n        if file_prompt_mode == FilePromptMode.ALERT:\n            merge_events = [\n                (\n                    f\"copy {self.filesystem}{self.candidate_config_filename} running-config\",\n                    \"Destination filename\",\n                ),\n                (\"\", \"\"),\n            ]\n        elif file_prompt_mode == FilePromptMode.NOISY:\n            merge_events = [\n                (\n                    f\"copy {self.filesystem}{self.candidate_config_filename} running-config\",\n                    \"Source filename\",\n                ),\n                (\n                    \"\",\n                    \"Destination filename\",\n                ),\n                (\"\", \"\"),\n            ]\n        else:\n            merge_events = [\n                (f\"copy {self.filesystem}{self.candidate_config_filename} running-config\", \"\")\n            ]\n\n        commit_result = await self.conn.send_interactive(interact_events=merge_events)\n        return commit_result\n\n    async def commit_config(self, source: str = \"running\") -&gt; ScrapliCfgResponse:\n        scrapli_responses = []\n        response = self._pre_commit_config(\n            source=source, session_or_config_file=bool(self.candidate_config_filename)\n        )\n\n        file_prompt_mode = await self._determine_file_prompt_mode()\n\n        if self._replace is True:\n            replace_command = (\n                f\"configure replace {self.filesystem}{self.candidate_config_filename} force\"\n            )\n            commit_result = await self.conn.send_command(command=replace_command)\n        else:\n            commit_result = await self._commit_config_merge(file_prompt_mode=file_prompt_mode)\n\n        scrapli_responses.append(commit_result)\n\n        save_config_result = await self.save_config()\n        scrapli_responses.append(save_config_result)\n\n        if self.cleanup_post_commit:\n            cleanup_result = await self._delete_candidate_config()\n            scrapli_responses.append(cleanup_result)\n\n        self._reset_config_session()\n\n        return self._post_load_config(\n            response=response,\n            scrapli_responses=scrapli_responses,\n        )\n\n    async def diff_config(self, source: str = \"running\") -&gt; ScrapliCfgDiffResponse:\n        scrapli_responses = []\n        device_diff = \"\"\n        source_config = \"\"\n\n        diff_response = self._pre_diff_config(\n            source=source, session_or_config_file=bool(self.candidate_config_filename)\n        )\n\n        try:\n            diff_result = await self.conn.send_command(\n                command=self._get_diff_command(source=source)\n            )\n            scrapli_responses.append(diff_result)\n            if diff_result.failed:\n                msg = \"failed generating diff for config session\"\n                self.logger.critical(msg)\n                raise DiffConfigError(msg)\n\n            device_diff = diff_result.result\n\n            source_config_result = await self.get_config(source=source)\n            source_config = source_config_result.result\n\n            if isinstance(source_config_result.scrapli_responses, list):\n                scrapli_responses.extend(source_config_result.scrapli_responses)\n\n            if source_config_result.failed:\n                msg = \"failed fetching source config for diff comparison\"\n                self.logger.critical(msg)\n                raise DiffConfigError(msg)\n\n        except DiffConfigError:\n            pass\n\n        return self._post_diff_config(\n            diff_response=diff_response,\n            scrapli_responses=scrapli_responses,\n            source_config=self.clean_config(source_config),\n            candidate_config=self.clean_config(self.candidate_config),\n            device_diff=device_diff,\n        )\n        </code>\n    </pre>"},{"location":"api_docs/platform/core/cisco_iosxe/async_platform/#classes","title":"Classes","text":""},{"location":"api_docs/platform/core/cisco_iosxe/async_platform/#asyncscraplicfgiosxe","title":"AsyncScrapliCfgIOSXE","text":"<pre><code>Helper class that provides a standard way to create an ABC using\ninheritance.\n\nScrapli Config async base class\n\nArgs:\n    conn: scrapli connection to use\n    config_sources: list of config sources\n    on_prepare: optional callable to run at connection `prepare`\n    dedicated_connection: if `False` (default value) scrapli cfg will not open or close the\n        underlying scrapli connection and will raise an exception if the scrapli connection\n        is not open. If `True` will automatically open and close the scrapli connection when\n        using with a context manager, `prepare` will open the scrapli connection (if not\n        already open), and `close` will close the scrapli connection.\n    ignore_version: ignore checking device version support; currently this just means that\n        scrapli-cfg will not fetch the device version during the prepare phase, however this\n        will (hopefully) be used in the future to limit what methods can be used against a\n        target device. For example, for EOS devices we need &gt; 4.14 to load configs; so if a\n        device is encountered at 4.13 the version check would raise an exception rather than\n        just failing in a potentially awkward fashion.\n\nReturns:\n    None\n\nRaises:\n    N/A\n</code></pre> Expand source code <pre>\n        <code>\nclass AsyncScrapliCfgIOSXE(AsyncScrapliCfgPlatform, ScrapliCfgIOSXEBase):\n    def __init__(\n        self,\n        conn: AsyncNetworkDriver,\n        *,\n        config_sources: Optional[List[str]] = None,\n        on_prepare: Optional[Callable[..., Any]] = None,\n        filesystem: str = \"flash:\",\n        cleanup_post_commit: bool = True,\n        dedicated_connection: bool = False,\n        ignore_version: bool = False,\n    ) -&gt; None:\n        if config_sources is None:\n            config_sources = CONFIG_SOURCES\n\n        super().__init__(\n            conn=conn,\n            config_sources=config_sources,\n            on_prepare=on_prepare,\n            dedicated_connection=dedicated_connection,\n            ignore_version=ignore_version,\n        )\n\n        self.filesystem = filesystem\n        self._filesystem_space_available_buffer_perc = 10\n\n        self._replace = False\n\n        self.candidate_config_filename = \"\"\n\n        self.cleanup_post_commit = cleanup_post_commit\n\n    async def _get_filesystem_space_available(self) -&gt; int:\n        \"\"\"\n        Abort a configuration -- discards any loaded config\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            FailedToDetermineDeviceState: if unable to fetch file filesystem bytes available\n\n        \"\"\"\n        filesystem_size_result = await self.conn.send_command(\n            command=f\"dir {self.filesystem} | i bytes\"\n        )\n        if filesystem_size_result.failed:\n            raise FailedToDetermineDeviceState(\"failed to determine space available on filesystem\")\n\n        return self._post_get_filesystem_space_available(output=filesystem_size_result.result)\n\n    async def _determine_file_prompt_mode(self) -&gt; FilePromptMode:\n        \"\"\"\n        Determine the device file prompt mode\n\n        Args:\n            N/A\n\n        Returns:\n            FilePromptMode: enum representing file prompt mode\n\n        Raises:\n            FailedToDetermineDeviceState: if unable to fetch file prompt mode\n\n        \"\"\"\n        file_prompt_mode_result = await self.conn.send_command(command=\"show run | i file prompt\")\n        if file_prompt_mode_result.failed:\n            raise FailedToDetermineDeviceState(\"failed to determine file prompt mode\")\n\n        return self._post_determine_file_prompt_mode(output=file_prompt_mode_result.result)\n\n    async def _delete_candidate_config(self) -&gt; Response:\n        \"\"\"\n        Delete candidate config from the filesystem\n\n        Args:\n            N/A\n\n        Returns:\n            Response: response from deleting the candidate config\n\n        Raises:\n            N/A\n\n        \"\"\"\n        # have to check again because the candidate config may have changed this!\n        file_prompt_mode = await self._determine_file_prompt_mode()\n        if file_prompt_mode in (FilePromptMode.ALERT, FilePromptMode.NOISY):\n            delete_events = [\n                (\n                    f\"delete {self.filesystem}{self.candidate_config_filename}\",\n                    \"Delete filename\",\n                ),\n                (\n                    \"\",\n                    \"[confirm]\",\n                ),\n                (\"\", \"\"),\n            ]\n        else:\n            delete_events = [\n                (f\"delete {self.filesystem}{self.candidate_config_filename}\", \"[confirm]\"),\n                (\"\", \"\"),\n            ]\n        delete_result = await self.conn.send_interactive(interact_events=delete_events)\n        return delete_result\n\n    async def get_version(self) -&gt; ScrapliCfgResponse:\n        response = self._pre_get_version()\n\n        version_result = await self.conn.send_command(command=\"show version | i Version\")\n\n        return self._post_get_version(\n            response=response,\n            scrapli_responses=[version_result],\n            result=self._parse_version(device_output=version_result.result),\n        )\n\n    async def get_config(self, source: str = \"running\") -&gt; ScrapliCfgResponse:\n        response = self._pre_get_config(source=source)\n\n        config_result = await self.conn.send_command(\n            command=self._get_config_command(source=source)\n        )\n\n        return self._post_get_config(\n            response=response,\n            source=source,\n            scrapli_responses=[config_result],\n            result=config_result.result,\n        )\n\n    async def load_config(\n        self, config: str, replace: bool = False, **kwargs: Any\n    ) -&gt; ScrapliCfgResponse:\n        \"\"\"\n        Load configuration to a device\n\n        Supported kwargs:\n            N/A\n\n        Args:\n            config: string of the configuration to load\n            replace: replace the configuration or not, if false configuration will be loaded as a\n                merge operation\n            kwargs: additional kwargs that the implementing classes may need for their platform,\n                see above for iosxe supported kwargs\n\n        Returns:\n            ScrapliCfgResponse: response object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        response = self._pre_load_config(config=config)\n\n        config = self._prepare_load_config(config=config, replace=replace)\n\n        filesystem_bytes_available = await self._get_filesystem_space_available()\n        self._space_available(filesystem_bytes_available=filesystem_bytes_available)\n\n        # when in tcl command mode or whatever it is, tcl wants \\r for return char, so stash the\n        # original return char and sub in \\r for a bit\n        original_return_char = self.conn.comms_return_char\n        tcl_comms_return_char = \"\\r\"\n\n        # pop into tclsh before swapping the return char just to be safe -- \\r or \\n should both be\n        # fine for up to here but who knows... :)\n        await self.conn.acquire_priv(desired_priv=\"tclsh\")\n        self.conn.comms_return_char = tcl_comms_return_char\n        config_result = await self.conn.send_config(config=config, privilege_level=\"tclsh\")\n\n        # reset the return char to the \"normal\" one and drop into whatever is the \"default\" priv\n        await self.conn.acquire_priv(desired_priv=self.conn.default_desired_privilege_level)\n        self.conn.comms_return_char = original_return_char\n\n        return self._post_load_config(\n            response=response,\n            scrapli_responses=[config_result],\n        )\n\n    async def abort_config(self) -&gt; ScrapliCfgResponse:\n        response = self._pre_abort_config(\n            session_or_config_file=bool(self.candidate_config_filename)\n        )\n\n        abort_result = await self._delete_candidate_config()\n        self._reset_config_session()\n\n        return self._post_abort_config(response=response, scrapli_responses=[abort_result])\n\n    async def save_config(self) -&gt; Response:\n        \"\"\"\n        Save the config -- \"copy run start\"!\n\n        Args:\n             N/A\n\n        Returns:\n            Response: scrapli response object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        # we always re-check file prompt mode because it could have changed!\n        file_prompt_mode = await self._determine_file_prompt_mode()\n\n        if file_prompt_mode == FilePromptMode.ALERT:\n            save_events = [\n                (\n                    \"copy running-config startup-config\",\n                    \"Destination filename\",\n                ),\n                (\"\", \"\"),\n            ]\n        elif file_prompt_mode == FilePromptMode.NOISY:\n            save_events = [\n                (\n                    \"copy running-config startup-config\",\n                    \"Source filename\",\n                ),\n                (\n                    \"\",\n                    \"Destination filename\",\n                ),\n                (\"\", \"\"),\n            ]\n        else:\n            save_events = [(\"copy running-config startup-config\", \"\")]\n\n        save_result = await self.conn.send_interactive(interact_events=save_events)\n        return save_result\n\n    async def _commit_config_merge(\n        self, file_prompt_mode: Optional[FilePromptMode] = None\n    ) -&gt; Response:\n        \"\"\"\n        Commit the configuration in merge mode\n\n        Args:\n             file_prompt_mode: optionally provide the file prompt mode, if its None we will fetch it\n                 to decide if we need to use interactive mode or not\n\n        Returns:\n            Response: scrapli response object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        if file_prompt_mode is None:\n            file_prompt_mode = await self._determine_file_prompt_mode()\n\n        if file_prompt_mode == FilePromptMode.ALERT:\n            merge_events = [\n                (\n                    f\"copy {self.filesystem}{self.candidate_config_filename} running-config\",\n                    \"Destination filename\",\n                ),\n                (\"\", \"\"),\n            ]\n        elif file_prompt_mode == FilePromptMode.NOISY:\n            merge_events = [\n                (\n                    f\"copy {self.filesystem}{self.candidate_config_filename} running-config\",\n                    \"Source filename\",\n                ),\n                (\n                    \"\",\n                    \"Destination filename\",\n                ),\n                (\"\", \"\"),\n            ]\n        else:\n            merge_events = [\n                (f\"copy {self.filesystem}{self.candidate_config_filename} running-config\", \"\")\n            ]\n\n        commit_result = await self.conn.send_interactive(interact_events=merge_events)\n        return commit_result\n\n    async def commit_config(self, source: str = \"running\") -&gt; ScrapliCfgResponse:\n        scrapli_responses = []\n        response = self._pre_commit_config(\n            source=source, session_or_config_file=bool(self.candidate_config_filename)\n        )\n\n        file_prompt_mode = await self._determine_file_prompt_mode()\n\n        if self._replace is True:\n            replace_command = (\n                f\"configure replace {self.filesystem}{self.candidate_config_filename} force\"\n            )\n            commit_result = await self.conn.send_command(command=replace_command)\n        else:\n            commit_result = await self._commit_config_merge(file_prompt_mode=file_prompt_mode)\n\n        scrapli_responses.append(commit_result)\n\n        save_config_result = await self.save_config()\n        scrapli_responses.append(save_config_result)\n\n        if self.cleanup_post_commit:\n            cleanup_result = await self._delete_candidate_config()\n            scrapli_responses.append(cleanup_result)\n\n        self._reset_config_session()\n\n        return self._post_load_config(\n            response=response,\n            scrapli_responses=scrapli_responses,\n        )\n\n    async def diff_config(self, source: str = \"running\") -&gt; ScrapliCfgDiffResponse:\n        scrapli_responses = []\n        device_diff = \"\"\n        source_config = \"\"\n\n        diff_response = self._pre_diff_config(\n            source=source, session_or_config_file=bool(self.candidate_config_filename)\n        )\n\n        try:\n            diff_result = await self.conn.send_command(\n                command=self._get_diff_command(source=source)\n            )\n            scrapli_responses.append(diff_result)\n            if diff_result.failed:\n                msg = \"failed generating diff for config session\"\n                self.logger.critical(msg)\n                raise DiffConfigError(msg)\n\n            device_diff = diff_result.result\n\n            source_config_result = await self.get_config(source=source)\n            source_config = source_config_result.result\n\n            if isinstance(source_config_result.scrapli_responses, list):\n                scrapli_responses.extend(source_config_result.scrapli_responses)\n\n            if source_config_result.failed:\n                msg = \"failed fetching source config for diff comparison\"\n                self.logger.critical(msg)\n                raise DiffConfigError(msg)\n\n        except DiffConfigError:\n            pass\n\n        return self._post_diff_config(\n            diff_response=diff_response,\n            scrapli_responses=scrapli_responses,\n            source_config=self.clean_config(source_config),\n            candidate_config=self.clean_config(self.candidate_config),\n            device_diff=device_diff,\n        )\n        </code>\n    </pre>"},{"location":"api_docs/platform/core/cisco_iosxe/async_platform/#ancestors-in-mro","title":"Ancestors (in MRO)","text":"<ul> <li>scrapli_cfg.platform.base.async_platform.AsyncScrapliCfgPlatform</li> <li>abc.ABC</li> <li>scrapli_cfg.platform.base.base_platform.ScrapliCfgBase</li> <li>scrapli_cfg.platform.core.cisco_iosxe.base_platform.ScrapliCfgIOSXEBase</li> </ul>"},{"location":"api_docs/platform/core/cisco_iosxe/async_platform/#class-variables","title":"Class variables","text":"<p><code>conn: Union[scrapli.driver.network.sync_driver.NetworkDriver,\u00a0scrapli.driver.network.async_driver.AsyncNetworkDriver]</code></p>"},{"location":"api_docs/platform/core/cisco_iosxe/async_platform/#methods","title":"Methods","text":""},{"location":"api_docs/platform/core/cisco_iosxe/async_platform/#load_config","title":"load_config","text":"<p><code>load_config(self, config:\u00a0str, replace:\u00a0bool\u00a0=\u00a0False, **kwargs:\u00a0Any) \u2011&gt; scrapli_cfg.response.ScrapliCfgResponse</code></p> <pre><code>Load configuration to a device\n\nSupported kwargs:\n    N/A\n\nArgs:\n    config: string of the configuration to load\n    replace: replace the configuration or not, if false configuration will be loaded as a\n        merge operation\n    kwargs: additional kwargs that the implementing classes may need for their platform,\n        see above for iosxe supported kwargs\n\nReturns:\n    ScrapliCfgResponse: response object\n\nRaises:\n    N/A\n</code></pre>"},{"location":"api_docs/platform/core/cisco_iosxe/async_platform/#save_config","title":"save_config","text":"<p><code>save_config(self) \u2011&gt; scrapli.response.Response</code></p> <pre><code>Save the config -- \"copy run start\"!\n\nArgs:\n     N/A\n\nReturns:\n    Response: scrapli response object\n\nRaises:\n    N/A\n</code></pre>"},{"location":"api_docs/platform/core/cisco_iosxe/base_platform/","title":"Base platform","text":"window.addEventListener('DOMContentLoaded', () =&gt; hljs.initHighlighting())"},{"location":"api_docs/platform/core/cisco_iosxe/base_platform/#module-scrapli_cfgplatformcorecisco_iosxebase_platform","title":"Module scrapli_cfg.platform.core.cisco_iosxe.base_platform","text":"<p>scrapli_cfg.platform.core.cisco_iosxe.base</p> Expand source code <pre>\n        <code>\n\"\"\"scrapli_cfg.platform.core.cisco_iosxe.base\"\"\"\nimport re\nfrom datetime import datetime\nfrom enum import Enum\nfrom logging import Logger, LoggerAdapter\nfrom typing import TYPE_CHECKING, Tuple\n\nfrom scrapli_cfg.exceptions import FailedToFetchSpaceAvailable, InsufficientSpaceAvailable\nfrom scrapli_cfg.helper import strip_blank_lines\nfrom scrapli_cfg.platform.core.cisco_iosxe.patterns import (\n    BYTES_FREE,\n    FILE_PROMPT_MODE,\n    OUTPUT_HEADER_PATTERN,\n    VERSION_PATTERN,\n)\n\nif TYPE_CHECKING:\n    LoggerAdapterT = LoggerAdapter[Logger]  # pylint:disable=E1136\nelse:\n    LoggerAdapterT = LoggerAdapter\n\n\nCONFIG_SOURCES = [\n    \"running\",\n    \"startup\",\n]\n\n\nclass FilePromptMode(Enum):\n    \"\"\"Enum representing file prompt modes\"\"\"\n\n    NOISY = \"noisy\"\n    ALERT = \"alert\"\n    QUIET = \"quiet\"\n\n\nclass ScrapliCfgIOSXEBase:\n    logger: LoggerAdapterT\n    candidate_config: str\n    candidate_config_filename: str\n    _replace: bool\n    filesystem: str\n    _filesystem_space_available_buffer_perc: int\n\n    def _post_get_filesystem_space_available(self, output: str) -&gt; int:\n        \"\"\"\n        Handle post \"get_filesystem_space_available\" operations for parity between sync and async\n\n        Args:\n            output: output that was fetched from the device\n\n        Returns:\n            int: bytes of space available on filesystem\n\n        Raises:\n            FailedToFetchSpaceAvailable: if could not determine space available... duh :)\n\n        \"\"\"\n        self.logger.info(\"determining space available from device output\")\n\n        bytes_available_match = re.search(pattern=BYTES_FREE, string=output)\n        if not bytes_available_match:\n            msg = \"could not determine space available on filesystem\"\n            self.logger.critical(msg)\n            raise FailedToFetchSpaceAvailable(msg)\n\n        return int(bytes_available_match.groupdict()[\"bytes_available\"])\n\n    def _space_available(self, filesystem_bytes_available: int) -&gt; None:\n        \"\"\"\n        Space available operations for parity between sync and async\n\n        It seems that on iosxe the length of the config is near enough 1:1 to the size it takes up\n        on the disk... so roll w/ that plus a bit of buffer based on the available buffer perc\n\n        Args:\n            filesystem_bytes_available: bytes available on filesystem\n\n        Returns:\n            None\n\n        Raises:\n            InsufficientSpaceAvailable: if... insufficient space available....\n\n        \"\"\"\n        if filesystem_bytes_available &lt; (\n            len(self.candidate_config) / (self._filesystem_space_available_buffer_perc / 100)\n        ) + len(self.candidate_config):\n            # filesystem has less than candidate config file size + 10% (by default) space, bail out\n            msg = (\n                f\"insufficient space available for candidate config + \"\n                f\"{self._filesystem_space_available_buffer_perc}% (buffer)\"\n            )\n            self.logger.critical(msg)\n            raise InsufficientSpaceAvailable(msg)\n\n    def _post_determine_file_prompt_mode(self, output: str) -&gt; FilePromptMode:\n        \"\"\"\n        Handle post \"determine_file_prompt_mode\" operations for parity between sync and async\n\n        Args:\n            output: output that was fetched from the device\n\n        Returns:\n            FilePromptMode: enum representing file prompt mode\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.logger.debug(\"determining file prompt mode from device output\")\n\n        file_prompt_match = re.search(pattern=FILE_PROMPT_MODE, string=output)\n        if not file_prompt_match:\n            return FilePromptMode.ALERT\n        prompt_mode = file_prompt_match.groupdict()[\"prompt_mode\"]\n        if prompt_mode == \"noisy\":\n            return FilePromptMode.NOISY\n        return FilePromptMode.QUIET\n\n    @staticmethod\n    def _parse_version(device_output: str) -&gt; str:\n        \"\"\"\n        Parse version string out of device output\n\n        Args:\n            device_output: output from show version command\n\n        Returns:\n            str: device version string\n\n        Raises:\n            N/A\n\n        \"\"\"\n        version_string_search = re.search(pattern=VERSION_PATTERN, string=device_output)\n\n        if not version_string_search:\n            return \"\"\n\n        version_string = version_string_search.group(0) or \"\"\n        return version_string\n\n    def clean_config(self, config: str) -&gt; str:\n        \"\"\"\n        Clean a configuration file of unwanted lines\n\n        Args:\n            config: configuration string to \"clean\"; cleaning removes lines that would prevent using\n                the provided configuration as a \"load_config\" source from working -- i.e. removes\n                the leading \"Building Configuration\" line\n\n        Returns:\n            str: cleaned configuration string\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.logger.debug(\"cleaning config file\")\n\n        return strip_blank_lines(\n            config=re.sub(pattern=OUTPUT_HEADER_PATTERN, string=config, repl=\"\", count=1)\n        )\n\n    def _reset_config_session(self) -&gt; None:\n        \"\"\"\n        Reset config session info\n\n        Resets the candidate config and config session name attributes -- when these are \"empty\" we\n        know there is no current config session\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.logger.debug(\"resetting candidate config and candidate config file name\")\n        self.candidate_config = \"\"\n        self.candidate_config_filename = \"\"\n\n    @staticmethod\n    def _get_config_command(source: str) -&gt; str:\n        \"\"\"\n        Return command to use to get config based on the provided source\n\n        Args:\n            source: name of the config source, generally running|startup\n\n        Returns:\n            str: command to use to fetch the requested config\n\n        Raises:\n            N/A\n\n        \"\"\"\n        if source == \"running\":\n            return \"show running-config\"\n        return \"show startup-config\"\n\n    def _get_diff_command(self, source: str) -&gt; str:\n        \"\"\"\n        Return command to use to get config diff based on the provided source\n\n        Args:\n            source: name of the config source, generally running|startup\n\n        Returns:\n            str: command to use to fetch the requested config\n\n        Raises:\n            N/A\n\n        \"\"\"\n        if self._replace:\n            return (\n                f\"show archive config differences system:{source}-config {self.filesystem}\"\n                f\"{self.candidate_config_filename}\"\n            )\n        return (\n            f\"show archive config incremental-diffs {self.filesystem}\"\n            f\"{self.candidate_config_filename} ignorecase\"\n        )\n\n    def _prepare_config_payloads(self, config: str) -&gt; str:\n        \"\"\"\n        Prepare a configuration so it can be nicely sent to the device via scrapli\n\n        Args:\n            config: configuration to prep\n\n        Returns:\n            str: string of config lines to write to candidate config file\n\n        Raises:\n            N/A\n\n        \"\"\"\n        tclsh_start_file = f'puts [open \"{self.filesystem}{self.candidate_config_filename}\" w+] {{'\n        tclsh_end_file = \"}\"\n        final_config = \"\\n\".join((tclsh_start_file, config, tclsh_end_file))\n\n        return final_config\n\n    def _prepare_load_config(self, config: str, replace: bool) -&gt; str:\n        \"\"\"\n        Handle pre \"load_config\" operations for parity between sync and async\n\n        Args:\n            config: candidate config to load\n            replace: True/False replace the configuration; passed here so it can be set at the class\n                level as we need to stay in config mode and we need to know if we are doing a merge\n                or a replace when we go to diff things\n\n        Returns:\n            str: string of config to write to candidate config file\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.candidate_config = config\n\n        if not self.candidate_config_filename:\n            self.candidate_config_filename = f\"scrapli_cfg_{round(datetime.now().timestamp())}\"\n            self.logger.debug(\n                f\"candidate config file name will be '{self.candidate_config_filename}'\"\n            )\n\n        config = self._prepare_config_payloads(config=config)\n        self._replace = replace\n\n        return config\n\n    def _normalize_source_candidate_configs(self, source_config: str) -&gt; Tuple[str, str]:\n        \"\"\"\n        Normalize candidate config and source config so that we can easily diff them\n\n        Args:\n            source_config: current config of the source config store\n\n        Returns:\n            ScrapliCfgDiff: scrapli cfg diff object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.logger.debug(\"normalizing source and candidate configs for diff object\")\n\n        # remove any of the leading timestamp/building config/config size/last change lines in\n        # both the source and candidate configs so they dont need to be compared\n        source_config = self.clean_config(config=source_config)\n        candidate_config = self.clean_config(config=self.candidate_config)\n\n        return source_config, candidate_config\n        </code>\n    </pre>"},{"location":"api_docs/platform/core/cisco_iosxe/base_platform/#classes","title":"Classes","text":""},{"location":"api_docs/platform/core/cisco_iosxe/base_platform/#filepromptmode","title":"FilePromptMode","text":"<pre><code>Enum representing file prompt modes\n</code></pre> Expand source code <pre>\n        <code>\nclass FilePromptMode(Enum):\n    \"\"\"Enum representing file prompt modes\"\"\"\n\n    NOISY = \"noisy\"\n    ALERT = \"alert\"\n    QUIET = \"quiet\"\n        </code>\n    </pre>"},{"location":"api_docs/platform/core/cisco_iosxe/base_platform/#ancestors-in-mro","title":"Ancestors (in MRO)","text":"<ul> <li>enum.Enum</li> </ul>"},{"location":"api_docs/platform/core/cisco_iosxe/base_platform/#class-variables","title":"Class variables","text":"<p><code>ALERT</code></p> <p><code>NOISY</code></p> <p><code>QUIET</code></p>"},{"location":"api_docs/platform/core/cisco_iosxe/base_platform/#scraplicfgiosxebase","title":"ScrapliCfgIOSXEBase","text":"Expand source code <pre>\n        <code>\nclass ScrapliCfgIOSXEBase:\n    logger: LoggerAdapterT\n    candidate_config: str\n    candidate_config_filename: str\n    _replace: bool\n    filesystem: str\n    _filesystem_space_available_buffer_perc: int\n\n    def _post_get_filesystem_space_available(self, output: str) -&gt; int:\n        \"\"\"\n        Handle post \"get_filesystem_space_available\" operations for parity between sync and async\n\n        Args:\n            output: output that was fetched from the device\n\n        Returns:\n            int: bytes of space available on filesystem\n\n        Raises:\n            FailedToFetchSpaceAvailable: if could not determine space available... duh :)\n\n        \"\"\"\n        self.logger.info(\"determining space available from device output\")\n\n        bytes_available_match = re.search(pattern=BYTES_FREE, string=output)\n        if not bytes_available_match:\n            msg = \"could not determine space available on filesystem\"\n            self.logger.critical(msg)\n            raise FailedToFetchSpaceAvailable(msg)\n\n        return int(bytes_available_match.groupdict()[\"bytes_available\"])\n\n    def _space_available(self, filesystem_bytes_available: int) -&gt; None:\n        \"\"\"\n        Space available operations for parity between sync and async\n\n        It seems that on iosxe the length of the config is near enough 1:1 to the size it takes up\n        on the disk... so roll w/ that plus a bit of buffer based on the available buffer perc\n\n        Args:\n            filesystem_bytes_available: bytes available on filesystem\n\n        Returns:\n            None\n\n        Raises:\n            InsufficientSpaceAvailable: if... insufficient space available....\n\n        \"\"\"\n        if filesystem_bytes_available &lt; (\n            len(self.candidate_config) / (self._filesystem_space_available_buffer_perc / 100)\n        ) + len(self.candidate_config):\n            # filesystem has less than candidate config file size + 10% (by default) space, bail out\n            msg = (\n                f\"insufficient space available for candidate config + \"\n                f\"{self._filesystem_space_available_buffer_perc}% (buffer)\"\n            )\n            self.logger.critical(msg)\n            raise InsufficientSpaceAvailable(msg)\n\n    def _post_determine_file_prompt_mode(self, output: str) -&gt; FilePromptMode:\n        \"\"\"\n        Handle post \"determine_file_prompt_mode\" operations for parity between sync and async\n\n        Args:\n            output: output that was fetched from the device\n\n        Returns:\n            FilePromptMode: enum representing file prompt mode\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.logger.debug(\"determining file prompt mode from device output\")\n\n        file_prompt_match = re.search(pattern=FILE_PROMPT_MODE, string=output)\n        if not file_prompt_match:\n            return FilePromptMode.ALERT\n        prompt_mode = file_prompt_match.groupdict()[\"prompt_mode\"]\n        if prompt_mode == \"noisy\":\n            return FilePromptMode.NOISY\n        return FilePromptMode.QUIET\n\n    @staticmethod\n    def _parse_version(device_output: str) -&gt; str:\n        \"\"\"\n        Parse version string out of device output\n\n        Args:\n            device_output: output from show version command\n\n        Returns:\n            str: device version string\n\n        Raises:\n            N/A\n\n        \"\"\"\n        version_string_search = re.search(pattern=VERSION_PATTERN, string=device_output)\n\n        if not version_string_search:\n            return \"\"\n\n        version_string = version_string_search.group(0) or \"\"\n        return version_string\n\n    def clean_config(self, config: str) -&gt; str:\n        \"\"\"\n        Clean a configuration file of unwanted lines\n\n        Args:\n            config: configuration string to \"clean\"; cleaning removes lines that would prevent using\n                the provided configuration as a \"load_config\" source from working -- i.e. removes\n                the leading \"Building Configuration\" line\n\n        Returns:\n            str: cleaned configuration string\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.logger.debug(\"cleaning config file\")\n\n        return strip_blank_lines(\n            config=re.sub(pattern=OUTPUT_HEADER_PATTERN, string=config, repl=\"\", count=1)\n        )\n\n    def _reset_config_session(self) -&gt; None:\n        \"\"\"\n        Reset config session info\n\n        Resets the candidate config and config session name attributes -- when these are \"empty\" we\n        know there is no current config session\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.logger.debug(\"resetting candidate config and candidate config file name\")\n        self.candidate_config = \"\"\n        self.candidate_config_filename = \"\"\n\n    @staticmethod\n    def _get_config_command(source: str) -&gt; str:\n        \"\"\"\n        Return command to use to get config based on the provided source\n\n        Args:\n            source: name of the config source, generally running|startup\n\n        Returns:\n            str: command to use to fetch the requested config\n\n        Raises:\n            N/A\n\n        \"\"\"\n        if source == \"running\":\n            return \"show running-config\"\n        return \"show startup-config\"\n\n    def _get_diff_command(self, source: str) -&gt; str:\n        \"\"\"\n        Return command to use to get config diff based on the provided source\n\n        Args:\n            source: name of the config source, generally running|startup\n\n        Returns:\n            str: command to use to fetch the requested config\n\n        Raises:\n            N/A\n\n        \"\"\"\n        if self._replace:\n            return (\n                f\"show archive config differences system:{source}-config {self.filesystem}\"\n                f\"{self.candidate_config_filename}\"\n            )\n        return (\n            f\"show archive config incremental-diffs {self.filesystem}\"\n            f\"{self.candidate_config_filename} ignorecase\"\n        )\n\n    def _prepare_config_payloads(self, config: str) -&gt; str:\n        \"\"\"\n        Prepare a configuration so it can be nicely sent to the device via scrapli\n\n        Args:\n            config: configuration to prep\n\n        Returns:\n            str: string of config lines to write to candidate config file\n\n        Raises:\n            N/A\n\n        \"\"\"\n        tclsh_start_file = f'puts [open \"{self.filesystem}{self.candidate_config_filename}\" w+] {{'\n        tclsh_end_file = \"}\"\n        final_config = \"\\n\".join((tclsh_start_file, config, tclsh_end_file))\n\n        return final_config\n\n    def _prepare_load_config(self, config: str, replace: bool) -&gt; str:\n        \"\"\"\n        Handle pre \"load_config\" operations for parity between sync and async\n\n        Args:\n            config: candidate config to load\n            replace: True/False replace the configuration; passed here so it can be set at the class\n                level as we need to stay in config mode and we need to know if we are doing a merge\n                or a replace when we go to diff things\n\n        Returns:\n            str: string of config to write to candidate config file\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.candidate_config = config\n\n        if not self.candidate_config_filename:\n            self.candidate_config_filename = f\"scrapli_cfg_{round(datetime.now().timestamp())}\"\n            self.logger.debug(\n                f\"candidate config file name will be '{self.candidate_config_filename}'\"\n            )\n\n        config = self._prepare_config_payloads(config=config)\n        self._replace = replace\n\n        return config\n\n    def _normalize_source_candidate_configs(self, source_config: str) -&gt; Tuple[str, str]:\n        \"\"\"\n        Normalize candidate config and source config so that we can easily diff them\n\n        Args:\n            source_config: current config of the source config store\n\n        Returns:\n            ScrapliCfgDiff: scrapli cfg diff object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.logger.debug(\"normalizing source and candidate configs for diff object\")\n\n        # remove any of the leading timestamp/building config/config size/last change lines in\n        # both the source and candidate configs so they dont need to be compared\n        source_config = self.clean_config(config=source_config)\n        candidate_config = self.clean_config(config=self.candidate_config)\n\n        return source_config, candidate_config\n        </code>\n    </pre>"},{"location":"api_docs/platform/core/cisco_iosxe/base_platform/#descendants","title":"Descendants","text":"<ul> <li>scrapli_cfg.platform.core.cisco_iosxe.async_platform.AsyncScrapliCfgIOSXE</li> <li>scrapli_cfg.platform.core.cisco_iosxe.sync_platform.ScrapliCfgIOSXE</li> </ul>"},{"location":"api_docs/platform/core/cisco_iosxe/base_platform/#class-variables_1","title":"Class variables","text":"<p><code>candidate_config: str</code></p> <p><code>candidate_config_filename: str</code></p> <p><code>filesystem: str</code></p> <p><code>logger: logging.LoggerAdapter</code></p>"},{"location":"api_docs/platform/core/cisco_iosxe/base_platform/#methods","title":"Methods","text":""},{"location":"api_docs/platform/core/cisco_iosxe/base_platform/#clean_config","title":"clean_config","text":"<p><code>clean_config(self, config:\u00a0str) \u2011&gt; str</code></p> <pre><code>Clean a configuration file of unwanted lines\n\nArgs:\n    config: configuration string to \"clean\"; cleaning removes lines that would prevent using\n        the provided configuration as a \"load_config\" source from working -- i.e. removes\n        the leading \"Building Configuration\" line\n\nReturns:\n    str: cleaned configuration string\n\nRaises:\n    N/A\n</code></pre>"},{"location":"api_docs/platform/core/cisco_iosxe/patterns/","title":"Patterns","text":"window.addEventListener('DOMContentLoaded', () =&gt; hljs.initHighlighting())"},{"location":"api_docs/platform/core/cisco_iosxe/patterns/#module-scrapli_cfgplatformcorecisco_iosxepatterns","title":"Module scrapli_cfg.platform.core.cisco_iosxe.patterns","text":"<p>scrapli_cfg.platform.core.cisco_iosxe.patterns</p> Expand source code <pre>\n        <code>\n\"\"\"scrapli_cfg.platform.core.cisco_iosxe.patterns\"\"\"\nimport re\n\nVERSION_PATTERN = re.compile(pattern=r\"\\d+\\.[a-z0-9\\(\\)\\.]+\", flags=re.I)\nBYTES_FREE = re.compile(pattern=r\"(?P\\d+)(?: bytes free)\", flags=re.I)\nFILE_PROMPT_MODE = re.compile(pattern=r\"(?:file prompt )(?P\\w+)\", flags=re.I)\n\nOUTPUT_HEADER_PATTERN = re.compile(\n    pattern=r\".*(?=(version \\d+\\.\\d+))\",\n    flags=re.I | re.S,\n)"},{"location":"api_docs/platform/core/cisco_iosxe/sync_platform/","title":"Sync Platform","text":"window.addEventListener('DOMContentLoaded', () =&gt; hljs.initHighlighting())"},{"location":"api_docs/platform/core/cisco_iosxe/sync_platform/#module-scrapli_cfgplatformcorecisco_iosxesync_platform","title":"Module scrapli_cfg.platform.core.cisco_iosxe.sync_platform","text":"<p>scrapli_cfg.platform.core.cisco_iosxe.sync_platform</p> Expand source code <pre>\n        <code>\n\"\"\"scrapli_cfg.platform.core.cisco_iosxe.sync_platform\"\"\"\nfrom typing import Any, Callable, List, Optional\n\nfrom scrapli.driver import NetworkDriver\nfrom scrapli.response import MultiResponse, Response\nfrom scrapli_cfg.diff import ScrapliCfgDiffResponse\nfrom scrapli_cfg.exceptions import DiffConfigError, FailedToDetermineDeviceState\nfrom scrapli_cfg.platform.base.sync_platform import ScrapliCfgPlatform\nfrom scrapli_cfg.platform.core.cisco_iosxe.base_platform import (\n    CONFIG_SOURCES,\n    FilePromptMode,\n    ScrapliCfgIOSXEBase,\n)\nfrom scrapli_cfg.response import ScrapliCfgResponse\n\n\nclass ScrapliCfgIOSXE(ScrapliCfgPlatform, ScrapliCfgIOSXEBase):\n    def __init__(\n        self,\n        conn: NetworkDriver,\n        *,\n        config_sources: Optional[List[str]] = None,\n        on_prepare: Optional[Callable[..., Any]] = None,\n        filesystem: str = \"flash:\",\n        cleanup_post_commit: bool = True,\n        dedicated_connection: bool = False,\n        ignore_version: bool = False,\n    ) -&gt; None:\n        if config_sources is None:\n            config_sources = CONFIG_SOURCES\n\n        super().__init__(\n            conn=conn,\n            config_sources=config_sources,\n            on_prepare=on_prepare,\n            dedicated_connection=dedicated_connection,\n            ignore_version=ignore_version,\n        )\n\n        self.filesystem = filesystem\n        self._filesystem_space_available_buffer_perc = 10\n\n        self._replace = False\n\n        self.candidate_config_filename = \"\"\n\n        self.cleanup_post_commit = cleanup_post_commit\n\n    def _get_filesystem_space_available(self) -&gt; int:\n        \"\"\"\n        Abort a configuration -- discards any loaded config\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            FailedToDetermineDeviceState: if unable to fetch file filesystem bytes available\n\n        \"\"\"\n        filesystem_size_result = self.conn.send_command(command=f\"dir {self.filesystem} | i bytes\")\n        if filesystem_size_result.failed:\n            raise FailedToDetermineDeviceState(\"failed to determine space available on filesystem\")\n\n        return self._post_get_filesystem_space_available(output=filesystem_size_result.result)\n\n    def _determine_file_prompt_mode(self) -&gt; FilePromptMode:\n        \"\"\"\n        Determine the device file prompt mode\n\n        Args:\n            N/A\n\n        Returns:\n            FilePromptMode: enum representing file prompt mode\n\n        Raises:\n            FailedToDetermineDeviceState: if unable to fetch file prompt mode\n\n        \"\"\"\n        file_prompt_mode_result = self.conn.send_command(command=\"show run | i file prompt\")\n        if file_prompt_mode_result.failed:\n            raise FailedToDetermineDeviceState(\"failed to determine file prompt mode\")\n\n        return self._post_determine_file_prompt_mode(output=file_prompt_mode_result.result)\n\n    def _delete_candidate_config(self) -&gt; Response:\n        \"\"\"\n        Delete candidate config from the filesystem\n\n        Args:\n            N/A\n\n        Returns:\n            Response: response from deleting the candidate config\n\n        Raises:\n            N/A\n\n        \"\"\"\n        # have to check again because the candidate config may have changed this!\n        file_prompt_mode = self._determine_file_prompt_mode()\n        if file_prompt_mode in (FilePromptMode.ALERT, FilePromptMode.NOISY):\n            delete_events = [\n                (\n                    f\"delete {self.filesystem}{self.candidate_config_filename}\",\n                    \"Delete filename\",\n                ),\n                (\n                    \"\",\n                    \"[confirm]\",\n                ),\n                (\"\", \"\"),\n            ]\n        else:\n            delete_events = [\n                (f\"delete {self.filesystem}{self.candidate_config_filename}\", \"[confirm]\"),\n                (\"\", \"\"),\n            ]\n        delete_result = self.conn.send_interactive(interact_events=delete_events)\n        return delete_result\n\n    def get_version(self) -&gt; ScrapliCfgResponse:\n        response = self._pre_get_version()\n\n        version_result = self.conn.send_command(command=\"show version | i Version\")\n\n        return self._post_get_version(\n            response=response,\n            scrapli_responses=[version_result],\n            result=self._parse_version(device_output=version_result.result),\n        )\n\n    def get_config(self, source: str = \"running\") -&gt; ScrapliCfgResponse:\n        response = self._pre_get_config(source=source)\n\n        config_result = self.conn.send_command(command=self._get_config_command(source=source))\n\n        return self._post_get_config(\n            response=response,\n            source=source,\n            scrapli_responses=[config_result],\n            result=config_result.result,\n        )\n\n    def load_config(self, config: str, replace: bool = False, **kwargs: Any) -&gt; ScrapliCfgResponse:\n        \"\"\"\n        Load configuration to a device\n\n        Supported kwargs:\n            auto_clean: automatically \"clean\" any data that would be in a configuration from a\n                \"get_config\" operation that would prevent loading a config -- for example, things\n                like the \"Building Configuration\" lines in IOSXE output, etc.. Defaults to `True`\n\n        Args:\n            config: string of the configuration to load\n            replace: replace the configuration or not, if false configuration will be loaded as a\n                merge operation\n            kwargs: additional kwargs that the implementing classes may need for their platform,\n                see above for iosxe supported kwargs\n\n        Returns:\n            ScrapliCfgResponse: response object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        if kwargs.get(\"auto_clean\", True) is True:\n            config = self.clean_config(config=config)\n\n        response = self._pre_load_config(config=config)\n\n        config = self._prepare_load_config(config=config, replace=replace)\n\n        filesystem_bytes_available = self._get_filesystem_space_available()\n        self._space_available(filesystem_bytes_available=filesystem_bytes_available)\n\n        # when in tcl command mode or whatever it is, tcl wants \\r for return char, so stash the\n        # original return char and sub in \\r for a bit\n        original_return_char = self.conn.comms_return_char\n        tcl_comms_return_char = \"\\r\"\n\n        # pop into tclsh before swapping the return char just to be safe -- \\r or \\n should both be\n        # fine for up to here but who knows... :)\n        self.conn.acquire_priv(desired_priv=\"tclsh\")\n        self.conn.comms_return_char = tcl_comms_return_char\n        config_result = self.conn.send_config(config=config, privilege_level=\"tclsh\")\n\n        # reset the return char to the \"normal\" one and drop into whatever is the \"default\" priv\n        self.conn.acquire_priv(desired_priv=self.conn.default_desired_privilege_level)\n        self.conn.comms_return_char = original_return_char\n\n        return self._post_load_config(\n            response=response,\n            scrapli_responses=[config_result],\n        )\n\n    def abort_config(self) -&gt; ScrapliCfgResponse:\n        response = self._pre_abort_config(\n            session_or_config_file=bool(self.candidate_config_filename)\n        )\n\n        abort_result = self._delete_candidate_config()\n        self._reset_config_session()\n\n        return self._post_abort_config(response=response, scrapli_responses=[abort_result])\n\n    def save_config(self) -&gt; Response:\n        \"\"\"\n        Save the config -- \"copy run start\"!\n\n        Args:\n             N/A\n\n        Returns:\n            Response: scrapli response object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        # we always re-check file prompt mode because it could have changed!\n        file_prompt_mode = self._determine_file_prompt_mode()\n\n        if file_prompt_mode == FilePromptMode.ALERT:\n            save_events = [\n                (\n                    \"copy running-config startup-config\",\n                    \"Destination filename\",\n                ),\n                (\"\", \"\"),\n            ]\n        elif file_prompt_mode == FilePromptMode.NOISY:\n            save_events = [\n                (\n                    \"copy running-config startup-config\",\n                    \"Source filename\",\n                ),\n                (\n                    \"\",\n                    \"Destination filename\",\n                ),\n                (\"\", \"\"),\n            ]\n        else:\n            save_events = [(\"copy running-config startup-config\", \"\")]\n\n        save_result = self.conn.send_interactive(interact_events=save_events)\n        return save_result\n\n    def _commit_config_merge(self, file_prompt_mode: Optional[FilePromptMode] = None) -&gt; Response:\n        \"\"\"\n        Commit the configuration in merge mode\n\n        Args:\n             file_prompt_mode: optionally provide the file prompt mode, if its None we will fetch it\n                 to decide if we need to use interactive mode or not\n\n        Returns:\n            Response: scrapli response object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        if file_prompt_mode is None:\n            file_prompt_mode = self._determine_file_prompt_mode()\n\n        if file_prompt_mode == FilePromptMode.ALERT:\n            merge_events = [\n                (\n                    f\"copy {self.filesystem}{self.candidate_config_filename} running-config\",\n                    \"Destination filename\",\n                ),\n                (\"\", \"\"),\n            ]\n        elif file_prompt_mode == FilePromptMode.NOISY:\n            merge_events = [\n                (\n                    f\"copy {self.filesystem}{self.candidate_config_filename} running-config\",\n                    \"Source filename\",\n                ),\n                (\n                    \"\",\n                    \"Destination filename\",\n                ),\n                (\"\", \"\"),\n            ]\n        else:\n            merge_events = [\n                (f\"copy {self.filesystem}{self.candidate_config_filename} running-config\", \"\")\n            ]\n\n        commit_result = self.conn.send_interactive(interact_events=merge_events)\n        return commit_result\n\n    def commit_config(self, source: str = \"running\") -&gt; ScrapliCfgResponse:\n        scrapli_responses = []\n        response = self._pre_commit_config(\n            source=source, session_or_config_file=bool(self.candidate_config_filename)\n        )\n\n        file_prompt_mode = self._determine_file_prompt_mode()\n\n        if self._replace is True:\n            replace_command = (\n                f\"configure replace {self.filesystem}{self.candidate_config_filename} force\"\n            )\n            commit_result = self.conn.send_command(command=replace_command)\n        else:\n            commit_result = self._commit_config_merge(file_prompt_mode=file_prompt_mode)\n\n        scrapli_responses.append(commit_result)\n\n        save_config_result = self.save_config()\n        scrapli_responses.append(save_config_result)\n\n        if self.cleanup_post_commit:\n            cleanup_result = self._delete_candidate_config()\n            scrapli_responses.append(cleanup_result)\n\n        self._reset_config_session()\n\n        return self._post_load_config(\n            response=response,\n            scrapli_responses=scrapli_responses,\n        )\n\n    def diff_config(self, source: str = \"running\") -&gt; ScrapliCfgDiffResponse:\n        scrapli_responses = []\n        device_diff = \"\"\n        source_config = \"\"\n\n        diff_response = self._pre_diff_config(\n            source=source, session_or_config_file=bool(self.candidate_config_filename)\n        )\n\n        try:\n            diff_result = self.conn.send_command(command=self._get_diff_command(source=source))\n            scrapli_responses.append(diff_result)\n            if diff_result.failed:\n                msg = \"failed generating diff for config session\"\n                self.logger.critical(msg)\n                raise DiffConfigError(msg)\n\n            device_diff = diff_result.result\n\n            source_config_result = self.get_config(source=source)\n            source_config = source_config_result.result\n\n            if isinstance(source_config_result.scrapli_responses, MultiResponse):\n                # in this case this will always be a multiresponse or nothing (failure) but mypy\n                # doesnt know that, hence the isinstance check\n                scrapli_responses.extend(source_config_result.scrapli_responses)\n\n            if source_config_result.failed:\n                msg = \"failed fetching source config for diff comparison\"\n                self.logger.critical(msg)\n                raise DiffConfigError(msg)\n\n        except DiffConfigError:\n            pass\n\n        return self._post_diff_config(\n            diff_response=diff_response,\n            scrapli_responses=scrapli_responses,\n            source_config=self.clean_config(source_config),\n            candidate_config=self.clean_config(self.candidate_config),\n            device_diff=device_diff,\n        )\n        </code>\n    </pre>"},{"location":"api_docs/platform/core/cisco_iosxe/sync_platform/#classes","title":"Classes","text":""},{"location":"api_docs/platform/core/cisco_iosxe/sync_platform/#scraplicfgiosxe","title":"ScrapliCfgIOSXE","text":"<pre><code>Helper class that provides a standard way to create an ABC using\ninheritance.\n\nScrapli Config base class\n\nArgs:\n    conn: scrapli connection to use\n    config_sources: list of config sources\n    on_prepare: optional callable to run at connection `prepare`\n    dedicated_connection: if `False` (default value) scrapli cfg will not open or close the\n        underlying scrapli connection and will raise an exception if the scrapli connection\n        is not open. If `True` will automatically open and close the scrapli connection when\n        using with a context manager, `prepare` will open the scrapli connection (if not\n        already open), and `close` will close the scrapli connection.\n    ignore_version: ignore checking device version support; currently this just means that\n        scrapli-cfg will not fetch the device version during the prepare phase, however this\n        will (hopefully) be used in the future to limit what methods can be used against a\n        target device. For example, for EOS devices we need &gt; 4.14 to load configs; so if a\n        device is encountered at 4.13 the version check would raise an exception rather than\n        just failing in a potentially awkward fashion.\n\nReturns:\n    None\n\nRaises:\n    N/A\n</code></pre> Expand source code <pre>\n        <code>\nclass ScrapliCfgIOSXE(ScrapliCfgPlatform, ScrapliCfgIOSXEBase):\n    def __init__(\n        self,\n        conn: NetworkDriver,\n        *,\n        config_sources: Optional[List[str]] = None,\n        on_prepare: Optional[Callable[..., Any]] = None,\n        filesystem: str = \"flash:\",\n        cleanup_post_commit: bool = True,\n        dedicated_connection: bool = False,\n        ignore_version: bool = False,\n    ) -&gt; None:\n        if config_sources is None:\n            config_sources = CONFIG_SOURCES\n\n        super().__init__(\n            conn=conn,\n            config_sources=config_sources,\n            on_prepare=on_prepare,\n            dedicated_connection=dedicated_connection,\n            ignore_version=ignore_version,\n        )\n\n        self.filesystem = filesystem\n        self._filesystem_space_available_buffer_perc = 10\n\n        self._replace = False\n\n        self.candidate_config_filename = \"\"\n\n        self.cleanup_post_commit = cleanup_post_commit\n\n    def _get_filesystem_space_available(self) -&gt; int:\n        \"\"\"\n        Abort a configuration -- discards any loaded config\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            FailedToDetermineDeviceState: if unable to fetch file filesystem bytes available\n\n        \"\"\"\n        filesystem_size_result = self.conn.send_command(command=f\"dir {self.filesystem} | i bytes\")\n        if filesystem_size_result.failed:\n            raise FailedToDetermineDeviceState(\"failed to determine space available on filesystem\")\n\n        return self._post_get_filesystem_space_available(output=filesystem_size_result.result)\n\n    def _determine_file_prompt_mode(self) -&gt; FilePromptMode:\n        \"\"\"\n        Determine the device file prompt mode\n\n        Args:\n            N/A\n\n        Returns:\n            FilePromptMode: enum representing file prompt mode\n\n        Raises:\n            FailedToDetermineDeviceState: if unable to fetch file prompt mode\n\n        \"\"\"\n        file_prompt_mode_result = self.conn.send_command(command=\"show run | i file prompt\")\n        if file_prompt_mode_result.failed:\n            raise FailedToDetermineDeviceState(\"failed to determine file prompt mode\")\n\n        return self._post_determine_file_prompt_mode(output=file_prompt_mode_result.result)\n\n    def _delete_candidate_config(self) -&gt; Response:\n        \"\"\"\n        Delete candidate config from the filesystem\n\n        Args:\n            N/A\n\n        Returns:\n            Response: response from deleting the candidate config\n\n        Raises:\n            N/A\n\n        \"\"\"\n        # have to check again because the candidate config may have changed this!\n        file_prompt_mode = self._determine_file_prompt_mode()\n        if file_prompt_mode in (FilePromptMode.ALERT, FilePromptMode.NOISY):\n            delete_events = [\n                (\n                    f\"delete {self.filesystem}{self.candidate_config_filename}\",\n                    \"Delete filename\",\n                ),\n                (\n                    \"\",\n                    \"[confirm]\",\n                ),\n                (\"\", \"\"),\n            ]\n        else:\n            delete_events = [\n                (f\"delete {self.filesystem}{self.candidate_config_filename}\", \"[confirm]\"),\n                (\"\", \"\"),\n            ]\n        delete_result = self.conn.send_interactive(interact_events=delete_events)\n        return delete_result\n\n    def get_version(self) -&gt; ScrapliCfgResponse:\n        response = self._pre_get_version()\n\n        version_result = self.conn.send_command(command=\"show version | i Version\")\n\n        return self._post_get_version(\n            response=response,\n            scrapli_responses=[version_result],\n            result=self._parse_version(device_output=version_result.result),\n        )\n\n    def get_config(self, source: str = \"running\") -&gt; ScrapliCfgResponse:\n        response = self._pre_get_config(source=source)\n\n        config_result = self.conn.send_command(command=self._get_config_command(source=source))\n\n        return self._post_get_config(\n            response=response,\n            source=source,\n            scrapli_responses=[config_result],\n            result=config_result.result,\n        )\n\n    def load_config(self, config: str, replace: bool = False, **kwargs: Any) -&gt; ScrapliCfgResponse:\n        \"\"\"\n        Load configuration to a device\n\n        Supported kwargs:\n            auto_clean: automatically \"clean\" any data that would be in a configuration from a\n                \"get_config\" operation that would prevent loading a config -- for example, things\n                like the \"Building Configuration\" lines in IOSXE output, etc.. Defaults to `True`\n\n        Args:\n            config: string of the configuration to load\n            replace: replace the configuration or not, if false configuration will be loaded as a\n                merge operation\n            kwargs: additional kwargs that the implementing classes may need for their platform,\n                see above for iosxe supported kwargs\n\n        Returns:\n            ScrapliCfgResponse: response object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        if kwargs.get(\"auto_clean\", True) is True:\n            config = self.clean_config(config=config)\n\n        response = self._pre_load_config(config=config)\n\n        config = self._prepare_load_config(config=config, replace=replace)\n\n        filesystem_bytes_available = self._get_filesystem_space_available()\n        self._space_available(filesystem_bytes_available=filesystem_bytes_available)\n\n        # when in tcl command mode or whatever it is, tcl wants \\r for return char, so stash the\n        # original return char and sub in \\r for a bit\n        original_return_char = self.conn.comms_return_char\n        tcl_comms_return_char = \"\\r\"\n\n        # pop into tclsh before swapping the return char just to be safe -- \\r or \\n should both be\n        # fine for up to here but who knows... :)\n        self.conn.acquire_priv(desired_priv=\"tclsh\")\n        self.conn.comms_return_char = tcl_comms_return_char\n        config_result = self.conn.send_config(config=config, privilege_level=\"tclsh\")\n\n        # reset the return char to the \"normal\" one and drop into whatever is the \"default\" priv\n        self.conn.acquire_priv(desired_priv=self.conn.default_desired_privilege_level)\n        self.conn.comms_return_char = original_return_char\n\n        return self._post_load_config(\n            response=response,\n            scrapli_responses=[config_result],\n        )\n\n    def abort_config(self) -&gt; ScrapliCfgResponse:\n        response = self._pre_abort_config(\n            session_or_config_file=bool(self.candidate_config_filename)\n        )\n\n        abort_result = self._delete_candidate_config()\n        self._reset_config_session()\n\n        return self._post_abort_config(response=response, scrapli_responses=[abort_result])\n\n    def save_config(self) -&gt; Response:\n        \"\"\"\n        Save the config -- \"copy run start\"!\n\n        Args:\n             N/A\n\n        Returns:\n            Response: scrapli response object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        # we always re-check file prompt mode because it could have changed!\n        file_prompt_mode = self._determine_file_prompt_mode()\n\n        if file_prompt_mode == FilePromptMode.ALERT:\n            save_events = [\n                (\n                    \"copy running-config startup-config\",\n                    \"Destination filename\",\n                ),\n                (\"\", \"\"),\n            ]\n        elif file_prompt_mode == FilePromptMode.NOISY:\n            save_events = [\n                (\n                    \"copy running-config startup-config\",\n                    \"Source filename\",\n                ),\n                (\n                    \"\",\n                    \"Destination filename\",\n                ),\n                (\"\", \"\"),\n            ]\n        else:\n            save_events = [(\"copy running-config startup-config\", \"\")]\n\n        save_result = self.conn.send_interactive(interact_events=save_events)\n        return save_result\n\n    def _commit_config_merge(self, file_prompt_mode: Optional[FilePromptMode] = None) -&gt; Response:\n        \"\"\"\n        Commit the configuration in merge mode\n\n        Args:\n             file_prompt_mode: optionally provide the file prompt mode, if its None we will fetch it\n                 to decide if we need to use interactive mode or not\n\n        Returns:\n            Response: scrapli response object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        if file_prompt_mode is None:\n            file_prompt_mode = self._determine_file_prompt_mode()\n\n        if file_prompt_mode == FilePromptMode.ALERT:\n            merge_events = [\n                (\n                    f\"copy {self.filesystem}{self.candidate_config_filename} running-config\",\n                    \"Destination filename\",\n                ),\n                (\"\", \"\"),\n            ]\n        elif file_prompt_mode == FilePromptMode.NOISY:\n            merge_events = [\n                (\n                    f\"copy {self.filesystem}{self.candidate_config_filename} running-config\",\n                    \"Source filename\",\n                ),\n                (\n                    \"\",\n                    \"Destination filename\",\n                ),\n                (\"\", \"\"),\n            ]\n        else:\n            merge_events = [\n                (f\"copy {self.filesystem}{self.candidate_config_filename} running-config\", \"\")\n            ]\n\n        commit_result = self.conn.send_interactive(interact_events=merge_events)\n        return commit_result\n\n    def commit_config(self, source: str = \"running\") -&gt; ScrapliCfgResponse:\n        scrapli_responses = []\n        response = self._pre_commit_config(\n            source=source, session_or_config_file=bool(self.candidate_config_filename)\n        )\n\n        file_prompt_mode = self._determine_file_prompt_mode()\n\n        if self._replace is True:\n            replace_command = (\n                f\"configure replace {self.filesystem}{self.candidate_config_filename} force\"\n            )\n            commit_result = self.conn.send_command(command=replace_command)\n        else:\n            commit_result = self._commit_config_merge(file_prompt_mode=file_prompt_mode)\n\n        scrapli_responses.append(commit_result)\n\n        save_config_result = self.save_config()\n        scrapli_responses.append(save_config_result)\n\n        if self.cleanup_post_commit:\n            cleanup_result = self._delete_candidate_config()\n            scrapli_responses.append(cleanup_result)\n\n        self._reset_config_session()\n\n        return self._post_load_config(\n            response=response,\n            scrapli_responses=scrapli_responses,\n        )\n\n    def diff_config(self, source: str = \"running\") -&gt; ScrapliCfgDiffResponse:\n        scrapli_responses = []\n        device_diff = \"\"\n        source_config = \"\"\n\n        diff_response = self._pre_diff_config(\n            source=source, session_or_config_file=bool(self.candidate_config_filename)\n        )\n\n        try:\n            diff_result = self.conn.send_command(command=self._get_diff_command(source=source))\n            scrapli_responses.append(diff_result)\n            if diff_result.failed:\n                msg = \"failed generating diff for config session\"\n                self.logger.critical(msg)\n                raise DiffConfigError(msg)\n\n            device_diff = diff_result.result\n\n            source_config_result = self.get_config(source=source)\n            source_config = source_config_result.result\n\n            if isinstance(source_config_result.scrapli_responses, MultiResponse):\n                # in this case this will always be a multiresponse or nothing (failure) but mypy\n                # doesnt know that, hence the isinstance check\n                scrapli_responses.extend(source_config_result.scrapli_responses)\n\n            if source_config_result.failed:\n                msg = \"failed fetching source config for diff comparison\"\n                self.logger.critical(msg)\n                raise DiffConfigError(msg)\n\n        except DiffConfigError:\n            pass\n\n        return self._post_diff_config(\n            diff_response=diff_response,\n            scrapli_responses=scrapli_responses,\n            source_config=self.clean_config(source_config),\n            candidate_config=self.clean_config(self.candidate_config),\n            device_diff=device_diff,\n        )\n        </code>\n    </pre>"},{"location":"api_docs/platform/core/cisco_iosxe/sync_platform/#ancestors-in-mro","title":"Ancestors (in MRO)","text":"<ul> <li>scrapli_cfg.platform.base.sync_platform.ScrapliCfgPlatform</li> <li>abc.ABC</li> <li>scrapli_cfg.platform.base.base_platform.ScrapliCfgBase</li> <li>scrapli_cfg.platform.core.cisco_iosxe.base_platform.ScrapliCfgIOSXEBase</li> </ul>"},{"location":"api_docs/platform/core/cisco_iosxe/sync_platform/#class-variables","title":"Class variables","text":"<p><code>conn: Union[scrapli.driver.network.sync_driver.NetworkDriver,\u00a0scrapli.driver.network.async_driver.AsyncNetworkDriver]</code></p>"},{"location":"api_docs/platform/core/cisco_iosxe/sync_platform/#methods","title":"Methods","text":""},{"location":"api_docs/platform/core/cisco_iosxe/sync_platform/#load_config","title":"load_config","text":"<p><code>load_config(self, config:\u00a0str, replace:\u00a0bool\u00a0=\u00a0False, **kwargs:\u00a0Any) \u2011&gt; scrapli_cfg.response.ScrapliCfgResponse</code></p> <pre><code>Load configuration to a device\n\nSupported kwargs:\n    auto_clean: automatically \"clean\" any data that would be in a configuration from a\n        \"get_config\" operation that would prevent loading a config -- for example, things\n        like the \"Building Configuration\" lines in IOSXE output, etc.. Defaults to `True`\n\nArgs:\n    config: string of the configuration to load\n    replace: replace the configuration or not, if false configuration will be loaded as a\n        merge operation\n    kwargs: additional kwargs that the implementing classes may need for their platform,\n        see above for iosxe supported kwargs\n\nReturns:\n    ScrapliCfgResponse: response object\n\nRaises:\n    N/A\n</code></pre>"},{"location":"api_docs/platform/core/cisco_iosxe/sync_platform/#save_config","title":"save_config","text":"<p><code>save_config(self) \u2011&gt; scrapli.response.Response</code></p> <pre><code>Save the config -- \"copy run start\"!\n\nArgs:\n     N/A\n\nReturns:\n    Response: scrapli response object\n\nRaises:\n    N/A\n</code></pre>"},{"location":"api_docs/platform/core/cisco_iosxe/types/","title":"Types","text":"window.addEventListener('DOMContentLoaded', () =&gt; hljs.initHighlighting())"},{"location":"api_docs/platform/core/cisco_iosxe/types/#module-scrapli_cfgplatformcorecisco_iosxetypes","title":"Module scrapli_cfg.platform.core.cisco_iosxe.types","text":"<p>scrapli_cfg.platform.core.cisco_iosxe.types</p> Expand source code <pre>\n        <code>\n\"\"\"scrapli_cfg.platform.core.cisco_iosxe.types\"\"\"\nfrom enum import Enum\n\n\nclass FilePromptMode(Enum):\n    \"\"\"Enum representing file prompt modes\"\"\"\n\n    NOISY = \"noisy\"\n    ALERT = \"alert\"\n    QUIET = \"quiet\"\n        </code>\n    </pre>"},{"location":"api_docs/platform/core/cisco_iosxe/types/#classes","title":"Classes","text":""},{"location":"api_docs/platform/core/cisco_iosxe/types/#filepromptmode","title":"FilePromptMode","text":"<pre><code>Enum representing file prompt modes\n</code></pre> Expand source code <pre>\n        <code>\nclass FilePromptMode(Enum):\n    \"\"\"Enum representing file prompt modes\"\"\"\n\n    NOISY = \"noisy\"\n    ALERT = \"alert\"\n    QUIET = \"quiet\"\n        </code>\n    </pre>"},{"location":"api_docs/platform/core/cisco_iosxe/types/#ancestors-in-mro","title":"Ancestors (in MRO)","text":"<ul> <li>enum.Enum</li> </ul>"},{"location":"api_docs/platform/core/cisco_iosxe/types/#class-variables","title":"Class variables","text":"<p><code>ALERT</code></p> <p><code>NOISY</code></p> <p><code>QUIET</code></p>"},{"location":"api_docs/platform/core/cisco_iosxr/async_platform/","title":"Async Platform","text":"window.addEventListener('DOMContentLoaded', () =&gt; hljs.initHighlighting())"},{"location":"api_docs/platform/core/cisco_iosxr/async_platform/#module-scrapli_cfgplatformcorecisco_iosxrasync_platform","title":"Module scrapli_cfg.platform.core.cisco_iosxr.async_platform","text":"<p>scrapli_cfg.platform.core.cisco_iosxr.async_platform</p> Expand source code <pre>\n        <code>\n\"\"\"scrapli_cfg.platform.core.cisco_iosxr.async_platform\"\"\"\nfrom typing import Any, Callable, List, Optional, Union\n\nfrom scrapli.driver import AsyncNetworkDriver\nfrom scrapli.response import MultiResponse, Response\nfrom scrapli_cfg.diff import ScrapliCfgDiffResponse\nfrom scrapli_cfg.exceptions import DiffConfigError, LoadConfigError\nfrom scrapli_cfg.platform.base.async_platform import AsyncScrapliCfgPlatform\nfrom scrapli_cfg.platform.core.cisco_iosxr.base_platform import CONFIG_SOURCES, ScrapliCfgIOSXRBase\nfrom scrapli_cfg.response import ScrapliCfgResponse\n\n\nclass AsyncScrapliCfgIOSXR(AsyncScrapliCfgPlatform, ScrapliCfgIOSXRBase):\n    def __init__(\n        self,\n        conn: AsyncNetworkDriver,\n        *,\n        config_sources: Optional[List[str]] = None,\n        on_prepare: Optional[Callable[..., Any]] = None,\n        dedicated_connection: bool = False,\n        ignore_version: bool = False,\n    ) -&gt; None:\n        if config_sources is None:\n            config_sources = CONFIG_SOURCES\n\n        super().__init__(\n            conn=conn,\n            config_sources=config_sources,\n            on_prepare=on_prepare,\n            dedicated_connection=dedicated_connection,\n            ignore_version=ignore_version,\n        )\n\n        self._replace = False\n\n        self._in_configuration_session = False\n        self._config_privilege_level = \"configuration\"\n\n    async def get_version(self) -&gt; ScrapliCfgResponse:\n        response = self._pre_get_version()\n\n        version_result = await self.conn.send_command(command=\"show version | i Version\")\n\n        return self._post_get_version(\n            response=response,\n            scrapli_responses=[version_result],\n            result=self._parse_version(device_output=version_result.result),\n        )\n\n    async def get_config(self, source: str = \"running\") -&gt; ScrapliCfgResponse:\n        response = self._pre_get_config(source=source)\n\n        if not self._in_configuration_session:\n            config_result = await self.conn.send_command(command=\"show running-config\")\n        else:\n            config_result = await self.conn.send_config(\n                config=\"show running-config\", privilege_level=self._config_privilege_level\n            )\n\n        return self._post_get_config(\n            response=response,\n            source=source,\n            scrapli_responses=[config_result],\n            result=config_result.result,\n        )\n\n    async def load_config(\n        self, config: str, replace: bool = False, **kwargs: Any\n    ) -&gt; ScrapliCfgResponse:\n        \"\"\"\n        Load configuration to a device\n\n        Supported kwargs:\n            exclusive: True/False use `configure exclusive` mode\n\n        Args:\n            config: string of the configuration to load\n            replace: replace the configuration or not, if false configuration will be loaded as a\n                merge operation\n            kwargs: additional kwargs that the implementing classes may need for their platform,\n                see above for iosxr supported kwargs\n\n        Returns:\n            ScrapliCfgResponse: response object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        scrapli_responses = []\n        response = self._pre_load_config(config=config)\n\n        exclusive = kwargs.get(\"exclusive\", False)\n\n        config, eager_config = self._prepare_load_config_session_and_payload(\n            config=config, replace=replace, exclusive=exclusive\n        )\n\n        try:\n            config_result = await self.conn.send_config(\n                config=config, privilege_level=self._config_privilege_level\n            )\n            scrapli_responses.append(config_result)\n            if config_result.failed:\n                msg = \"failed to load the candidate config into the config session\"\n                self.logger.critical(msg)\n                raise LoadConfigError(msg)\n\n            # eager cuz banners and such; perhaps if no banner/macro we can disable eager though....\n            if eager_config:\n                eager_config_result = await self.conn.send_config(\n                    config=eager_config, privilege_level=self._config_privilege_level, eager=True\n                )\n                scrapli_responses.append(eager_config_result)\n                if eager_config_result.failed:\n                    msg = \"failed to load the candidate config into the config session\"\n                    self.logger.critical(msg)\n                    raise LoadConfigError(msg)\n\n        except LoadConfigError:\n            pass\n\n        return self._post_load_config(\n            response=response,\n            scrapli_responses=scrapli_responses,\n        )\n\n    async def abort_config(self) -&gt; ScrapliCfgResponse:\n        response = self._pre_abort_config(session_or_config_file=self._in_configuration_session)\n\n        await self.conn._abort_config()  # pylint: disable=W0212\n        self._reset_config_session()\n\n        return self._post_abort_config(response=response, scrapli_responses=[])\n\n    async def commit_config(self, source: str = \"running\") -&gt; ScrapliCfgResponse:\n        scrapli_responses: List[Union[MultiResponse, Response]] = []\n        response = self._pre_commit_config(\n            source=source, session_or_config_file=self._in_configuration_session\n        )\n\n        if self._replace is True:\n            commit_events = [(\"commit replace\", \"proceed?\"), (\"yes\", \"\")]\n            commit_result = await self.conn.send_interactive(\n                interact_events=commit_events, privilege_level=self._config_privilege_level\n            )\n        else:\n            commit_result = await self.conn.send_config(config=\"commit\")\n\n        scrapli_responses.append(commit_result)\n        self._reset_config_session()\n\n        return self._post_commit_config(response=response, scrapli_responses=[commit_result])\n\n    async def diff_config(self, source: str = \"running\") -&gt; ScrapliCfgDiffResponse:\n        scrapli_responses = []\n        device_diff = \"\"\n        source_config = \"\"\n\n        diff_response = self._pre_diff_config(\n            source=source, session_or_config_file=self._in_configuration_session\n        )\n\n        try:\n            diff_result = await self.conn.send_config(\n                config=self._get_diff_command(), privilege_level=self._config_privilege_level\n            )\n            scrapli_responses.append(diff_result)\n            if diff_result.failed:\n                msg = \"failed generating diff for config session\"\n                self.logger.critical(msg)\n                raise DiffConfigError(msg)\n\n            device_diff = diff_result.result\n\n            source_config_result = await self.get_config(source=source)\n            source_config = source_config_result.result\n\n            if isinstance(source_config_result.scrapli_responses, MultiResponse):\n                # in this case this will always be a multiresponse or nothing (failure) but mypy\n                # doesnt know that, hence the isinstance check\n                scrapli_responses.extend(source_config_result.scrapli_responses)\n\n            if source_config_result.failed:\n                msg = \"failed fetching source config for diff comparison\"\n                self.logger.critical(msg)\n                raise DiffConfigError(msg)\n\n        except DiffConfigError:\n            pass\n\n        return self._post_diff_config(\n            diff_response=diff_response,\n            scrapli_responses=scrapli_responses,\n            source_config=self.clean_config(source_config),\n            candidate_config=self.clean_config(self.candidate_config),\n            device_diff=device_diff,\n        )\n        </code>\n    </pre>"},{"location":"api_docs/platform/core/cisco_iosxr/async_platform/#classes","title":"Classes","text":""},{"location":"api_docs/platform/core/cisco_iosxr/async_platform/#asyncscraplicfgiosxr","title":"AsyncScrapliCfgIOSXR","text":"<pre><code>Helper class that provides a standard way to create an ABC using\ninheritance.\n\nScrapli Config async base class\n\nArgs:\n    conn: scrapli connection to use\n    config_sources: list of config sources\n    on_prepare: optional callable to run at connection `prepare`\n    dedicated_connection: if `False` (default value) scrapli cfg will not open or close the\n        underlying scrapli connection and will raise an exception if the scrapli connection\n        is not open. If `True` will automatically open and close the scrapli connection when\n        using with a context manager, `prepare` will open the scrapli connection (if not\n        already open), and `close` will close the scrapli connection.\n    ignore_version: ignore checking device version support; currently this just means that\n        scrapli-cfg will not fetch the device version during the prepare phase, however this\n        will (hopefully) be used in the future to limit what methods can be used against a\n        target device. For example, for EOS devices we need &gt; 4.14 to load configs; so if a\n        device is encountered at 4.13 the version check would raise an exception rather than\n        just failing in a potentially awkward fashion.\n\nReturns:\n    None\n\nRaises:\n    N/A\n</code></pre> Expand source code <pre>\n        <code>\nclass AsyncScrapliCfgIOSXR(AsyncScrapliCfgPlatform, ScrapliCfgIOSXRBase):\n    def __init__(\n        self,\n        conn: AsyncNetworkDriver,\n        *,\n        config_sources: Optional[List[str]] = None,\n        on_prepare: Optional[Callable[..., Any]] = None,\n        dedicated_connection: bool = False,\n        ignore_version: bool = False,\n    ) -&gt; None:\n        if config_sources is None:\n            config_sources = CONFIG_SOURCES\n\n        super().__init__(\n            conn=conn,\n            config_sources=config_sources,\n            on_prepare=on_prepare,\n            dedicated_connection=dedicated_connection,\n            ignore_version=ignore_version,\n        )\n\n        self._replace = False\n\n        self._in_configuration_session = False\n        self._config_privilege_level = \"configuration\"\n\n    async def get_version(self) -&gt; ScrapliCfgResponse:\n        response = self._pre_get_version()\n\n        version_result = await self.conn.send_command(command=\"show version | i Version\")\n\n        return self._post_get_version(\n            response=response,\n            scrapli_responses=[version_result],\n            result=self._parse_version(device_output=version_result.result),\n        )\n\n    async def get_config(self, source: str = \"running\") -&gt; ScrapliCfgResponse:\n        response = self._pre_get_config(source=source)\n\n        if not self._in_configuration_session:\n            config_result = await self.conn.send_command(command=\"show running-config\")\n        else:\n            config_result = await self.conn.send_config(\n                config=\"show running-config\", privilege_level=self._config_privilege_level\n            )\n\n        return self._post_get_config(\n            response=response,\n            source=source,\n            scrapli_responses=[config_result],\n            result=config_result.result,\n        )\n\n    async def load_config(\n        self, config: str, replace: bool = False, **kwargs: Any\n    ) -&gt; ScrapliCfgResponse:\n        \"\"\"\n        Load configuration to a device\n\n        Supported kwargs:\n            exclusive: True/False use `configure exclusive` mode\n\n        Args:\n            config: string of the configuration to load\n            replace: replace the configuration or not, if false configuration will be loaded as a\n                merge operation\n            kwargs: additional kwargs that the implementing classes may need for their platform,\n                see above for iosxr supported kwargs\n\n        Returns:\n            ScrapliCfgResponse: response object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        scrapli_responses = []\n        response = self._pre_load_config(config=config)\n\n        exclusive = kwargs.get(\"exclusive\", False)\n\n        config, eager_config = self._prepare_load_config_session_and_payload(\n            config=config, replace=replace, exclusive=exclusive\n        )\n\n        try:\n            config_result = await self.conn.send_config(\n                config=config, privilege_level=self._config_privilege_level\n            )\n            scrapli_responses.append(config_result)\n            if config_result.failed:\n                msg = \"failed to load the candidate config into the config session\"\n                self.logger.critical(msg)\n                raise LoadConfigError(msg)\n\n            # eager cuz banners and such; perhaps if no banner/macro we can disable eager though....\n            if eager_config:\n                eager_config_result = await self.conn.send_config(\n                    config=eager_config, privilege_level=self._config_privilege_level, eager=True\n                )\n                scrapli_responses.append(eager_config_result)\n                if eager_config_result.failed:\n                    msg = \"failed to load the candidate config into the config session\"\n                    self.logger.critical(msg)\n                    raise LoadConfigError(msg)\n\n        except LoadConfigError:\n            pass\n\n        return self._post_load_config(\n            response=response,\n            scrapli_responses=scrapli_responses,\n        )\n\n    async def abort_config(self) -&gt; ScrapliCfgResponse:\n        response = self._pre_abort_config(session_or_config_file=self._in_configuration_session)\n\n        await self.conn._abort_config()  # pylint: disable=W0212\n        self._reset_config_session()\n\n        return self._post_abort_config(response=response, scrapli_responses=[])\n\n    async def commit_config(self, source: str = \"running\") -&gt; ScrapliCfgResponse:\n        scrapli_responses: List[Union[MultiResponse, Response]] = []\n        response = self._pre_commit_config(\n            source=source, session_or_config_file=self._in_configuration_session\n        )\n\n        if self._replace is True:\n            commit_events = [(\"commit replace\", \"proceed?\"), (\"yes\", \"\")]\n            commit_result = await self.conn.send_interactive(\n                interact_events=commit_events, privilege_level=self._config_privilege_level\n            )\n        else:\n            commit_result = await self.conn.send_config(config=\"commit\")\n\n        scrapli_responses.append(commit_result)\n        self._reset_config_session()\n\n        return self._post_commit_config(response=response, scrapli_responses=[commit_result])\n\n    async def diff_config(self, source: str = \"running\") -&gt; ScrapliCfgDiffResponse:\n        scrapli_responses = []\n        device_diff = \"\"\n        source_config = \"\"\n\n        diff_response = self._pre_diff_config(\n            source=source, session_or_config_file=self._in_configuration_session\n        )\n\n        try:\n            diff_result = await self.conn.send_config(\n                config=self._get_diff_command(), privilege_level=self._config_privilege_level\n            )\n            scrapli_responses.append(diff_result)\n            if diff_result.failed:\n                msg = \"failed generating diff for config session\"\n                self.logger.critical(msg)\n                raise DiffConfigError(msg)\n\n            device_diff = diff_result.result\n\n            source_config_result = await self.get_config(source=source)\n            source_config = source_config_result.result\n\n            if isinstance(source_config_result.scrapli_responses, MultiResponse):\n                # in this case this will always be a multiresponse or nothing (failure) but mypy\n                # doesnt know that, hence the isinstance check\n                scrapli_responses.extend(source_config_result.scrapli_responses)\n\n            if source_config_result.failed:\n                msg = \"failed fetching source config for diff comparison\"\n                self.logger.critical(msg)\n                raise DiffConfigError(msg)\n\n        except DiffConfigError:\n            pass\n\n        return self._post_diff_config(\n            diff_response=diff_response,\n            scrapli_responses=scrapli_responses,\n            source_config=self.clean_config(source_config),\n            candidate_config=self.clean_config(self.candidate_config),\n            device_diff=device_diff,\n        )\n        </code>\n    </pre>"},{"location":"api_docs/platform/core/cisco_iosxr/async_platform/#ancestors-in-mro","title":"Ancestors (in MRO)","text":"<ul> <li>scrapli_cfg.platform.base.async_platform.AsyncScrapliCfgPlatform</li> <li>abc.ABC</li> <li>scrapli_cfg.platform.base.base_platform.ScrapliCfgBase</li> <li>scrapli_cfg.platform.core.cisco_iosxr.base_platform.ScrapliCfgIOSXRBase</li> </ul>"},{"location":"api_docs/platform/core/cisco_iosxr/async_platform/#class-variables","title":"Class variables","text":"<p><code>conn: Union[scrapli.driver.network.sync_driver.NetworkDriver,\u00a0scrapli.driver.network.async_driver.AsyncNetworkDriver]</code></p>"},{"location":"api_docs/platform/core/cisco_iosxr/async_platform/#methods","title":"Methods","text":""},{"location":"api_docs/platform/core/cisco_iosxr/async_platform/#load_config","title":"load_config","text":"<p><code>load_config(self, config:\u00a0str, replace:\u00a0bool\u00a0=\u00a0False, **kwargs:\u00a0Any) \u2011&gt; scrapli_cfg.response.ScrapliCfgResponse</code></p> <pre><code>Load configuration to a device\n\nSupported kwargs:\n    exclusive: True/False use `configure exclusive` mode\n\nArgs:\n    config: string of the configuration to load\n    replace: replace the configuration or not, if false configuration will be loaded as a\n        merge operation\n    kwargs: additional kwargs that the implementing classes may need for their platform,\n        see above for iosxr supported kwargs\n\nReturns:\n    ScrapliCfgResponse: response object\n\nRaises:\n    N/A\n</code></pre>"},{"location":"api_docs/platform/core/cisco_iosxr/base_platform/","title":"Base platform","text":"window.addEventListener('DOMContentLoaded', () =&gt; hljs.initHighlighting())"},{"location":"api_docs/platform/core/cisco_iosxr/base_platform/#module-scrapli_cfgplatformcorecisco_iosxrbase_platform","title":"Module scrapli_cfg.platform.core.cisco_iosxr.base_platform","text":"<p>scrapli_cfg.platform.core.cisco_iosxr.base_platform</p> Expand source code <pre>\n        <code>\n\"\"\"scrapli_cfg.platform.core.cisco_iosxr.base_platform\"\"\"\nimport re\nfrom logging import Logger, LoggerAdapter\nfrom typing import TYPE_CHECKING, Tuple\n\nfrom scrapli_cfg.helper import strip_blank_lines\nfrom scrapli_cfg.platform.core.cisco_iosxr.patterns import (\n    BANNER_PATTERN,\n    END_PATTERN,\n    OUTPUT_HEADER_PATTERN,\n    VERSION_PATTERN,\n)\n\nif TYPE_CHECKING:\n    LoggerAdapterT = LoggerAdapter[Logger]  # pylint:disable=E1136\nelse:\n    LoggerAdapterT = LoggerAdapter\n\n\nCONFIG_SOURCES = [\n    \"running\",\n]\n\n\nclass ScrapliCfgIOSXRBase:\n    logger: LoggerAdapterT\n    _in_configuration_session: bool\n    _config_privilege_level: str\n    _replace: bool\n    candidate_config: str\n\n    @staticmethod\n    def _parse_version(device_output: str) -&gt; str:\n        \"\"\"\n        Parse version string out of device output\n\n        Args:\n            device_output: output from show version command\n\n        Returns:\n            str: device version string\n\n        Raises:\n            N/A\n\n        \"\"\"\n        version_string_search = re.search(pattern=VERSION_PATTERN, string=device_output)\n\n        if not version_string_search:\n            return \"\"\n\n        version_string = version_string_search.group(0) or \"\"\n        return version_string\n\n    @staticmethod\n    def _prepare_config_payloads(config: str) -&gt; Tuple[str, str]:\n        \"\"\"\n        Prepare a configuration so it can be nicely sent to the device via scrapli\n\n        Args:\n            config: configuration to prep\n\n        Returns:\n            tuple: tuple of \"normal\" config lines and \"eager\" config lines\n\n        Raises:\n            N/A\n\n        \"\"\"\n        # remove building config lines\n        config = re.sub(pattern=OUTPUT_HEADER_PATTERN, repl=\"!\", string=config)\n\n        # remove \"end\" at the end of config if present - if its present it will drop scrapli out\n        # of the config session which we do not want\n        config = re.sub(pattern=END_PATTERN, repl=\"!\", string=config)\n\n        # find all sections that need to be \"eagerly\" sent\n        eager_config = re.findall(pattern=BANNER_PATTERN, string=config)\n\n        for eager_section in eager_config:\n            # afaik cant backreference a non capturing group so we have an extra group per match\n            # that we ignore here (element 1)\n            config = config.replace(eager_section[0], \"!\")\n\n        joined_eager_config = \"\\n\".join(captured_section[0] for captured_section in eager_config)\n\n        return config, joined_eager_config\n\n    def _prepare_load_config_session_and_payload(\n        self, config: str, replace: bool, exclusive: bool\n    ) -&gt; Tuple[str, str]:\n        \"\"\"\n        Handle pre \"load_config\" operations for parity between sync and async\n\n        Args:\n            config: candidate config to load\n            replace: True/False replace the configuration; passed here so it can be set at the class\n                level as we need to stay in config mode and we need to know if we are doing a merge\n                or a replace when we go to diff things\n            exclusive: True/False use exclusive config mode\n\n        Returns:\n            tuple: tuple containing \"normal\" config elements to send to the device and \"eager\" mode\n                config elements to send to the device (things like banners/macro that require\n                scrapli \"eager=True\")\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.candidate_config = config\n        config, eager_config = self._prepare_config_payloads(config=config)\n\n        self._in_configuration_session = True\n        self._config_privilege_level = \"configuration_exclusive\" if exclusive else \"configuration\"\n        self._replace = replace\n\n        return config, eager_config\n\n    def _reset_config_session(self) -&gt; None:\n        \"\"\"\n        Reset config session info\n\n        Resets the candidate config and config session name attributes -- when these are \"empty\" we\n        know there is no current config session\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.logger.debug(\"resetting candidate config and config session name\")\n        self.candidate_config = \"\"\n        self._in_configuration_session = False\n        self._config_privilege_level = \"configuration\"\n\n    def _get_diff_command(self) -&gt; str:\n        \"\"\"\n        Generate diff command based on source to diff and filesystem/candidate config name\n\n        Args:\n            N/A\n\n        Returns:\n            str: command to use to diff the configuration\n\n        Raises:\n            N/A\n\n        \"\"\"\n        if self._replace:\n            return \"show configuration changes diff\"\n        return \"show commit changes diff\"\n\n    def clean_config(self, config: str) -&gt; str:\n        \"\"\"\n        Clean a configuration file of unwanted lines\n\n        Args:\n            config: configuration string to \"clean\"; cleaning removes leading timestamp/building\n                config/xr version/last change lines.\n\n        Returns:\n            str: cleaned configuration string\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.logger.debug(\"cleaning config file\")\n\n        # remove any of the leading timestamp/building config/xr version/last change lines in\n        # both the source and candidate configs so they dont need to be compared\n        return strip_blank_lines(\n            config=re.sub(pattern=OUTPUT_HEADER_PATTERN, string=config, repl=\"\")\n        )\n        </code>\n    </pre>"},{"location":"api_docs/platform/core/cisco_iosxr/base_platform/#classes","title":"Classes","text":""},{"location":"api_docs/platform/core/cisco_iosxr/base_platform/#scraplicfgiosxrbase","title":"ScrapliCfgIOSXRBase","text":"Expand source code <pre>\n        <code>\nclass ScrapliCfgIOSXRBase:\n    logger: LoggerAdapterT\n    _in_configuration_session: bool\n    _config_privilege_level: str\n    _replace: bool\n    candidate_config: str\n\n    @staticmethod\n    def _parse_version(device_output: str) -&gt; str:\n        \"\"\"\n        Parse version string out of device output\n\n        Args:\n            device_output: output from show version command\n\n        Returns:\n            str: device version string\n\n        Raises:\n            N/A\n\n        \"\"\"\n        version_string_search = re.search(pattern=VERSION_PATTERN, string=device_output)\n\n        if not version_string_search:\n            return \"\"\n\n        version_string = version_string_search.group(0) or \"\"\n        return version_string\n\n    @staticmethod\n    def _prepare_config_payloads(config: str) -&gt; Tuple[str, str]:\n        \"\"\"\n        Prepare a configuration so it can be nicely sent to the device via scrapli\n\n        Args:\n            config: configuration to prep\n\n        Returns:\n            tuple: tuple of \"normal\" config lines and \"eager\" config lines\n\n        Raises:\n            N/A\n\n        \"\"\"\n        # remove building config lines\n        config = re.sub(pattern=OUTPUT_HEADER_PATTERN, repl=\"!\", string=config)\n\n        # remove \"end\" at the end of config if present - if its present it will drop scrapli out\n        # of the config session which we do not want\n        config = re.sub(pattern=END_PATTERN, repl=\"!\", string=config)\n\n        # find all sections that need to be \"eagerly\" sent\n        eager_config = re.findall(pattern=BANNER_PATTERN, string=config)\n\n        for eager_section in eager_config:\n            # afaik cant backreference a non capturing group so we have an extra group per match\n            # that we ignore here (element 1)\n            config = config.replace(eager_section[0], \"!\")\n\n        joined_eager_config = \"\\n\".join(captured_section[0] for captured_section in eager_config)\n\n        return config, joined_eager_config\n\n    def _prepare_load_config_session_and_payload(\n        self, config: str, replace: bool, exclusive: bool\n    ) -&gt; Tuple[str, str]:\n        \"\"\"\n        Handle pre \"load_config\" operations for parity between sync and async\n\n        Args:\n            config: candidate config to load\n            replace: True/False replace the configuration; passed here so it can be set at the class\n                level as we need to stay in config mode and we need to know if we are doing a merge\n                or a replace when we go to diff things\n            exclusive: True/False use exclusive config mode\n\n        Returns:\n            tuple: tuple containing \"normal\" config elements to send to the device and \"eager\" mode\n                config elements to send to the device (things like banners/macro that require\n                scrapli \"eager=True\")\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.candidate_config = config\n        config, eager_config = self._prepare_config_payloads(config=config)\n\n        self._in_configuration_session = True\n        self._config_privilege_level = \"configuration_exclusive\" if exclusive else \"configuration\"\n        self._replace = replace\n\n        return config, eager_config\n\n    def _reset_config_session(self) -&gt; None:\n        \"\"\"\n        Reset config session info\n\n        Resets the candidate config and config session name attributes -- when these are \"empty\" we\n        know there is no current config session\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.logger.debug(\"resetting candidate config and config session name\")\n        self.candidate_config = \"\"\n        self._in_configuration_session = False\n        self._config_privilege_level = \"configuration\"\n\n    def _get_diff_command(self) -&gt; str:\n        \"\"\"\n        Generate diff command based on source to diff and filesystem/candidate config name\n\n        Args:\n            N/A\n\n        Returns:\n            str: command to use to diff the configuration\n\n        Raises:\n            N/A\n\n        \"\"\"\n        if self._replace:\n            return \"show configuration changes diff\"\n        return \"show commit changes diff\"\n\n    def clean_config(self, config: str) -&gt; str:\n        \"\"\"\n        Clean a configuration file of unwanted lines\n\n        Args:\n            config: configuration string to \"clean\"; cleaning removes leading timestamp/building\n                config/xr version/last change lines.\n\n        Returns:\n            str: cleaned configuration string\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.logger.debug(\"cleaning config file\")\n\n        # remove any of the leading timestamp/building config/xr version/last change lines in\n        # both the source and candidate configs so they dont need to be compared\n        return strip_blank_lines(\n            config=re.sub(pattern=OUTPUT_HEADER_PATTERN, string=config, repl=\"\")\n        )\n        </code>\n    </pre>"},{"location":"api_docs/platform/core/cisco_iosxr/base_platform/#descendants","title":"Descendants","text":"<ul> <li>scrapli_cfg.platform.core.cisco_iosxr.async_platform.AsyncScrapliCfgIOSXR</li> <li>scrapli_cfg.platform.core.cisco_iosxr.sync_platform.ScrapliCfgIOSXR</li> </ul>"},{"location":"api_docs/platform/core/cisco_iosxr/base_platform/#class-variables","title":"Class variables","text":"<p><code>candidate_config: str</code></p> <p><code>logger: logging.LoggerAdapter</code></p>"},{"location":"api_docs/platform/core/cisco_iosxr/base_platform/#methods","title":"Methods","text":""},{"location":"api_docs/platform/core/cisco_iosxr/base_platform/#clean_config","title":"clean_config","text":"<p><code>clean_config(self, config:\u00a0str) \u2011&gt; str</code></p> <pre><code>Clean a configuration file of unwanted lines\n\nArgs:\n    config: configuration string to \"clean\"; cleaning removes leading timestamp/building\n        config/xr version/last change lines.\n\nReturns:\n    str: cleaned configuration string\n\nRaises:\n    N/A\n</code></pre>"},{"location":"api_docs/platform/core/cisco_iosxr/patterns/","title":"Patterns","text":"window.addEventListener('DOMContentLoaded', () =&gt; hljs.initHighlighting())"},{"location":"api_docs/platform/core/cisco_iosxr/patterns/#module-scrapli_cfgplatformcorecisco_iosxrpatterns","title":"Module scrapli_cfg.platform.core.cisco_iosxr.patterns","text":"<p>scrapli_cfg.platform.core.cisco_iosxr.patterns</p> Expand source code <pre>\n        <code>\n\"\"\"scrapli_cfg.platform.core.cisco_iosxr.patterns\"\"\"\nimport re\n\nVERSION_PATTERN = re.compile(pattern=r\"\\d+\\.\\d+\\.\\d+\", flags=re.I)\nBANNER_PATTERN = re.compile(\n    pattern=r\"(^banner\\s(?:exec|incoming|login|motd|prompt-timeout|slip-ppp)\\s\"\n    r\"(?P.{1}).*(?P=delim)$)\",\n    flags=re.I | re.M | re.S,\n)\n\nTIMESTAMP_PATTERN = datetime_pattern = re.compile(\n    r\"^(mon|tue|wed|thu|fri|sat|sun)\\s+\"\n    r\"(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)\\s+\"\n    r\"\\d+\\s+\\d+:\\d+:\\d+((\\.\\d+\\s\\w+)|\\s\\d+)$\",\n    flags=re.M | re.I,\n)\nBUILD_CONFIG_PATTERN = re.compile(r\"(^building configuration\\.\\.\\.$)\", flags=re.I | re.M)\nCONFIG_VERSION_PATTERN = re.compile(r\"(^!! ios xr.*$)\", flags=re.I | re.M)\nCONFIG_CHANGE_PATTERN = re.compile(r\"(^!! last config.*$)\", flags=re.I | re.M)\nOUTPUT_HEADER_PATTERN = re.compile(\n    pattern=rf\"{TIMESTAMP_PATTERN.pattern}|\"\n    rf\"{BUILD_CONFIG_PATTERN.pattern}|\"\n    rf\"{CONFIG_VERSION_PATTERN.pattern}|\"\n    rf\"{CONFIG_CHANGE_PATTERN.pattern}\",\n    flags=re.I | re.M,\n)\n\nEND_PATTERN = re.compile(pattern=\"end$\")\n\n# pre-canned config section grabber patterns\n\n# match all ethernet interfaces w/ or w/out config items below them\nIOSXR_INTERFACES_PATTERN = r\"(?:Ethernet|GigabitEthernet|TenGigE|HundredGigE)\"\nETHERNET_INTERFACES = re.compile(\n    pattern=rf\"(^interface {IOSXR_INTERFACES_PATTERN}(?:\\d|\\/)+$(?:\\n^\\s{1}.*$)*\\n!\\n)+\",\n    flags=re.I | re.M,\n)\n# match mgmteth[numbers, letters, forward slashes] interface and config items below it\nMANAGEMENT_ONE_INTERFACE = re.compile(\n    pattern=r\"^^interface mgmteth(?:[a-z0-9\\/]+)(?:\\n^\\s.*$)*\\n!\", flags=re.I | re.M\n)"},{"location":"api_docs/platform/core/cisco_iosxr/sync_platform/","title":"Sync Platform","text":"window.addEventListener('DOMContentLoaded', () =&gt; hljs.initHighlighting())"},{"location":"api_docs/platform/core/cisco_iosxr/sync_platform/#module-scrapli_cfgplatformcorecisco_iosxrsync_platform","title":"Module scrapli_cfg.platform.core.cisco_iosxr.sync_platform","text":"<p>scrapli_cfg.platform.core.cisco_iosxr.sync_platform</p> Expand source code <pre>\n        <code>\n\"\"\"scrapli_cfg.platform.core.cisco_iosxr.sync_platform\"\"\"\nfrom typing import Any, Callable, List, Optional, Union\n\nfrom scrapli.driver import NetworkDriver\nfrom scrapli.response import MultiResponse, Response\nfrom scrapli_cfg.diff import ScrapliCfgDiffResponse\nfrom scrapli_cfg.exceptions import DiffConfigError, LoadConfigError\nfrom scrapli_cfg.platform.base.sync_platform import ScrapliCfgPlatform\nfrom scrapli_cfg.platform.core.cisco_iosxr.base_platform import CONFIG_SOURCES, ScrapliCfgIOSXRBase\nfrom scrapli_cfg.response import ScrapliCfgResponse\n\n\nclass ScrapliCfgIOSXR(ScrapliCfgPlatform, ScrapliCfgIOSXRBase):\n    def __init__(\n        self,\n        conn: NetworkDriver,\n        *,\n        config_sources: Optional[List[str]] = None,\n        on_prepare: Optional[Callable[..., Any]] = None,\n        dedicated_connection: bool = False,\n        ignore_version: bool = False,\n    ) -&gt; None:\n        if config_sources is None:\n            config_sources = CONFIG_SOURCES\n\n        super().__init__(\n            conn=conn,\n            config_sources=config_sources,\n            on_prepare=on_prepare,\n            dedicated_connection=dedicated_connection,\n            ignore_version=ignore_version,\n        )\n\n        self._replace = False\n\n        self._in_configuration_session = False\n        self._config_privilege_level = \"configuration\"\n\n    def get_version(self) -&gt; ScrapliCfgResponse:\n        response = self._pre_get_version()\n\n        version_result = self.conn.send_command(command=\"show version | i Version\")\n\n        return self._post_get_version(\n            response=response,\n            scrapli_responses=[version_result],\n            result=self._parse_version(device_output=version_result.result),\n        )\n\n    def get_config(self, source: str = \"running\") -&gt; ScrapliCfgResponse:\n        response = self._pre_get_config(source=source)\n\n        if not self._in_configuration_session:\n            config_result = self.conn.send_command(command=\"show running-config\")\n        else:\n            config_result = self.conn.send_config(\n                config=\"show running-config\", privilege_level=self._config_privilege_level\n            )\n\n        return self._post_get_config(\n            response=response,\n            source=source,\n            scrapli_responses=[config_result],\n            result=config_result.result,\n        )\n\n    def load_config(self, config: str, replace: bool = False, **kwargs: Any) -&gt; ScrapliCfgResponse:\n        \"\"\"\n        Load configuration to a device\n\n        Supported kwargs:\n            exclusive: True/False use `configure exclusive` mode\n\n        Args:\n            config: string of the configuration to load\n            replace: replace the configuration or not, if false configuration will be loaded as a\n                merge operation\n            kwargs: additional kwargs that the implementing classes may need for their platform,\n                see above for iosxr supported kwargs\n\n        Returns:\n            ScrapliCfgResponse: response object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        scrapli_responses = []\n        response = self._pre_load_config(config=config)\n\n        exclusive = kwargs.get(\"exclusive\", False)\n\n        config, eager_config = self._prepare_load_config_session_and_payload(\n            config=config, replace=replace, exclusive=exclusive\n        )\n\n        try:\n            config_result = self.conn.send_config(\n                config=config, privilege_level=self._config_privilege_level\n            )\n            scrapli_responses.append(config_result)\n            if config_result.failed:\n                msg = \"failed to load the candidate config into the config session\"\n                self.logger.critical(msg)\n                raise LoadConfigError(msg)\n\n            # eager cuz banners and such; perhaps if no banner/macro we can disable eager though....\n            if eager_config:\n                eager_config_result = self.conn.send_config(\n                    config=eager_config, privilege_level=self._config_privilege_level, eager=True\n                )\n                scrapli_responses.append(eager_config_result)\n                if eager_config_result.failed:\n                    msg = \"failed to load the candidate config into the config session\"\n                    self.logger.critical(msg)\n                    raise LoadConfigError(msg)\n\n        except LoadConfigError:\n            pass\n\n        return self._post_load_config(\n            response=response,\n            scrapli_responses=scrapli_responses,\n        )\n\n    def abort_config(self) -&gt; ScrapliCfgResponse:\n        response = self._pre_abort_config(session_or_config_file=self._in_configuration_session)\n\n        self.conn._abort_config()  # pylint: disable=W0212\n        self._reset_config_session()\n\n        return self._post_abort_config(response=response, scrapli_responses=[])\n\n    def commit_config(self, source: str = \"running\") -&gt; ScrapliCfgResponse:\n        scrapli_responses: List[Union[MultiResponse, Response]] = []\n        response = self._pre_commit_config(\n            source=source, session_or_config_file=self._in_configuration_session\n        )\n\n        if self._replace is True:\n            commit_events = [(\"commit replace\", \"proceed?\"), (\"yes\", \"\")]\n            commit_result = self.conn.send_interactive(\n                interact_events=commit_events, privilege_level=self._config_privilege_level\n            )\n        else:\n            commit_result = self.conn.send_config(config=\"commit\")\n\n        scrapli_responses.append(commit_result)\n        self._reset_config_session()\n\n        return self._post_commit_config(response=response, scrapli_responses=scrapli_responses)\n\n    def diff_config(self, source: str = \"running\") -&gt; ScrapliCfgDiffResponse:\n        scrapli_responses = []\n        device_diff = \"\"\n        source_config = \"\"\n\n        diff_response = self._pre_diff_config(\n            source=source, session_or_config_file=self._in_configuration_session\n        )\n\n        try:\n            diff_result = self.conn.send_config(\n                config=self._get_diff_command(), privilege_level=self._config_privilege_level\n            )\n            scrapli_responses.append(diff_result)\n            if diff_result.failed:\n                msg = \"failed generating diff for config session\"\n                self.logger.critical(msg)\n                raise DiffConfigError(msg)\n\n            device_diff = diff_result.result\n\n            source_config_result = self.get_config(source=source)\n            source_config = source_config_result.result\n\n            if isinstance(source_config_result.scrapli_responses, MultiResponse):\n                # in this case this will always be a multiresponse or nothing (failure) but mypy\n                # doesnt know that, hence the isinstance check\n                scrapli_responses.extend(source_config_result.scrapli_responses)\n\n            if source_config_result.failed:\n                msg = \"failed fetching source config for diff comparison\"\n                self.logger.critical(msg)\n                raise DiffConfigError(msg)\n\n        except DiffConfigError:\n            pass\n\n        return self._post_diff_config(\n            diff_response=diff_response,\n            scrapli_responses=scrapli_responses,\n            source_config=self.clean_config(source_config),\n            candidate_config=self.clean_config(self.candidate_config),\n            device_diff=device_diff,\n        )\n        </code>\n    </pre>"},{"location":"api_docs/platform/core/cisco_iosxr/sync_platform/#classes","title":"Classes","text":""},{"location":"api_docs/platform/core/cisco_iosxr/sync_platform/#scraplicfgiosxr","title":"ScrapliCfgIOSXR","text":"<pre><code>Helper class that provides a standard way to create an ABC using\ninheritance.\n\nScrapli Config base class\n\nArgs:\n    conn: scrapli connection to use\n    config_sources: list of config sources\n    on_prepare: optional callable to run at connection `prepare`\n    dedicated_connection: if `False` (default value) scrapli cfg will not open or close the\n        underlying scrapli connection and will raise an exception if the scrapli connection\n        is not open. If `True` will automatically open and close the scrapli connection when\n        using with a context manager, `prepare` will open the scrapli connection (if not\n        already open), and `close` will close the scrapli connection.\n    ignore_version: ignore checking device version support; currently this just means that\n        scrapli-cfg will not fetch the device version during the prepare phase, however this\n        will (hopefully) be used in the future to limit what methods can be used against a\n        target device. For example, for EOS devices we need &gt; 4.14 to load configs; so if a\n        device is encountered at 4.13 the version check would raise an exception rather than\n        just failing in a potentially awkward fashion.\n\nReturns:\n    None\n\nRaises:\n    N/A\n</code></pre> Expand source code <pre>\n        <code>\nclass ScrapliCfgIOSXR(ScrapliCfgPlatform, ScrapliCfgIOSXRBase):\n    def __init__(\n        self,\n        conn: NetworkDriver,\n        *,\n        config_sources: Optional[List[str]] = None,\n        on_prepare: Optional[Callable[..., Any]] = None,\n        dedicated_connection: bool = False,\n        ignore_version: bool = False,\n    ) -&gt; None:\n        if config_sources is None:\n            config_sources = CONFIG_SOURCES\n\n        super().__init__(\n            conn=conn,\n            config_sources=config_sources,\n            on_prepare=on_prepare,\n            dedicated_connection=dedicated_connection,\n            ignore_version=ignore_version,\n        )\n\n        self._replace = False\n\n        self._in_configuration_session = False\n        self._config_privilege_level = \"configuration\"\n\n    def get_version(self) -&gt; ScrapliCfgResponse:\n        response = self._pre_get_version()\n\n        version_result = self.conn.send_command(command=\"show version | i Version\")\n\n        return self._post_get_version(\n            response=response,\n            scrapli_responses=[version_result],\n            result=self._parse_version(device_output=version_result.result),\n        )\n\n    def get_config(self, source: str = \"running\") -&gt; ScrapliCfgResponse:\n        response = self._pre_get_config(source=source)\n\n        if not self._in_configuration_session:\n            config_result = self.conn.send_command(command=\"show running-config\")\n        else:\n            config_result = self.conn.send_config(\n                config=\"show running-config\", privilege_level=self._config_privilege_level\n            )\n\n        return self._post_get_config(\n            response=response,\n            source=source,\n            scrapli_responses=[config_result],\n            result=config_result.result,\n        )\n\n    def load_config(self, config: str, replace: bool = False, **kwargs: Any) -&gt; ScrapliCfgResponse:\n        \"\"\"\n        Load configuration to a device\n\n        Supported kwargs:\n            exclusive: True/False use `configure exclusive` mode\n\n        Args:\n            config: string of the configuration to load\n            replace: replace the configuration or not, if false configuration will be loaded as a\n                merge operation\n            kwargs: additional kwargs that the implementing classes may need for their platform,\n                see above for iosxr supported kwargs\n\n        Returns:\n            ScrapliCfgResponse: response object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        scrapli_responses = []\n        response = self._pre_load_config(config=config)\n\n        exclusive = kwargs.get(\"exclusive\", False)\n\n        config, eager_config = self._prepare_load_config_session_and_payload(\n            config=config, replace=replace, exclusive=exclusive\n        )\n\n        try:\n            config_result = self.conn.send_config(\n                config=config, privilege_level=self._config_privilege_level\n            )\n            scrapli_responses.append(config_result)\n            if config_result.failed:\n                msg = \"failed to load the candidate config into the config session\"\n                self.logger.critical(msg)\n                raise LoadConfigError(msg)\n\n            # eager cuz banners and such; perhaps if no banner/macro we can disable eager though....\n            if eager_config:\n                eager_config_result = self.conn.send_config(\n                    config=eager_config, privilege_level=self._config_privilege_level, eager=True\n                )\n                scrapli_responses.append(eager_config_result)\n                if eager_config_result.failed:\n                    msg = \"failed to load the candidate config into the config session\"\n                    self.logger.critical(msg)\n                    raise LoadConfigError(msg)\n\n        except LoadConfigError:\n            pass\n\n        return self._post_load_config(\n            response=response,\n            scrapli_responses=scrapli_responses,\n        )\n\n    def abort_config(self) -&gt; ScrapliCfgResponse:\n        response = self._pre_abort_config(session_or_config_file=self._in_configuration_session)\n\n        self.conn._abort_config()  # pylint: disable=W0212\n        self._reset_config_session()\n\n        return self._post_abort_config(response=response, scrapli_responses=[])\n\n    def commit_config(self, source: str = \"running\") -&gt; ScrapliCfgResponse:\n        scrapli_responses: List[Union[MultiResponse, Response]] = []\n        response = self._pre_commit_config(\n            source=source, session_or_config_file=self._in_configuration_session\n        )\n\n        if self._replace is True:\n            commit_events = [(\"commit replace\", \"proceed?\"), (\"yes\", \"\")]\n            commit_result = self.conn.send_interactive(\n                interact_events=commit_events, privilege_level=self._config_privilege_level\n            )\n        else:\n            commit_result = self.conn.send_config(config=\"commit\")\n\n        scrapli_responses.append(commit_result)\n        self._reset_config_session()\n\n        return self._post_commit_config(response=response, scrapli_responses=scrapli_responses)\n\n    def diff_config(self, source: str = \"running\") -&gt; ScrapliCfgDiffResponse:\n        scrapli_responses = []\n        device_diff = \"\"\n        source_config = \"\"\n\n        diff_response = self._pre_diff_config(\n            source=source, session_or_config_file=self._in_configuration_session\n        )\n\n        try:\n            diff_result = self.conn.send_config(\n                config=self._get_diff_command(), privilege_level=self._config_privilege_level\n            )\n            scrapli_responses.append(diff_result)\n            if diff_result.failed:\n                msg = \"failed generating diff for config session\"\n                self.logger.critical(msg)\n                raise DiffConfigError(msg)\n\n            device_diff = diff_result.result\n\n            source_config_result = self.get_config(source=source)\n            source_config = source_config_result.result\n\n            if isinstance(source_config_result.scrapli_responses, MultiResponse):\n                # in this case this will always be a multiresponse or nothing (failure) but mypy\n                # doesnt know that, hence the isinstance check\n                scrapli_responses.extend(source_config_result.scrapli_responses)\n\n            if source_config_result.failed:\n                msg = \"failed fetching source config for diff comparison\"\n                self.logger.critical(msg)\n                raise DiffConfigError(msg)\n\n        except DiffConfigError:\n            pass\n\n        return self._post_diff_config(\n            diff_response=diff_response,\n            scrapli_responses=scrapli_responses,\n            source_config=self.clean_config(source_config),\n            candidate_config=self.clean_config(self.candidate_config),\n            device_diff=device_diff,\n        )\n        </code>\n    </pre>"},{"location":"api_docs/platform/core/cisco_iosxr/sync_platform/#ancestors-in-mro","title":"Ancestors (in MRO)","text":"<ul> <li>scrapli_cfg.platform.base.sync_platform.ScrapliCfgPlatform</li> <li>abc.ABC</li> <li>scrapli_cfg.platform.base.base_platform.ScrapliCfgBase</li> <li>scrapli_cfg.platform.core.cisco_iosxr.base_platform.ScrapliCfgIOSXRBase</li> </ul>"},{"location":"api_docs/platform/core/cisco_iosxr/sync_platform/#class-variables","title":"Class variables","text":"<p><code>conn: Union[scrapli.driver.network.sync_driver.NetworkDriver,\u00a0scrapli.driver.network.async_driver.AsyncNetworkDriver]</code></p>"},{"location":"api_docs/platform/core/cisco_iosxr/sync_platform/#methods","title":"Methods","text":""},{"location":"api_docs/platform/core/cisco_iosxr/sync_platform/#load_config","title":"load_config","text":"<p><code>load_config(self, config:\u00a0str, replace:\u00a0bool\u00a0=\u00a0False, **kwargs:\u00a0Any) \u2011&gt; scrapli_cfg.response.ScrapliCfgResponse</code></p> <pre><code>Load configuration to a device\n\nSupported kwargs:\n    exclusive: True/False use `configure exclusive` mode\n\nArgs:\n    config: string of the configuration to load\n    replace: replace the configuration or not, if false configuration will be loaded as a\n        merge operation\n    kwargs: additional kwargs that the implementing classes may need for their platform,\n        see above for iosxr supported kwargs\n\nReturns:\n    ScrapliCfgResponse: response object\n\nRaises:\n    N/A\n</code></pre>"},{"location":"api_docs/platform/core/cisco_nxos/async_platform/","title":"Async Platform","text":"window.addEventListener('DOMContentLoaded', () =&gt; hljs.initHighlighting())"},{"location":"api_docs/platform/core/cisco_nxos/async_platform/#module-scrapli_cfgplatformcorecisco_nxosasync_platform","title":"Module scrapli_cfg.platform.core.cisco_nxos.async_platform","text":"<p>scrapli_cfg.platform.core.cisco_nxos.async_platform</p> Expand source code <pre>\n        <code>\n\"\"\"scrapli_cfg.platform.core.cisco_nxos.async_platform\"\"\"\nfrom typing import Any, Callable, List, Optional, Union\n\nfrom scrapli.driver.core import AsyncNXOSDriver\nfrom scrapli.response import MultiResponse, Response\nfrom scrapli_cfg.diff import ScrapliCfgDiffResponse\nfrom scrapli_cfg.exceptions import DiffConfigError, FailedToDetermineDeviceState\nfrom scrapli_cfg.platform.base.async_platform import AsyncScrapliCfgPlatform\nfrom scrapli_cfg.platform.core.cisco_nxos.base_platform import CONFIG_SOURCES, ScrapliCfgNXOSBase\nfrom scrapli_cfg.response import ScrapliCfgResponse\n\n\nclass AsyncScrapliCfgNXOS(AsyncScrapliCfgPlatform, ScrapliCfgNXOSBase):\n    def __init__(\n        self,\n        conn: AsyncNXOSDriver,\n        *,\n        config_sources: Optional[List[str]] = None,\n        on_prepare: Optional[Callable[..., Any]] = None,\n        filesystem: str = \"bootflash:\",\n        cleanup_post_commit: bool = True,\n        dedicated_connection: bool = False,\n        ignore_version: bool = False,\n    ) -&gt; None:\n        if config_sources is None:\n            config_sources = CONFIG_SOURCES\n\n        super().__init__(\n            conn=conn,\n            config_sources=config_sources,\n            on_prepare=on_prepare,\n            dedicated_connection=dedicated_connection,\n            ignore_version=ignore_version,\n        )\n\n        self.filesystem = filesystem\n        self._filesystem_space_available_buffer_perc = 10\n\n        self._replace = False\n\n        self.candidate_config_filename = \"\"\n\n        self.cleanup_post_commit = cleanup_post_commit\n\n    async def _get_filesystem_space_available(self) -&gt; int:\n        \"\"\"\n        Get available space on filesystem\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            FailedToDetermineDeviceState: if unable to fetch file filesystem bytes available\n\n        \"\"\"\n        filesystem_size_result = await self.conn.send_command(\n            command=f\"dir {self.filesystem} | i 'bytes free'\"\n        )\n        if filesystem_size_result.failed:\n            raise FailedToDetermineDeviceState(\"failed to determine space available on filesystem\")\n\n        return self._post_get_filesystem_space_available(output=filesystem_size_result.result)\n\n    async def _delete_candidate_config(self) -&gt; MultiResponse:\n        \"\"\"\n        Delete candidate config from the filesystem\n\n        Args:\n            N/A\n\n        Returns:\n            MultiResponse: response from deleting the candidate config\n\n        Raises:\n            N/A\n\n        \"\"\"\n        delete_commands = [\n            \"terminal dont-ask\",\n            f\"delete {self.filesystem}{self.candidate_config_filename}\",\n        ]\n        delete_result = await self.conn.send_commands(commands=delete_commands)\n        return delete_result\n\n    async def get_checkpoint(self) -&gt; ScrapliCfgResponse:\n        \"\"\"\n        Get device checkpoint file\n\n        Args:\n            N/A\n\n        Returns:\n            ScrapliCfgResponse: response object containing string of the target config source as the\n                `result` attribute\n\n        Raises:\n            N/A\n\n        \"\"\"\n        response, checkpoint_commands = self._pre_get_checkpoint(conn=self.conn)\n\n        checkpoint_results = await self.conn.send_commands(commands=checkpoint_commands)\n\n        try:\n            checkpoint: str = checkpoint_results[2].result\n        except IndexError:\n            checkpoint = \"\"\n\n        return self._post_get_config(\n            response=response,\n            source=\"running\",\n            scrapli_responses=[checkpoint_results],\n            result=checkpoint,\n        )\n\n    async def get_version(self) -&gt; ScrapliCfgResponse:\n        response = self._pre_get_version()\n\n        version_result = await self.conn.send_command(command='show version | i \"NXOS: version\"')\n\n        return self._post_get_version(\n            response=response,\n            scrapli_responses=[version_result],\n            result=self._parse_version(device_output=version_result.result),\n        )\n\n    async def get_config(self, source: str = \"running\") -&gt; ScrapliCfgResponse:\n        response = self._pre_get_config(source=source)\n\n        config_result = await self.conn.send_command(\n            command=self._get_config_command(source=source)\n        )\n\n        return self._post_get_config(\n            response=response,\n            source=source,\n            scrapli_responses=[config_result],\n            result=config_result.result,\n        )\n\n    async def load_config(\n        self, config: str, replace: bool = False, **kwargs: Any\n    ) -&gt; ScrapliCfgResponse:\n        \"\"\"\n        Load configuration to a device\n\n        Supported kwargs:\n            N/A\n\n        Args:\n            config: string of the configuration to load\n            replace: replace the configuration or not, if false configuration will be loaded as a\n                merge operation\n            kwargs: additional kwargs that the implementing classes may need for their platform,\n                see above for nxos supported kwargs\n\n        Returns:\n            ScrapliCfgResponse: response object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        response = self._pre_load_config(config=config)\n\n        config = self._prepare_load_config(config=config, replace=replace)\n\n        filesystem_bytes_available = await self._get_filesystem_space_available()\n        self._space_available(filesystem_bytes_available=filesystem_bytes_available)\n\n        await self.conn.acquire_priv(desired_priv=\"tclsh\")\n        config_result = await self.conn.send_config(config=config, privilege_level=\"tclsh\")\n        await self.conn.acquire_priv(desired_priv=self.conn.default_desired_privilege_level)\n\n        return self._post_load_config(\n            response=response,\n            scrapli_responses=[config_result],\n        )\n\n    async def abort_config(self) -&gt; ScrapliCfgResponse:\n        response = self._pre_abort_config(\n            session_or_config_file=bool(self.candidate_config_filename)\n        )\n\n        abort_result = await self._delete_candidate_config()\n        self._reset_config_session()\n\n        return self._post_abort_config(response=response, scrapli_responses=[abort_result])\n\n    async def commit_config(self, source: str = \"running\") -&gt; ScrapliCfgResponse:\n        scrapli_responses: List[Union[MultiResponse, Response]] = []\n        response = self._pre_commit_config(\n            source=source, session_or_config_file=bool(self.candidate_config_filename)\n        )\n\n        if self._replace is True:\n            replace_command = (\n                f\"rollback running-config file {self.filesystem}{self.candidate_config_filename}\"\n            )\n            commit_result = await self.conn.send_command(command=replace_command)\n        else:\n            merge_command = f\"copy {self.filesystem}{self.candidate_config_filename} running-config\"\n            commit_result = await self.conn.send_command(command=merge_command)\n\n        scrapli_responses.append(commit_result)\n\n        save_config_result = await self.conn.send_command(\n            command=\"copy running-config startup-config\"\n        )\n        scrapli_responses.append(save_config_result)\n\n        if self.cleanup_post_commit:\n            cleanup_result = await self._delete_candidate_config()\n            scrapli_responses.append(cleanup_result)\n\n        self._reset_config_session()\n\n        return self._post_commit_config(\n            response=response,\n            scrapli_responses=scrapli_responses,\n        )\n\n    async def diff_config(self, source: str = \"running\") -&gt; ScrapliCfgDiffResponse:\n        scrapli_responses = []\n        device_diff = \"\"\n        source_config = \"\"\n\n        diff_response = self._pre_diff_config(\n            source=source, session_or_config_file=bool(self.candidate_config_filename)\n        )\n\n        try:\n            diff_command = self._get_diff_command(source=source)\n\n            if diff_command:\n                diff_result = await self.conn.send_command(command=diff_command)\n                scrapli_responses.append(diff_result)\n                if diff_result.failed:\n                    msg = \"failed generating diff for config session\"\n                    self.logger.critical(msg)\n                    raise DiffConfigError(msg)\n                device_diff = diff_result.result\n            else:\n                device_diff = \"\"\n\n            source_config_result = await self.get_config(source=source)\n            source_config = source_config_result.result\n\n            if isinstance(source_config_result.scrapli_responses, MultiResponse):\n                # in this case this will always be a multiresponse or nothing (failure) but mypy\n                # doesnt know that, hence the isinstance check\n                scrapli_responses.extend(source_config_result.scrapli_responses)\n\n            if source_config_result.failed:\n                msg = \"failed fetching source config for diff comparison\"\n                self.logger.critical(msg)\n                raise DiffConfigError(msg)\n\n        except DiffConfigError:\n            pass\n\n        return self._post_diff_config(\n            diff_response=diff_response,\n            scrapli_responses=scrapli_responses,\n            source_config=self.clean_config(source_config),\n            candidate_config=self.clean_config(self.candidate_config),\n            device_diff=device_diff,\n        )\n        </code>\n    </pre>"},{"location":"api_docs/platform/core/cisco_nxos/async_platform/#classes","title":"Classes","text":""},{"location":"api_docs/platform/core/cisco_nxos/async_platform/#asyncscraplicfgnxos","title":"AsyncScrapliCfgNXOS","text":"<pre><code>Helper class that provides a standard way to create an ABC using\ninheritance.\n\nScrapli Config async base class\n\nArgs:\n    conn: scrapli connection to use\n    config_sources: list of config sources\n    on_prepare: optional callable to run at connection `prepare`\n    dedicated_connection: if `False` (default value) scrapli cfg will not open or close the\n        underlying scrapli connection and will raise an exception if the scrapli connection\n        is not open. If `True` will automatically open and close the scrapli connection when\n        using with a context manager, `prepare` will open the scrapli connection (if not\n        already open), and `close` will close the scrapli connection.\n    ignore_version: ignore checking device version support; currently this just means that\n        scrapli-cfg will not fetch the device version during the prepare phase, however this\n        will (hopefully) be used in the future to limit what methods can be used against a\n        target device. For example, for EOS devices we need &gt; 4.14 to load configs; so if a\n        device is encountered at 4.13 the version check would raise an exception rather than\n        just failing in a potentially awkward fashion.\n\nReturns:\n    None\n\nRaises:\n    N/A\n</code></pre> Expand source code <pre>\n        <code>\nclass AsyncScrapliCfgNXOS(AsyncScrapliCfgPlatform, ScrapliCfgNXOSBase):\n    def __init__(\n        self,\n        conn: AsyncNXOSDriver,\n        *,\n        config_sources: Optional[List[str]] = None,\n        on_prepare: Optional[Callable[..., Any]] = None,\n        filesystem: str = \"bootflash:\",\n        cleanup_post_commit: bool = True,\n        dedicated_connection: bool = False,\n        ignore_version: bool = False,\n    ) -&gt; None:\n        if config_sources is None:\n            config_sources = CONFIG_SOURCES\n\n        super().__init__(\n            conn=conn,\n            config_sources=config_sources,\n            on_prepare=on_prepare,\n            dedicated_connection=dedicated_connection,\n            ignore_version=ignore_version,\n        )\n\n        self.filesystem = filesystem\n        self._filesystem_space_available_buffer_perc = 10\n\n        self._replace = False\n\n        self.candidate_config_filename = \"\"\n\n        self.cleanup_post_commit = cleanup_post_commit\n\n    async def _get_filesystem_space_available(self) -&gt; int:\n        \"\"\"\n        Get available space on filesystem\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            FailedToDetermineDeviceState: if unable to fetch file filesystem bytes available\n\n        \"\"\"\n        filesystem_size_result = await self.conn.send_command(\n            command=f\"dir {self.filesystem} | i 'bytes free'\"\n        )\n        if filesystem_size_result.failed:\n            raise FailedToDetermineDeviceState(\"failed to determine space available on filesystem\")\n\n        return self._post_get_filesystem_space_available(output=filesystem_size_result.result)\n\n    async def _delete_candidate_config(self) -&gt; MultiResponse:\n        \"\"\"\n        Delete candidate config from the filesystem\n\n        Args:\n            N/A\n\n        Returns:\n            MultiResponse: response from deleting the candidate config\n\n        Raises:\n            N/A\n\n        \"\"\"\n        delete_commands = [\n            \"terminal dont-ask\",\n            f\"delete {self.filesystem}{self.candidate_config_filename}\",\n        ]\n        delete_result = await self.conn.send_commands(commands=delete_commands)\n        return delete_result\n\n    async def get_checkpoint(self) -&gt; ScrapliCfgResponse:\n        \"\"\"\n        Get device checkpoint file\n\n        Args:\n            N/A\n\n        Returns:\n            ScrapliCfgResponse: response object containing string of the target config source as the\n                `result` attribute\n\n        Raises:\n            N/A\n\n        \"\"\"\n        response, checkpoint_commands = self._pre_get_checkpoint(conn=self.conn)\n\n        checkpoint_results = await self.conn.send_commands(commands=checkpoint_commands)\n\n        try:\n            checkpoint: str = checkpoint_results[2].result\n        except IndexError:\n            checkpoint = \"\"\n\n        return self._post_get_config(\n            response=response,\n            source=\"running\",\n            scrapli_responses=[checkpoint_results],\n            result=checkpoint,\n        )\n\n    async def get_version(self) -&gt; ScrapliCfgResponse:\n        response = self._pre_get_version()\n\n        version_result = await self.conn.send_command(command='show version | i \"NXOS: version\"')\n\n        return self._post_get_version(\n            response=response,\n            scrapli_responses=[version_result],\n            result=self._parse_version(device_output=version_result.result),\n        )\n\n    async def get_config(self, source: str = \"running\") -&gt; ScrapliCfgResponse:\n        response = self._pre_get_config(source=source)\n\n        config_result = await self.conn.send_command(\n            command=self._get_config_command(source=source)\n        )\n\n        return self._post_get_config(\n            response=response,\n            source=source,\n            scrapli_responses=[config_result],\n            result=config_result.result,\n        )\n\n    async def load_config(\n        self, config: str, replace: bool = False, **kwargs: Any\n    ) -&gt; ScrapliCfgResponse:\n        \"\"\"\n        Load configuration to a device\n\n        Supported kwargs:\n            N/A\n\n        Args:\n            config: string of the configuration to load\n            replace: replace the configuration or not, if false configuration will be loaded as a\n                merge operation\n            kwargs: additional kwargs that the implementing classes may need for their platform,\n                see above for nxos supported kwargs\n\n        Returns:\n            ScrapliCfgResponse: response object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        response = self._pre_load_config(config=config)\n\n        config = self._prepare_load_config(config=config, replace=replace)\n\n        filesystem_bytes_available = await self._get_filesystem_space_available()\n        self._space_available(filesystem_bytes_available=filesystem_bytes_available)\n\n        await self.conn.acquire_priv(desired_priv=\"tclsh\")\n        config_result = await self.conn.send_config(config=config, privilege_level=\"tclsh\")\n        await self.conn.acquire_priv(desired_priv=self.conn.default_desired_privilege_level)\n\n        return self._post_load_config(\n            response=response,\n            scrapli_responses=[config_result],\n        )\n\n    async def abort_config(self) -&gt; ScrapliCfgResponse:\n        response = self._pre_abort_config(\n            session_or_config_file=bool(self.candidate_config_filename)\n        )\n\n        abort_result = await self._delete_candidate_config()\n        self._reset_config_session()\n\n        return self._post_abort_config(response=response, scrapli_responses=[abort_result])\n\n    async def commit_config(self, source: str = \"running\") -&gt; ScrapliCfgResponse:\n        scrapli_responses: List[Union[MultiResponse, Response]] = []\n        response = self._pre_commit_config(\n            source=source, session_or_config_file=bool(self.candidate_config_filename)\n        )\n\n        if self._replace is True:\n            replace_command = (\n                f\"rollback running-config file {self.filesystem}{self.candidate_config_filename}\"\n            )\n            commit_result = await self.conn.send_command(command=replace_command)\n        else:\n            merge_command = f\"copy {self.filesystem}{self.candidate_config_filename} running-config\"\n            commit_result = await self.conn.send_command(command=merge_command)\n\n        scrapli_responses.append(commit_result)\n\n        save_config_result = await self.conn.send_command(\n            command=\"copy running-config startup-config\"\n        )\n        scrapli_responses.append(save_config_result)\n\n        if self.cleanup_post_commit:\n            cleanup_result = await self._delete_candidate_config()\n            scrapli_responses.append(cleanup_result)\n\n        self._reset_config_session()\n\n        return self._post_commit_config(\n            response=response,\n            scrapli_responses=scrapli_responses,\n        )\n\n    async def diff_config(self, source: str = \"running\") -&gt; ScrapliCfgDiffResponse:\n        scrapli_responses = []\n        device_diff = \"\"\n        source_config = \"\"\n\n        diff_response = self._pre_diff_config(\n            source=source, session_or_config_file=bool(self.candidate_config_filename)\n        )\n\n        try:\n            diff_command = self._get_diff_command(source=source)\n\n            if diff_command:\n                diff_result = await self.conn.send_command(command=diff_command)\n                scrapli_responses.append(diff_result)\n                if diff_result.failed:\n                    msg = \"failed generating diff for config session\"\n                    self.logger.critical(msg)\n                    raise DiffConfigError(msg)\n                device_diff = diff_result.result\n            else:\n                device_diff = \"\"\n\n            source_config_result = await self.get_config(source=source)\n            source_config = source_config_result.result\n\n            if isinstance(source_config_result.scrapli_responses, MultiResponse):\n                # in this case this will always be a multiresponse or nothing (failure) but mypy\n                # doesnt know that, hence the isinstance check\n                scrapli_responses.extend(source_config_result.scrapli_responses)\n\n            if source_config_result.failed:\n                msg = \"failed fetching source config for diff comparison\"\n                self.logger.critical(msg)\n                raise DiffConfigError(msg)\n\n        except DiffConfigError:\n            pass\n\n        return self._post_diff_config(\n            diff_response=diff_response,\n            scrapli_responses=scrapli_responses,\n            source_config=self.clean_config(source_config),\n            candidate_config=self.clean_config(self.candidate_config),\n            device_diff=device_diff,\n        )\n        </code>\n    </pre>"},{"location":"api_docs/platform/core/cisco_nxos/async_platform/#ancestors-in-mro","title":"Ancestors (in MRO)","text":"<ul> <li>scrapli_cfg.platform.base.async_platform.AsyncScrapliCfgPlatform</li> <li>abc.ABC</li> <li>scrapli_cfg.platform.base.base_platform.ScrapliCfgBase</li> <li>scrapli_cfg.platform.core.cisco_nxos.base_platform.ScrapliCfgNXOSBase</li> </ul>"},{"location":"api_docs/platform/core/cisco_nxos/async_platform/#class-variables","title":"Class variables","text":"<p><code>conn: Union[scrapli.driver.network.sync_driver.NetworkDriver,\u00a0scrapli.driver.network.async_driver.AsyncNetworkDriver]</code></p>"},{"location":"api_docs/platform/core/cisco_nxos/async_platform/#methods","title":"Methods","text":""},{"location":"api_docs/platform/core/cisco_nxos/async_platform/#get_checkpoint","title":"get_checkpoint","text":"<p><code>get_checkpoint(self) \u2011&gt; scrapli_cfg.response.ScrapliCfgResponse</code></p> <pre><code>Get device checkpoint file\n\nArgs:\n    N/A\n\nReturns:\n    ScrapliCfgResponse: response object containing string of the target config source as the\n        `result` attribute\n\nRaises:\n    N/A\n</code></pre>"},{"location":"api_docs/platform/core/cisco_nxos/async_platform/#load_config","title":"load_config","text":"<p><code>load_config(self, config:\u00a0str, replace:\u00a0bool\u00a0=\u00a0False, **kwargs:\u00a0Any) \u2011&gt; scrapli_cfg.response.ScrapliCfgResponse</code></p> <pre><code>Load configuration to a device\n\nSupported kwargs:\n    N/A\n\nArgs:\n    config: string of the configuration to load\n    replace: replace the configuration or not, if false configuration will be loaded as a\n        merge operation\n    kwargs: additional kwargs that the implementing classes may need for their platform,\n        see above for nxos supported kwargs\n\nReturns:\n    ScrapliCfgResponse: response object\n\nRaises:\n    N/A\n</code></pre>"},{"location":"api_docs/platform/core/cisco_nxos/base_platform/","title":"Base platform","text":"window.addEventListener('DOMContentLoaded', () =&gt; hljs.initHighlighting())"},{"location":"api_docs/platform/core/cisco_nxos/base_platform/#module-scrapli_cfgplatformcorecisco_nxosbase_platform","title":"Module scrapli_cfg.platform.core.cisco_nxos.base_platform","text":"<p>scrapli_cfg.platform.core.cisco_nxos.base_platform</p> Expand source code <pre>\n        <code>\n\"\"\"scrapli_cfg.platform.core.cisco_nxos.base_platform\"\"\"\nimport re\nfrom datetime import datetime\nfrom logging import Logger, LoggerAdapter\nfrom typing import TYPE_CHECKING, List, Tuple, Union\n\nfrom scrapli.driver.network import AsyncNetworkDriver, NetworkDriver\nfrom scrapli_cfg.exceptions import (\n    FailedToFetchSpaceAvailable,\n    GetConfigError,\n    InsufficientSpaceAvailable,\n)\nfrom scrapli_cfg.helper import strip_blank_lines\nfrom scrapli_cfg.platform.core.cisco_nxos.patterns import (\n    BYTES_FREE,\n    CHECKPOINT_LINE,\n    OUTPUT_HEADER_PATTERN,\n    VERSION_PATTERN,\n)\nfrom scrapli_cfg.response import ScrapliCfgResponse\n\nif TYPE_CHECKING:\n    LoggerAdapterT = LoggerAdapter[Logger]  # pylint:disable=E1136\nelse:\n    LoggerAdapterT = LoggerAdapter\n\n\nCONFIG_SOURCES = [\n    \"running\",\n    \"startup\",\n]\n\n\nclass ScrapliCfgNXOSBase:\n    logger: LoggerAdapterT\n    candidate_config: str\n    candidate_config_filename: str\n    _replace: bool\n    filesystem: str\n    _filesystem_space_available_buffer_perc: int\n\n    def _post_get_filesystem_space_available(self, output: str) -&gt; int:\n        \"\"\"\n        Handle post \"get_filesystem_space_available\" operations for parity between sync and async\n\n        Args:\n            output: output that was fetched from the device\n\n        Returns:\n            int: bytes of space available on filesystem\n\n        Raises:\n            FailedToFetchSpaceAvailable: if could not determine space available... duh :)\n\n        \"\"\"\n        self.logger.info(\"determining space available from device output\")\n\n        bytes_available_match = re.search(pattern=BYTES_FREE, string=output)\n        if not bytes_available_match:\n            msg = \"could not determine space available on filesystem\"\n            self.logger.critical(msg)\n            raise FailedToFetchSpaceAvailable(msg)\n\n        return int(bytes_available_match.groupdict()[\"bytes_available\"])\n\n    def _space_available(self, filesystem_bytes_available: int) -&gt; None:\n        \"\"\"\n        Space available operations for parity between sync and async\n\n        It seems that the length of the config is near enough 1:1 to the size it takes up\n        on the disk... so roll w/ that plus a bit of buffer based on the available buffer perc\n\n        Args:\n            filesystem_bytes_available: bytes available on filesystem\n\n        Returns:\n            None\n\n        Raises:\n            InsufficientSpaceAvailable: if... insufficient space available....\n\n        \"\"\"\n        if filesystem_bytes_available &lt; (\n            len(self.candidate_config) / (self._filesystem_space_available_buffer_perc / 100)\n        ) + len(self.candidate_config):\n            # filesystem has less than candidate config file size + 10% (by default) space, bail out\n            msg = (\n                f\"insufficient space available for candidate config + \"\n                f\"{self._filesystem_space_available_buffer_perc}% (buffer)\"\n            )\n            self.logger.critical(msg)\n            raise InsufficientSpaceAvailable(msg)\n\n    @staticmethod\n    def _parse_version(device_output: str) -&gt; str:\n        \"\"\"\n        Parse version string out of device output\n\n        Args:\n            device_output: output from show version command\n\n        Returns:\n            str: device version string\n\n        Raises:\n            N/A\n\n        \"\"\"\n        version_string_search = re.search(pattern=VERSION_PATTERN, string=device_output)\n\n        if not version_string_search:\n            return \"\"\n\n        version_string = version_string_search.group(0) or \"\"\n        return version_string\n\n    def _reset_config_session(self) -&gt; None:\n        \"\"\"\n        Reset config session info\n\n        Resets the candidate config and config session name attributes -- when these are \"empty\" we\n        know there is no current config session\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.logger.debug(\"resetting candidate config and config session name\")\n        self.candidate_config = \"\"\n        self.candidate_config_filename = \"\"\n\n    @staticmethod\n    def _get_config_command(source: str) -&gt; str:\n        \"\"\"\n        Return command to use to get config based on the provided source\n\n        Args:\n            source: name of the config source, generally running|startup\n\n        Returns:\n            str: command to use to fetch the requested config\n\n        Raises:\n            N/A\n\n        \"\"\"\n        if source == \"running\":\n            return \"show running-config\"\n        return \"show startup-config\"\n\n    def _get_diff_command(self, source: str) -&gt; str:\n        \"\"\"\n        Generate diff command based on source to diff and filesystem/candidate config name\n\n        Args:\n            source: config source to gen diff for\n\n        Returns:\n            str: command to use to diff the configuration\n\n        Raises:\n            N/A\n\n        \"\"\"\n        if self._replace:\n            return (\n                f\"show diff rollback-patch {source}-config file {self.filesystem}\"\n                f\"{self.candidate_config_filename}\"\n            )\n        return \"\"\n\n    def _prepare_config_payloads(self, config: str) -&gt; str:\n        \"\"\"\n        Prepare a configuration so it can be nicely sent to the device via scrapli\n\n        Args:\n            config: configuration to prep\n\n        Returns:\n            str: string of config lines to write to candidate config file\n\n        Raises:\n            N/A\n\n        \"\"\"\n        # with the \"normal\" method (the way iosxe does this) it seems to want to stop at 250ish\n        # lines... so this works but its kinda wonky... the actual lines we want to put in the text\n        # file are enclosed in curly braces for tcl-reasons i guess\n        tclsh_filesystem = f\"/{self.filesystem.strip(':')}/\"\n        tclsh_start_file = f'set fl [open \"{tclsh_filesystem}{self.candidate_config_filename}\" wb+]'\n        tcl_config = \"\\n\".join(\n            [f\"puts -nonewline $fl {{{line}\\r}}\" for line in config.splitlines()]\n        )\n        tclsh_end_file = \"close $fl\"\n        final_config = \"\\n\".join((tclsh_start_file, tcl_config, tclsh_end_file))\n\n        return final_config\n\n    def _prepare_load_config(self, config: str, replace: bool) -&gt; str:\n        \"\"\"\n        Handle pre \"load_config\" operations for parity between sync and async\n\n        Args:\n            config: candidate config to load\n            replace: True/False replace the configuration; passed here so it can be set at the class\n                level as we need to stay in config mode and we need to know if we are doing a merge\n                or a replace when we go to diff things\n\n        Returns:\n            str: string of config to write to candidate config file\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.candidate_config = config\n\n        if not self.candidate_config_filename:\n            self.candidate_config_filename = f\"scrapli_cfg_{round(datetime.now().timestamp())}\"\n            self.logger.debug(\n                f\"candidate config file name will be '{self.candidate_config_filename}'\"\n            )\n\n        config = self._prepare_config_payloads(config=config)\n        self._replace = replace\n\n        return config\n\n    def clean_config(self, config: str) -&gt; str:\n        \"\"\"\n        Clean a configuration file of unwanted lines\n\n        Args:\n            config: configuration string to \"clean\"\n\n        Returns:\n            str: cleaned configuration string\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.logger.debug(\"cleaning config file\")\n\n        config = re.sub(pattern=CHECKPOINT_LINE, string=config, repl=\"\")\n        config = re.sub(pattern=OUTPUT_HEADER_PATTERN, string=config, repl=\"\")\n        return strip_blank_lines(config=config)\n\n    def _pre_get_checkpoint(\n        self, conn: Union[AsyncNetworkDriver, NetworkDriver]\n    ) -&gt; Tuple[ScrapliCfgResponse, List[str]]:\n        \"\"\"\n        Handle pre \"get_checkpoint\" operations for parity between sync and async\n\n        Args:\n            conn: connection from the sync or async platform; passed in explicitly to maintain\n                typing sanity\n\n        Returns:\n            list: list of commands needed to generate checkpoint and show it\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.logger.info(\"get_checkpoint requested\")\n\n        tmp_timestamp = round(datetime.now().timestamp())\n        checkpoint_commands = [\n            \"terminal dont-ask\",\n            f\"checkpoint file {self.filesystem}scrapli_cfg_tmp_{tmp_timestamp}\",\n            f\"show file {self.filesystem}scrapli_cfg_tmp_{tmp_timestamp}\",\n            f\"delete {self.filesystem}scrapli_cfg_tmp_{tmp_timestamp}\",\n        ]\n\n        response = ScrapliCfgResponse(host=conn.host, raise_for_status_exception=GetConfigError)\n\n        return response, checkpoint_commands\n        </code>\n    </pre>"},{"location":"api_docs/platform/core/cisco_nxos/base_platform/#classes","title":"Classes","text":""},{"location":"api_docs/platform/core/cisco_nxos/base_platform/#scraplicfgnxosbase","title":"ScrapliCfgNXOSBase","text":"Expand source code <pre>\n        <code>\nclass ScrapliCfgNXOSBase:\n    logger: LoggerAdapterT\n    candidate_config: str\n    candidate_config_filename: str\n    _replace: bool\n    filesystem: str\n    _filesystem_space_available_buffer_perc: int\n\n    def _post_get_filesystem_space_available(self, output: str) -&gt; int:\n        \"\"\"\n        Handle post \"get_filesystem_space_available\" operations for parity between sync and async\n\n        Args:\n            output: output that was fetched from the device\n\n        Returns:\n            int: bytes of space available on filesystem\n\n        Raises:\n            FailedToFetchSpaceAvailable: if could not determine space available... duh :)\n\n        \"\"\"\n        self.logger.info(\"determining space available from device output\")\n\n        bytes_available_match = re.search(pattern=BYTES_FREE, string=output)\n        if not bytes_available_match:\n            msg = \"could not determine space available on filesystem\"\n            self.logger.critical(msg)\n            raise FailedToFetchSpaceAvailable(msg)\n\n        return int(bytes_available_match.groupdict()[\"bytes_available\"])\n\n    def _space_available(self, filesystem_bytes_available: int) -&gt; None:\n        \"\"\"\n        Space available operations for parity between sync and async\n\n        It seems that the length of the config is near enough 1:1 to the size it takes up\n        on the disk... so roll w/ that plus a bit of buffer based on the available buffer perc\n\n        Args:\n            filesystem_bytes_available: bytes available on filesystem\n\n        Returns:\n            None\n\n        Raises:\n            InsufficientSpaceAvailable: if... insufficient space available....\n\n        \"\"\"\n        if filesystem_bytes_available &lt; (\n            len(self.candidate_config) / (self._filesystem_space_available_buffer_perc / 100)\n        ) + len(self.candidate_config):\n            # filesystem has less than candidate config file size + 10% (by default) space, bail out\n            msg = (\n                f\"insufficient space available for candidate config + \"\n                f\"{self._filesystem_space_available_buffer_perc}% (buffer)\"\n            )\n            self.logger.critical(msg)\n            raise InsufficientSpaceAvailable(msg)\n\n    @staticmethod\n    def _parse_version(device_output: str) -&gt; str:\n        \"\"\"\n        Parse version string out of device output\n\n        Args:\n            device_output: output from show version command\n\n        Returns:\n            str: device version string\n\n        Raises:\n            N/A\n\n        \"\"\"\n        version_string_search = re.search(pattern=VERSION_PATTERN, string=device_output)\n\n        if not version_string_search:\n            return \"\"\n\n        version_string = version_string_search.group(0) or \"\"\n        return version_string\n\n    def _reset_config_session(self) -&gt; None:\n        \"\"\"\n        Reset config session info\n\n        Resets the candidate config and config session name attributes -- when these are \"empty\" we\n        know there is no current config session\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.logger.debug(\"resetting candidate config and config session name\")\n        self.candidate_config = \"\"\n        self.candidate_config_filename = \"\"\n\n    @staticmethod\n    def _get_config_command(source: str) -&gt; str:\n        \"\"\"\n        Return command to use to get config based on the provided source\n\n        Args:\n            source: name of the config source, generally running|startup\n\n        Returns:\n            str: command to use to fetch the requested config\n\n        Raises:\n            N/A\n\n        \"\"\"\n        if source == \"running\":\n            return \"show running-config\"\n        return \"show startup-config\"\n\n    def _get_diff_command(self, source: str) -&gt; str:\n        \"\"\"\n        Generate diff command based on source to diff and filesystem/candidate config name\n\n        Args:\n            source: config source to gen diff for\n\n        Returns:\n            str: command to use to diff the configuration\n\n        Raises:\n            N/A\n\n        \"\"\"\n        if self._replace:\n            return (\n                f\"show diff rollback-patch {source}-config file {self.filesystem}\"\n                f\"{self.candidate_config_filename}\"\n            )\n        return \"\"\n\n    def _prepare_config_payloads(self, config: str) -&gt; str:\n        \"\"\"\n        Prepare a configuration so it can be nicely sent to the device via scrapli\n\n        Args:\n            config: configuration to prep\n\n        Returns:\n            str: string of config lines to write to candidate config file\n\n        Raises:\n            N/A\n\n        \"\"\"\n        # with the \"normal\" method (the way iosxe does this) it seems to want to stop at 250ish\n        # lines... so this works but its kinda wonky... the actual lines we want to put in the text\n        # file are enclosed in curly braces for tcl-reasons i guess\n        tclsh_filesystem = f\"/{self.filesystem.strip(':')}/\"\n        tclsh_start_file = f'set fl [open \"{tclsh_filesystem}{self.candidate_config_filename}\" wb+]'\n        tcl_config = \"\\n\".join(\n            [f\"puts -nonewline $fl {{{line}\\r}}\" for line in config.splitlines()]\n        )\n        tclsh_end_file = \"close $fl\"\n        final_config = \"\\n\".join((tclsh_start_file, tcl_config, tclsh_end_file))\n\n        return final_config\n\n    def _prepare_load_config(self, config: str, replace: bool) -&gt; str:\n        \"\"\"\n        Handle pre \"load_config\" operations for parity between sync and async\n\n        Args:\n            config: candidate config to load\n            replace: True/False replace the configuration; passed here so it can be set at the class\n                level as we need to stay in config mode and we need to know if we are doing a merge\n                or a replace when we go to diff things\n\n        Returns:\n            str: string of config to write to candidate config file\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.candidate_config = config\n\n        if not self.candidate_config_filename:\n            self.candidate_config_filename = f\"scrapli_cfg_{round(datetime.now().timestamp())}\"\n            self.logger.debug(\n                f\"candidate config file name will be '{self.candidate_config_filename}'\"\n            )\n\n        config = self._prepare_config_payloads(config=config)\n        self._replace = replace\n\n        return config\n\n    def clean_config(self, config: str) -&gt; str:\n        \"\"\"\n        Clean a configuration file of unwanted lines\n\n        Args:\n            config: configuration string to \"clean\"\n\n        Returns:\n            str: cleaned configuration string\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.logger.debug(\"cleaning config file\")\n\n        config = re.sub(pattern=CHECKPOINT_LINE, string=config, repl=\"\")\n        config = re.sub(pattern=OUTPUT_HEADER_PATTERN, string=config, repl=\"\")\n        return strip_blank_lines(config=config)\n\n    def _pre_get_checkpoint(\n        self, conn: Union[AsyncNetworkDriver, NetworkDriver]\n    ) -&gt; Tuple[ScrapliCfgResponse, List[str]]:\n        \"\"\"\n        Handle pre \"get_checkpoint\" operations for parity between sync and async\n\n        Args:\n            conn: connection from the sync or async platform; passed in explicitly to maintain\n                typing sanity\n\n        Returns:\n            list: list of commands needed to generate checkpoint and show it\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.logger.info(\"get_checkpoint requested\")\n\n        tmp_timestamp = round(datetime.now().timestamp())\n        checkpoint_commands = [\n            \"terminal dont-ask\",\n            f\"checkpoint file {self.filesystem}scrapli_cfg_tmp_{tmp_timestamp}\",\n            f\"show file {self.filesystem}scrapli_cfg_tmp_{tmp_timestamp}\",\n            f\"delete {self.filesystem}scrapli_cfg_tmp_{tmp_timestamp}\",\n        ]\n\n        response = ScrapliCfgResponse(host=conn.host, raise_for_status_exception=GetConfigError)\n\n        return response, checkpoint_commands\n        </code>\n    </pre>"},{"location":"api_docs/platform/core/cisco_nxos/base_platform/#descendants","title":"Descendants","text":"<ul> <li>scrapli_cfg.platform.core.cisco_nxos.async_platform.AsyncScrapliCfgNXOS</li> <li>scrapli_cfg.platform.core.cisco_nxos.sync_platform.ScrapliCfgNXOS</li> </ul>"},{"location":"api_docs/platform/core/cisco_nxos/base_platform/#class-variables","title":"Class variables","text":"<p><code>candidate_config: str</code></p> <p><code>candidate_config_filename: str</code></p> <p><code>filesystem: str</code></p> <p><code>logger: logging.LoggerAdapter</code></p>"},{"location":"api_docs/platform/core/cisco_nxos/base_platform/#methods","title":"Methods","text":""},{"location":"api_docs/platform/core/cisco_nxos/base_platform/#clean_config","title":"clean_config","text":"<p><code>clean_config(self, config:\u00a0str) \u2011&gt; str</code></p> <pre><code>Clean a configuration file of unwanted lines\n\nArgs:\n    config: configuration string to \"clean\"\n\nReturns:\n    str: cleaned configuration string\n\nRaises:\n    N/A\n</code></pre>"},{"location":"api_docs/platform/core/cisco_nxos/patterns/","title":"Patterns","text":"window.addEventListener('DOMContentLoaded', () =&gt; hljs.initHighlighting())"},{"location":"api_docs/platform/core/cisco_nxos/patterns/#module-scrapli_cfgplatformcorecisco_nxospatterns","title":"Module scrapli_cfg.platform.core.cisco_nxos.patterns","text":"<p>scrapli_cfg.platforms.cisco_nxos.patterns</p> Expand source code <pre>\n        <code>\n\"\"\"scrapli_cfg.platforms.cisco_nxos.patterns\"\"\"\nimport re\n\nVERSION_PATTERN = re.compile(pattern=r\"\\d+\\.[a-z0-9\\(\\)\\.]+\", flags=re.I)\nBYTES_FREE = re.compile(pattern=r\"(?P\\d+)(?: bytes free)\", flags=re.I)\n\nBUILD_CONFIG_PATTERN = re.compile(r\"(^!command:.*$)\", flags=re.I | re.M)\nCONFIG_VERSION_PATTERN = re.compile(r\"(^!running configuration last done.*$)\", flags=re.I | re.M)\nCONFIG_CHANGE_PATTERN = re.compile(r\"(^!time.*$)\", flags=re.I | re.M)\nOUTPUT_HEADER_PATTERN = re.compile(\n    pattern=rf\"{BUILD_CONFIG_PATTERN.pattern}|\"\n    rf\"{CONFIG_VERSION_PATTERN.pattern}|\"\n    rf\"{CONFIG_CHANGE_PATTERN.pattern}\",\n    flags=re.I | re.M,\n)\n\nCHECKPOINT_LINE = re.compile(pattern=r\"^\\s*!#.*$\", flags=re.M)"},{"location":"api_docs/platform/core/cisco_nxos/sync_platform/","title":"Sync Platform","text":"window.addEventListener('DOMContentLoaded', () =&gt; hljs.initHighlighting())"},{"location":"api_docs/platform/core/cisco_nxos/sync_platform/#module-scrapli_cfgplatformcorecisco_nxossync_platform","title":"Module scrapli_cfg.platform.core.cisco_nxos.sync_platform","text":"<p>scrapli_cfg.platform.core.cisco_nxos.sync_platform</p> Expand source code <pre>\n        <code>\n\"\"\"scrapli_cfg.platform.core.cisco_nxos.sync_platform\"\"\"\nfrom typing import Any, Callable, List, Optional, Union\n\nfrom scrapli.driver.core import NXOSDriver\nfrom scrapli.response import MultiResponse, Response\nfrom scrapli_cfg.diff import ScrapliCfgDiffResponse\nfrom scrapli_cfg.exceptions import DiffConfigError, FailedToDetermineDeviceState\nfrom scrapli_cfg.platform.base.sync_platform import ScrapliCfgPlatform\nfrom scrapli_cfg.platform.core.cisco_nxos.base_platform import CONFIG_SOURCES, ScrapliCfgNXOSBase\nfrom scrapli_cfg.response import ScrapliCfgResponse\n\n\nclass ScrapliCfgNXOS(ScrapliCfgNXOSBase, ScrapliCfgPlatform):\n    def __init__(\n        self,\n        conn: NXOSDriver,\n        *,\n        config_sources: Optional[List[str]] = None,\n        on_prepare: Optional[Callable[..., Any]] = None,\n        filesystem: str = \"bootflash:\",\n        cleanup_post_commit: bool = True,\n        dedicated_connection: bool = False,\n        ignore_version: bool = False,\n    ) -&gt; None:\n        if config_sources is None:\n            config_sources = CONFIG_SOURCES\n\n        super().__init__(\n            conn=conn,\n            config_sources=config_sources,\n            on_prepare=on_prepare,\n            dedicated_connection=dedicated_connection,\n            ignore_version=ignore_version,\n        )\n\n        self.filesystem = filesystem\n        self._filesystem_space_available_buffer_perc = 10\n\n        self._replace = False\n\n        self.candidate_config_filename = \"\"\n\n        self.cleanup_post_commit = cleanup_post_commit\n\n    def _get_filesystem_space_available(self) -&gt; int:\n        \"\"\"\n        Get available space on filesystem\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            FailedToDetermineDeviceState: if unable to fetch file filesystem bytes available\n\n        \"\"\"\n        filesystem_size_result = self.conn.send_command(\n            command=f\"dir {self.filesystem} | i 'bytes free'\"\n        )\n        if filesystem_size_result.failed:\n            raise FailedToDetermineDeviceState(\"failed to determine space available on filesystem\")\n\n        return self._post_get_filesystem_space_available(output=filesystem_size_result.result)\n\n    def _delete_candidate_config(self) -&gt; MultiResponse:\n        \"\"\"\n        Delete candidate config from the filesystem\n\n        Args:\n            N/A\n\n        Returns:\n            MultiResponse: response from deleting the candidate config\n\n        Raises:\n            N/A\n\n        \"\"\"\n        delete_commands = [\n            \"terminal dont-ask\",\n            f\"delete {self.filesystem}{self.candidate_config_filename}\",\n        ]\n        delete_result = self.conn.send_commands(commands=delete_commands)\n        return delete_result\n\n    def get_checkpoint(self) -&gt; ScrapliCfgResponse:\n        \"\"\"\n        Get device checkpoint file\n\n        Args:\n            N/A\n\n        Returns:\n            ScrapliCfgResponse: response object containing string of the target config source as the\n                `result` attribute\n\n        Raises:\n            N/A\n\n        \"\"\"\n        response, checkpoint_commands = self._pre_get_checkpoint(conn=self.conn)\n\n        checkpoint_results = self.conn.send_commands(commands=checkpoint_commands)\n\n        try:\n            checkpoint: str = checkpoint_results[2].result\n        except IndexError:\n            checkpoint = \"\"\n\n        return self._post_get_config(\n            response=response,\n            source=\"running\",\n            scrapli_responses=[checkpoint_results],\n            result=checkpoint,\n        )\n\n    def get_version(self) -&gt; ScrapliCfgResponse:\n        response = self._pre_get_version()\n\n        version_result = self.conn.send_command(command='show version | i \"NXOS: version\"')\n\n        return self._post_get_version(\n            response=response,\n            scrapli_responses=[version_result],\n            result=self._parse_version(device_output=version_result.result),\n        )\n\n    def get_config(self, source: str = \"running\") -&gt; ScrapliCfgResponse:\n        response = self._pre_get_config(source=source)\n\n        config_result = self.conn.send_command(command=self._get_config_command(source=source))\n\n        return self._post_get_config(\n            response=response,\n            source=source,\n            scrapli_responses=[config_result],\n            result=config_result.result,\n        )\n\n    def load_config(self, config: str, replace: bool = False, **kwargs: Any) -&gt; ScrapliCfgResponse:\n        \"\"\"\n        Load configuration to a device\n\n        Supported kwargs:\n            N/A\n\n        Args:\n            config: string of the configuration to load\n            replace: replace the configuration or not, if false configuration will be loaded as a\n                merge operation\n            kwargs: additional kwargs that the implementing classes may need for their platform,\n                see above for nxos supported kwargs\n\n        Returns:\n            ScrapliCfgResponse: response object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        response = self._pre_load_config(config=config)\n\n        config = self._prepare_load_config(config=config, replace=replace)\n\n        filesystem_bytes_available = self._get_filesystem_space_available()\n        self._space_available(filesystem_bytes_available=filesystem_bytes_available)\n\n        self.conn.acquire_priv(desired_priv=\"tclsh\")\n        config_result = self.conn.send_config(config=config, privilege_level=\"tclsh\")\n        self.conn.acquire_priv(desired_priv=self.conn.default_desired_privilege_level)\n\n        return self._post_load_config(\n            response=response,\n            scrapli_responses=[config_result],\n        )\n\n    def abort_config(self) -&gt; ScrapliCfgResponse:\n        response = self._pre_abort_config(\n            session_or_config_file=bool(self.candidate_config_filename)\n        )\n\n        abort_result = self._delete_candidate_config()\n        self._reset_config_session()\n\n        return self._post_abort_config(response=response, scrapli_responses=[abort_result])\n\n    def commit_config(self, source: str = \"running\") -&gt; ScrapliCfgResponse:\n        scrapli_responses: List[Union[MultiResponse, Response]] = []\n        response = self._pre_commit_config(\n            source=source, session_or_config_file=bool(self.candidate_config_filename)\n        )\n\n        if self._replace is True:\n            replace_command = (\n                f\"rollback running-config file {self.filesystem}{self.candidate_config_filename}\"\n            )\n            commit_result = self.conn.send_command(command=replace_command)\n        else:\n            merge_command = f\"copy {self.filesystem}{self.candidate_config_filename} running-config\"\n            commit_result = self.conn.send_command(command=merge_command)\n\n        scrapli_responses.append(commit_result)\n\n        save_config_result = self.conn.send_command(command=\"copy running-config startup-config\")\n        scrapli_responses.append(save_config_result)\n\n        if self.cleanup_post_commit:\n            cleanup_result = self._delete_candidate_config()\n            scrapli_responses.append(cleanup_result)\n\n        self._reset_config_session()\n\n        return self._post_commit_config(\n            response=response,\n            scrapli_responses=scrapli_responses,\n        )\n\n    def diff_config(self, source: str = \"running\") -&gt; ScrapliCfgDiffResponse:\n        scrapli_responses = []\n        device_diff = \"\"\n        source_config = \"\"\n\n        diff_response = self._pre_diff_config(\n            source=source, session_or_config_file=bool(self.candidate_config_filename)\n        )\n\n        try:\n            diff_command = self._get_diff_command(source=source)\n\n            if diff_command:\n                diff_result = self.conn.send_command(command=diff_command)\n                scrapli_responses.append(diff_result)\n                if diff_result.failed:\n                    msg = \"failed generating diff for config session\"\n                    self.logger.critical(msg)\n                    raise DiffConfigError(msg)\n                device_diff = diff_result.result\n            else:\n                device_diff = \"\"\n\n            source_config_result = self.get_config(source=source)\n            source_config = source_config_result.result\n\n            if isinstance(source_config_result.scrapli_responses, MultiResponse):\n                # in this case this will always be a multiresponse or nothing (failure) but mypy\n                # doesnt know that, hence the isinstance check\n                scrapli_responses.extend(source_config_result.scrapli_responses)\n\n            if source_config_result.failed:\n                msg = \"failed fetching source config for diff comparison\"\n                self.logger.critical(msg)\n                raise DiffConfigError(msg)\n\n        except DiffConfigError:\n            pass\n\n        return self._post_diff_config(\n            diff_response=diff_response,\n            scrapli_responses=scrapli_responses,\n            source_config=self.clean_config(source_config),\n            candidate_config=self.clean_config(self.candidate_config),\n            device_diff=device_diff,\n        )\n        </code>\n    </pre>"},{"location":"api_docs/platform/core/cisco_nxos/sync_platform/#classes","title":"Classes","text":""},{"location":"api_docs/platform/core/cisco_nxos/sync_platform/#scraplicfgnxos","title":"ScrapliCfgNXOS","text":"<pre><code>Helper class that provides a standard way to create an ABC using\ninheritance.\n</code></pre> Expand source code <pre>\n        <code>\nclass ScrapliCfgNXOS(ScrapliCfgNXOSBase, ScrapliCfgPlatform):\n    def __init__(\n        self,\n        conn: NXOSDriver,\n        *,\n        config_sources: Optional[List[str]] = None,\n        on_prepare: Optional[Callable[..., Any]] = None,\n        filesystem: str = \"bootflash:\",\n        cleanup_post_commit: bool = True,\n        dedicated_connection: bool = False,\n        ignore_version: bool = False,\n    ) -&gt; None:\n        if config_sources is None:\n            config_sources = CONFIG_SOURCES\n\n        super().__init__(\n            conn=conn,\n            config_sources=config_sources,\n            on_prepare=on_prepare,\n            dedicated_connection=dedicated_connection,\n            ignore_version=ignore_version,\n        )\n\n        self.filesystem = filesystem\n        self._filesystem_space_available_buffer_perc = 10\n\n        self._replace = False\n\n        self.candidate_config_filename = \"\"\n\n        self.cleanup_post_commit = cleanup_post_commit\n\n    def _get_filesystem_space_available(self) -&gt; int:\n        \"\"\"\n        Get available space on filesystem\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            FailedToDetermineDeviceState: if unable to fetch file filesystem bytes available\n\n        \"\"\"\n        filesystem_size_result = self.conn.send_command(\n            command=f\"dir {self.filesystem} | i 'bytes free'\"\n        )\n        if filesystem_size_result.failed:\n            raise FailedToDetermineDeviceState(\"failed to determine space available on filesystem\")\n\n        return self._post_get_filesystem_space_available(output=filesystem_size_result.result)\n\n    def _delete_candidate_config(self) -&gt; MultiResponse:\n        \"\"\"\n        Delete candidate config from the filesystem\n\n        Args:\n            N/A\n\n        Returns:\n            MultiResponse: response from deleting the candidate config\n\n        Raises:\n            N/A\n\n        \"\"\"\n        delete_commands = [\n            \"terminal dont-ask\",\n            f\"delete {self.filesystem}{self.candidate_config_filename}\",\n        ]\n        delete_result = self.conn.send_commands(commands=delete_commands)\n        return delete_result\n\n    def get_checkpoint(self) -&gt; ScrapliCfgResponse:\n        \"\"\"\n        Get device checkpoint file\n\n        Args:\n            N/A\n\n        Returns:\n            ScrapliCfgResponse: response object containing string of the target config source as the\n                `result` attribute\n\n        Raises:\n            N/A\n\n        \"\"\"\n        response, checkpoint_commands = self._pre_get_checkpoint(conn=self.conn)\n\n        checkpoint_results = self.conn.send_commands(commands=checkpoint_commands)\n\n        try:\n            checkpoint: str = checkpoint_results[2].result\n        except IndexError:\n            checkpoint = \"\"\n\n        return self._post_get_config(\n            response=response,\n            source=\"running\",\n            scrapli_responses=[checkpoint_results],\n            result=checkpoint,\n        )\n\n    def get_version(self) -&gt; ScrapliCfgResponse:\n        response = self._pre_get_version()\n\n        version_result = self.conn.send_command(command='show version | i \"NXOS: version\"')\n\n        return self._post_get_version(\n            response=response,\n            scrapli_responses=[version_result],\n            result=self._parse_version(device_output=version_result.result),\n        )\n\n    def get_config(self, source: str = \"running\") -&gt; ScrapliCfgResponse:\n        response = self._pre_get_config(source=source)\n\n        config_result = self.conn.send_command(command=self._get_config_command(source=source))\n\n        return self._post_get_config(\n            response=response,\n            source=source,\n            scrapli_responses=[config_result],\n            result=config_result.result,\n        )\n\n    def load_config(self, config: str, replace: bool = False, **kwargs: Any) -&gt; ScrapliCfgResponse:\n        \"\"\"\n        Load configuration to a device\n\n        Supported kwargs:\n            N/A\n\n        Args:\n            config: string of the configuration to load\n            replace: replace the configuration or not, if false configuration will be loaded as a\n                merge operation\n            kwargs: additional kwargs that the implementing classes may need for their platform,\n                see above for nxos supported kwargs\n\n        Returns:\n            ScrapliCfgResponse: response object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        response = self._pre_load_config(config=config)\n\n        config = self._prepare_load_config(config=config, replace=replace)\n\n        filesystem_bytes_available = self._get_filesystem_space_available()\n        self._space_available(filesystem_bytes_available=filesystem_bytes_available)\n\n        self.conn.acquire_priv(desired_priv=\"tclsh\")\n        config_result = self.conn.send_config(config=config, privilege_level=\"tclsh\")\n        self.conn.acquire_priv(desired_priv=self.conn.default_desired_privilege_level)\n\n        return self._post_load_config(\n            response=response,\n            scrapli_responses=[config_result],\n        )\n\n    def abort_config(self) -&gt; ScrapliCfgResponse:\n        response = self._pre_abort_config(\n            session_or_config_file=bool(self.candidate_config_filename)\n        )\n\n        abort_result = self._delete_candidate_config()\n        self._reset_config_session()\n\n        return self._post_abort_config(response=response, scrapli_responses=[abort_result])\n\n    def commit_config(self, source: str = \"running\") -&gt; ScrapliCfgResponse:\n        scrapli_responses: List[Union[MultiResponse, Response]] = []\n        response = self._pre_commit_config(\n            source=source, session_or_config_file=bool(self.candidate_config_filename)\n        )\n\n        if self._replace is True:\n            replace_command = (\n                f\"rollback running-config file {self.filesystem}{self.candidate_config_filename}\"\n            )\n            commit_result = self.conn.send_command(command=replace_command)\n        else:\n            merge_command = f\"copy {self.filesystem}{self.candidate_config_filename} running-config\"\n            commit_result = self.conn.send_command(command=merge_command)\n\n        scrapli_responses.append(commit_result)\n\n        save_config_result = self.conn.send_command(command=\"copy running-config startup-config\")\n        scrapli_responses.append(save_config_result)\n\n        if self.cleanup_post_commit:\n            cleanup_result = self._delete_candidate_config()\n            scrapli_responses.append(cleanup_result)\n\n        self._reset_config_session()\n\n        return self._post_commit_config(\n            response=response,\n            scrapli_responses=scrapli_responses,\n        )\n\n    def diff_config(self, source: str = \"running\") -&gt; ScrapliCfgDiffResponse:\n        scrapli_responses = []\n        device_diff = \"\"\n        source_config = \"\"\n\n        diff_response = self._pre_diff_config(\n            source=source, session_or_config_file=bool(self.candidate_config_filename)\n        )\n\n        try:\n            diff_command = self._get_diff_command(source=source)\n\n            if diff_command:\n                diff_result = self.conn.send_command(command=diff_command)\n                scrapli_responses.append(diff_result)\n                if diff_result.failed:\n                    msg = \"failed generating diff for config session\"\n                    self.logger.critical(msg)\n                    raise DiffConfigError(msg)\n                device_diff = diff_result.result\n            else:\n                device_diff = \"\"\n\n            source_config_result = self.get_config(source=source)\n            source_config = source_config_result.result\n\n            if isinstance(source_config_result.scrapli_responses, MultiResponse):\n                # in this case this will always be a multiresponse or nothing (failure) but mypy\n                # doesnt know that, hence the isinstance check\n                scrapli_responses.extend(source_config_result.scrapli_responses)\n\n            if source_config_result.failed:\n                msg = \"failed fetching source config for diff comparison\"\n                self.logger.critical(msg)\n                raise DiffConfigError(msg)\n\n        except DiffConfigError:\n            pass\n\n        return self._post_diff_config(\n            diff_response=diff_response,\n            scrapli_responses=scrapli_responses,\n            source_config=self.clean_config(source_config),\n            candidate_config=self.clean_config(self.candidate_config),\n            device_diff=device_diff,\n        )\n        </code>\n    </pre>"},{"location":"api_docs/platform/core/cisco_nxos/sync_platform/#ancestors-in-mro","title":"Ancestors (in MRO)","text":"<ul> <li>scrapli_cfg.platform.core.cisco_nxos.base_platform.ScrapliCfgNXOSBase</li> <li>scrapli_cfg.platform.base.sync_platform.ScrapliCfgPlatform</li> <li>abc.ABC</li> <li>scrapli_cfg.platform.base.base_platform.ScrapliCfgBase</li> </ul>"},{"location":"api_docs/platform/core/cisco_nxos/sync_platform/#class-variables","title":"Class variables","text":"<p><code>candidate_config: str</code></p> <p><code>candidate_config_filename: str</code></p> <p><code>filesystem: str</code></p> <p><code>logger: logging.LoggerAdapter</code></p>"},{"location":"api_docs/platform/core/cisco_nxos/sync_platform/#methods","title":"Methods","text":""},{"location":"api_docs/platform/core/cisco_nxos/sync_platform/#get_checkpoint","title":"get_checkpoint","text":"<p><code>get_checkpoint(self) \u2011&gt; scrapli_cfg.response.ScrapliCfgResponse</code></p> <pre><code>Get device checkpoint file\n\nArgs:\n    N/A\n\nReturns:\n    ScrapliCfgResponse: response object containing string of the target config source as the\n        `result` attribute\n\nRaises:\n    N/A\n</code></pre>"},{"location":"api_docs/platform/core/cisco_nxos/sync_platform/#load_config","title":"load_config","text":"<p><code>load_config(self, config:\u00a0str, replace:\u00a0bool\u00a0=\u00a0False, **kwargs:\u00a0Any) \u2011&gt; scrapli_cfg.response.ScrapliCfgResponse</code></p> <pre><code>Load configuration to a device\n\nSupported kwargs:\n    N/A\n\nArgs:\n    config: string of the configuration to load\n    replace: replace the configuration or not, if false configuration will be loaded as a\n        merge operation\n    kwargs: additional kwargs that the implementing classes may need for their platform,\n        see above for nxos supported kwargs\n\nReturns:\n    ScrapliCfgResponse: response object\n\nRaises:\n    N/A\n</code></pre>"},{"location":"api_docs/platform/core/juniper_junos/async_platform/","title":"Async Platform","text":"window.addEventListener('DOMContentLoaded', () =&gt; hljs.initHighlighting())"},{"location":"api_docs/platform/core/juniper_junos/async_platform/#module-scrapli_cfgplatformcorejuniper_junosasync_platform","title":"Module scrapli_cfg.platform.core.juniper_junos.async_platform","text":"<p>scrapli_cfg.platform.core.juniper_junos.async_platform</p> Expand source code <pre>\n        <code>\n\"\"\"scrapli_cfg.platform.core.juniper_junos.async_platform\"\"\"\nfrom typing import Any, Callable, List, Optional\n\nfrom scrapli.driver import AsyncNetworkDriver\nfrom scrapli.response import MultiResponse, Response\nfrom scrapli_cfg.diff import ScrapliCfgDiffResponse\nfrom scrapli_cfg.exceptions import DiffConfigError\nfrom scrapli_cfg.platform.base.async_platform import AsyncScrapliCfgPlatform\nfrom scrapli_cfg.platform.core.juniper_junos.base_platform import (\n    CONFIG_SOURCES,\n    ScrapliCfgJunosBase,\n)\nfrom scrapli_cfg.response import ScrapliCfgResponse\n\n\nclass AsyncScrapliCfgJunos(AsyncScrapliCfgPlatform, ScrapliCfgJunosBase):\n    def __init__(\n        self,\n        conn: AsyncNetworkDriver,\n        *,\n        config_sources: Optional[List[str]] = None,\n        on_prepare: Optional[Callable[..., Any]] = None,\n        filesystem: str = \"/config/\",\n        cleanup_post_commit: bool = True,\n        dedicated_connection: bool = False,\n        ignore_version: bool = False,\n    ) -&gt; None:\n        if config_sources is None:\n            config_sources = CONFIG_SOURCES\n\n        super().__init__(\n            conn=conn,\n            config_sources=config_sources,\n            on_prepare=on_prepare,\n            dedicated_connection=dedicated_connection,\n            ignore_version=ignore_version,\n        )\n\n        self.filesystem = filesystem\n\n        self._replace = False\n        self._set = False\n\n        self.candidate_config_filename = \"\"\n        self._in_configuration_session = False\n\n        self.cleanup_post_commit = cleanup_post_commit\n\n    async def _delete_candidate_config(self) -&gt; Response:\n        \"\"\"\n        Delete candidate config from the filesystem\n\n        Args:\n            N/A\n\n        Returns:\n            Response: response from deleting the candidate config\n\n        Raises:\n            N/A\n\n        \"\"\"\n        delete_result = await self.conn.send_config(\n            config=f\"rm {self.filesystem}{self.candidate_config_filename}\",\n            privilege_level=\"root_shell\",\n        )\n        return delete_result\n\n    async def get_version(self) -&gt; ScrapliCfgResponse:\n        response = self._pre_get_version()\n\n        version_result = await self.conn.send_command(command=\"show version | grep junos:\")\n\n        return self._post_get_version(\n            response=response,\n            scrapli_responses=[version_result],\n            result=self._parse_version(device_output=version_result.result),\n        )\n\n    async def get_config(self, source: str = \"running\") -&gt; ScrapliCfgResponse:\n        response = self._pre_get_config(source=source)\n\n        if self._in_configuration_session is True:\n            config_result = await self.conn.send_config(config=\"run show configuration\")\n        else:\n            config_result = await self.conn.send_command(command=\"show configuration\")\n\n        return self._post_get_config(\n            response=response,\n            source=source,\n            scrapli_responses=[config_result],\n            result=config_result.result,\n        )\n\n    async def load_config(\n        self, config: str, replace: bool = False, **kwargs: Any\n    ) -&gt; ScrapliCfgResponse:\n        \"\"\"\n        Load configuration to a device\n\n        Supported kwargs:\n            set: bool indicating config is a \"set\" style config (ignored if replace is True)\n\n        Args:\n            config: string of the configuration to load\n            replace: replace the configuration or not, if false configuration will be loaded as a\n                merge operation\n            kwargs: additional kwargs that the implementing classes may need for their platform,\n                see above for junos supported kwargs\n\n        Returns:\n            ScrapliCfgResponse: response object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self._set = kwargs.get(\"set\", False)\n\n        response = self._pre_load_config(config=config)\n\n        config = self._prepare_load_config(config=config, replace=replace)\n\n        config_result = await self.conn.send_config(config=config, privilege_level=\"root_shell\")\n\n        if self._replace is True:\n            load_config = f\"load override {self.filesystem}{self.candidate_config_filename}\"\n        else:\n            if self._set is True:\n                load_config = f\"load set {self.filesystem}{self.candidate_config_filename}\"\n            else:\n                load_config = f\"load merge {self.filesystem}{self.candidate_config_filename}\"\n\n        load_result = await self.conn.send_config(config=load_config)\n        self._in_configuration_session = True\n\n        return self._post_load_config(\n            response=response,\n            scrapli_responses=[config_result, load_result],\n        )\n\n    async def abort_config(self) -&gt; ScrapliCfgResponse:\n        response = self._pre_abort_config(\n            session_or_config_file=bool(self.candidate_config_filename)\n        )\n\n        rollback_result = await self.conn.send_config(config=\"rollback 0\")\n        abort_result = await self._delete_candidate_config()\n        self._reset_config_session()\n\n        return self._post_abort_config(\n            response=response, scrapli_responses=[rollback_result, abort_result]\n        )\n\n    async def commit_config(self, source: str = \"running\") -&gt; ScrapliCfgResponse:\n        scrapli_responses = []\n        response = self._pre_commit_config(\n            source=source, session_or_config_file=bool(self.candidate_config_filename)\n        )\n\n        commit_result = await self.conn.send_config(config=\"commit\")\n        scrapli_responses.append(commit_result)\n\n        if self.cleanup_post_commit:\n            cleanup_result = await self._delete_candidate_config()\n            scrapli_responses.append(cleanup_result)\n\n        self._reset_config_session()\n\n        return self._post_load_config(\n            response=response,\n            scrapli_responses=scrapli_responses,\n        )\n\n    async def diff_config(self, source: str = \"running\") -&gt; ScrapliCfgDiffResponse:\n        scrapli_responses = []\n        device_diff = \"\"\n        source_config = \"\"\n\n        diff_response = self._pre_diff_config(\n            source=source, session_or_config_file=bool(self.candidate_config_filename)\n        )\n\n        try:\n            diff_result = await self.conn.send_config(config=\"show | compare\")\n            scrapli_responses.append(diff_result)\n            if diff_result.failed:\n                msg = \"failed generating diff for config session\"\n                self.logger.critical(msg)\n                raise DiffConfigError(msg)\n\n            device_diff = diff_result.result\n\n            source_config_result = await self.get_config(source=source)\n            source_config = source_config_result.result\n\n            if isinstance(source_config_result.scrapli_responses, MultiResponse):\n                # in this case this will always be a multiresponse or nothing (failure) but mypy\n                # doesnt know that, hence the isinstance check\n                scrapli_responses.extend(source_config_result.scrapli_responses)\n\n            if source_config_result.failed:\n                msg = \"failed fetching source config for diff comparison\"\n                self.logger.critical(msg)\n                raise DiffConfigError(msg)\n\n        except DiffConfigError:\n            pass\n\n        return self._post_diff_config(\n            diff_response=diff_response,\n            scrapli_responses=scrapli_responses,\n            source_config=self.clean_config(source_config),\n            candidate_config=self.clean_config(self.candidate_config),\n            device_diff=device_diff,\n        )\n        </code>\n    </pre>"},{"location":"api_docs/platform/core/juniper_junos/async_platform/#classes","title":"Classes","text":""},{"location":"api_docs/platform/core/juniper_junos/async_platform/#asyncscraplicfgjunos","title":"AsyncScrapliCfgJunos","text":"<pre><code>Helper class that provides a standard way to create an ABC using\ninheritance.\n\nScrapli Config async base class\n\nArgs:\n    conn: scrapli connection to use\n    config_sources: list of config sources\n    on_prepare: optional callable to run at connection `prepare`\n    dedicated_connection: if `False` (default value) scrapli cfg will not open or close the\n        underlying scrapli connection and will raise an exception if the scrapli connection\n        is not open. If `True` will automatically open and close the scrapli connection when\n        using with a context manager, `prepare` will open the scrapli connection (if not\n        already open), and `close` will close the scrapli connection.\n    ignore_version: ignore checking device version support; currently this just means that\n        scrapli-cfg will not fetch the device version during the prepare phase, however this\n        will (hopefully) be used in the future to limit what methods can be used against a\n        target device. For example, for EOS devices we need &gt; 4.14 to load configs; so if a\n        device is encountered at 4.13 the version check would raise an exception rather than\n        just failing in a potentially awkward fashion.\n\nReturns:\n    None\n\nRaises:\n    N/A\n</code></pre> Expand source code <pre>\n        <code>\nclass AsyncScrapliCfgJunos(AsyncScrapliCfgPlatform, ScrapliCfgJunosBase):\n    def __init__(\n        self,\n        conn: AsyncNetworkDriver,\n        *,\n        config_sources: Optional[List[str]] = None,\n        on_prepare: Optional[Callable[..., Any]] = None,\n        filesystem: str = \"/config/\",\n        cleanup_post_commit: bool = True,\n        dedicated_connection: bool = False,\n        ignore_version: bool = False,\n    ) -&gt; None:\n        if config_sources is None:\n            config_sources = CONFIG_SOURCES\n\n        super().__init__(\n            conn=conn,\n            config_sources=config_sources,\n            on_prepare=on_prepare,\n            dedicated_connection=dedicated_connection,\n            ignore_version=ignore_version,\n        )\n\n        self.filesystem = filesystem\n\n        self._replace = False\n        self._set = False\n\n        self.candidate_config_filename = \"\"\n        self._in_configuration_session = False\n\n        self.cleanup_post_commit = cleanup_post_commit\n\n    async def _delete_candidate_config(self) -&gt; Response:\n        \"\"\"\n        Delete candidate config from the filesystem\n\n        Args:\n            N/A\n\n        Returns:\n            Response: response from deleting the candidate config\n\n        Raises:\n            N/A\n\n        \"\"\"\n        delete_result = await self.conn.send_config(\n            config=f\"rm {self.filesystem}{self.candidate_config_filename}\",\n            privilege_level=\"root_shell\",\n        )\n        return delete_result\n\n    async def get_version(self) -&gt; ScrapliCfgResponse:\n        response = self._pre_get_version()\n\n        version_result = await self.conn.send_command(command=\"show version | grep junos:\")\n\n        return self._post_get_version(\n            response=response,\n            scrapli_responses=[version_result],\n            result=self._parse_version(device_output=version_result.result),\n        )\n\n    async def get_config(self, source: str = \"running\") -&gt; ScrapliCfgResponse:\n        response = self._pre_get_config(source=source)\n\n        if self._in_configuration_session is True:\n            config_result = await self.conn.send_config(config=\"run show configuration\")\n        else:\n            config_result = await self.conn.send_command(command=\"show configuration\")\n\n        return self._post_get_config(\n            response=response,\n            source=source,\n            scrapli_responses=[config_result],\n            result=config_result.result,\n        )\n\n    async def load_config(\n        self, config: str, replace: bool = False, **kwargs: Any\n    ) -&gt; ScrapliCfgResponse:\n        \"\"\"\n        Load configuration to a device\n\n        Supported kwargs:\n            set: bool indicating config is a \"set\" style config (ignored if replace is True)\n\n        Args:\n            config: string of the configuration to load\n            replace: replace the configuration or not, if false configuration will be loaded as a\n                merge operation\n            kwargs: additional kwargs that the implementing classes may need for their platform,\n                see above for junos supported kwargs\n\n        Returns:\n            ScrapliCfgResponse: response object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self._set = kwargs.get(\"set\", False)\n\n        response = self._pre_load_config(config=config)\n\n        config = self._prepare_load_config(config=config, replace=replace)\n\n        config_result = await self.conn.send_config(config=config, privilege_level=\"root_shell\")\n\n        if self._replace is True:\n            load_config = f\"load override {self.filesystem}{self.candidate_config_filename}\"\n        else:\n            if self._set is True:\n                load_config = f\"load set {self.filesystem}{self.candidate_config_filename}\"\n            else:\n                load_config = f\"load merge {self.filesystem}{self.candidate_config_filename}\"\n\n        load_result = await self.conn.send_config(config=load_config)\n        self._in_configuration_session = True\n\n        return self._post_load_config(\n            response=response,\n            scrapli_responses=[config_result, load_result],\n        )\n\n    async def abort_config(self) -&gt; ScrapliCfgResponse:\n        response = self._pre_abort_config(\n            session_or_config_file=bool(self.candidate_config_filename)\n        )\n\n        rollback_result = await self.conn.send_config(config=\"rollback 0\")\n        abort_result = await self._delete_candidate_config()\n        self._reset_config_session()\n\n        return self._post_abort_config(\n            response=response, scrapli_responses=[rollback_result, abort_result]\n        )\n\n    async def commit_config(self, source: str = \"running\") -&gt; ScrapliCfgResponse:\n        scrapli_responses = []\n        response = self._pre_commit_config(\n            source=source, session_or_config_file=bool(self.candidate_config_filename)\n        )\n\n        commit_result = await self.conn.send_config(config=\"commit\")\n        scrapli_responses.append(commit_result)\n\n        if self.cleanup_post_commit:\n            cleanup_result = await self._delete_candidate_config()\n            scrapli_responses.append(cleanup_result)\n\n        self._reset_config_session()\n\n        return self._post_load_config(\n            response=response,\n            scrapli_responses=scrapli_responses,\n        )\n\n    async def diff_config(self, source: str = \"running\") -&gt; ScrapliCfgDiffResponse:\n        scrapli_responses = []\n        device_diff = \"\"\n        source_config = \"\"\n\n        diff_response = self._pre_diff_config(\n            source=source, session_or_config_file=bool(self.candidate_config_filename)\n        )\n\n        try:\n            diff_result = await self.conn.send_config(config=\"show | compare\")\n            scrapli_responses.append(diff_result)\n            if diff_result.failed:\n                msg = \"failed generating diff for config session\"\n                self.logger.critical(msg)\n                raise DiffConfigError(msg)\n\n            device_diff = diff_result.result\n\n            source_config_result = await self.get_config(source=source)\n            source_config = source_config_result.result\n\n            if isinstance(source_config_result.scrapli_responses, MultiResponse):\n                # in this case this will always be a multiresponse or nothing (failure) but mypy\n                # doesnt know that, hence the isinstance check\n                scrapli_responses.extend(source_config_result.scrapli_responses)\n\n            if source_config_result.failed:\n                msg = \"failed fetching source config for diff comparison\"\n                self.logger.critical(msg)\n                raise DiffConfigError(msg)\n\n        except DiffConfigError:\n            pass\n\n        return self._post_diff_config(\n            diff_response=diff_response,\n            scrapli_responses=scrapli_responses,\n            source_config=self.clean_config(source_config),\n            candidate_config=self.clean_config(self.candidate_config),\n            device_diff=device_diff,\n        )\n        </code>\n    </pre>"},{"location":"api_docs/platform/core/juniper_junos/async_platform/#ancestors-in-mro","title":"Ancestors (in MRO)","text":"<ul> <li>scrapli_cfg.platform.base.async_platform.AsyncScrapliCfgPlatform</li> <li>abc.ABC</li> <li>scrapli_cfg.platform.base.base_platform.ScrapliCfgBase</li> <li>scrapli_cfg.platform.core.juniper_junos.base_platform.ScrapliCfgJunosBase</li> </ul>"},{"location":"api_docs/platform/core/juniper_junos/async_platform/#class-variables","title":"Class variables","text":"<p><code>conn: Union[scrapli.driver.network.sync_driver.NetworkDriver,\u00a0scrapli.driver.network.async_driver.AsyncNetworkDriver]</code></p>"},{"location":"api_docs/platform/core/juniper_junos/async_platform/#methods","title":"Methods","text":""},{"location":"api_docs/platform/core/juniper_junos/async_platform/#load_config","title":"load_config","text":"<p><code>load_config(self, config:\u00a0str, replace:\u00a0bool\u00a0=\u00a0False, **kwargs:\u00a0Any) \u2011&gt; scrapli_cfg.response.ScrapliCfgResponse</code></p> <pre><code>Load configuration to a device\n\nSupported kwargs:\n    set: bool indicating config is a \"set\" style config (ignored if replace is True)\n\nArgs:\n    config: string of the configuration to load\n    replace: replace the configuration or not, if false configuration will be loaded as a\n        merge operation\n    kwargs: additional kwargs that the implementing classes may need for their platform,\n        see above for junos supported kwargs\n\nReturns:\n    ScrapliCfgResponse: response object\n\nRaises:\n    N/A\n</code></pre>"},{"location":"api_docs/platform/core/juniper_junos/base_platform/","title":"Base platform","text":"window.addEventListener('DOMContentLoaded', () =&gt; hljs.initHighlighting())"},{"location":"api_docs/platform/core/juniper_junos/base_platform/#module-scrapli_cfgplatformcorejuniper_junosbase_platform","title":"Module scrapli_cfg.platform.core.juniper_junos.base_platform","text":"<p>scrapli_cfg.platform.core.juniper_junos.base_platform</p> Expand source code <pre>\n        <code>\n\"\"\"scrapli_cfg.platform.core.juniper_junos.base_platform\"\"\"\nimport re\nfrom datetime import datetime\nfrom logging import Logger, LoggerAdapter\nfrom typing import TYPE_CHECKING\n\nfrom scrapli_cfg.helper import strip_blank_lines\nfrom scrapli_cfg.platform.core.juniper_junos.patterns import (\n    EDIT_PATTERN,\n    OUTPUT_HEADER_PATTERN,\n    VERSION_PATTERN,\n)\n\nif TYPE_CHECKING:\n    LoggerAdapterT = LoggerAdapter[Logger]  # pylint:disable=E1136\nelse:\n    LoggerAdapterT = LoggerAdapter\n\n\nCONFIG_SOURCES = [\n    \"running\",\n]\n\n\nclass ScrapliCfgJunosBase:\n    logger: LoggerAdapterT\n    candidate_config: str\n    candidate_config_filename: str\n    _in_configuration_session: bool\n    _replace: bool\n    _set: bool\n    filesystem: str\n\n    @staticmethod\n    def _parse_version(device_output: str) -&gt; str:\n        \"\"\"\n        Parse version string out of device output\n\n        Args:\n            device_output: output from show version command\n\n        Returns:\n            str: device version string\n\n        Raises:\n            N/A\n\n        \"\"\"\n        version_string_search = re.search(pattern=VERSION_PATTERN, string=device_output)\n\n        if not version_string_search:\n            return \"\"\n\n        version_string = version_string_search.group(0) or \"\"\n        return version_string\n\n    def _reset_config_session(self) -&gt; None:\n        \"\"\"\n        Reset config session info\n\n        Resets the candidate config and config session name attributes -- when these are \"empty\" we\n        know there is no current config session\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.logger.debug(\"resetting candidate config and candidate config file name\")\n        self.candidate_config = \"\"\n        self.candidate_config_filename = \"\"\n        self._in_configuration_session = False\n        self._set = False\n\n    def _prepare_config_payloads(self, config: str) -&gt; str:\n        \"\"\"\n        Prepare a configuration so it can be nicely sent to the device via scrapli\n\n        Args:\n            config: configuration to prep\n\n        Returns:\n            str: string of config lines to write to candidate config file\n\n        Raises:\n            N/A\n\n        \"\"\"\n        final_config_list = []\n        for config_line in config.splitlines():\n            final_config_list.append(\n                f\"echo &gt;&gt; {self.filesystem}{self.candidate_config_filename} '{config_line}'\"\n            )\n\n        final_config = \"\\n\".join(final_config_list)\n\n        return final_config\n\n    def _prepare_load_config(self, config: str, replace: bool) -&gt; str:\n        \"\"\"\n        Handle pre \"load_config\" operations for parity between sync and async\n\n        Args:\n            config: candidate config to load\n            replace: True/False replace the configuration; passed here so it can be set at the class\n                level as we need to stay in config mode and we need to know if we are doing a merge\n                or a replace when we go to diff things\n\n        Returns:\n            str: string of config to write to candidate config file\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.candidate_config = config\n\n        if not self.candidate_config_filename:\n            self.candidate_config_filename = f\"scrapli_cfg_{round(datetime.now().timestamp())}\"\n            self.logger.debug(\n                f\"candidate config file name will be '{self.candidate_config_filename}'\"\n            )\n\n        config = self._prepare_config_payloads(config=config)\n        self._replace = replace\n\n        return config\n\n    def clean_config(self, config: str) -&gt; str:\n        \"\"\"\n        Clean a configuration file of unwanted lines\n\n        Args:\n            config: configuration string to \"clean\"\n\n        Returns:\n            str: cleaned configuration string\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.logger.debug(\"cleaning config file\")\n\n        config = re.sub(pattern=OUTPUT_HEADER_PATTERN, string=config, repl=\"\")\n        config = re.sub(pattern=EDIT_PATTERN, string=config, repl=\"\")\n        return strip_blank_lines(config=config)\n        </code>\n    </pre>"},{"location":"api_docs/platform/core/juniper_junos/base_platform/#classes","title":"Classes","text":""},{"location":"api_docs/platform/core/juniper_junos/base_platform/#scraplicfgjunosbase","title":"ScrapliCfgJunosBase","text":"Expand source code <pre>\n        <code>\nclass ScrapliCfgJunosBase:\n    logger: LoggerAdapterT\n    candidate_config: str\n    candidate_config_filename: str\n    _in_configuration_session: bool\n    _replace: bool\n    _set: bool\n    filesystem: str\n\n    @staticmethod\n    def _parse_version(device_output: str) -&gt; str:\n        \"\"\"\n        Parse version string out of device output\n\n        Args:\n            device_output: output from show version command\n\n        Returns:\n            str: device version string\n\n        Raises:\n            N/A\n\n        \"\"\"\n        version_string_search = re.search(pattern=VERSION_PATTERN, string=device_output)\n\n        if not version_string_search:\n            return \"\"\n\n        version_string = version_string_search.group(0) or \"\"\n        return version_string\n\n    def _reset_config_session(self) -&gt; None:\n        \"\"\"\n        Reset config session info\n\n        Resets the candidate config and config session name attributes -- when these are \"empty\" we\n        know there is no current config session\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.logger.debug(\"resetting candidate config and candidate config file name\")\n        self.candidate_config = \"\"\n        self.candidate_config_filename = \"\"\n        self._in_configuration_session = False\n        self._set = False\n\n    def _prepare_config_payloads(self, config: str) -&gt; str:\n        \"\"\"\n        Prepare a configuration so it can be nicely sent to the device via scrapli\n\n        Args:\n            config: configuration to prep\n\n        Returns:\n            str: string of config lines to write to candidate config file\n\n        Raises:\n            N/A\n\n        \"\"\"\n        final_config_list = []\n        for config_line in config.splitlines():\n            final_config_list.append(\n                f\"echo &gt;&gt; {self.filesystem}{self.candidate_config_filename} '{config_line}'\"\n            )\n\n        final_config = \"\\n\".join(final_config_list)\n\n        return final_config\n\n    def _prepare_load_config(self, config: str, replace: bool) -&gt; str:\n        \"\"\"\n        Handle pre \"load_config\" operations for parity between sync and async\n\n        Args:\n            config: candidate config to load\n            replace: True/False replace the configuration; passed here so it can be set at the class\n                level as we need to stay in config mode and we need to know if we are doing a merge\n                or a replace when we go to diff things\n\n        Returns:\n            str: string of config to write to candidate config file\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.candidate_config = config\n\n        if not self.candidate_config_filename:\n            self.candidate_config_filename = f\"scrapli_cfg_{round(datetime.now().timestamp())}\"\n            self.logger.debug(\n                f\"candidate config file name will be '{self.candidate_config_filename}'\"\n            )\n\n        config = self._prepare_config_payloads(config=config)\n        self._replace = replace\n\n        return config\n\n    def clean_config(self, config: str) -&gt; str:\n        \"\"\"\n        Clean a configuration file of unwanted lines\n\n        Args:\n            config: configuration string to \"clean\"\n\n        Returns:\n            str: cleaned configuration string\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.logger.debug(\"cleaning config file\")\n\n        config = re.sub(pattern=OUTPUT_HEADER_PATTERN, string=config, repl=\"\")\n        config = re.sub(pattern=EDIT_PATTERN, string=config, repl=\"\")\n        return strip_blank_lines(config=config)\n        </code>\n    </pre>"},{"location":"api_docs/platform/core/juniper_junos/base_platform/#descendants","title":"Descendants","text":"<ul> <li>scrapli_cfg.platform.core.juniper_junos.async_platform.AsyncScrapliCfgJunos</li> <li>scrapli_cfg.platform.core.juniper_junos.sync_platform.ScrapliCfgJunos</li> </ul>"},{"location":"api_docs/platform/core/juniper_junos/base_platform/#class-variables","title":"Class variables","text":"<p><code>candidate_config: str</code></p> <p><code>candidate_config_filename: str</code></p> <p><code>filesystem: str</code></p> <p><code>logger: logging.LoggerAdapter</code></p>"},{"location":"api_docs/platform/core/juniper_junos/base_platform/#methods","title":"Methods","text":""},{"location":"api_docs/platform/core/juniper_junos/base_platform/#clean_config","title":"clean_config","text":"<p><code>clean_config(self, config:\u00a0str) \u2011&gt; str</code></p> <pre><code>Clean a configuration file of unwanted lines\n\nArgs:\n    config: configuration string to \"clean\"\n\nReturns:\n    str: cleaned configuration string\n\nRaises:\n    N/A\n</code></pre>"},{"location":"api_docs/platform/core/juniper_junos/patterns/","title":"Patterns","text":"window.addEventListener('DOMContentLoaded', () =&gt; hljs.initHighlighting())"},{"location":"api_docs/platform/core/juniper_junos/patterns/#module-scrapli_cfgplatformcorejuniper_junospatterns","title":"Module scrapli_cfg.platform.core.juniper_junos.patterns","text":"<p>scrapli_cfg.platform.core.juniper_junos.patterns</p> Expand source code <pre>\n        <code>\n\"\"\"scrapli_cfg.platform.core.juniper_junos.patterns\"\"\"\nimport re\n\nVERSION_PATTERN = re.compile(\n    # should match at least versions looking like:\n    # 17.3R2.10\n    # 18.1R3-S2.5\n    pattern=r\"\\d+\\.[\\w-]+\\.\\w+\",\n)\nOUTPUT_HEADER_PATTERN = re.compile(pattern=r\"^## last commit.*$\\nversion.*$\", flags=re.M | re.I)\nEDIT_PATTERN = re.compile(pattern=r\"^\\[edit\\]$\", flags=re.M)\n        </code>\n    </pre>"},{"location":"api_docs/platform/core/juniper_junos/sync_platform/","title":"Sync Platform","text":"window.addEventListener('DOMContentLoaded', () =&gt; hljs.initHighlighting())"},{"location":"api_docs/platform/core/juniper_junos/sync_platform/#module-scrapli_cfgplatformcorejuniper_junossync_platform","title":"Module scrapli_cfg.platform.core.juniper_junos.sync_platform","text":"<p>scrapli_cfg.platform.core.juniper_junos.sync_platform</p> Expand source code <pre>\n        <code>\n\"\"\"scrapli_cfg.platform.core.juniper_junos.sync_platform\"\"\"\nfrom typing import Any, Callable, List, Optional\n\nfrom scrapli.driver import NetworkDriver\nfrom scrapli.response import MultiResponse, Response\nfrom scrapli_cfg.diff import ScrapliCfgDiffResponse\nfrom scrapli_cfg.exceptions import DiffConfigError\nfrom scrapli_cfg.platform.base.sync_platform import ScrapliCfgPlatform\nfrom scrapli_cfg.platform.core.juniper_junos.base_platform import (\n    CONFIG_SOURCES,\n    ScrapliCfgJunosBase,\n)\nfrom scrapli_cfg.response import ScrapliCfgResponse\n\n\nclass ScrapliCfgJunos(ScrapliCfgPlatform, ScrapliCfgJunosBase):\n    def __init__(\n        self,\n        conn: NetworkDriver,\n        *,\n        config_sources: Optional[List[str]] = None,\n        on_prepare: Optional[Callable[..., Any]] = None,\n        filesystem: str = \"/config/\",\n        cleanup_post_commit: bool = True,\n        dedicated_connection: bool = False,\n        ignore_version: bool = False,\n    ) -&gt; None:\n        if config_sources is None:\n            config_sources = CONFIG_SOURCES\n\n        super().__init__(\n            conn=conn,\n            config_sources=config_sources,\n            on_prepare=on_prepare,\n            dedicated_connection=dedicated_connection,\n            ignore_version=ignore_version,\n        )\n\n        self.filesystem = filesystem\n\n        self._replace = False\n        self._set = False\n\n        self.candidate_config_filename = \"\"\n        self._in_configuration_session = False\n\n        self.cleanup_post_commit = cleanup_post_commit\n\n    def _delete_candidate_config(self) -&gt; Response:\n        \"\"\"\n        Delete candidate config from the filesystem\n\n        Args:\n            N/A\n\n        Returns:\n            Response: response from deleting the candidate config\n\n        Raises:\n            N/A\n\n        \"\"\"\n        delete_result = self.conn.send_config(\n            config=f\"rm {self.filesystem}{self.candidate_config_filename}\",\n            privilege_level=\"root_shell\",\n        )\n        return delete_result\n\n    def get_version(self) -&gt; ScrapliCfgResponse:\n        response = self._pre_get_version()\n\n        version_result = self.conn.send_command(command=\"show version | grep junos:\")\n\n        return self._post_get_version(\n            response=response,\n            scrapli_responses=[version_result],\n            result=self._parse_version(device_output=version_result.result),\n        )\n\n    def get_config(self, source: str = \"running\") -&gt; ScrapliCfgResponse:\n        response = self._pre_get_config(source=source)\n\n        if self._in_configuration_session is True:\n            config_result = self.conn.send_config(config=\"run show configuration\")\n        else:\n            config_result = self.conn.send_command(command=\"show configuration\")\n\n        return self._post_get_config(\n            response=response,\n            source=source,\n            scrapli_responses=[config_result],\n            result=config_result.result,\n        )\n\n    def load_config(self, config: str, replace: bool = False, **kwargs: Any) -&gt; ScrapliCfgResponse:\n        \"\"\"\n        Load configuration to a device\n\n        Supported kwargs:\n            set: bool indicating config is a \"set\" style config (ignored if replace is True)\n\n        Args:\n            config: string of the configuration to load\n            replace: replace the configuration or not, if false configuration will be loaded as a\n                merge operation\n            kwargs: additional kwargs that the implementing classes may need for their platform,\n                see above for junos supported kwargs\n\n        Returns:\n            ScrapliCfgResponse: response object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self._set = kwargs.get(\"set\", False)\n\n        response = self._pre_load_config(config=config)\n\n        config = self._prepare_load_config(config=config, replace=replace)\n\n        config_result = self.conn.send_config(config=config, privilege_level=\"root_shell\")\n\n        if self._replace is True:\n            load_config = f\"load override {self.filesystem}{self.candidate_config_filename}\"\n        else:\n            if self._set is True:\n                load_config = f\"load set {self.filesystem}{self.candidate_config_filename}\"\n            else:\n                load_config = f\"load merge {self.filesystem}{self.candidate_config_filename}\"\n\n        load_result = self.conn.send_config(config=load_config)\n        self._in_configuration_session = True\n\n        return self._post_load_config(\n            response=response,\n            scrapli_responses=[config_result, load_result],\n        )\n\n    def abort_config(self) -&gt; ScrapliCfgResponse:\n        response = self._pre_abort_config(\n            session_or_config_file=bool(self.candidate_config_filename)\n        )\n\n        rollback_result = self.conn.send_config(config=\"rollback 0\")\n        abort_result = self._delete_candidate_config()\n        self._reset_config_session()\n\n        return self._post_abort_config(\n            response=response, scrapli_responses=[rollback_result, abort_result]\n        )\n\n    def commit_config(self, source: str = \"running\") -&gt; ScrapliCfgResponse:\n        scrapli_responses = []\n        response = self._pre_commit_config(\n            source=source, session_or_config_file=bool(self.candidate_config_filename)\n        )\n\n        commit_result = self.conn.send_config(config=\"commit\")\n        scrapli_responses.append(commit_result)\n\n        if self.cleanup_post_commit:\n            cleanup_result = self._delete_candidate_config()\n            scrapli_responses.append(cleanup_result)\n\n        self._reset_config_session()\n\n        return self._post_load_config(\n            response=response,\n            scrapli_responses=scrapli_responses,\n        )\n\n    def diff_config(self, source: str = \"running\") -&gt; ScrapliCfgDiffResponse:\n        scrapli_responses = []\n        device_diff = \"\"\n        source_config = \"\"\n\n        diff_response = self._pre_diff_config(\n            source=source, session_or_config_file=bool(self.candidate_config_filename)\n        )\n\n        try:\n            diff_result = self.conn.send_config(config=\"show | compare\")\n            scrapli_responses.append(diff_result)\n            if diff_result.failed:\n                msg = \"failed generating diff for config session\"\n                self.logger.critical(msg)\n                raise DiffConfigError(msg)\n\n            device_diff = diff_result.result\n\n            source_config_result = self.get_config(source=source)\n            source_config = source_config_result.result\n\n            if isinstance(source_config_result.scrapli_responses, MultiResponse):\n                # in this case this will always be a multiresponse or nothing (failure) but mypy\n                # doesnt know that, hence the isinstance check\n                scrapli_responses.extend(source_config_result.scrapli_responses)\n\n            if source_config_result.failed:\n                msg = \"failed fetching source config for diff comparison\"\n                self.logger.critical(msg)\n                raise DiffConfigError(msg)\n\n        except DiffConfigError:\n            pass\n\n        return self._post_diff_config(\n            diff_response=diff_response,\n            scrapli_responses=scrapli_responses,\n            source_config=self.clean_config(source_config),\n            candidate_config=self.clean_config(self.candidate_config),\n            device_diff=device_diff,\n        )\n        </code>\n    </pre>"},{"location":"api_docs/platform/core/juniper_junos/sync_platform/#classes","title":"Classes","text":""},{"location":"api_docs/platform/core/juniper_junos/sync_platform/#scraplicfgjunos","title":"ScrapliCfgJunos","text":"<pre><code>Helper class that provides a standard way to create an ABC using\ninheritance.\n\nScrapli Config base class\n\nArgs:\n    conn: scrapli connection to use\n    config_sources: list of config sources\n    on_prepare: optional callable to run at connection `prepare`\n    dedicated_connection: if `False` (default value) scrapli cfg will not open or close the\n        underlying scrapli connection and will raise an exception if the scrapli connection\n        is not open. If `True` will automatically open and close the scrapli connection when\n        using with a context manager, `prepare` will open the scrapli connection (if not\n        already open), and `close` will close the scrapli connection.\n    ignore_version: ignore checking device version support; currently this just means that\n        scrapli-cfg will not fetch the device version during the prepare phase, however this\n        will (hopefully) be used in the future to limit what methods can be used against a\n        target device. For example, for EOS devices we need &gt; 4.14 to load configs; so if a\n        device is encountered at 4.13 the version check would raise an exception rather than\n        just failing in a potentially awkward fashion.\n\nReturns:\n    None\n\nRaises:\n    N/A\n</code></pre> Expand source code <pre>\n        <code>\nclass ScrapliCfgJunos(ScrapliCfgPlatform, ScrapliCfgJunosBase):\n    def __init__(\n        self,\n        conn: NetworkDriver,\n        *,\n        config_sources: Optional[List[str]] = None,\n        on_prepare: Optional[Callable[..., Any]] = None,\n        filesystem: str = \"/config/\",\n        cleanup_post_commit: bool = True,\n        dedicated_connection: bool = False,\n        ignore_version: bool = False,\n    ) -&gt; None:\n        if config_sources is None:\n            config_sources = CONFIG_SOURCES\n\n        super().__init__(\n            conn=conn,\n            config_sources=config_sources,\n            on_prepare=on_prepare,\n            dedicated_connection=dedicated_connection,\n            ignore_version=ignore_version,\n        )\n\n        self.filesystem = filesystem\n\n        self._replace = False\n        self._set = False\n\n        self.candidate_config_filename = \"\"\n        self._in_configuration_session = False\n\n        self.cleanup_post_commit = cleanup_post_commit\n\n    def _delete_candidate_config(self) -&gt; Response:\n        \"\"\"\n        Delete candidate config from the filesystem\n\n        Args:\n            N/A\n\n        Returns:\n            Response: response from deleting the candidate config\n\n        Raises:\n            N/A\n\n        \"\"\"\n        delete_result = self.conn.send_config(\n            config=f\"rm {self.filesystem}{self.candidate_config_filename}\",\n            privilege_level=\"root_shell\",\n        )\n        return delete_result\n\n    def get_version(self) -&gt; ScrapliCfgResponse:\n        response = self._pre_get_version()\n\n        version_result = self.conn.send_command(command=\"show version | grep junos:\")\n\n        return self._post_get_version(\n            response=response,\n            scrapli_responses=[version_result],\n            result=self._parse_version(device_output=version_result.result),\n        )\n\n    def get_config(self, source: str = \"running\") -&gt; ScrapliCfgResponse:\n        response = self._pre_get_config(source=source)\n\n        if self._in_configuration_session is True:\n            config_result = self.conn.send_config(config=\"run show configuration\")\n        else:\n            config_result = self.conn.send_command(command=\"show configuration\")\n\n        return self._post_get_config(\n            response=response,\n            source=source,\n            scrapli_responses=[config_result],\n            result=config_result.result,\n        )\n\n    def load_config(self, config: str, replace: bool = False, **kwargs: Any) -&gt; ScrapliCfgResponse:\n        \"\"\"\n        Load configuration to a device\n\n        Supported kwargs:\n            set: bool indicating config is a \"set\" style config (ignored if replace is True)\n\n        Args:\n            config: string of the configuration to load\n            replace: replace the configuration or not, if false configuration will be loaded as a\n                merge operation\n            kwargs: additional kwargs that the implementing classes may need for their platform,\n                see above for junos supported kwargs\n\n        Returns:\n            ScrapliCfgResponse: response object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self._set = kwargs.get(\"set\", False)\n\n        response = self._pre_load_config(config=config)\n\n        config = self._prepare_load_config(config=config, replace=replace)\n\n        config_result = self.conn.send_config(config=config, privilege_level=\"root_shell\")\n\n        if self._replace is True:\n            load_config = f\"load override {self.filesystem}{self.candidate_config_filename}\"\n        else:\n            if self._set is True:\n                load_config = f\"load set {self.filesystem}{self.candidate_config_filename}\"\n            else:\n                load_config = f\"load merge {self.filesystem}{self.candidate_config_filename}\"\n\n        load_result = self.conn.send_config(config=load_config)\n        self._in_configuration_session = True\n\n        return self._post_load_config(\n            response=response,\n            scrapli_responses=[config_result, load_result],\n        )\n\n    def abort_config(self) -&gt; ScrapliCfgResponse:\n        response = self._pre_abort_config(\n            session_or_config_file=bool(self.candidate_config_filename)\n        )\n\n        rollback_result = self.conn.send_config(config=\"rollback 0\")\n        abort_result = self._delete_candidate_config()\n        self._reset_config_session()\n\n        return self._post_abort_config(\n            response=response, scrapli_responses=[rollback_result, abort_result]\n        )\n\n    def commit_config(self, source: str = \"running\") -&gt; ScrapliCfgResponse:\n        scrapli_responses = []\n        response = self._pre_commit_config(\n            source=source, session_or_config_file=bool(self.candidate_config_filename)\n        )\n\n        commit_result = self.conn.send_config(config=\"commit\")\n        scrapli_responses.append(commit_result)\n\n        if self.cleanup_post_commit:\n            cleanup_result = self._delete_candidate_config()\n            scrapli_responses.append(cleanup_result)\n\n        self._reset_config_session()\n\n        return self._post_load_config(\n            response=response,\n            scrapli_responses=scrapli_responses,\n        )\n\n    def diff_config(self, source: str = \"running\") -&gt; ScrapliCfgDiffResponse:\n        scrapli_responses = []\n        device_diff = \"\"\n        source_config = \"\"\n\n        diff_response = self._pre_diff_config(\n            source=source, session_or_config_file=bool(self.candidate_config_filename)\n        )\n\n        try:\n            diff_result = self.conn.send_config(config=\"show | compare\")\n            scrapli_responses.append(diff_result)\n            if diff_result.failed:\n                msg = \"failed generating diff for config session\"\n                self.logger.critical(msg)\n                raise DiffConfigError(msg)\n\n            device_diff = diff_result.result\n\n            source_config_result = self.get_config(source=source)\n            source_config = source_config_result.result\n\n            if isinstance(source_config_result.scrapli_responses, MultiResponse):\n                # in this case this will always be a multiresponse or nothing (failure) but mypy\n                # doesnt know that, hence the isinstance check\n                scrapli_responses.extend(source_config_result.scrapli_responses)\n\n            if source_config_result.failed:\n                msg = \"failed fetching source config for diff comparison\"\n                self.logger.critical(msg)\n                raise DiffConfigError(msg)\n\n        except DiffConfigError:\n            pass\n\n        return self._post_diff_config(\n            diff_response=diff_response,\n            scrapli_responses=scrapli_responses,\n            source_config=self.clean_config(source_config),\n            candidate_config=self.clean_config(self.candidate_config),\n            device_diff=device_diff,\n        )\n        </code>\n    </pre>"},{"location":"api_docs/platform/core/juniper_junos/sync_platform/#ancestors-in-mro","title":"Ancestors (in MRO)","text":"<ul> <li>scrapli_cfg.platform.base.sync_platform.ScrapliCfgPlatform</li> <li>abc.ABC</li> <li>scrapli_cfg.platform.base.base_platform.ScrapliCfgBase</li> <li>scrapli_cfg.platform.core.juniper_junos.base_platform.ScrapliCfgJunosBase</li> </ul>"},{"location":"api_docs/platform/core/juniper_junos/sync_platform/#class-variables","title":"Class variables","text":"<p><code>conn: Union[scrapli.driver.network.sync_driver.NetworkDriver,\u00a0scrapli.driver.network.async_driver.AsyncNetworkDriver]</code></p>"},{"location":"api_docs/platform/core/juniper_junos/sync_platform/#methods","title":"Methods","text":""},{"location":"api_docs/platform/core/juniper_junos/sync_platform/#load_config","title":"load_config","text":"<p><code>load_config(self, config:\u00a0str, replace:\u00a0bool\u00a0=\u00a0False, **kwargs:\u00a0Any) \u2011&gt; scrapli_cfg.response.ScrapliCfgResponse</code></p> <pre><code>Load configuration to a device\n\nSupported kwargs:\n    set: bool indicating config is a \"set\" style config (ignored if replace is True)\n\nArgs:\n    config: string of the configuration to load\n    replace: replace the configuration or not, if false configuration will be loaded as a\n        merge operation\n    kwargs: additional kwargs that the implementing classes may need for their platform,\n        see above for junos supported kwargs\n\nReturns:\n    ScrapliCfgResponse: response object\n\nRaises:\n    N/A\n</code></pre>"},{"location":"more_scrapli/nornir_scrapli/","title":"Nornir scrapli","text":"<p>If you want to use scrapli, but don't want to deal with handling concurrency yourself, there is great news! The  nornir_scrapli plugin allows you to use scrapli (and scrapli netconf  and scrapli cfg) within the Nornir framework!</p>"},{"location":"more_scrapli/scrapli/","title":"Scrapli","text":"<p>scrapli (docs) is the  \"parent\" scrapli library. Check it out if you need to connect to devices with telnet or ssh!</p>"},{"location":"more_scrapli/scrapli_community/","title":"Scrapli Community","text":"<p>If you would like to use scrapli, but the platform(s) that you work with are not supported in the \"core\" scrapli  platforms, you should check out scrapli_community! This is the place  for users to share \"non-core\" scrapli platforms.</p>"},{"location":"more_scrapli/scrapli_netconf/","title":"Scrapli Netconf","text":"<p>scrapli_netconf (docs)  is a netconf driver built on top of scrapli. The purpose of scrapli_netconf is to provide a fast, flexible,  thoroughly tested, well typed, well documented, simple API that supports both synchronous and asynchronous usage.  Working together scrapli and scrapli_netconf aim to provide a consistent (as is practical) look and feel when  automating devices over telnet, SSH, or netconf (over SSH).</p>"},{"location":"more_scrapli/scrapli_replay/","title":"Scrapli Replay","text":"<p>scrapli_replay (docs)  is a set of tools used to help test scrapli programs. scrapli_replay includes a utility to capture command  input/output from real life servers and replay them in a semi-interactive fashion, as well as a pytest plugin that  patches and records and replays session data (like vcr.py) for scrapli connections. </p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>diff</li> <li>exceptions</li> <li>factory</li> <li>helper</li> <li>logging</li> <li>platform<ul> <li>base<ul> <li>async_platform</li> <li>base_platform</li> <li>sync_platform</li> </ul> </li> <li>core<ul> <li>arista_eos<ul> <li>async_platform</li> <li>base_platform</li> <li>patterns</li> <li>sync_platform</li> </ul> </li> <li>cisco_iosxe<ul> <li>async_platform</li> <li>base_platform</li> <li>patterns</li> <li>sync_platform</li> </ul> </li> <li>cisco_iosxr<ul> <li>async_platform</li> <li>base_platform</li> <li>patterns</li> <li>sync_platform</li> </ul> </li> <li>cisco_nxos<ul> <li>async_platform</li> <li>base_platform</li> <li>patterns</li> <li>sync_platform</li> </ul> </li> <li>juniper_junos<ul> <li>async_platform</li> <li>base_platform</li> <li>patterns</li> <li>sync_platform</li> </ul> </li> </ul> </li> </ul> </li> <li>response</li> </ul>"},{"location":"reference/diff/","title":"Diff","text":"<p>scrapli_cfg.diff</p>"},{"location":"reference/diff/#diff.ScrapliCfgDiffResponse","title":"<code>ScrapliCfgDiffResponse</code>","text":"<p>         Bases: <code>ScrapliCfgResponse</code></p> Source code in <code>scrapli_cfg/diff.py</code> <pre><code>class ScrapliCfgDiffResponse(ScrapliCfgResponse):\n    def __init__(\n        self, host: str, source: str, colorize: bool = True, side_by_side_diff_width: int = 0\n    ) -&gt; None:\n\"\"\"\n        Scrapli config diff object\n\n        Args:\n            host: host the diff is for\n            source: source config store from the device, typically running|startup\n            colorize: True/False colorize diff output\n            side_by_side_diff_width: width to use to generate the side-by-side diff, if not provided\n                will fetch the current terminal width\n\n        Returns:\n            N/A\n\n        Raises:\n            N/A\n\n        \"\"\"\n        super().__init__(host=host, raise_for_status_exception=DiffConfigError)\n\n        self.colorize = colorize\n        self.side_by_side_diff_width = side_by_side_diff_width\n\n        self.source = source\n        self.source_config = \"\"\n        self.candidate_config = \"\"\n        self.device_diff = \"\"\n\n        self._difflines: List[str] = []\n        self.additions = \"\"\n        self.subtractions = \"\"\n\n        self._unified_diff = \"\"\n        self._side_by_side_diff = \"\"\n\n    def __repr__(self) -&gt; str:\n\"\"\"\n        Magic repr method for ScrapliCfgResponse class\n\n        Args:\n            N/A\n\n        Returns:\n            str: repr for class object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        return f\"ScrapliCfgDiffResponse &lt;Success: {str(not self.failed)}&gt;\"\n\n    def __str__(self) -&gt; str:\n\"\"\"\n        Magic str method for ScrapliCfgDiffResponse class\n\n        Args:\n            N/A\n\n        Returns:\n            str: str for class object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        return f\"ScrapliCfgDiffResponse &lt;Success: {str(not self.failed)}&gt;\"\n\n    def record_diff_response(\n        self, source_config: str, candidate_config: str, device_diff: str\n    ) -&gt; None:\n\"\"\"\n        Scrapli config diff object\n\n        Args:\n            source_config: the actual contents of the source config\n            candidate_config: the scrapli_cfg candidate config\n            device_diff: diff generated by the device itself (if applicable)\n\n        Returns:\n            N/A\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.source_config = source_config\n        self.candidate_config = candidate_config\n        self.device_diff = device_diff\n\n        _differ = difflib.Differ()\n        self._difflines = list(\n            _differ.compare(\n                self.source_config.splitlines(keepends=True),\n                self.candidate_config.splitlines(keepends=True),\n            )\n        )\n\n        self.additions = \"\".join([line[2:] for line in self._difflines if line[:2] == \"+ \"])\n        self.subtractions = \"\".join([line[2:] for line in self._difflines if line[:2] == \"- \"])\n\n    def _generate_colors(self) -&gt; Tuple[str, str, str, str]:\n\"\"\"\n        Generate the necessary strings for colorizing or not output\n\n        Args:\n            N/A\n\n        Returns:\n            tuple: tuple of strings for colorizing (or not) output\n\n        Raises:\n            N/A\n\n        \"\"\"\n        yellow = YELLOW if self.colorize else \"? \"\n        red = RED if self.colorize else \"- \"\n        green = GREEN if self.colorize else \"+ \"\n        end = END_COLOR if self.colorize else \"\"\n        return yellow, red, green, end\n\n    @property\n    def side_by_side_diff(self) -&gt; str:\n\"\"\"\n        Generate a side-by-side diff of source vs candidate\n\n        Args:\n            N/A\n\n        Returns:\n            str: unified diff text\n\n        Raises:\n            N/A\n\n        \"\"\"\n        if self._side_by_side_diff:\n            return self._side_by_side_diff\n\n        yellow, red, green, end = self._generate_colors()\n\n        term_width = self.side_by_side_diff_width or shutil.get_terminal_size().columns\n        half_term_width = int(term_width / 2)\n        diff_side_width = int(half_term_width - 5)\n\n        side_by_side_diff_lines = []\n        for line in self._difflines:\n            if line[:2] == \"? \":\n                current = (\n                    yellow + f\"{line[2:][:diff_side_width].rstrip() : &lt;{half_term_width}}\" + end\n                )\n                candidate = yellow + f\"{line[2:][:diff_side_width].rstrip()}\" + end\n            elif line[:2] == \"- \":\n                current = red + f\"{line[2:][:diff_side_width].rstrip() : &lt;{half_term_width}}\" + end\n                candidate = \"\"\n            elif line[:2] == \"+ \":\n                current = f\"{'' : &lt;{half_term_width}}\"\n                candidate = green + f\"{line[2:][:diff_side_width].rstrip()}\" + end\n            else:\n                current = f\"{line[2:][:diff_side_width].rstrip() : &lt;{half_term_width}}\"\n                candidate = f\"{line[2:][:diff_side_width].rstrip()}\"\n\n            side_by_side_diff_lines.append(current + candidate)\n\n        joined_side_by_side_diff = \"\\n\".join(side_by_side_diff_lines)\n\n        self._side_by_side_diff = joined_side_by_side_diff\n\n        return self._side_by_side_diff\n\n    @property\n    def unified_diff(self) -&gt; str:\n\"\"\"\n        Generate a unified diff of source vs candidate\n\n        Args:\n            N/A\n\n        Returns:\n            str: unified diff text\n\n        Raises:\n            N/A\n\n        \"\"\"\n        if self._unified_diff:\n            return self._unified_diff\n\n        yellow, red, green, end = self._generate_colors()\n\n        unified_diff = [\n            yellow + line[2:] + end\n            if line[:2] == \"? \"\n            else red + line[2:] + end\n            if line[:2] == \"- \"\n            else green + line[2:] + end\n            if line[:2] == \"+ \"\n            else line[2:]\n            for line in self._difflines\n        ]\n        joined_unified_diff = \"\".join(unified_diff)\n\n        self._unified_diff = joined_unified_diff\n\n        return self._unified_diff\n</code></pre>"},{"location":"reference/diff/#diff.ScrapliCfgDiffResponse.__init__","title":"<code>__init__(host: str, source: str, colorize: bool = True, side_by_side_diff_width: int = 0) -&gt; None</code>","text":"<p>Scrapli config diff object</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>host the diff is for</p> required <code>source</code> <code>str</code> <p>source config store from the device, typically running|startup</p> required <code>colorize</code> <code>bool</code> <p>True/False colorize diff output</p> <code>True</code> <code>side_by_side_diff_width</code> <code>int</code> <p>width to use to generate the side-by-side diff, if not provided will fetch the current terminal width</p> <code>0</code> <p>Returns:</p> Type Description <code>None</code> <p>N/A</p> Source code in <code>scrapli_cfg/diff.py</code> <pre><code>def __init__(\n    self, host: str, source: str, colorize: bool = True, side_by_side_diff_width: int = 0\n) -&gt; None:\n\"\"\"\n    Scrapli config diff object\n\n    Args:\n        host: host the diff is for\n        source: source config store from the device, typically running|startup\n        colorize: True/False colorize diff output\n        side_by_side_diff_width: width to use to generate the side-by-side diff, if not provided\n            will fetch the current terminal width\n\n    Returns:\n        N/A\n\n    Raises:\n        N/A\n\n    \"\"\"\n    super().__init__(host=host, raise_for_status_exception=DiffConfigError)\n\n    self.colorize = colorize\n    self.side_by_side_diff_width = side_by_side_diff_width\n\n    self.source = source\n    self.source_config = \"\"\n    self.candidate_config = \"\"\n    self.device_diff = \"\"\n\n    self._difflines: List[str] = []\n    self.additions = \"\"\n    self.subtractions = \"\"\n\n    self._unified_diff = \"\"\n    self._side_by_side_diff = \"\"\n</code></pre>"},{"location":"reference/diff/#diff.ScrapliCfgDiffResponse.__repr__","title":"<code>__repr__() -&gt; str</code>","text":"<p>Magic repr method for ScrapliCfgResponse class</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>repr for class object</p> Source code in <code>scrapli_cfg/diff.py</code> <pre><code>def __repr__(self) -&gt; str:\n\"\"\"\n    Magic repr method for ScrapliCfgResponse class\n\n    Args:\n        N/A\n\n    Returns:\n        str: repr for class object\n\n    Raises:\n        N/A\n\n    \"\"\"\n    return f\"ScrapliCfgDiffResponse &lt;Success: {str(not self.failed)}&gt;\"\n</code></pre>"},{"location":"reference/diff/#diff.ScrapliCfgDiffResponse.__str__","title":"<code>__str__() -&gt; str</code>","text":"<p>Magic str method for ScrapliCfgDiffResponse class</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>str for class object</p> Source code in <code>scrapli_cfg/diff.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"\n    Magic str method for ScrapliCfgDiffResponse class\n\n    Args:\n        N/A\n\n    Returns:\n        str: str for class object\n\n    Raises:\n        N/A\n\n    \"\"\"\n    return f\"ScrapliCfgDiffResponse &lt;Success: {str(not self.failed)}&gt;\"\n</code></pre>"},{"location":"reference/diff/#diff.ScrapliCfgDiffResponse.record_diff_response","title":"<code>record_diff_response(source_config: str, candidate_config: str, device_diff: str) -&gt; None</code>","text":"<p>Scrapli config diff object</p> <p>Parameters:</p> Name Type Description Default <code>source_config</code> <code>str</code> <p>the actual contents of the source config</p> required <code>candidate_config</code> <code>str</code> <p>the scrapli_cfg candidate config</p> required <code>device_diff</code> <code>str</code> <p>diff generated by the device itself (if applicable)</p> required <p>Returns:</p> Type Description <code>None</code> <p>N/A</p> Source code in <code>scrapli_cfg/diff.py</code> <pre><code>def record_diff_response(\n    self, source_config: str, candidate_config: str, device_diff: str\n) -&gt; None:\n\"\"\"\n    Scrapli config diff object\n\n    Args:\n        source_config: the actual contents of the source config\n        candidate_config: the scrapli_cfg candidate config\n        device_diff: diff generated by the device itself (if applicable)\n\n    Returns:\n        N/A\n\n    Raises:\n        N/A\n\n    \"\"\"\n    self.source_config = source_config\n    self.candidate_config = candidate_config\n    self.device_diff = device_diff\n\n    _differ = difflib.Differ()\n    self._difflines = list(\n        _differ.compare(\n            self.source_config.splitlines(keepends=True),\n            self.candidate_config.splitlines(keepends=True),\n        )\n    )\n\n    self.additions = \"\".join([line[2:] for line in self._difflines if line[:2] == \"+ \"])\n    self.subtractions = \"\".join([line[2:] for line in self._difflines if line[:2] == \"- \"])\n</code></pre>"},{"location":"reference/diff/#diff.ScrapliCfgDiffResponse.side_by_side_diff","title":"<code>side_by_side_diff() -&gt; str</code>  <code>property</code>","text":"<p>Generate a side-by-side diff of source vs candidate</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>unified diff text</p> Source code in <code>scrapli_cfg/diff.py</code> <pre><code>@property\ndef side_by_side_diff(self) -&gt; str:\n\"\"\"\n    Generate a side-by-side diff of source vs candidate\n\n    Args:\n        N/A\n\n    Returns:\n        str: unified diff text\n\n    Raises:\n        N/A\n\n    \"\"\"\n    if self._side_by_side_diff:\n        return self._side_by_side_diff\n\n    yellow, red, green, end = self._generate_colors()\n\n    term_width = self.side_by_side_diff_width or shutil.get_terminal_size().columns\n    half_term_width = int(term_width / 2)\n    diff_side_width = int(half_term_width - 5)\n\n    side_by_side_diff_lines = []\n    for line in self._difflines:\n        if line[:2] == \"? \":\n            current = (\n                yellow + f\"{line[2:][:diff_side_width].rstrip() : &lt;{half_term_width}}\" + end\n            )\n            candidate = yellow + f\"{line[2:][:diff_side_width].rstrip()}\" + end\n        elif line[:2] == \"- \":\n            current = red + f\"{line[2:][:diff_side_width].rstrip() : &lt;{half_term_width}}\" + end\n            candidate = \"\"\n        elif line[:2] == \"+ \":\n            current = f\"{'' : &lt;{half_term_width}}\"\n            candidate = green + f\"{line[2:][:diff_side_width].rstrip()}\" + end\n        else:\n            current = f\"{line[2:][:diff_side_width].rstrip() : &lt;{half_term_width}}\"\n            candidate = f\"{line[2:][:diff_side_width].rstrip()}\"\n\n        side_by_side_diff_lines.append(current + candidate)\n\n    joined_side_by_side_diff = \"\\n\".join(side_by_side_diff_lines)\n\n    self._side_by_side_diff = joined_side_by_side_diff\n\n    return self._side_by_side_diff\n</code></pre>"},{"location":"reference/diff/#diff.ScrapliCfgDiffResponse.unified_diff","title":"<code>unified_diff() -&gt; str</code>  <code>property</code>","text":"<p>Generate a unified diff of source vs candidate</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>unified diff text</p> Source code in <code>scrapli_cfg/diff.py</code> <pre><code>@property\ndef unified_diff(self) -&gt; str:\n\"\"\"\n    Generate a unified diff of source vs candidate\n\n    Args:\n        N/A\n\n    Returns:\n        str: unified diff text\n\n    Raises:\n        N/A\n\n    \"\"\"\n    if self._unified_diff:\n        return self._unified_diff\n\n    yellow, red, green, end = self._generate_colors()\n\n    unified_diff = [\n        yellow + line[2:] + end\n        if line[:2] == \"? \"\n        else red + line[2:] + end\n        if line[:2] == \"- \"\n        else green + line[2:] + end\n        if line[:2] == \"+ \"\n        else line[2:]\n        for line in self._difflines\n    ]\n    joined_unified_diff = \"\".join(unified_diff)\n\n    self._unified_diff = joined_unified_diff\n\n    return self._unified_diff\n</code></pre>"},{"location":"reference/exceptions/","title":"Exceptions","text":"<p>scrapli_cfg.exceptions</p>"},{"location":"reference/exceptions/#exceptions.AbortConfigError","title":"<code>AbortConfigError</code>","text":"<p>         Bases: <code>ConfigError</code></p> <p>For errors aborting a configuration</p> Source code in <code>scrapli_cfg/exceptions.py</code> <pre><code>class AbortConfigError(ConfigError):\n\"\"\"For errors aborting a configuration\"\"\"\n</code></pre>"},{"location":"reference/exceptions/#exceptions.CleanupError","title":"<code>CleanupError</code>","text":"<p>         Bases: <code>ScrapliCfgException</code></p> <p>For errors during cleanup (i.e. removing candidate config, etc.)</p> Source code in <code>scrapli_cfg/exceptions.py</code> <pre><code>class CleanupError(ScrapliCfgException):\n\"\"\"For errors during cleanup (i.e. removing candidate config, etc.)\"\"\"\n</code></pre>"},{"location":"reference/exceptions/#exceptions.CommitConfigError","title":"<code>CommitConfigError</code>","text":"<p>         Bases: <code>ConfigError</code></p> <p>For errors committing a configuration</p> Source code in <code>scrapli_cfg/exceptions.py</code> <pre><code>class CommitConfigError(ConfigError):\n\"\"\"For errors committing a configuration\"\"\"\n</code></pre>"},{"location":"reference/exceptions/#exceptions.ConfigError","title":"<code>ConfigError</code>","text":"<p>         Bases: <code>ScrapliCfgException</code></p> <p>For configuration operation related errors</p> Source code in <code>scrapli_cfg/exceptions.py</code> <pre><code>class ConfigError(ScrapliCfgException):\n\"\"\"For configuration operation related errors\"\"\"\n</code></pre>"},{"location":"reference/exceptions/#exceptions.DiffConfigError","title":"<code>DiffConfigError</code>","text":"<p>         Bases: <code>ConfigError</code></p> <p>For errors diffing a configuration</p> Source code in <code>scrapli_cfg/exceptions.py</code> <pre><code>class DiffConfigError(ConfigError):\n\"\"\"For errors diffing a configuration\"\"\"\n</code></pre>"},{"location":"reference/exceptions/#exceptions.FailedToDetermineDeviceState","title":"<code>FailedToDetermineDeviceState</code>","text":"<p>         Bases: <code>ScrapliCfgException</code></p> <p>For issues determining device state (i.e. what mode is file prompt in, etc.)</p> Source code in <code>scrapli_cfg/exceptions.py</code> <pre><code>class FailedToDetermineDeviceState(ScrapliCfgException):\n\"\"\"For issues determining device state (i.e. what mode is file prompt in, etc.)\"\"\"\n</code></pre>"},{"location":"reference/exceptions/#exceptions.FailedToFetchSpaceAvailable","title":"<code>FailedToFetchSpaceAvailable</code>","text":"<p>         Bases: <code>ConfigError</code></p> <p>Unable to determine space available on filesystem</p> Source code in <code>scrapli_cfg/exceptions.py</code> <pre><code>class FailedToFetchSpaceAvailable(ConfigError):\n\"\"\"Unable to determine space available on filesystem\"\"\"\n</code></pre>"},{"location":"reference/exceptions/#exceptions.GetConfigError","title":"<code>GetConfigError</code>","text":"<p>         Bases: <code>ConfigError</code></p> <p>For errors getting configuration from a device</p> Source code in <code>scrapli_cfg/exceptions.py</code> <pre><code>class GetConfigError(ConfigError):\n\"\"\"For errors getting configuration from a device\"\"\"\n</code></pre>"},{"location":"reference/exceptions/#exceptions.InsufficientSpaceAvailable","title":"<code>InsufficientSpaceAvailable</code>","text":"<p>         Bases: <code>ConfigError</code></p> <p>If space available on filesystem is insufficient</p> Source code in <code>scrapli_cfg/exceptions.py</code> <pre><code>class InsufficientSpaceAvailable(ConfigError):\n\"\"\"If space available on filesystem is insufficient\"\"\"\n</code></pre>"},{"location":"reference/exceptions/#exceptions.InvalidConfigTarget","title":"<code>InvalidConfigTarget</code>","text":"<p>         Bases: <code>ConfigError</code></p> <p>User has provided an invalid configuration target</p> Source code in <code>scrapli_cfg/exceptions.py</code> <pre><code>class InvalidConfigTarget(ConfigError):\n\"\"\"User has provided an invalid configuration target\"\"\"\n</code></pre>"},{"location":"reference/exceptions/#exceptions.LoadConfigError","title":"<code>LoadConfigError</code>","text":"<p>         Bases: <code>ConfigError</code></p> <p>For errors loading a configuration</p> Source code in <code>scrapli_cfg/exceptions.py</code> <pre><code>class LoadConfigError(ConfigError):\n\"\"\"For errors loading a configuration\"\"\"\n</code></pre>"},{"location":"reference/exceptions/#exceptions.PrepareNotCalled","title":"<code>PrepareNotCalled</code>","text":"<p>         Bases: <code>ScrapliCfgException</code></p> <p>Raised when the <code>prepare</code> method has not been called</p> <p>This will only be raised in two scenarios: 1) an <code>on_prepare</code> callable has been provided, yet <code>prepare</code> was not called 2) <code>ignore_version</code> is False and <code>prepare</code> was not called</p> <p>If using a context manager this should never be raised as the enter method will handle things for you</p> Source code in <code>scrapli_cfg/exceptions.py</code> <pre><code>class PrepareNotCalled(ScrapliCfgException):\n\"\"\"\n    Raised when the `prepare` method has not been called\n\n    This will only be raised in two scenarios:\n    1) an `on_prepare` callable has been provided, yet `prepare` was not called\n    2) `ignore_version` is False and `prepare` was not called\n\n    If using a context manager this should never be raised as the enter method will handle things\n    for you\n    \"\"\"\n</code></pre>"},{"location":"reference/exceptions/#exceptions.ScrapliCfgException","title":"<code>ScrapliCfgException</code>","text":"<p>         Bases: <code>ScrapliException</code></p> <p>Base scrapli_cfg exception</p> Source code in <code>scrapli_cfg/exceptions.py</code> <pre><code>class ScrapliCfgException(ScrapliException):\n\"\"\"Base scrapli_cfg exception\"\"\"\n</code></pre>"},{"location":"reference/exceptions/#exceptions.TemplateError","title":"<code>TemplateError</code>","text":"<p>         Bases: <code>ScrapliCfgException</code></p> <p>For errors relating to configuration templates</p> Source code in <code>scrapli_cfg/exceptions.py</code> <pre><code>class TemplateError(ScrapliCfgException):\n\"\"\"For errors relating to configuration templates\"\"\"\n</code></pre>"},{"location":"reference/exceptions/#exceptions.VersionError","title":"<code>VersionError</code>","text":"<p>         Bases: <code>ScrapliCfgException</code></p> <p>For errors related to getting/parsing/invalid versions</p> Source code in <code>scrapli_cfg/exceptions.py</code> <pre><code>class VersionError(ScrapliCfgException):\n\"\"\"For errors related to getting/parsing/invalid versions\"\"\"\n</code></pre>"},{"location":"reference/factory/","title":"Factory","text":"<p>scrapli_cfg.factory</p>"},{"location":"reference/factory/#factory.AsyncScrapliCfg","title":"<code>AsyncScrapliCfg(conn: AsyncNetworkDriver, *, config_sources: Optional[List[str]] = None, on_prepare: Optional[Callable[..., Any]] = None, dedicated_connection: bool = False, ignore_version: bool = False, **kwargs: Any) -&gt; AsyncScrapliCfgPlatform</code>","text":"<p>Scrapli Config Async Factory</p> <p>Return a async scrapli config object for the provided platform. Prefer to use factory classes just so that the naming convention (w/ upper case things) is \"right\", but given that the class version inherited from the base ScrapliCfgPlatform and did not implement the abstract methods this felt like a better move.</p> <p>Parameters:</p> Name Type Description Default <code>conn</code> <code>AsyncNetworkDriver</code> <p>scrapli connection to use</p> required <code>config_sources</code> <code>Optional[List[str]]</code> <p>list of config sources</p> <code>None</code> <code>on_prepare</code> <code>Optional[Callable[..., Any]]</code> <p>optional callable to run at connection <code>prepare</code></p> <code>None</code> <code>dedicated_connection</code> <code>bool</code> <p>if <code>False</code> (default value) scrapli cfg will not open or close the underlying scrapli connection and will raise an exception if the scrapli connection is not open. If <code>True</code> will automatically open and close the scrapli connection when using with a context manager, <code>prepare</code> will open the scrapli connection (if not already open), and <code>close</code> will close the scrapli connection.</p> <code>False</code> <code>ignore_version</code> <code>bool</code> <p>ignore checking device version support; currently this just means that scrapli-cfg will not fetch the device version during the prepare phase, however this will (hopefully) be used in the future to limit what methods can be used against a target device. For example, for EOS devices we need &gt; 4.14 to load configs; so if a device is encountered at 4.13 the version check would raise an exception rather than just failing in a potentially awkward fashion.</p> <code>False</code> <code>kwargs</code> <p>keyword args to pass to the scrapli_cfg object (for things like iosxe 'filesystem' argument)</p> required <p>Returns:</p> Name Type Description <code>AsyncScrapliCfg</code> <code>AsyncScrapliCfgPlatform</code> <p>async scrapli cfg object</p> <p>Raises:</p> Type Description <code>ScrapliCfgException</code> <p>if provided connection object is sync</p> <code>ScrapliCfgException</code> <p>if provided connection object is async but is not a supported (\"core\") platform type</p> Source code in <code>scrapli_cfg/factory.py</code> <pre><code>def AsyncScrapliCfg(\n    conn: AsyncNetworkDriver,\n    *,\n    config_sources: Optional[List[str]] = None,\n    on_prepare: Optional[Callable[..., Any]] = None,\n    dedicated_connection: bool = False,\n    ignore_version: bool = False,\n    **kwargs: Any,\n) -&gt; \"AsyncScrapliCfgPlatform\":\n\"\"\"\n    Scrapli Config Async Factory\n\n    Return a async scrapli config object for the provided platform. Prefer to use factory classes\n    just so that the naming convention (w/ upper case things) is \"right\", but given that the class\n    version inherited from the base ScrapliCfgPlatform and did not implement the abstract methods\n    this felt like a better move.\n\n    Args:\n        conn: scrapli connection to use\n        config_sources: list of config sources\n        on_prepare: optional callable to run at connection `prepare`\n        dedicated_connection: if `False` (default value) scrapli cfg will not open or close the\n            underlying scrapli connection and will raise an exception if the scrapli connection\n            is not open. If `True` will automatically open and close the scrapli connection when\n            using with a context manager, `prepare` will open the scrapli connection (if not\n            already open), and `close` will close the scrapli connection.\n        ignore_version: ignore checking device version support; currently this just means that\n            scrapli-cfg will not fetch the device version during the prepare phase, however this\n            will (hopefully) be used in the future to limit what methods can be used against a\n            target device. For example, for EOS devices we need &gt; 4.14 to load configs; so if a\n            device is encountered at 4.13 the version check would raise an exception rather than\n            just failing in a potentially awkward fashion.\n        kwargs: keyword args to pass to the scrapli_cfg object (for things like iosxe 'filesystem'\n            argument)\n\n    Returns:\n        AsyncScrapliCfg: async scrapli cfg object\n\n    Raises:\n        ScrapliCfgException: if provided connection object is sync\n        ScrapliCfgException: if provided connection object is async but is not a supported (\"core\")\n            platform type\n\n    \"\"\"\n    logger.debug(\"AsyncScrapliCfg factory initialized\")\n\n    if isinstance(conn, NetworkDriver):\n        raise ScrapliCfgException(\n            \"provided scrapli connection is sync but using 'AsyncScrapliCfg' -- you must use an \"\n            \"async connection with 'AsyncScrapliCfg'!\"\n        )\n\n    platform_class = ASYNC_CORE_PLATFORM_MAP.get(type(conn))\n    if not platform_class:\n        raise ScrapliCfgException(\n            f\"scrapli connection object type '{type(conn)}' not a supported scrapli-cfg type\"\n        )\n\n    final_platform: \"AsyncScrapliCfgPlatform\" = platform_class(\n        conn=conn,\n        config_sources=config_sources,\n        on_prepare=on_prepare,\n        dedicated_connection=dedicated_connection,\n        ignore_version=ignore_version,\n        **kwargs,\n    )\n\n    return final_platform\n</code></pre>"},{"location":"reference/factory/#factory.ScrapliCfg","title":"<code>ScrapliCfg(conn: NetworkDriver, *, config_sources: Optional[List[str]] = None, on_prepare: Optional[Callable[..., Any]] = None, dedicated_connection: bool = False, ignore_version: bool = False, **kwargs: Any) -&gt; ScrapliCfgPlatform</code>","text":"<p>Scrapli Config Sync Factory</p> <p>Return a sync scrapli config object for the provided platform. Prefer to use factory classes just so that the naming convention (w/ upper case things) is \"right\", but given that the class version inherited from the base ScrapliCfgPlatform and did not implement the abstract methods this felt like a better move.</p> <p>Parameters:</p> Name Type Description Default <code>conn</code> <code>NetworkDriver</code> <p>scrapli connection to use</p> required <code>config_sources</code> <code>Optional[List[str]]</code> <p>list of config sources</p> <code>None</code> <code>on_prepare</code> <code>Optional[Callable[..., Any]]</code> <p>optional callable to run at connection <code>prepare</code></p> <code>None</code> <code>dedicated_connection</code> <code>bool</code> <p>if <code>False</code> (default value) scrapli cfg will not open or close the underlying scrapli connection and will raise an exception if the scrapli connection is not open. If <code>True</code> will automatically open and close the scrapli connection when using with a context manager, <code>prepare</code> will open the scrapli connection (if not already open), and <code>close</code> will close the scrapli connection.</p> <code>False</code> <code>ignore_version</code> <code>bool</code> <p>ignore checking device version support; currently this just means that scrapli-cfg will not fetch the device version during the prepare phase, however this will (hopefully) be used in the future to limit what methods can be used against a target device. For example, for EOS devices we need &gt; 4.14 to load configs; so if a device is encountered at 4.13 the version check would raise an exception rather than just failing in a potentially awkward fashion.</p> <code>False</code> <code>kwargs</code> <p>keyword args to pass to the scrapli_cfg object (for things like iosxe 'filesystem' argument)</p> required <p>Returns:</p> Name Type Description <code>ScrapliCfg</code> <code>ScrapliCfgPlatform</code> <p>sync scrapli cfg object</p> <p>Raises:</p> Type Description <code>ScrapliCfgException</code> <p>if provided connection object is async</p> <code>ScrapliCfgException</code> <p>if provided connection object is sync but is not a supported (\"core\") platform type</p> Source code in <code>scrapli_cfg/factory.py</code> <pre><code>def ScrapliCfg(\n    conn: NetworkDriver,\n    *,\n    config_sources: Optional[List[str]] = None,\n    on_prepare: Optional[Callable[..., Any]] = None,\n    dedicated_connection: bool = False,\n    ignore_version: bool = False,\n    **kwargs: Any,\n) -&gt; \"ScrapliCfgPlatform\":\n\"\"\"\n    Scrapli Config Sync Factory\n\n    Return a sync scrapli config object for the provided platform. Prefer to use factory classes\n    just so that the naming convention (w/ upper case things) is \"right\", but given that the class\n    version inherited from the base ScrapliCfgPlatform and did not implement the abstract methods\n    this felt like a better move.\n\n    Args:\n        conn: scrapli connection to use\n        config_sources: list of config sources\n        on_prepare: optional callable to run at connection `prepare`\n        dedicated_connection: if `False` (default value) scrapli cfg will not open or close the\n            underlying scrapli connection and will raise an exception if the scrapli connection\n            is not open. If `True` will automatically open and close the scrapli connection when\n            using with a context manager, `prepare` will open the scrapli connection (if not\n            already open), and `close` will close the scrapli connection.\n        ignore_version: ignore checking device version support; currently this just means that\n            scrapli-cfg will not fetch the device version during the prepare phase, however this\n            will (hopefully) be used in the future to limit what methods can be used against a\n            target device. For example, for EOS devices we need &gt; 4.14 to load configs; so if a\n            device is encountered at 4.13 the version check would raise an exception rather than\n            just failing in a potentially awkward fashion.\n        kwargs: keyword args to pass to the scrapli_cfg object (for things like iosxe 'filesystem'\n            argument)\n\n    Returns:\n        ScrapliCfg: sync scrapli cfg object\n\n    Raises:\n        ScrapliCfgException: if provided connection object is async\n        ScrapliCfgException: if provided connection object is sync but is not a supported (\"core\")\n            platform type\n\n    \"\"\"\n    logger.debug(\"ScrapliCfg factory initialized\")\n\n    if isinstance(conn, AsyncNetworkDriver):\n        raise ScrapliCfgException(\n            \"provided scrapli connection is sync but using 'AsyncScrapliCfg' -- you must use an \"\n            \"async connection with 'AsyncScrapliCfg'!\"\n        )\n\n    platform_class = SYNC_CORE_PLATFORM_MAP.get(type(conn))\n    if not platform_class:\n        raise ScrapliCfgException(\n            f\"scrapli connection object type '{type(conn)}' not a supported scrapli-cfg type\"\n        )\n\n    final_platform: \"ScrapliCfgPlatform\" = platform_class(\n        conn=conn,\n        config_sources=config_sources,\n        on_prepare=on_prepare,\n        dedicated_connection=dedicated_connection,\n        ignore_version=ignore_version,\n        **kwargs,\n    )\n\n    return final_platform\n</code></pre>"},{"location":"reference/helper/","title":"Helper","text":"<p>scrapli_cfg.helper</p>"},{"location":"reference/helper/#helper.strip_blank_lines","title":"<code>strip_blank_lines(config: str) -&gt; str</code>","text":"<p>Strip blank lines out of a config</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>str</code> <p>config to normalize</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>normalized config</p> Source code in <code>scrapli_cfg/helper.py</code> <pre><code>def strip_blank_lines(config: str) -&gt; str:\n\"\"\"\n    Strip blank lines out of a config\n\n    Args:\n        config: config to normalize\n\n    Returns:\n        str: normalized config\n\n    Raises:\n        N/A\n\n    \"\"\"\n    return \"\\n\".join(line for line in config.splitlines() if line)\n</code></pre>"},{"location":"reference/logging/","title":"Logging","text":"<p>scrapli_cfg.logging</p>"},{"location":"reference/logging/#logging.enable_basic_logging","title":"<code>enable_basic_logging(file: Union[str, bool] = False, level: str = 'info', caller_info: bool = False, buffer_log: bool = True) -&gt; None</code>","text":"<p>Enable opinionated logging for scrapli_cfg</p> <p>Uses scrapli \"core\" formatter/file handler</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>Union[str, bool]</code> <p>True to output to default log path (\"scrapli.log\"), otherwise string path to write log file to</p> <code>False</code> <code>level</code> <code>str</code> <p>string name of logging level to use, i.e. \"info\", \"debug\", etc.</p> <code>'info'</code> <code>caller_info</code> <code>bool</code> <p>add info about module/function/line in the log entry</p> <code>False</code> <code>buffer_log</code> <code>bool</code> <p>buffer log read outputs</p> <code>True</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>scrapli_cfg/logging.py</code> <pre><code>def enable_basic_logging(\n    file: Union[str, bool] = False,\n    level: str = \"info\",\n    caller_info: bool = False,\n    buffer_log: bool = True,\n) -&gt; None:\n\"\"\"\n    Enable opinionated logging for scrapli_cfg\n\n    Uses scrapli \"core\" formatter/file handler\n\n    Args:\n        file: True to output to default log path (\"scrapli.log\"), otherwise string path to write log\n            file to\n        level: string name of logging level to use, i.e. \"info\", \"debug\", etc.\n        caller_info: add info about module/function/line in the log entry\n        buffer_log: buffer log read outputs\n\n    Returns:\n        None\n\n    Raises:\n        N/A\n\n    \"\"\"\n    logger.propagate = False\n    logger.setLevel(level=level.upper())\n\n    scrapli_formatter = ScrapliFormatter(caller_info=caller_info)\n\n    if file:\n        if isinstance(file, bool):\n            filename = \"scrapli_cfg.log\"\n        else:\n            filename = file\n\n        if not buffer_log:\n            fh = FileHandler(filename=filename, mode=\"w\")\n        else:\n            fh = ScrapliFileHandler(filename=filename, mode=\"w\")\n\n        fh.setFormatter(scrapli_formatter)\n\n        logger.addHandler(fh)\n</code></pre>"},{"location":"reference/response/","title":"Response","text":"<p>scrapli_cfg.response</p>"},{"location":"reference/response/#response.ScrapliCfgResponse","title":"<code>ScrapliCfgResponse</code>","text":"Source code in <code>scrapli_cfg/response.py</code> <pre><code>class ScrapliCfgResponse:\n    def __init__(\n        self, host: str, raise_for_status_exception: Type[Exception] = ScrapliCfgException\n    ) -&gt; None:\n\"\"\"\n        Scrapli CFG Response object\n\n        Args:\n            host: host that was operated on\n            raise_for_status_exception: exception to raise if response is failed and user calls\n                `raise_for_status`\n\n        Returns:\n            N/A\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.host = host\n        self.start_time = datetime.now()\n        self.finish_time: Optional[datetime] = None\n        self.elapsed_time: Optional[float] = None\n\n        # scrapli_responses is a \"flattened\" list of responses from all operations that were\n        # performed; meaning that if we used any plural operations like send_commands we'll flatten\n        # the MultiResponse bits into a list of singular response objects and store them here\n        self.scrapli_responses: List[Response] = []\n        self.result: str = \"\"\n\n        self.raise_for_status_exception = raise_for_status_exception\n        self.failed = True\n\n    def __bool__(self) -&gt; bool:\n\"\"\"\n        Magic bool method based on operation being failed or not\n\n        Args:\n            N/A\n\n        Returns:\n            bool: True/False if channel_input failed\n\n        Raises:\n            N/A\n\n        \"\"\"\n        return self.failed\n\n    def __repr__(self) -&gt; str:\n\"\"\"\n        Magic repr method for ScrapliCfgResponse class\n\n        Args:\n            N/A\n\n        Returns:\n            str: repr for class object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        return f\"ScrapliCfgResponse &lt;Success: {str(not self.failed)}&gt;\"\n\n    def __str__(self) -&gt; str:\n\"\"\"\n        Magic str method for ScrapliCfgResponse class\n\n        Args:\n            N/A\n\n        Returns:\n            str: str for class object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        return f\"ScrapliCfgResponse &lt;Success: {str(not self.failed)}&gt;\"\n\n    def record_response(\n        self, scrapli_responses: Iterable[Union[Response, MultiResponse]], result: str = \"\"\n    ) -&gt; None:\n\"\"\"\n        Record channel_input results and elapsed time of channel input/reading output\n\n        Args:\n            scrapli_responses: list of scrapli response/multiresponse objects\n            result: string to assign to final result for the scrapli cfg response object\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.finish_time = datetime.now()\n        self.elapsed_time = (self.finish_time - self.start_time).total_seconds()\n\n        for response in scrapli_responses:\n            if isinstance(response, Response):\n                self.scrapli_responses.append(response)\n            elif isinstance(response, MultiResponse):\n                for sub_response in response:\n                    self.scrapli_responses.append(sub_response)\n\n        self.result = result\n\n        if not any(response.failed for response in self.scrapli_responses):\n            self.failed = False\n\n    def raise_for_status(self) -&gt; None:\n\"\"\"\n        Raise a `ScrapliCommandFailure` if command/config failed\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            raise_for_status_exception: exception raised is dependent on the type of response object\n\n        \"\"\"\n        if self.failed:\n            raise self.raise_for_status_exception()\n</code></pre>"},{"location":"reference/response/#response.ScrapliCfgResponse.__bool__","title":"<code>__bool__() -&gt; bool</code>","text":"<p>Magic bool method based on operation being failed or not</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True/False if channel_input failed</p> Source code in <code>scrapli_cfg/response.py</code> <pre><code>def __bool__(self) -&gt; bool:\n\"\"\"\n    Magic bool method based on operation being failed or not\n\n    Args:\n        N/A\n\n    Returns:\n        bool: True/False if channel_input failed\n\n    Raises:\n        N/A\n\n    \"\"\"\n    return self.failed\n</code></pre>"},{"location":"reference/response/#response.ScrapliCfgResponse.__init__","title":"<code>__init__(host: str, raise_for_status_exception: Type[Exception] = ScrapliCfgException) -&gt; None</code>","text":"<p>Scrapli CFG Response object</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>host that was operated on</p> required <code>raise_for_status_exception</code> <code>Type[Exception]</code> <p>exception to raise if response is failed and user calls <code>raise_for_status</code></p> <code>ScrapliCfgException</code> <p>Returns:</p> Type Description <code>None</code> <p>N/A</p> Source code in <code>scrapli_cfg/response.py</code> <pre><code>def __init__(\n    self, host: str, raise_for_status_exception: Type[Exception] = ScrapliCfgException\n) -&gt; None:\n\"\"\"\n    Scrapli CFG Response object\n\n    Args:\n        host: host that was operated on\n        raise_for_status_exception: exception to raise if response is failed and user calls\n            `raise_for_status`\n\n    Returns:\n        N/A\n\n    Raises:\n        N/A\n\n    \"\"\"\n    self.host = host\n    self.start_time = datetime.now()\n    self.finish_time: Optional[datetime] = None\n    self.elapsed_time: Optional[float] = None\n\n    # scrapli_responses is a \"flattened\" list of responses from all operations that were\n    # performed; meaning that if we used any plural operations like send_commands we'll flatten\n    # the MultiResponse bits into a list of singular response objects and store them here\n    self.scrapli_responses: List[Response] = []\n    self.result: str = \"\"\n\n    self.raise_for_status_exception = raise_for_status_exception\n    self.failed = True\n</code></pre>"},{"location":"reference/response/#response.ScrapliCfgResponse.__repr__","title":"<code>__repr__() -&gt; str</code>","text":"<p>Magic repr method for ScrapliCfgResponse class</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>repr for class object</p> Source code in <code>scrapli_cfg/response.py</code> <pre><code>def __repr__(self) -&gt; str:\n\"\"\"\n    Magic repr method for ScrapliCfgResponse class\n\n    Args:\n        N/A\n\n    Returns:\n        str: repr for class object\n\n    Raises:\n        N/A\n\n    \"\"\"\n    return f\"ScrapliCfgResponse &lt;Success: {str(not self.failed)}&gt;\"\n</code></pre>"},{"location":"reference/response/#response.ScrapliCfgResponse.__str__","title":"<code>__str__() -&gt; str</code>","text":"<p>Magic str method for ScrapliCfgResponse class</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>str for class object</p> Source code in <code>scrapli_cfg/response.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"\n    Magic str method for ScrapliCfgResponse class\n\n    Args:\n        N/A\n\n    Returns:\n        str: str for class object\n\n    Raises:\n        N/A\n\n    \"\"\"\n    return f\"ScrapliCfgResponse &lt;Success: {str(not self.failed)}&gt;\"\n</code></pre>"},{"location":"reference/response/#response.ScrapliCfgResponse.raise_for_status","title":"<code>raise_for_status() -&gt; None</code>","text":"<p>Raise a <code>ScrapliCommandFailure</code> if command/config failed</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Raises:</p> Type Description <code>raise_for_status_exception</code> <p>exception raised is dependent on the type of response object</p> Source code in <code>scrapli_cfg/response.py</code> <pre><code>def raise_for_status(self) -&gt; None:\n\"\"\"\n    Raise a `ScrapliCommandFailure` if command/config failed\n\n    Args:\n        N/A\n\n    Returns:\n        None\n\n    Raises:\n        raise_for_status_exception: exception raised is dependent on the type of response object\n\n    \"\"\"\n    if self.failed:\n        raise self.raise_for_status_exception()\n</code></pre>"},{"location":"reference/response/#response.ScrapliCfgResponse.record_response","title":"<code>record_response(scrapli_responses: Iterable[Union[Response, MultiResponse]], result: str = '') -&gt; None</code>","text":"<p>Record channel_input results and elapsed time of channel input/reading output</p> <p>Parameters:</p> Name Type Description Default <code>scrapli_responses</code> <code>Iterable[Union[Response, MultiResponse]]</code> <p>list of scrapli response/multiresponse objects</p> required <code>result</code> <code>str</code> <p>string to assign to final result for the scrapli cfg response object</p> <code>''</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>scrapli_cfg/response.py</code> <pre><code>def record_response(\n    self, scrapli_responses: Iterable[Union[Response, MultiResponse]], result: str = \"\"\n) -&gt; None:\n\"\"\"\n    Record channel_input results and elapsed time of channel input/reading output\n\n    Args:\n        scrapli_responses: list of scrapli response/multiresponse objects\n        result: string to assign to final result for the scrapli cfg response object\n\n    Returns:\n        None\n\n    Raises:\n        N/A\n\n    \"\"\"\n    self.finish_time = datetime.now()\n    self.elapsed_time = (self.finish_time - self.start_time).total_seconds()\n\n    for response in scrapli_responses:\n        if isinstance(response, Response):\n            self.scrapli_responses.append(response)\n        elif isinstance(response, MultiResponse):\n            for sub_response in response:\n                self.scrapli_responses.append(sub_response)\n\n    self.result = result\n\n    if not any(response.failed for response in self.scrapli_responses):\n        self.failed = False\n</code></pre>"},{"location":"reference/platform/","title":"Index","text":"<p>scrapli_cfg.platform</p>"},{"location":"reference/platform/base/","title":"Index","text":"<p>scrapli_cfg.platform.base</p>"},{"location":"reference/platform/base/async_platform/","title":"Async platform","text":"<p>scrapli_cfg.platform.async_platform</p>"},{"location":"reference/platform/base/async_platform/#platform.base.async_platform.AsyncScrapliCfgPlatform","title":"<code>AsyncScrapliCfgPlatform</code>","text":"<p>         Bases: <code>ABC</code>, <code>ScrapliCfgBase</code></p> Source code in <code>platform/base/async_platform.py</code> <pre><code>class AsyncScrapliCfgPlatform(ABC, ScrapliCfgBase):\n    def __init__(\n        self,\n        conn: AsyncNetworkDriver,\n        config_sources: List[str],\n        on_prepare: Optional[Callable[..., Any]],\n        dedicated_connection: bool,\n        ignore_version: bool,\n    ) -&gt; None:\n\"\"\"\n        Scrapli Config async base class\n\n        Args:\n            conn: scrapli connection to use\n            config_sources: list of config sources\n            on_prepare: optional callable to run at connection `prepare`\n            dedicated_connection: if `False` (default value) scrapli cfg will not open or close the\n                underlying scrapli connection and will raise an exception if the scrapli connection\n                is not open. If `True` will automatically open and close the scrapli connection when\n                using with a context manager, `prepare` will open the scrapli connection (if not\n                already open), and `close` will close the scrapli connection.\n            ignore_version: ignore checking device version support; currently this just means that\n                scrapli-cfg will not fetch the device version during the prepare phase, however this\n                will (hopefully) be used in the future to limit what methods can be used against a\n                target device. For example, for EOS devices we need &gt; 4.14 to load configs; so if a\n                device is encountered at 4.13 the version check would raise an exception rather than\n                just failing in a potentially awkward fashion.\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.conn: AsyncNetworkDriver = conn\n        self.dedicated_connection = dedicated_connection\n\n        self.on_prepare = on_prepare\n\n        super().__init__(config_sources=config_sources, ignore_version=ignore_version)\n\n    async def __aenter__(self) -&gt; \"AsyncScrapliCfgPlatform\":\n\"\"\"\n        Enter method for async context manager\n\n        Args:\n            N/A\n\n        Returns:\n            AsyncScrapliCfg: opened AsyncScrapliCfg object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        await self.prepare()\n        return self\n\n    async def __aexit__(\n        self,\n        exception_type: Optional[Type[BaseException]],\n        exception_value: Optional[BaseException],\n        traceback: Optional[TracebackType],\n    ) -&gt; None:\n\"\"\"\n        Exit method to cleanup for async context manager\n\n        Args:\n            exception_type: exception type being raised\n            exception_value: message from exception being raised\n            traceback: traceback from exception being raised\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        await self.cleanup()\n\n    async def _open(self) -&gt; None:\n\"\"\"\n        Handle opening (or raising exception if not open) of underlying scrapli connection\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            ScrapliCfgException: if scrapli connection is not open and auto_open_connection is False\n\n        \"\"\"\n        if self.conn.isalive():\n            return\n\n        if self.dedicated_connection:\n            self.logger.info(\n                \"underlying scrapli connection is not alive... opening scrapli connection\"\n            )\n            await self.conn.open()\n            return\n\n        raise ScrapliCfgException(\n            \"underlying scrapli connection is not open and `dedicated_connection` is False, \"\n            \"cannot continue!\"\n        )\n\n    async def _close(self) -&gt; None:\n\"\"\"\n        Close the scrapli connection\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        if self.dedicated_connection is True and self.conn.isalive():\n            self.logger.info(\"dedicated_connection is True, closing scrapli connection\")\n            await self.conn.close()\n\n    async def prepare(self) -&gt; None:\n\"\"\"\n        Prepare connection for scrapli_cfg operations\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.logger.info(\"preparing scrapli_cfg connection\")\n\n        await self._open()\n\n        if self.ignore_version is False:\n            self.logger.debug(\"ignore_version is False, fetching device version\")\n            version_response = await self.get_version()\n            self._validate_and_set_version(version_response=version_response)\n\n        if self.on_prepare is not None:\n            self.logger.debug(\"on_prepare provided, executing now\")\n            await self.on_prepare(self)\n\n        self._prepared = True\n\n    async def cleanup(self) -&gt; None:\n\"\"\"\n        Cleanup after scrapli-cfg operations\n\n        Generally this can be skipped, however it will be executed if using a context manager. The\n        purpose of this method is to close the underlying scrapli connection (if in\n        \"dedicated_connection\" mode), and to reset the internally used `_version_string`, attribute.\n        All this is done so that this cfg connection, if re-used later (as in later in that script\n        using the same object) starts with a fresh slate.\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        await self._close()\n\n        # reset the version string/prepare flag so we know we need to re-fetch/re-run if user\n        # re-opens connection\n        self._version_string = \"\"\n        self._prepared = False\n\n        # this has *probably* been reset already, but reset it just in case user re-opens connection\n        # we can have a clean slate to work with\n        try:\n            self._reset_config_session()  # type: ignore\n        except AttributeError:\n            pass\n\n    @abstractmethod\n    async def get_version(self) -&gt; ScrapliCfgResponse:\n\"\"\"\n        Get device version string\n\n        Args:\n            N/A\n\n        Returns:\n            ScrapliCfgResponse: response object where result is the string of the primary version\n                (as in the \"main\" os version) of the device\n\n        Raises:\n            N/A\n\n        \"\"\"\n\n    @abstractmethod\n    async def get_config(self, source: str = \"running\") -&gt; ScrapliCfgResponse:\n\"\"\"\n        Get device configuration\n\n        Args:\n            source: name of the config source, generally running|startup\n\n        Returns:\n            ScrapliCfgResponse: response object containing string of the target config source as the\n                `result` attribute\n\n        Raises:\n            N/A\n\n        \"\"\"\n\n    @abstractmethod\n    async def load_config(\n        self, config: str, replace: bool = False, **kwargs: Any\n    ) -&gt; ScrapliCfgResponse:\n\"\"\"\n        Load configuration to a device\n\n        Args:\n            config: string of the configuration to load\n            replace: replace the configuration or not, if false configuration will be loaded as a\n                merge operation\n            kwargs: additional kwargs that the implementing classes may need for their platform,\n                see your specific platform for details\n\n        Returns:\n            ScrapliCfgResponse: response object\n\n        Raises:\n            N/A\n\n        \"\"\"\n\n    @abstractmethod\n    async def abort_config(self) -&gt; ScrapliCfgResponse:\n\"\"\"\n        Abort a configuration -- discards any loaded config\n\n        Args:\n            N/A\n\n        Returns:\n            ScrapliCfgResponse: response object\n\n        Raises:\n            N/A\n\n        \"\"\"\n\n    @abstractmethod\n    async def commit_config(self, source: str = \"running\") -&gt; ScrapliCfgResponse:\n\"\"\"\n        Commit a loaded configuration\n\n        Args:\n            source: name of the config source to commit against, generally running|startup\n\n        Returns:\n            ScrapliCfgResponse: response object\n\n        Raises:\n            N/A\n\n        \"\"\"\n\n    @abstractmethod\n    async def diff_config(self, source: str = \"running\") -&gt; ScrapliCfgDiffResponse:\n\"\"\"\n        Diff a loaded configuration against the source config store\n\n        Args:\n            source: name of the config source to diff against, generally running|startup -- device\n                diffs will generally not care about this argument, but the built in scrapli differ\n                will\n\n        Returns:\n            ScrapliCfgDiffResponse: scrapli cfg diff object\n\n        Raises:\n            N/A\n\n        \"\"\"\n\n    async def render_substituted_config(\n        self,\n        config_template: str,\n        substitutes: List[Tuple[str, Pattern[str]]],\n        source: str = \"running\",\n    ) -&gt; str:\n\"\"\"\n        Render a substituted configuration file\n\n        Renders a configuration based on a user template, substitutes, and a target config from the\n        device.\n\n        Args:\n            config_template: config file to use as the base for substitutions -- should contain\n                jinja2-like variables that will be replaced with data fetched from the source config\n                by the substitutes patterns\n            substitutes: tuple of name, pattern -- where name matches the jinja2-like variable in\n                the config_template file, and pattern is a compiled regular expression pattern to be\n                used to fetch that section from the source config\n            source: config source to use for the substitution efforts, typically running|startup\n\n        Returns:\n            str: substituted/rendered config\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.logger.info(\"fetching configuration and replacing with provided substitutes\")\n\n        source_config = await self.get_config(source=source)\n        return self._render_substituted_config(\n            config_template=config_template,\n            substitutes=substitutes,\n            source_config=source_config.result,\n        )\n</code></pre>"},{"location":"reference/platform/base/async_platform/#platform.base.async_platform.AsyncScrapliCfgPlatform.__aenter__","title":"<code>__aenter__() -&gt; AsyncScrapliCfgPlatform</code>  <code>async</code>","text":"<p>Enter method for async context manager</p> <p>Returns:</p> Name Type Description <code>AsyncScrapliCfg</code> <code>AsyncScrapliCfgPlatform</code> <p>opened AsyncScrapliCfg object</p> Source code in <code>platform/base/async_platform.py</code> <pre><code>async def __aenter__(self) -&gt; \"AsyncScrapliCfgPlatform\":\n\"\"\"\n    Enter method for async context manager\n\n    Args:\n        N/A\n\n    Returns:\n        AsyncScrapliCfg: opened AsyncScrapliCfg object\n\n    Raises:\n        N/A\n\n    \"\"\"\n    await self.prepare()\n    return self\n</code></pre>"},{"location":"reference/platform/base/async_platform/#platform.base.async_platform.AsyncScrapliCfgPlatform.__aexit__","title":"<code>__aexit__(exception_type: Optional[Type[BaseException]], exception_value: Optional[BaseException], traceback: Optional[TracebackType]) -&gt; None</code>  <code>async</code>","text":"<p>Exit method to cleanup for async context manager</p> <p>Parameters:</p> Name Type Description Default <code>exception_type</code> <code>Optional[Type[BaseException]]</code> <p>exception type being raised</p> required <code>exception_value</code> <code>Optional[BaseException]</code> <p>message from exception being raised</p> required <code>traceback</code> <code>Optional[TracebackType]</code> <p>traceback from exception being raised</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>platform/base/async_platform.py</code> <pre><code>async def __aexit__(\n    self,\n    exception_type: Optional[Type[BaseException]],\n    exception_value: Optional[BaseException],\n    traceback: Optional[TracebackType],\n) -&gt; None:\n\"\"\"\n    Exit method to cleanup for async context manager\n\n    Args:\n        exception_type: exception type being raised\n        exception_value: message from exception being raised\n        traceback: traceback from exception being raised\n\n    Returns:\n        None\n\n    Raises:\n        N/A\n\n    \"\"\"\n    await self.cleanup()\n</code></pre>"},{"location":"reference/platform/base/async_platform/#platform.base.async_platform.AsyncScrapliCfgPlatform.__init__","title":"<code>__init__(conn: AsyncNetworkDriver, config_sources: List[str], on_prepare: Optional[Callable[..., Any]], dedicated_connection: bool, ignore_version: bool) -&gt; None</code>","text":"<p>Scrapli Config async base class</p> <p>Parameters:</p> Name Type Description Default <code>conn</code> <code>AsyncNetworkDriver</code> <p>scrapli connection to use</p> required <code>config_sources</code> <code>List[str]</code> <p>list of config sources</p> required <code>on_prepare</code> <code>Optional[Callable[..., Any]]</code> <p>optional callable to run at connection <code>prepare</code></p> required <code>dedicated_connection</code> <code>bool</code> <p>if <code>False</code> (default value) scrapli cfg will not open or close the underlying scrapli connection and will raise an exception if the scrapli connection is not open. If <code>True</code> will automatically open and close the scrapli connection when using with a context manager, <code>prepare</code> will open the scrapli connection (if not already open), and <code>close</code> will close the scrapli connection.</p> required <code>ignore_version</code> <code>bool</code> <p>ignore checking device version support; currently this just means that scrapli-cfg will not fetch the device version during the prepare phase, however this will (hopefully) be used in the future to limit what methods can be used against a target device. For example, for EOS devices we need &gt; 4.14 to load configs; so if a device is encountered at 4.13 the version check would raise an exception rather than just failing in a potentially awkward fashion.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>platform/base/async_platform.py</code> <pre><code>def __init__(\n    self,\n    conn: AsyncNetworkDriver,\n    config_sources: List[str],\n    on_prepare: Optional[Callable[..., Any]],\n    dedicated_connection: bool,\n    ignore_version: bool,\n) -&gt; None:\n\"\"\"\n    Scrapli Config async base class\n\n    Args:\n        conn: scrapli connection to use\n        config_sources: list of config sources\n        on_prepare: optional callable to run at connection `prepare`\n        dedicated_connection: if `False` (default value) scrapli cfg will not open or close the\n            underlying scrapli connection and will raise an exception if the scrapli connection\n            is not open. If `True` will automatically open and close the scrapli connection when\n            using with a context manager, `prepare` will open the scrapli connection (if not\n            already open), and `close` will close the scrapli connection.\n        ignore_version: ignore checking device version support; currently this just means that\n            scrapli-cfg will not fetch the device version during the prepare phase, however this\n            will (hopefully) be used in the future to limit what methods can be used against a\n            target device. For example, for EOS devices we need &gt; 4.14 to load configs; so if a\n            device is encountered at 4.13 the version check would raise an exception rather than\n            just failing in a potentially awkward fashion.\n\n    Returns:\n        None\n\n    Raises:\n        N/A\n\n    \"\"\"\n    self.conn: AsyncNetworkDriver = conn\n    self.dedicated_connection = dedicated_connection\n\n    self.on_prepare = on_prepare\n\n    super().__init__(config_sources=config_sources, ignore_version=ignore_version)\n</code></pre>"},{"location":"reference/platform/base/async_platform/#platform.base.async_platform.AsyncScrapliCfgPlatform.abort_config","title":"<code>abort_config() -&gt; ScrapliCfgResponse</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Abort a configuration -- discards any loaded config</p> <p>Returns:</p> Name Type Description <code>ScrapliCfgResponse</code> <code>ScrapliCfgResponse</code> <p>response object</p> Source code in <code>platform/base/async_platform.py</code> <pre><code>@abstractmethod\nasync def abort_config(self) -&gt; ScrapliCfgResponse:\n\"\"\"\n    Abort a configuration -- discards any loaded config\n\n    Args:\n        N/A\n\n    Returns:\n        ScrapliCfgResponse: response object\n\n    Raises:\n        N/A\n\n    \"\"\"\n</code></pre>"},{"location":"reference/platform/base/async_platform/#platform.base.async_platform.AsyncScrapliCfgPlatform.cleanup","title":"<code>cleanup() -&gt; None</code>  <code>async</code>","text":"<p>Cleanup after scrapli-cfg operations</p> <p>Generally this can be skipped, however it will be executed if using a context manager. The purpose of this method is to close the underlying scrapli connection (if in \"dedicated_connection\" mode), and to reset the internally used <code>_version_string</code>, attribute. All this is done so that this cfg connection, if re-used later (as in later in that script using the same object) starts with a fresh slate.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>platform/base/async_platform.py</code> <pre><code>async def cleanup(self) -&gt; None:\n\"\"\"\n    Cleanup after scrapli-cfg operations\n\n    Generally this can be skipped, however it will be executed if using a context manager. The\n    purpose of this method is to close the underlying scrapli connection (if in\n    \"dedicated_connection\" mode), and to reset the internally used `_version_string`, attribute.\n    All this is done so that this cfg connection, if re-used later (as in later in that script\n    using the same object) starts with a fresh slate.\n\n    Args:\n        N/A\n\n    Returns:\n        None\n\n    Raises:\n        N/A\n\n    \"\"\"\n    await self._close()\n\n    # reset the version string/prepare flag so we know we need to re-fetch/re-run if user\n    # re-opens connection\n    self._version_string = \"\"\n    self._prepared = False\n\n    # this has *probably* been reset already, but reset it just in case user re-opens connection\n    # we can have a clean slate to work with\n    try:\n        self._reset_config_session()  # type: ignore\n    except AttributeError:\n        pass\n</code></pre>"},{"location":"reference/platform/base/async_platform/#platform.base.async_platform.AsyncScrapliCfgPlatform.commit_config","title":"<code>commit_config(source: str = 'running') -&gt; ScrapliCfgResponse</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Commit a loaded configuration</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>name of the config source to commit against, generally running|startup</p> <code>'running'</code> <p>Returns:</p> Name Type Description <code>ScrapliCfgResponse</code> <code>ScrapliCfgResponse</code> <p>response object</p> Source code in <code>platform/base/async_platform.py</code> <pre><code>@abstractmethod\nasync def commit_config(self, source: str = \"running\") -&gt; ScrapliCfgResponse:\n\"\"\"\n    Commit a loaded configuration\n\n    Args:\n        source: name of the config source to commit against, generally running|startup\n\n    Returns:\n        ScrapliCfgResponse: response object\n\n    Raises:\n        N/A\n\n    \"\"\"\n</code></pre>"},{"location":"reference/platform/base/async_platform/#platform.base.async_platform.AsyncScrapliCfgPlatform.diff_config","title":"<code>diff_config(source: str = 'running') -&gt; ScrapliCfgDiffResponse</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Diff a loaded configuration against the source config store</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>name of the config source to diff against, generally running|startup -- device diffs will generally not care about this argument, but the built in scrapli differ will</p> <code>'running'</code> <p>Returns:</p> Name Type Description <code>ScrapliCfgDiffResponse</code> <code>ScrapliCfgDiffResponse</code> <p>scrapli cfg diff object</p> Source code in <code>platform/base/async_platform.py</code> <pre><code>@abstractmethod\nasync def diff_config(self, source: str = \"running\") -&gt; ScrapliCfgDiffResponse:\n\"\"\"\n    Diff a loaded configuration against the source config store\n\n    Args:\n        source: name of the config source to diff against, generally running|startup -- device\n            diffs will generally not care about this argument, but the built in scrapli differ\n            will\n\n    Returns:\n        ScrapliCfgDiffResponse: scrapli cfg diff object\n\n    Raises:\n        N/A\n\n    \"\"\"\n</code></pre>"},{"location":"reference/platform/base/async_platform/#platform.base.async_platform.AsyncScrapliCfgPlatform.get_config","title":"<code>get_config(source: str = 'running') -&gt; ScrapliCfgResponse</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Get device configuration</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>name of the config source, generally running|startup</p> <code>'running'</code> <p>Returns:</p> Name Type Description <code>ScrapliCfgResponse</code> <code>ScrapliCfgResponse</code> <p>response object containing string of the target config source as the <code>result</code> attribute</p> Source code in <code>platform/base/async_platform.py</code> <pre><code>@abstractmethod\nasync def get_config(self, source: str = \"running\") -&gt; ScrapliCfgResponse:\n\"\"\"\n    Get device configuration\n\n    Args:\n        source: name of the config source, generally running|startup\n\n    Returns:\n        ScrapliCfgResponse: response object containing string of the target config source as the\n            `result` attribute\n\n    Raises:\n        N/A\n\n    \"\"\"\n</code></pre>"},{"location":"reference/platform/base/async_platform/#platform.base.async_platform.AsyncScrapliCfgPlatform.get_version","title":"<code>get_version() -&gt; ScrapliCfgResponse</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Get device version string</p> <p>Returns:</p> Name Type Description <code>ScrapliCfgResponse</code> <code>ScrapliCfgResponse</code> <p>response object where result is the string of the primary version (as in the \"main\" os version) of the device</p> Source code in <code>platform/base/async_platform.py</code> <pre><code>@abstractmethod\nasync def get_version(self) -&gt; ScrapliCfgResponse:\n\"\"\"\n    Get device version string\n\n    Args:\n        N/A\n\n    Returns:\n        ScrapliCfgResponse: response object where result is the string of the primary version\n            (as in the \"main\" os version) of the device\n\n    Raises:\n        N/A\n\n    \"\"\"\n</code></pre>"},{"location":"reference/platform/base/async_platform/#platform.base.async_platform.AsyncScrapliCfgPlatform.load_config","title":"<code>load_config(config: str, replace: bool = False, **kwargs: Any) -&gt; ScrapliCfgResponse</code>  <code>abstractmethod</code> <code>async</code>","text":"<p>Load configuration to a device</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>str</code> <p>string of the configuration to load</p> required <code>replace</code> <code>bool</code> <p>replace the configuration or not, if false configuration will be loaded as a merge operation</p> <code>False</code> <code>kwargs</code> <p>additional kwargs that the implementing classes may need for their platform, see your specific platform for details</p> required <p>Returns:</p> Name Type Description <code>ScrapliCfgResponse</code> <code>ScrapliCfgResponse</code> <p>response object</p> Source code in <code>platform/base/async_platform.py</code> <pre><code>@abstractmethod\nasync def load_config(\n    self, config: str, replace: bool = False, **kwargs: Any\n) -&gt; ScrapliCfgResponse:\n\"\"\"\n    Load configuration to a device\n\n    Args:\n        config: string of the configuration to load\n        replace: replace the configuration or not, if false configuration will be loaded as a\n            merge operation\n        kwargs: additional kwargs that the implementing classes may need for their platform,\n            see your specific platform for details\n\n    Returns:\n        ScrapliCfgResponse: response object\n\n    Raises:\n        N/A\n\n    \"\"\"\n</code></pre>"},{"location":"reference/platform/base/async_platform/#platform.base.async_platform.AsyncScrapliCfgPlatform.prepare","title":"<code>prepare() -&gt; None</code>  <code>async</code>","text":"<p>Prepare connection for scrapli_cfg operations</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>platform/base/async_platform.py</code> <pre><code>async def prepare(self) -&gt; None:\n\"\"\"\n    Prepare connection for scrapli_cfg operations\n\n    Args:\n        N/A\n\n    Returns:\n        None\n\n    Raises:\n        N/A\n\n    \"\"\"\n    self.logger.info(\"preparing scrapli_cfg connection\")\n\n    await self._open()\n\n    if self.ignore_version is False:\n        self.logger.debug(\"ignore_version is False, fetching device version\")\n        version_response = await self.get_version()\n        self._validate_and_set_version(version_response=version_response)\n\n    if self.on_prepare is not None:\n        self.logger.debug(\"on_prepare provided, executing now\")\n        await self.on_prepare(self)\n\n    self._prepared = True\n</code></pre>"},{"location":"reference/platform/base/async_platform/#platform.base.async_platform.AsyncScrapliCfgPlatform.render_substituted_config","title":"<code>render_substituted_config(config_template: str, substitutes: List[Tuple[str, Pattern[str]]], source: str = 'running') -&gt; str</code>  <code>async</code>","text":"<p>Render a substituted configuration file</p> <p>Renders a configuration based on a user template, substitutes, and a target config from the device.</p> <p>Parameters:</p> Name Type Description Default <code>config_template</code> <code>str</code> <p>config file to use as the base for substitutions -- should contain jinja2-like variables that will be replaced with data fetched from the source config by the substitutes patterns</p> required <code>substitutes</code> <code>List[Tuple[str, Pattern[str]]]</code> <p>tuple of name, pattern -- where name matches the jinja2-like variable in the config_template file, and pattern is a compiled regular expression pattern to be used to fetch that section from the source config</p> required <code>source</code> <code>str</code> <p>config source to use for the substitution efforts, typically running|startup</p> <code>'running'</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>substituted/rendered config</p> Source code in <code>platform/base/async_platform.py</code> <pre><code>async def render_substituted_config(\n    self,\n    config_template: str,\n    substitutes: List[Tuple[str, Pattern[str]]],\n    source: str = \"running\",\n) -&gt; str:\n\"\"\"\n    Render a substituted configuration file\n\n    Renders a configuration based on a user template, substitutes, and a target config from the\n    device.\n\n    Args:\n        config_template: config file to use as the base for substitutions -- should contain\n            jinja2-like variables that will be replaced with data fetched from the source config\n            by the substitutes patterns\n        substitutes: tuple of name, pattern -- where name matches the jinja2-like variable in\n            the config_template file, and pattern is a compiled regular expression pattern to be\n            used to fetch that section from the source config\n        source: config source to use for the substitution efforts, typically running|startup\n\n    Returns:\n        str: substituted/rendered config\n\n    Raises:\n        N/A\n\n    \"\"\"\n    self.logger.info(\"fetching configuration and replacing with provided substitutes\")\n\n    source_config = await self.get_config(source=source)\n    return self._render_substituted_config(\n        config_template=config_template,\n        substitutes=substitutes,\n        source_config=source_config.result,\n    )\n</code></pre>"},{"location":"reference/platform/base/base_platform/","title":"Base platform","text":"<p>scrapli_cfg.platforms.base_platform</p>"},{"location":"reference/platform/base/base_platform/#platform.base.base_platform.ScrapliCfgBase","title":"<code>ScrapliCfgBase</code>","text":"Source code in <code>platform/base/base_platform.py</code> <pre><code>class ScrapliCfgBase:\n    conn: Union[NetworkDriver, AsyncNetworkDriver]\n\n    def __init__(self, config_sources: List[str], ignore_version: bool = False) -&gt; None:\n\"\"\"\n        Base class for all CFG platforms\n\n        Args:\n            config_sources: list of allowed config sources\n            ignore_version: ignore platform version check or not\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.logger = get_instance_logger(\n            instance_name=\"scrapli_cfg.platform\", host=self.conn.host, port=self.conn.port\n        )\n\n        self.config_sources = config_sources\n        self.candidate_config = \"\"\n\n        self.ignore_version = ignore_version\n        self._get_version_command = \"\"\n        self._version_string = \"\"\n\n        # bool indicated if a `on_prepare` callable has been executed or not\n        self._prepared = False\n\n    def _render_substituted_config(\n        self, config_template: str, substitutes: List[Tuple[str, Pattern[str]]], source_config: str\n    ) -&gt; str:\n\"\"\"\n        Render a substituted configuration file\n\n        Renders a configuration based on a user template, substitutes, and a target config from the\n        device.\n\n        Args:\n            config_template: config file to use as the base for substitutions -- should contain\n                jinja2-like variables that will be replaced with data fetched from the source config\n                by the substitutes patterns\n            substitutes: tuple of name, pattern -- where name matches the jinja2-like variable in\n                the config_template file, and pattern is a compiled regular expression pattern to be\n                used to fetch that section from the source config\n            source_config: current source config to use in substitution process\n\n        Returns:\n            None\n\n        Raises:\n            TemplateError: if no substitute sections are provided\n            TemplateError: if one or more of the substitute sections is missing in the template\n            TemplateError: if a substitute pattern is not found in the config template\n\n        \"\"\"\n        self.logger.debug(\"rendering substituted config\")\n\n        if not substitutes:\n            msg = \"no substitutes provided...\"\n            self.logger.critical(msg)\n            raise TemplateError(msg)\n\n        if not all(f\"{{{{ {name} }}}}\" in config_template for name, _ in substitutes):\n            msg = \"missing one or more of the provided substitutions from the config template\"\n            self.logger.critical(msg)\n            raise TemplateError(msg)\n\n        replace_sections = [\n            (name, re.search(pattern=pattern, string=source_config))\n            for name, pattern in substitutes\n        ]\n\n        rendered_config = \"\"\n        for name, replace_section in replace_sections:\n            if not replace_section:\n                msg = (\n                    f\"substitution pattern {name} was unable to find a match in the target config\"\n                    \" source\"\n                )\n                self.logger.critical(msg)\n                raise TemplateError(msg)\n\n            replace_group = replace_section.group()\n            rendered_config = config_template.replace(f\"{{{{ {name} }}}}\", replace_group)\n\n        # remove any totally empty lines (from bad regex, or just device spitting out lines w/\n        # nothing on it\n        rendered_config = \"\\n\".join(line for line in rendered_config.splitlines() if line)\n\n        self.logger.debug(\"rendering substituted config complete\")\n\n        return rendered_config\n\n    def _validate_and_set_version(self, version_response: ScrapliCfgResponse) -&gt; None:\n\"\"\"\n        Ensure version was fetched successfully and set internal version attribute\n\n        Args:\n            version_response: scrapli cfg response from get version operation\n\n        Returns:\n            None\n\n        Raises:\n            VersionError: if fetching version failed or failed to parse version\n\n        \"\"\"\n        if version_response.failed:\n            msg = \"failed getting version from device\"\n            self.logger.critical(msg)\n            raise VersionError(msg)\n        if not version_response.result:\n            msg = \"failed parsing version string from device output\"\n            self.logger.critical(msg)\n            raise VersionError(msg)\n        self._version_string = version_response.result\n\n    def _prepare_ok(self) -&gt; None:\n\"\"\"\n        Determine if prepare is \"OK\" for a given operation\n\n        Checks if an `on_prepare` callable has been provided, and if so, if it has been executed.\n        This is meant to help force users into calling `prepare` or using the context manager prior\n        to running any methods.\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            PrepareNotCalled: if `on_prepare` is not None and `_prepared` is False\n\n        \"\"\"\n        # ignoring type/complaints as `on_prepare` will always be set in the sync/async classes;\n        # but is not set here since in one its a coroutine and the other not\n        _on_prepare = self.on_prepare  # type: ignore  # noqa\n        if _on_prepare is not None and self._prepared is False:\n            raise PrepareNotCalled(\n                \"on_prepare callable provided, but prepare method not called. call prepare method \"\n                \"or use context manager to ensure it is called for you\"\n            )\n\n    def _version_ok(self) -&gt; None:\n\"\"\"\n        Determine if version is \"OK\" for a given operation\n\n        Should be overridden and super'd to by platforms that implement version constraints, will\n        simply check that if `ignore_version` is `False` we have set the internal `_version_string`\n        attribute, if not, will raise `PrepareNotCalled` exception.\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            PrepareNotCalled: if ignore version is False and _version_string not set\n\n        \"\"\"\n        if self.ignore_version is False and not self._version_string:\n            raise PrepareNotCalled(\n                \"ignore_version is False, but version has not yet been fetched. call prepare method\"\n                \" or use context manager to ensure that version is properly gathered\"\n            )\n\n    def _operation_ok(self) -&gt; None:\n\"\"\"\n        Determine if all values are \"OK\" for a given operation\n\n        Checks if version and prepare are ok. Convenience func to just have one thing to call in the\n        `_pre` operation methods.\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self._prepare_ok()\n        self._version_ok()\n\n    def _pre_get_version(self) -&gt; ScrapliCfgResponse:\n\"\"\"\n        Handle pre \"get_version\" operations for parity between sync and async\n\n        Args:\n            N/A\n\n        Returns:\n            ScrapliCfgResponse: new response object to update w/ get results\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.logger.info(\"get_version requested\")\n\n        response = ScrapliCfgResponse(host=self.conn.host, raise_for_status_exception=VersionError)\n\n        return response\n\n    def _post_get_version(\n        self,\n        response: ScrapliCfgResponse,\n        scrapli_responses: List[Response],\n        result: str,\n    ) -&gt; ScrapliCfgResponse:\n\"\"\"\n        Handle post \"get_version\" operations for parity between sync and async\n\n        Args:\n            response: response object to update\n            scrapli_responses: list of scrapli response objects from fetching the version\n            result: final version string of the device\n\n        Returns:\n            ScrapliCfgResponse: response object containing string of the version as the `result`\n                attribute\n\n        Raises:\n            N/A\n\n        \"\"\"\n        response.record_response(scrapli_responses=scrapli_responses, result=result)\n\n        if response.failed:\n            msg = \"failed to get version from device\"\n            self.logger.critical(msg)\n\n        return response\n\n    def _pre_get_config(self, source: str) -&gt; ScrapliCfgResponse:\n\"\"\"\n        Handle pre \"get_config\" operations for parity between sync and async\n\n        Args:\n            source: name of the config source, generally running|startup\n\n        Returns:\n            ScrapliCfgResponse: new response object to update w/ get results\n\n        Raises:\n            InvalidConfigTarget: if the requested config source is not valid\n\n        \"\"\"\n        self.logger.info(f\"get_config for config source '{source}' requested\")\n\n        self._operation_ok()\n\n        if source not in self.config_sources:\n            msg = (\n                f\"provided config source '{source}' not valid, must be one of {self.config_sources}\"\n            )\n            self.logger.critical(msg)\n            raise InvalidConfigTarget(msg)\n\n        response = ScrapliCfgResponse(\n            host=self.conn.host, raise_for_status_exception=GetConfigError\n        )\n\n        return response\n\n    def _post_get_config(\n        self,\n        response: ScrapliCfgResponse,\n        source: str,\n        scrapli_responses: List[Union[Response, MultiResponse]],\n        result: str,\n    ) -&gt; ScrapliCfgResponse:\n\"\"\"\n        Handle post \"get_config\" operations for parity between sync and async\n\n        Args:\n            response: response object to update\n            source: name of the config source, generally running|startup\n            scrapli_responses: list of scrapli response objects from fetching the config\n            result: final string of the \"get_config\" result\n\n        Returns:\n            ScrapliCfgResponse: response object containing string of the target config source as the\n                `result` attribute\n\n        Raises:\n            N/A\n\n        \"\"\"\n        response.record_response(scrapli_responses=scrapli_responses, result=result)\n\n        if response.failed:\n            msg = f\"failed to get {source} config\"\n            self.logger.critical(msg)\n\n        return response\n\n    def _pre_load_config(self, config: str) -&gt; ScrapliCfgResponse:\n\"\"\"\n        Handle pre \"load_config\" operations for parity between sync and async\n\n        Args:\n            config: candidate config to load\n\n        Returns:\n            ScrapliCfgResponse: new response object for load operation\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.logger.info(\"load_config requested\")\n\n        self._operation_ok()\n\n        self.candidate_config = config\n\n        response = ScrapliCfgResponse(\n            host=self.conn.host, raise_for_status_exception=LoadConfigError\n        )\n\n        return response\n\n    def _post_load_config(\n        self,\n        response: ScrapliCfgResponse,\n        scrapli_responses: List[Response],\n    ) -&gt; ScrapliCfgResponse:\n\"\"\"\n        Handle post \"get_config\" operations for parity between sync and async\n\n        Args:\n            response: response object to update\n            scrapli_responses: list of scrapli response objects from fetching the config\n\n        Returns:\n            ScrapliCfgResponse: response object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        response.record_response(scrapli_responses=scrapli_responses)\n\n        if response.failed:\n            msg = \"failed to load candidate config\"\n            self.logger.critical(msg)\n\n        return response\n\n    def _pre_abort_config(self, session_or_config_file: bool) -&gt; ScrapliCfgResponse:\n\"\"\"\n        Handle pre \"abort_config\" operations for parity between sync and async\n\n        Args:\n            session_or_config_file: bool indicating if a session or candidate config file has been\n                loaded -- in other words, is there anything to abort right now\n\n        Returns:\n            ScrapliCfgResponse: response object for abort operation\n\n        Raises:\n            AbortConfigError: if no config session or config file exists then we have no config to\n                abort!\n\n        \"\"\"\n        self.logger.info(\"abort_config requested\")\n\n        self._operation_ok()\n\n        if session_or_config_file is False:\n            msg = (\n                \"no configuration session or candidate configuration file exists, you must load a \"\n                \"config in order to abort it!\"\n            )\n            self.logger.critical(msg)\n            raise AbortConfigError(msg)\n\n        response = ScrapliCfgResponse(\n            host=self.conn.host, raise_for_status_exception=AbortConfigError\n        )\n\n        return response\n\n    def _post_abort_config(\n        self,\n        response: ScrapliCfgResponse,\n        scrapli_responses: List[Union[Response, MultiResponse]],\n    ) -&gt; ScrapliCfgResponse:\n\"\"\"\n        Handle post \"abort_config\" operations for parity between sync and async\n\n        Args:\n            response: response object to update\n            scrapli_responses: list of scrapli response objects from aborting the config\n\n        Returns:\n            ScrapliCfgResponse: response object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        response.record_response(scrapli_responses=scrapli_responses)\n\n        if response.failed:\n            msg = \"failed to abort config\"\n            self.logger.critical(msg)\n\n        return response\n\n    def _pre_commit_config(self, source: str, session_or_config_file: bool) -&gt; ScrapliCfgResponse:\n\"\"\"\n        Handle pre \"commit_config\" operations for parity between sync and async\n\n        Args:\n            source: name of the config source, generally running|startup\n            session_or_config_file: bool indicating if a session or candidate config file has been\n                loaded -- in other words, is there anything to commit right now\n\n        Returns:\n            ScrapliCfgResponse: new response object to update w/ commit results\n\n        Raises:\n            InvalidConfigTarget: if the requested config source is not valid\n            CommitConfigError: if no config session/file exists to commit\n\n        \"\"\"\n        self.logger.info(f\"get_config for config source '{source}' requested\")\n\n        self._operation_ok()\n\n        if source not in self.config_sources:\n            msg = (\n                f\"provided config source '{source}' not valid, must be one of {self.config_sources}\"\n            )\n            self.logger.critical(msg)\n            raise InvalidConfigTarget(msg)\n\n        if session_or_config_file is False:\n            msg = (\n                \"no configuration session or candidate configuration file exists, you must load a \"\n                \"config in order to commit it!\"\n            )\n            self.logger.critical(msg)\n            raise CommitConfigError(msg)\n\n        response = ScrapliCfgResponse(\n            host=self.conn.host, raise_for_status_exception=CommitConfigError\n        )\n\n        return response\n\n    def _post_commit_config(\n        self,\n        response: ScrapliCfgResponse,\n        scrapli_responses: List[Union[Response, MultiResponse]],\n    ) -&gt; ScrapliCfgResponse:\n\"\"\"\n        Handle post \"commit_config\" operations for parity between sync and async\n\n        Args:\n            response: response object to update\n            scrapli_responses: list of scrapli response objects from committing the config\n\n        Returns:\n            ScrapliCfgResponse: response object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        response.record_response(scrapli_responses=scrapli_responses)\n\n        if response.failed:\n            msg = \"failed to commit config\"\n            self.logger.critical(msg)\n\n        return response\n\n    def _pre_diff_config(self, source: str, session_or_config_file: bool) -&gt; ScrapliCfgDiffResponse:\n\"\"\"\n        Handle pre \"diff_config\" operations for parity between sync and async\n\n        Args:\n            source: config source to diff against\n            session_or_config_file: bool of config_session_name or candidate_config_filename\n\n        Returns:\n            ScrapliCfgDiffResponse: diff object for diff operation\n\n        Raises:\n            InvalidConfigTarget: if trying to diff against an invalid config target\n            DiffConfigError: if no config session or config file exists then we have no config to\n                diff!\n\n        \"\"\"\n        self.logger.info(\"diff_config requested\")\n\n        self._operation_ok()\n\n        if source not in self.config_sources:\n            msg = (\n                f\"provided config source '{source}' not valid, must be one of {self.config_sources}\"\n            )\n            self.logger.critical(msg)\n            raise InvalidConfigTarget(msg)\n\n        if session_or_config_file is False:\n            msg = (\n                \"no configuration session or candidate configuration file exists, you must load a \"\n                \"config in order to diff it!\"\n            )\n            self.logger.critical(msg)\n            raise DiffConfigError(msg)\n\n        diff_response = ScrapliCfgDiffResponse(host=self.conn.host, source=source)\n\n        return diff_response\n\n    def _post_diff_config(\n        self,\n        diff_response: ScrapliCfgDiffResponse,\n        scrapli_responses: List[Response],\n        source_config: str,\n        candidate_config: str,\n        device_diff: str,\n    ) -&gt; ScrapliCfgDiffResponse:\n\"\"\"\n        Handle post \"diff_config\" operations for parity between sync and async\n\n        Args:\n            diff_response: response object to update\n            scrapli_responses: list of scrapli response objects from committing the config\n            source_config: previous source config from the device\n            candidate_config: user provided configuration\n            device_diff: diff generated from the device itself\n\n        Returns:\n            ScrapliCfgDiffResponse: diff object for diff operation\n\n        Raises:\n            N/A\n\n        \"\"\"\n        diff_response.record_response(scrapli_responses=scrapli_responses)\n        diff_response.record_diff_response(\n            source_config=source_config + \"\\n\",\n            candidate_config=candidate_config + \"\\n\",\n            device_diff=device_diff,\n        )\n\n        if diff_response.failed:\n            msg = \"failed to diff config\"\n            self.logger.critical(msg)\n\n        return diff_response\n</code></pre>"},{"location":"reference/platform/base/base_platform/#platform.base.base_platform.ScrapliCfgBase.__init__","title":"<code>__init__(config_sources: List[str], ignore_version: bool = False) -&gt; None</code>","text":"<p>Base class for all CFG platforms</p> <p>Parameters:</p> Name Type Description Default <code>config_sources</code> <code>List[str]</code> <p>list of allowed config sources</p> required <code>ignore_version</code> <code>bool</code> <p>ignore platform version check or not</p> <code>False</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>platform/base/base_platform.py</code> <pre><code>def __init__(self, config_sources: List[str], ignore_version: bool = False) -&gt; None:\n\"\"\"\n    Base class for all CFG platforms\n\n    Args:\n        config_sources: list of allowed config sources\n        ignore_version: ignore platform version check or not\n\n    Returns:\n        None\n\n    Raises:\n        N/A\n\n    \"\"\"\n    self.logger = get_instance_logger(\n        instance_name=\"scrapli_cfg.platform\", host=self.conn.host, port=self.conn.port\n    )\n\n    self.config_sources = config_sources\n    self.candidate_config = \"\"\n\n    self.ignore_version = ignore_version\n    self._get_version_command = \"\"\n    self._version_string = \"\"\n\n    # bool indicated if a `on_prepare` callable has been executed or not\n    self._prepared = False\n</code></pre>"},{"location":"reference/platform/base/sync_platform/","title":"Sync platform","text":"<p>scrapli_cfg.platform.sync_platform</p>"},{"location":"reference/platform/base/sync_platform/#platform.base.sync_platform.ScrapliCfgPlatform","title":"<code>ScrapliCfgPlatform</code>","text":"<p>         Bases: <code>ABC</code>, <code>ScrapliCfgBase</code></p> Source code in <code>platform/base/sync_platform.py</code> <pre><code>class ScrapliCfgPlatform(ABC, ScrapliCfgBase):\n    def __init__(\n        self,\n        conn: NetworkDriver,\n        config_sources: List[str],\n        on_prepare: Optional[Callable[..., Any]],\n        dedicated_connection: bool,\n        ignore_version: bool,\n    ) -&gt; None:\n\"\"\"\n        Scrapli Config base class\n\n        Args:\n            conn: scrapli connection to use\n            config_sources: list of config sources\n            on_prepare: optional callable to run at connection `prepare`\n            dedicated_connection: if `False` (default value) scrapli cfg will not open or close the\n                underlying scrapli connection and will raise an exception if the scrapli connection\n                is not open. If `True` will automatically open and close the scrapli connection when\n                using with a context manager, `prepare` will open the scrapli connection (if not\n                already open), and `close` will close the scrapli connection.\n            ignore_version: ignore checking device version support; currently this just means that\n                scrapli-cfg will not fetch the device version during the prepare phase, however this\n                will (hopefully) be used in the future to limit what methods can be used against a\n                target device. For example, for EOS devices we need &gt; 4.14 to load configs; so if a\n                device is encountered at 4.13 the version check would raise an exception rather than\n                just failing in a potentially awkward fashion.\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.conn: NetworkDriver = conn\n        self.dedicated_connection = dedicated_connection\n\n        self.on_prepare = on_prepare\n\n        super().__init__(config_sources=config_sources, ignore_version=ignore_version)\n\n    def __enter__(self) -&gt; \"ScrapliCfgPlatform\":\n\"\"\"\n        Enter method for context manager\n\n        Args:\n            N/A\n\n        Returns:\n            ScrapliCfg: opened ScrapliCfg object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.prepare()\n        return self\n\n    def __exit__(\n        self,\n        exception_type: Optional[Type[BaseException]],\n        exception_value: Optional[BaseException],\n        traceback: Optional[TracebackType],\n    ) -&gt; None:\n\"\"\"\n        Exit method to cleanup for context manager\n\n        Args:\n            exception_type: exception type being raised\n            exception_value: message from exception being raised\n            traceback: traceback from exception being raised\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.cleanup()\n\n    def _open(self) -&gt; None:\n\"\"\"\n        Handle opening (or raising exception if not open) of underlying scrapli connection\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            ScrapliCfgException: if scrapli connection is not open and auto_open_connection is False\n\n        \"\"\"\n        if self.conn.isalive():\n            return\n\n        if self.dedicated_connection:\n            self.logger.info(\n                \"underlying scrapli connection is not alive... opening scrapli connection\"\n            )\n            self.conn.open()\n            return\n\n        raise ScrapliCfgException(\n            \"underlying scrapli connection is not open and `dedicated_connection` is False, \"\n            \"cannot continue!\"\n        )\n\n    def _close(self) -&gt; None:\n\"\"\"\n        Close the scrapli connection\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        if self.dedicated_connection is True and self.conn.isalive():\n            self.logger.info(\"dedicated_connection is True, closing scrapli connection\")\n            self.conn.close()\n\n    def prepare(self) -&gt; None:\n\"\"\"\n        Prepare connection for scrapli_cfg operations\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.logger.info(\"preparing scrapli_cfg connection\")\n\n        self._open()\n\n        if self.ignore_version is False:\n            self.logger.debug(\"ignore_version is False, fetching device version\")\n            version_response = self.get_version()\n            self._validate_and_set_version(version_response=version_response)\n\n        if self.on_prepare is not None:\n            self.logger.debug(\"on_prepare provided, executing now\")\n            self.on_prepare(self)\n\n        self._prepared = True\n\n    def cleanup(self) -&gt; None:\n\"\"\"\n        Cleanup after scrapli-cfg operations\n\n\n        Generally this can be skipped, however it will be executed if using a context manager. The\n        purpose of this method is to close the underlying scrapli connection (if in\n        \"dedicated_connection\" mode), and to reset the internally used `_version_string`, attribute.\n        All this is done so that this cfg connection, if re-used later (as in later in that script\n        using the same object) starts with a fresh slate.\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self._close()\n\n        # reset the version string/prepare flag so we know we need to re-fetch/re-run if user\n        # re-opens connection\n        self._version_string = \"\"\n        self._prepared = False\n\n        # this has *probably* been reset already, but reset it just in case user re-opens connection\n        # we can have a clean slate to work with\n        try:\n            self._reset_config_session()  # type: ignore\n        except AttributeError:\n            pass\n\n    @abstractmethod\n    def get_version(self) -&gt; ScrapliCfgResponse:\n\"\"\"\n        Get device version string\n\n        Args:\n            N/A\n\n        Returns:\n            ScrapliCfgResponse: response object where result is the string of the primary version\n                (as in the \"main\" os version) of the device\n\n        Raises:\n            N/A\n\n        \"\"\"\n\n    @abstractmethod\n    def get_config(self, source: str = \"running\") -&gt; ScrapliCfgResponse:\n\"\"\"\n        Get device configuration\n\n        Args:\n            source: name of the config source, generally running|startup\n\n        Returns:\n            ScrapliCfgResponse: response object containing string of the target config source as the\n                `result` attribute\n\n        Raises:\n            N/A\n\n        \"\"\"\n\n    @abstractmethod\n    def load_config(self, config: str, replace: bool = False, **kwargs: Any) -&gt; ScrapliCfgResponse:\n\"\"\"\n        Load configuration to a device\n\n        Args:\n            config: string of the configuration to load\n            replace: replace the configuration or not, if false configuration will be loaded as a\n                merge operation\n            kwargs: additional kwargs that the implementing classes may need for their platform,\n                see your specific platform for details\n\n        Returns:\n            ScrapliCfgResponse: response object\n\n        Raises:\n            N/A\n\n        \"\"\"\n\n    @abstractmethod\n    def abort_config(self) -&gt; ScrapliCfgResponse:\n\"\"\"\n        Abort a configuration -- discards any loaded config\n\n        Args:\n            N/A\n\n        Returns:\n            ScrapliCfgResponse: response object\n\n        Raises:\n            N/A\n\n        \"\"\"\n\n    @abstractmethod\n    def commit_config(self, source: str = \"running\") -&gt; ScrapliCfgResponse:\n\"\"\"\n        Commit a loaded configuration\n\n        Args:\n            source: name of the config source to commit against, generally running|startup\n\n        Returns:\n            ScrapliCfgResponse: response object\n\n        Raises:\n            N/A\n\n        \"\"\"\n\n    @abstractmethod\n    def diff_config(self, source: str = \"running\") -&gt; ScrapliCfgDiffResponse:\n\"\"\"\n        Diff a loaded configuration against the source config store\n\n        Args:\n            source: name of the config source to diff against, generally running|startup -- device\n                diffs will generally not care about this argument, but the built in scrapli differ\n                will\n\n        Returns:\n            ScrapliCfgDiffResponse: scrapli cfg diff object\n\n        Raises:\n            N/A\n\n        \"\"\"\n\n    def render_substituted_config(\n        self,\n        config_template: str,\n        substitutes: List[Tuple[str, Pattern[str]]],\n        source: str = \"running\",\n    ) -&gt; str:\n\"\"\"\n        Render a substituted configuration file\n\n        Renders a configuration based on a user template, substitutes, and a target config from the\n        device.\n\n        Args:\n            config_template: config file to use as the base for substitutions -- should contain\n                jinja2-like variables that will be replaced with data fetched from the source config\n                by the substitutes patterns\n            substitutes: tuple of name, pattern -- where name matches the jinja2-like variable in\n                the config_template file, and pattern is a compiled regular expression pattern to be\n                used to fetch that section from the source config\n            source: config source to use for the substitution efforts, typically running|startup\n\n        Returns:\n            str: substituted/rendered config\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.logger.info(\"fetching configuration and replacing with provided substitutes\")\n\n        source_config = self.get_config(source=source)\n        return self._render_substituted_config(\n            config_template=config_template,\n            substitutes=substitutes,\n            source_config=source_config.result,\n        )\n</code></pre>"},{"location":"reference/platform/base/sync_platform/#platform.base.sync_platform.ScrapliCfgPlatform.__enter__","title":"<code>__enter__() -&gt; ScrapliCfgPlatform</code>","text":"<p>Enter method for context manager</p> <p>Returns:</p> Name Type Description <code>ScrapliCfg</code> <code>ScrapliCfgPlatform</code> <p>opened ScrapliCfg object</p> Source code in <code>platform/base/sync_platform.py</code> <pre><code>def __enter__(self) -&gt; \"ScrapliCfgPlatform\":\n\"\"\"\n    Enter method for context manager\n\n    Args:\n        N/A\n\n    Returns:\n        ScrapliCfg: opened ScrapliCfg object\n\n    Raises:\n        N/A\n\n    \"\"\"\n    self.prepare()\n    return self\n</code></pre>"},{"location":"reference/platform/base/sync_platform/#platform.base.sync_platform.ScrapliCfgPlatform.__exit__","title":"<code>__exit__(exception_type: Optional[Type[BaseException]], exception_value: Optional[BaseException], traceback: Optional[TracebackType]) -&gt; None</code>","text":"<p>Exit method to cleanup for context manager</p> <p>Parameters:</p> Name Type Description Default <code>exception_type</code> <code>Optional[Type[BaseException]]</code> <p>exception type being raised</p> required <code>exception_value</code> <code>Optional[BaseException]</code> <p>message from exception being raised</p> required <code>traceback</code> <code>Optional[TracebackType]</code> <p>traceback from exception being raised</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>platform/base/sync_platform.py</code> <pre><code>def __exit__(\n    self,\n    exception_type: Optional[Type[BaseException]],\n    exception_value: Optional[BaseException],\n    traceback: Optional[TracebackType],\n) -&gt; None:\n\"\"\"\n    Exit method to cleanup for context manager\n\n    Args:\n        exception_type: exception type being raised\n        exception_value: message from exception being raised\n        traceback: traceback from exception being raised\n\n    Returns:\n        None\n\n    Raises:\n        N/A\n\n    \"\"\"\n    self.cleanup()\n</code></pre>"},{"location":"reference/platform/base/sync_platform/#platform.base.sync_platform.ScrapliCfgPlatform.__init__","title":"<code>__init__(conn: NetworkDriver, config_sources: List[str], on_prepare: Optional[Callable[..., Any]], dedicated_connection: bool, ignore_version: bool) -&gt; None</code>","text":"<p>Scrapli Config base class</p> <p>Parameters:</p> Name Type Description Default <code>conn</code> <code>NetworkDriver</code> <p>scrapli connection to use</p> required <code>config_sources</code> <code>List[str]</code> <p>list of config sources</p> required <code>on_prepare</code> <code>Optional[Callable[..., Any]]</code> <p>optional callable to run at connection <code>prepare</code></p> required <code>dedicated_connection</code> <code>bool</code> <p>if <code>False</code> (default value) scrapli cfg will not open or close the underlying scrapli connection and will raise an exception if the scrapli connection is not open. If <code>True</code> will automatically open and close the scrapli connection when using with a context manager, <code>prepare</code> will open the scrapli connection (if not already open), and <code>close</code> will close the scrapli connection.</p> required <code>ignore_version</code> <code>bool</code> <p>ignore checking device version support; currently this just means that scrapli-cfg will not fetch the device version during the prepare phase, however this will (hopefully) be used in the future to limit what methods can be used against a target device. For example, for EOS devices we need &gt; 4.14 to load configs; so if a device is encountered at 4.13 the version check would raise an exception rather than just failing in a potentially awkward fashion.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>platform/base/sync_platform.py</code> <pre><code>def __init__(\n    self,\n    conn: NetworkDriver,\n    config_sources: List[str],\n    on_prepare: Optional[Callable[..., Any]],\n    dedicated_connection: bool,\n    ignore_version: bool,\n) -&gt; None:\n\"\"\"\n    Scrapli Config base class\n\n    Args:\n        conn: scrapli connection to use\n        config_sources: list of config sources\n        on_prepare: optional callable to run at connection `prepare`\n        dedicated_connection: if `False` (default value) scrapli cfg will not open or close the\n            underlying scrapli connection and will raise an exception if the scrapli connection\n            is not open. If `True` will automatically open and close the scrapli connection when\n            using with a context manager, `prepare` will open the scrapli connection (if not\n            already open), and `close` will close the scrapli connection.\n        ignore_version: ignore checking device version support; currently this just means that\n            scrapli-cfg will not fetch the device version during the prepare phase, however this\n            will (hopefully) be used in the future to limit what methods can be used against a\n            target device. For example, for EOS devices we need &gt; 4.14 to load configs; so if a\n            device is encountered at 4.13 the version check would raise an exception rather than\n            just failing in a potentially awkward fashion.\n\n    Returns:\n        None\n\n    Raises:\n        N/A\n\n    \"\"\"\n    self.conn: NetworkDriver = conn\n    self.dedicated_connection = dedicated_connection\n\n    self.on_prepare = on_prepare\n\n    super().__init__(config_sources=config_sources, ignore_version=ignore_version)\n</code></pre>"},{"location":"reference/platform/base/sync_platform/#platform.base.sync_platform.ScrapliCfgPlatform.abort_config","title":"<code>abort_config() -&gt; ScrapliCfgResponse</code>  <code>abstractmethod</code>","text":"<p>Abort a configuration -- discards any loaded config</p> <p>Returns:</p> Name Type Description <code>ScrapliCfgResponse</code> <code>ScrapliCfgResponse</code> <p>response object</p> Source code in <code>platform/base/sync_platform.py</code> <pre><code>@abstractmethod\ndef abort_config(self) -&gt; ScrapliCfgResponse:\n\"\"\"\n    Abort a configuration -- discards any loaded config\n\n    Args:\n        N/A\n\n    Returns:\n        ScrapliCfgResponse: response object\n\n    Raises:\n        N/A\n\n    \"\"\"\n</code></pre>"},{"location":"reference/platform/base/sync_platform/#platform.base.sync_platform.ScrapliCfgPlatform.cleanup","title":"<code>cleanup() -&gt; None</code>","text":"<p>Cleanup after scrapli-cfg operations</p> <p>Generally this can be skipped, however it will be executed if using a context manager. The purpose of this method is to close the underlying scrapli connection (if in \"dedicated_connection\" mode), and to reset the internally used <code>_version_string</code>, attribute. All this is done so that this cfg connection, if re-used later (as in later in that script using the same object) starts with a fresh slate.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>platform/base/sync_platform.py</code> <pre><code>def cleanup(self) -&gt; None:\n\"\"\"\n    Cleanup after scrapli-cfg operations\n\n\n    Generally this can be skipped, however it will be executed if using a context manager. The\n    purpose of this method is to close the underlying scrapli connection (if in\n    \"dedicated_connection\" mode), and to reset the internally used `_version_string`, attribute.\n    All this is done so that this cfg connection, if re-used later (as in later in that script\n    using the same object) starts with a fresh slate.\n\n    Args:\n        N/A\n\n    Returns:\n        None\n\n    Raises:\n        N/A\n\n    \"\"\"\n    self._close()\n\n    # reset the version string/prepare flag so we know we need to re-fetch/re-run if user\n    # re-opens connection\n    self._version_string = \"\"\n    self._prepared = False\n\n    # this has *probably* been reset already, but reset it just in case user re-opens connection\n    # we can have a clean slate to work with\n    try:\n        self._reset_config_session()  # type: ignore\n    except AttributeError:\n        pass\n</code></pre>"},{"location":"reference/platform/base/sync_platform/#platform.base.sync_platform.ScrapliCfgPlatform.commit_config","title":"<code>commit_config(source: str = 'running') -&gt; ScrapliCfgResponse</code>  <code>abstractmethod</code>","text":"<p>Commit a loaded configuration</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>name of the config source to commit against, generally running|startup</p> <code>'running'</code> <p>Returns:</p> Name Type Description <code>ScrapliCfgResponse</code> <code>ScrapliCfgResponse</code> <p>response object</p> Source code in <code>platform/base/sync_platform.py</code> <pre><code>@abstractmethod\ndef commit_config(self, source: str = \"running\") -&gt; ScrapliCfgResponse:\n\"\"\"\n    Commit a loaded configuration\n\n    Args:\n        source: name of the config source to commit against, generally running|startup\n\n    Returns:\n        ScrapliCfgResponse: response object\n\n    Raises:\n        N/A\n\n    \"\"\"\n</code></pre>"},{"location":"reference/platform/base/sync_platform/#platform.base.sync_platform.ScrapliCfgPlatform.diff_config","title":"<code>diff_config(source: str = 'running') -&gt; ScrapliCfgDiffResponse</code>  <code>abstractmethod</code>","text":"<p>Diff a loaded configuration against the source config store</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>name of the config source to diff against, generally running|startup -- device diffs will generally not care about this argument, but the built in scrapli differ will</p> <code>'running'</code> <p>Returns:</p> Name Type Description <code>ScrapliCfgDiffResponse</code> <code>ScrapliCfgDiffResponse</code> <p>scrapli cfg diff object</p> Source code in <code>platform/base/sync_platform.py</code> <pre><code>@abstractmethod\ndef diff_config(self, source: str = \"running\") -&gt; ScrapliCfgDiffResponse:\n\"\"\"\n    Diff a loaded configuration against the source config store\n\n    Args:\n        source: name of the config source to diff against, generally running|startup -- device\n            diffs will generally not care about this argument, but the built in scrapli differ\n            will\n\n    Returns:\n        ScrapliCfgDiffResponse: scrapli cfg diff object\n\n    Raises:\n        N/A\n\n    \"\"\"\n</code></pre>"},{"location":"reference/platform/base/sync_platform/#platform.base.sync_platform.ScrapliCfgPlatform.get_config","title":"<code>get_config(source: str = 'running') -&gt; ScrapliCfgResponse</code>  <code>abstractmethod</code>","text":"<p>Get device configuration</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>name of the config source, generally running|startup</p> <code>'running'</code> <p>Returns:</p> Name Type Description <code>ScrapliCfgResponse</code> <code>ScrapliCfgResponse</code> <p>response object containing string of the target config source as the <code>result</code> attribute</p> Source code in <code>platform/base/sync_platform.py</code> <pre><code>@abstractmethod\ndef get_config(self, source: str = \"running\") -&gt; ScrapliCfgResponse:\n\"\"\"\n    Get device configuration\n\n    Args:\n        source: name of the config source, generally running|startup\n\n    Returns:\n        ScrapliCfgResponse: response object containing string of the target config source as the\n            `result` attribute\n\n    Raises:\n        N/A\n\n    \"\"\"\n</code></pre>"},{"location":"reference/platform/base/sync_platform/#platform.base.sync_platform.ScrapliCfgPlatform.get_version","title":"<code>get_version() -&gt; ScrapliCfgResponse</code>  <code>abstractmethod</code>","text":"<p>Get device version string</p> <p>Returns:</p> Name Type Description <code>ScrapliCfgResponse</code> <code>ScrapliCfgResponse</code> <p>response object where result is the string of the primary version (as in the \"main\" os version) of the device</p> Source code in <code>platform/base/sync_platform.py</code> <pre><code>@abstractmethod\ndef get_version(self) -&gt; ScrapliCfgResponse:\n\"\"\"\n    Get device version string\n\n    Args:\n        N/A\n\n    Returns:\n        ScrapliCfgResponse: response object where result is the string of the primary version\n            (as in the \"main\" os version) of the device\n\n    Raises:\n        N/A\n\n    \"\"\"\n</code></pre>"},{"location":"reference/platform/base/sync_platform/#platform.base.sync_platform.ScrapliCfgPlatform.load_config","title":"<code>load_config(config: str, replace: bool = False, **kwargs: Any) -&gt; ScrapliCfgResponse</code>  <code>abstractmethod</code>","text":"<p>Load configuration to a device</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>str</code> <p>string of the configuration to load</p> required <code>replace</code> <code>bool</code> <p>replace the configuration or not, if false configuration will be loaded as a merge operation</p> <code>False</code> <code>kwargs</code> <p>additional kwargs that the implementing classes may need for their platform, see your specific platform for details</p> required <p>Returns:</p> Name Type Description <code>ScrapliCfgResponse</code> <code>ScrapliCfgResponse</code> <p>response object</p> Source code in <code>platform/base/sync_platform.py</code> <pre><code>@abstractmethod\ndef load_config(self, config: str, replace: bool = False, **kwargs: Any) -&gt; ScrapliCfgResponse:\n\"\"\"\n    Load configuration to a device\n\n    Args:\n        config: string of the configuration to load\n        replace: replace the configuration or not, if false configuration will be loaded as a\n            merge operation\n        kwargs: additional kwargs that the implementing classes may need for their platform,\n            see your specific platform for details\n\n    Returns:\n        ScrapliCfgResponse: response object\n\n    Raises:\n        N/A\n\n    \"\"\"\n</code></pre>"},{"location":"reference/platform/base/sync_platform/#platform.base.sync_platform.ScrapliCfgPlatform.prepare","title":"<code>prepare() -&gt; None</code>","text":"<p>Prepare connection for scrapli_cfg operations</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>platform/base/sync_platform.py</code> <pre><code>def prepare(self) -&gt; None:\n\"\"\"\n    Prepare connection for scrapli_cfg operations\n\n    Args:\n        N/A\n\n    Returns:\n        None\n\n    Raises:\n        N/A\n\n    \"\"\"\n    self.logger.info(\"preparing scrapli_cfg connection\")\n\n    self._open()\n\n    if self.ignore_version is False:\n        self.logger.debug(\"ignore_version is False, fetching device version\")\n        version_response = self.get_version()\n        self._validate_and_set_version(version_response=version_response)\n\n    if self.on_prepare is not None:\n        self.logger.debug(\"on_prepare provided, executing now\")\n        self.on_prepare(self)\n\n    self._prepared = True\n</code></pre>"},{"location":"reference/platform/base/sync_platform/#platform.base.sync_platform.ScrapliCfgPlatform.render_substituted_config","title":"<code>render_substituted_config(config_template: str, substitutes: List[Tuple[str, Pattern[str]]], source: str = 'running') -&gt; str</code>","text":"<p>Render a substituted configuration file</p> <p>Renders a configuration based on a user template, substitutes, and a target config from the device.</p> <p>Parameters:</p> Name Type Description Default <code>config_template</code> <code>str</code> <p>config file to use as the base for substitutions -- should contain jinja2-like variables that will be replaced with data fetched from the source config by the substitutes patterns</p> required <code>substitutes</code> <code>List[Tuple[str, Pattern[str]]]</code> <p>tuple of name, pattern -- where name matches the jinja2-like variable in the config_template file, and pattern is a compiled regular expression pattern to be used to fetch that section from the source config</p> required <code>source</code> <code>str</code> <p>config source to use for the substitution efforts, typically running|startup</p> <code>'running'</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>substituted/rendered config</p> Source code in <code>platform/base/sync_platform.py</code> <pre><code>def render_substituted_config(\n    self,\n    config_template: str,\n    substitutes: List[Tuple[str, Pattern[str]]],\n    source: str = \"running\",\n) -&gt; str:\n\"\"\"\n    Render a substituted configuration file\n\n    Renders a configuration based on a user template, substitutes, and a target config from the\n    device.\n\n    Args:\n        config_template: config file to use as the base for substitutions -- should contain\n            jinja2-like variables that will be replaced with data fetched from the source config\n            by the substitutes patterns\n        substitutes: tuple of name, pattern -- where name matches the jinja2-like variable in\n            the config_template file, and pattern is a compiled regular expression pattern to be\n            used to fetch that section from the source config\n        source: config source to use for the substitution efforts, typically running|startup\n\n    Returns:\n        str: substituted/rendered config\n\n    Raises:\n        N/A\n\n    \"\"\"\n    self.logger.info(\"fetching configuration and replacing with provided substitutes\")\n\n    source_config = self.get_config(source=source)\n    return self._render_substituted_config(\n        config_template=config_template,\n        substitutes=substitutes,\n        source_config=source_config.result,\n    )\n</code></pre>"},{"location":"reference/platform/core/","title":"Index","text":"<p>scrapli_cfg.platform.core</p>"},{"location":"reference/platform/core/arista_eos/","title":"Index","text":"<p>scrapli_cfg.platform.core.arista_eos</p>"},{"location":"reference/platform/core/arista_eos/async_platform/","title":"Async platform","text":"<p>scrapli_cfg.platform.core.arista_eos.async_platform</p>"},{"location":"reference/platform/core/arista_eos/async_platform/#platform.core.arista_eos.async_platform.AsyncScrapliCfgEOS","title":"<code>AsyncScrapliCfgEOS</code>","text":"<p>         Bases: <code>AsyncScrapliCfgPlatform</code>, <code>ScrapliCfgEOSBase</code></p> Source code in <code>platform/core/arista_eos/async_platform.py</code> <pre><code>class AsyncScrapliCfgEOS(AsyncScrapliCfgPlatform, ScrapliCfgEOSBase):\n    def __init__(\n        self,\n        conn: AsyncEOSDriver,\n        *,\n        config_sources: Optional[List[str]] = None,\n        on_prepare: Optional[Callable[..., Any]] = None,\n        dedicated_connection: bool = False,\n        ignore_version: bool = False,\n    ) -&gt; None:\n        if config_sources is None:\n            config_sources = CONFIG_SOURCES\n\n        super().__init__(\n            conn=conn,\n            config_sources=config_sources,\n            on_prepare=on_prepare,\n            dedicated_connection=dedicated_connection,\n            ignore_version=ignore_version,\n        )\n\n        self.conn: AsyncEOSDriver\n\n        self.config_session_name = \"\"\n\n    async def _clear_config_session(self, session_name: str) -&gt; Response:\n\"\"\"\n        Clear a configuration session\n\n        Args:\n            session_name: name of session to clear\n\n        Returns:\n            Response: scrapli response from clearing the session\n\n        Raises:\n            N/A\n\n        \"\"\"\n        # Note, early versions of eos supporting config sessions cant be aborted like this, but\n        # i dont want to register a config session for each session we want to delete so we'll just\n        # roll w/ this for now\n        return await self.conn.send_command(command=f\"configure session {session_name} abort\")\n\n    async def clear_config_sessions(\n        self, session_name: str = \"\", session_prefix: str = \"\"\n    ) -&gt; ScrapliCfgResponse:\n\"\"\"\n        Clear a specific config session or all sessions with a prefix (ex: scrapli_cfg_)\n\n        Args:\n            session_name: name of specific config session to clear\n            session_prefix: prefix of session(s) to clear -- ignored if session_name is provided\n\n        Returns:\n            ScrapliCfgResponse: response object containing string of the target config source as the\n                `result` attribute\n\n        Raises:\n            N/A\n\n        \"\"\"\n        scrapli_responses = []\n        response = self._pre_clear_config_sessions()\n\n        try:\n            get_config_sessions_result = await self.conn.send_command(\n                command=\"show config sessions | json\"\n            )\n            scrapli_responses.append(get_config_sessions_result)\n            if get_config_sessions_result.failed:\n                msg = \"failed to show current config sessions\"\n                self.logger.critical(msg)\n                raise ScrapliCfgException(msg)\n\n            config_session_names = self._parse_config_sessions(\n                device_output=get_config_sessions_result.result\n            )\n            for config_session in config_session_names:\n                if session_name:\n                    if config_session == session_name:\n                        clear_config_session_result = await self._clear_config_session(\n                            session_name=session_name\n                        )\n                        scrapli_responses.append(clear_config_session_result)\n                else:\n                    if config_session.startswith(session_prefix):\n                        clear_config_session_result = await self._clear_config_session(\n                            session_name=session_name\n                        )\n                        scrapli_responses.append(clear_config_session_result)\n\n        except ScrapliCfgException:\n            pass\n\n        return self._post_clear_config_sessions(\n            response=response, scrapli_responses=scrapli_responses\n        )\n\n    async def get_version(self) -&gt; ScrapliCfgResponse:\n        response = self._pre_get_version()\n\n        version_result = await self.conn.send_command(\n            command=\"show version | i Software image version\"\n        )\n\n        return self._post_get_version(\n            response=response,\n            scrapli_responses=[version_result],\n            result=self._parse_version(device_output=version_result.result),\n        )\n\n    async def get_config(self, source: str = \"running\") -&gt; ScrapliCfgResponse:\n        response = self._pre_get_config(source=source)\n\n        config_result = await self.conn.send_command(\n            command=self._get_config_command(source=source)\n        )\n\n        return self._post_get_config(\n            response=response,\n            source=source,\n            scrapli_responses=[config_result],\n            result=config_result.result,\n        )\n\n    async def load_config(\n        self, config: str, replace: bool = False, **kwargs: Any\n    ) -&gt; ScrapliCfgResponse:\n\"\"\"\n        Load configuration to a device\n\n        Supported kwargs:\n            N/A\n\n        Args:\n            config: string of the configuration to load\n            replace: replace the configuration or not, if false configuration will be loaded as a\n                merge operation\n            kwargs: additional kwargs that the implementing classes may need for their platform,\n                see above for eos supported kwargs\n\n        Returns:\n            ScrapliCfgResponse: response object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        scrapli_responses = []\n        response = self._pre_load_config(config=config)\n        (\n            config,\n            eager_config,\n            register_config_session,\n        ) = self._prepare_load_config_session_and_payload(config=config)\n\n        if register_config_session:\n            # only need to register a session if we havent -- we will reset session to an empty\n            # string after any commits/aborts so we know if we are doing \"new\" operations\n            self.conn.register_configuration_session(session_name=self.config_session_name)\n\n        try:\n            if replace:\n                # default the config session - we only need to do this if we are doing a REPLACE\n                rollback_clean_config_result = await self.conn.send_config(\n                    config=\"rollback clean-config\", privilege_level=self.config_session_name\n                )\n                if rollback_clean_config_result.failed:\n                    msg = \"failed to load clean config in configuration session\"\n                    self.logger.critical(msg)\n                    raise LoadConfigError(msg)\n\n            config_result = await self.conn.send_config(\n                config=config, privilege_level=self.config_session_name\n            )\n            scrapli_responses.append(config_result)\n            if config_result.failed:\n                msg = \"failed to load the candidate config into the config session\"\n                self.logger.critical(msg)\n                raise LoadConfigError(msg)\n\n            # eager cuz banners and such; perhaps if no banner/macro we can disable eager though....\n            if eager_config:\n                eager_config_result = await self.conn.send_config(\n                    config=eager_config, privilege_level=self.config_session_name, eager=True\n                )\n                scrapli_responses.append(eager_config_result)\n                if eager_config_result.failed:\n                    msg = \"failed to load the candidate config into the config session\"\n                    self.logger.critical(msg)\n                    raise LoadConfigError(msg)\n\n        except LoadConfigError:\n            # we catch our own exception so we dont need to do any if failed checks along the way\n            # as soon as we hit this (or when we are done w/ the try block) we are done loading the\n            # config and can build and return a response object\n            pass\n\n        return self._post_load_config(\n            response=response,\n            scrapli_responses=scrapli_responses,\n        )\n\n    async def abort_config(self) -&gt; ScrapliCfgResponse:\n        response = self._pre_abort_config(session_or_config_file=bool(self.config_session_name))\n\n        await self.conn.acquire_priv(desired_priv=self.config_session_name)\n        await self.conn._abort_config()  # pylint: disable=W0212\n        self._reset_config_session()\n\n        return self._post_abort_config(\n            response=response,\n            scrapli_responses=[],\n        )\n\n    async def commit_config(self, source: str = \"running\") -&gt; ScrapliCfgResponse:\n        response = self._pre_commit_config(\n            source=source, session_or_config_file=bool(self.config_session_name)\n        )\n\n        commit_results = await self.conn.send_commands(\n            commands=[\n                f\"configure session {self.config_session_name} commit\",\n                \"copy running-config startup-config\",\n            ]\n        )\n        self._reset_config_session()\n\n        return self._post_commit_config(response=response, scrapli_responses=[commit_results])\n\n    async def diff_config(self, source: str = \"running\") -&gt; ScrapliCfgDiffResponse:\n        scrapli_responses = []\n        device_diff = \"\"\n        source_config = \"\"\n\n        diff_response = self._pre_diff_config(\n            source=source, session_or_config_file=bool(self.config_session_name)\n        )\n\n        try:\n            diff_result = await self.conn.send_config(\n                config=\"show session-config diffs\", privilege_level=self.config_session_name\n            )\n            scrapli_responses.append(diff_result)\n            if diff_result.failed:\n                msg = \"failed generating diff for config session\"\n                self.logger.critical(msg)\n                raise DiffConfigError(msg)\n\n            device_diff = diff_result.result\n\n            source_config_result = await self.get_config(source=source)\n            source_config = source_config_result.result\n\n            if isinstance(source_config_result.scrapli_responses, MultiResponse):\n                # in this case this will always be a multiresponse or nothing (failure) but mypy\n                # doesnt know that, hence the isinstance check\n                scrapli_responses.extend(source_config_result.scrapli_responses)\n\n            if source_config_result.failed:\n                msg = \"failed fetching source config for diff comparison\"\n                self.logger.critical(msg)\n                raise DiffConfigError(msg)\n\n        except DiffConfigError:\n            pass\n\n        return self._post_diff_config(\n            diff_response=diff_response,\n            scrapli_responses=scrapli_responses,\n            source_config=self.clean_config(source_config),\n            candidate_config=self.clean_config(self.candidate_config),\n            device_diff=device_diff,\n        )\n</code></pre>"},{"location":"reference/platform/core/arista_eos/async_platform/#platform.core.arista_eos.async_platform.AsyncScrapliCfgEOS.clear_config_sessions","title":"<code>clear_config_sessions(session_name: str = '', session_prefix: str = '') -&gt; ScrapliCfgResponse</code>  <code>async</code>","text":"<p>Clear a specific config session or all sessions with a prefix (ex: scrapli_cfg_)</p> <p>Parameters:</p> Name Type Description Default <code>session_name</code> <code>str</code> <p>name of specific config session to clear</p> <code>''</code> <code>session_prefix</code> <code>str</code> <p>prefix of session(s) to clear -- ignored if session_name is provided</p> <code>''</code> <p>Returns:</p> Name Type Description <code>ScrapliCfgResponse</code> <code>ScrapliCfgResponse</code> <p>response object containing string of the target config source as the <code>result</code> attribute</p> Source code in <code>platform/core/arista_eos/async_platform.py</code> <pre><code>async def clear_config_sessions(\n    self, session_name: str = \"\", session_prefix: str = \"\"\n) -&gt; ScrapliCfgResponse:\n\"\"\"\n    Clear a specific config session or all sessions with a prefix (ex: scrapli_cfg_)\n\n    Args:\n        session_name: name of specific config session to clear\n        session_prefix: prefix of session(s) to clear -- ignored if session_name is provided\n\n    Returns:\n        ScrapliCfgResponse: response object containing string of the target config source as the\n            `result` attribute\n\n    Raises:\n        N/A\n\n    \"\"\"\n    scrapli_responses = []\n    response = self._pre_clear_config_sessions()\n\n    try:\n        get_config_sessions_result = await self.conn.send_command(\n            command=\"show config sessions | json\"\n        )\n        scrapli_responses.append(get_config_sessions_result)\n        if get_config_sessions_result.failed:\n            msg = \"failed to show current config sessions\"\n            self.logger.critical(msg)\n            raise ScrapliCfgException(msg)\n\n        config_session_names = self._parse_config_sessions(\n            device_output=get_config_sessions_result.result\n        )\n        for config_session in config_session_names:\n            if session_name:\n                if config_session == session_name:\n                    clear_config_session_result = await self._clear_config_session(\n                        session_name=session_name\n                    )\n                    scrapli_responses.append(clear_config_session_result)\n            else:\n                if config_session.startswith(session_prefix):\n                    clear_config_session_result = await self._clear_config_session(\n                        session_name=session_name\n                    )\n                    scrapli_responses.append(clear_config_session_result)\n\n    except ScrapliCfgException:\n        pass\n\n    return self._post_clear_config_sessions(\n        response=response, scrapli_responses=scrapli_responses\n    )\n</code></pre>"},{"location":"reference/platform/core/arista_eos/async_platform/#platform.core.arista_eos.async_platform.AsyncScrapliCfgEOS.load_config","title":"<code>load_config(config: str, replace: bool = False, **kwargs: Any) -&gt; ScrapliCfgResponse</code>  <code>async</code>","text":"<p>Load configuration to a device</p> Supported kwargs <p>N/A</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>str</code> <p>string of the configuration to load</p> required <code>replace</code> <code>bool</code> <p>replace the configuration or not, if false configuration will be loaded as a merge operation</p> <code>False</code> <code>kwargs</code> <p>additional kwargs that the implementing classes may need for their platform, see above for eos supported kwargs</p> required <p>Returns:</p> Name Type Description <code>ScrapliCfgResponse</code> <code>ScrapliCfgResponse</code> <p>response object</p> Source code in <code>platform/core/arista_eos/async_platform.py</code> <pre><code>async def load_config(\n    self, config: str, replace: bool = False, **kwargs: Any\n) -&gt; ScrapliCfgResponse:\n\"\"\"\n    Load configuration to a device\n\n    Supported kwargs:\n        N/A\n\n    Args:\n        config: string of the configuration to load\n        replace: replace the configuration or not, if false configuration will be loaded as a\n            merge operation\n        kwargs: additional kwargs that the implementing classes may need for their platform,\n            see above for eos supported kwargs\n\n    Returns:\n        ScrapliCfgResponse: response object\n\n    Raises:\n        N/A\n\n    \"\"\"\n    scrapli_responses = []\n    response = self._pre_load_config(config=config)\n    (\n        config,\n        eager_config,\n        register_config_session,\n    ) = self._prepare_load_config_session_and_payload(config=config)\n\n    if register_config_session:\n        # only need to register a session if we havent -- we will reset session to an empty\n        # string after any commits/aborts so we know if we are doing \"new\" operations\n        self.conn.register_configuration_session(session_name=self.config_session_name)\n\n    try:\n        if replace:\n            # default the config session - we only need to do this if we are doing a REPLACE\n            rollback_clean_config_result = await self.conn.send_config(\n                config=\"rollback clean-config\", privilege_level=self.config_session_name\n            )\n            if rollback_clean_config_result.failed:\n                msg = \"failed to load clean config in configuration session\"\n                self.logger.critical(msg)\n                raise LoadConfigError(msg)\n\n        config_result = await self.conn.send_config(\n            config=config, privilege_level=self.config_session_name\n        )\n        scrapli_responses.append(config_result)\n        if config_result.failed:\n            msg = \"failed to load the candidate config into the config session\"\n            self.logger.critical(msg)\n            raise LoadConfigError(msg)\n\n        # eager cuz banners and such; perhaps if no banner/macro we can disable eager though....\n        if eager_config:\n            eager_config_result = await self.conn.send_config(\n                config=eager_config, privilege_level=self.config_session_name, eager=True\n            )\n            scrapli_responses.append(eager_config_result)\n            if eager_config_result.failed:\n                msg = \"failed to load the candidate config into the config session\"\n                self.logger.critical(msg)\n                raise LoadConfigError(msg)\n\n    except LoadConfigError:\n        # we catch our own exception so we dont need to do any if failed checks along the way\n        # as soon as we hit this (or when we are done w/ the try block) we are done loading the\n        # config and can build and return a response object\n        pass\n\n    return self._post_load_config(\n        response=response,\n        scrapli_responses=scrapli_responses,\n    )\n</code></pre>"},{"location":"reference/platform/core/arista_eos/base_platform/","title":"Base platform","text":"<p>scrapli_cfg.platform.core.arista_eos.base</p>"},{"location":"reference/platform/core/arista_eos/base_platform/#platform.core.arista_eos.base_platform.ScrapliCfgEOSBase","title":"<code>ScrapliCfgEOSBase</code>","text":"Source code in <code>platform/core/arista_eos/base_platform.py</code> <pre><code>class ScrapliCfgEOSBase:\n    conn: Union[NetworkDriver, AsyncNetworkDriver]\n    logger: LoggerAdapterT\n    config_sources: List[str]\n    config_session_name: str\n    candidate_config: str\n\n    @staticmethod\n    def _parse_version(device_output: str) -&gt; str:\n\"\"\"\n        Parse version string out of device output\n\n        Args:\n            device_output: output from show version command\n\n        Returns:\n            str: device version string\n\n        Raises:\n            N/A\n\n        \"\"\"\n        version_string_search = re.search(pattern=VERSION_PATTERN, string=device_output)\n\n        if not version_string_search:\n            return \"\"\n\n        version_string = version_string_search.group(0) or \"\"\n        return version_string\n\n    @staticmethod\n    def _parse_config_sessions(device_output: str) -&gt; List[str]:\n\"\"\"\n        Parse config session names out of device output\n\n        Args:\n            device_output: output from show version command\n\n        Returns:\n            list[str]: config session names\n\n        Raises:\n            N/A\n\n        \"\"\"\n        try:\n            config_session_dict = json.loads(device_output)\n        except json.JSONDecodeError:\n            return []\n\n        sessions = list(config_session_dict.get(\"sessions\", {}))\n        return sessions\n\n    @staticmethod\n    def _get_config_command(source: str) -&gt; str:\n\"\"\"\n        Return command to use to get config based on the provided source\n\n        Args:\n            source: name of the config source, generally running|startup\n\n        Returns:\n            str: command to use to fetch the requested config\n\n        Raises:\n            N/A\n\n        \"\"\"\n        if source == \"running\":\n            return \"show running-config\"\n        return \"show startup-config\"\n\n    @staticmethod\n    def _prepare_config_payloads(config: str) -&gt; Tuple[str, str]:\n\"\"\"\n        Prepare a configuration so it can be nicely sent to the device via scrapli\n\n        Args:\n            config: configuration to prep\n\n        Returns:\n            tuple: tuple of \"normal\" config lines and \"eager\" config lines\n\n        Raises:\n            N/A\n\n        \"\"\"\n        # remove comment lines\n        config = re.sub(pattern=GLOBAL_COMMENT_LINE_PATTERN, repl=\"!\", string=config)\n\n        # remove \"end\" at the end of config if present - if its present it will drop scrapli out\n        # of the config session which we do not want\n        config = re.sub(pattern=END_PATTERN, repl=\"!\", string=config)\n\n        # find all sections that need to be \"eagerly\" sent\n        eager_config = re.findall(pattern=BANNER_PATTERN, string=config)\n        for eager_section in eager_config:\n            config = config.replace(eager_section, \"!\")\n\n        joined_eager_config = \"\\n\".join(captured_section for captured_section in eager_config)\n\n        return config, joined_eager_config\n\n    def _prepare_load_config_session_and_payload(self, config: str) -&gt; Tuple[str, str, bool]:\n\"\"\"\n        Prepare the normal and eager payloads and decide if we need to register a config session\n\n        Args:\n            config: candidate config to load\n\n        Returns:\n            tuple: tuple containing \"normal\" config elements to send to the device and \"eager\" mode\n                config elements to send to the device (things like banners/macro that require\n                scrapli \"eager=True\"), and lastly a bool indicating if the config session needs to\n                be registered on the device\n\n        Raises:\n            N/A\n\n        \"\"\"\n        config, eager_config = self._prepare_config_payloads(config=config)\n\n        register_config_session = False\n        if not self.config_session_name:\n            self.config_session_name = f\"scrapli_cfg_{round(datetime.now().timestamp())}\"\n            self.logger.debug(f\"configuration session name will be '{self.config_session_name}'\")\n            register_config_session = True\n\n        return config, eager_config, register_config_session\n\n    def _reset_config_session(self) -&gt; None:\n\"\"\"\n        Reset config session info\n\n        Resets the candidate config and config session name attributes -- when these are \"empty\" we\n        know there is no current config session\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.logger.debug(\"resetting candidate config and config session name\")\n        self.candidate_config = \"\"\n        self.config_session_name = \"\"\n\n    def clean_config(self, config: str) -&gt; str:\n\"\"\"\n        Clean a configuration file of unwanted lines\n\n        Args:\n            config: configuration string to \"clean\";  remove all comment lines from both the source\n                and candidate configs -- this is only done here pre-diff, so we dont modify the user\n                provided candidate config which can totally have those comment lines - we only\n                remove \"global\" (top level) comments though... user comments attached to interfaces\n                and the stuff will remain\n\n        Returns:\n            str: cleaned configuration string\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.logger.debug(\"cleaning config file\")\n\n        return strip_blank_lines(\n            config=re.sub(pattern=GLOBAL_COMMENT_LINE_PATTERN, string=config, repl=\"\")\n        )\n\n    def _pre_clear_config_sessions(self) -&gt; ScrapliCfgResponse:\n\"\"\"\n        Handle pre \"clear_config_sessions\" operations for parity between sync and async\n\n        Args:\n            N/A\n\n        Returns:\n            ScrapliCfgResponse: new response object to update w/ get results\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.logger.info(\"clear_config_sessions requested\")\n\n        response = ScrapliCfgResponse(\n            host=self.conn.host, raise_for_status_exception=ScrapliCfgException\n        )\n\n        return response\n\n    def _post_clear_config_sessions(\n        self,\n        response: ScrapliCfgResponse,\n        scrapli_responses: Iterable[Response],\n    ) -&gt; ScrapliCfgResponse:\n\"\"\"\n        Handle post \"clear_config_sessions\" operations for parity between sync and async\n\n        Args:\n            response: response object to update\n            scrapli_responses: list of scrapli response objects from fetching the version\n\n        Returns:\n            ScrapliCfgResponse: response object containing string of the version as the `result`\n                attribute\n\n        Raises:\n            N/A\n\n        \"\"\"\n        response.record_response(scrapli_responses=scrapli_responses)\n\n        if response.failed:\n            msg = \"failed to clear device configuration session(s)\"\n            self.logger.critical(msg)\n            response.result = msg\n        else:\n            response.result = \"configuration session(s) cleared\"\n\n        return response\n</code></pre>"},{"location":"reference/platform/core/arista_eos/base_platform/#platform.core.arista_eos.base_platform.ScrapliCfgEOSBase.clean_config","title":"<code>clean_config(config: str) -&gt; str</code>","text":"<p>Clean a configuration file of unwanted lines</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>str</code> <p>configuration string to \"clean\";  remove all comment lines from both the source and candidate configs -- this is only done here pre-diff, so we dont modify the user provided candidate config which can totally have those comment lines - we only remove \"global\" (top level) comments though... user comments attached to interfaces and the stuff will remain</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>cleaned configuration string</p> Source code in <code>platform/core/arista_eos/base_platform.py</code> <pre><code>def clean_config(self, config: str) -&gt; str:\n\"\"\"\n    Clean a configuration file of unwanted lines\n\n    Args:\n        config: configuration string to \"clean\";  remove all comment lines from both the source\n            and candidate configs -- this is only done here pre-diff, so we dont modify the user\n            provided candidate config which can totally have those comment lines - we only\n            remove \"global\" (top level) comments though... user comments attached to interfaces\n            and the stuff will remain\n\n    Returns:\n        str: cleaned configuration string\n\n    Raises:\n        N/A\n\n    \"\"\"\n    self.logger.debug(\"cleaning config file\")\n\n    return strip_blank_lines(\n        config=re.sub(pattern=GLOBAL_COMMENT_LINE_PATTERN, string=config, repl=\"\")\n    )\n</code></pre>"},{"location":"reference/platform/core/arista_eos/patterns/","title":"Patterns","text":"<p>scrapli_cfg.platform.core.arista_eos.patterns</p>"},{"location":"reference/platform/core/arista_eos/sync_platform/","title":"Sync platform","text":"<p>scrapli_cfg.platform.core.arista_eos.sync</p>"},{"location":"reference/platform/core/arista_eos/sync_platform/#platform.core.arista_eos.sync_platform.ScrapliCfgEOS","title":"<code>ScrapliCfgEOS</code>","text":"<p>         Bases: <code>ScrapliCfgPlatform</code>, <code>ScrapliCfgEOSBase</code></p> Source code in <code>platform/core/arista_eos/sync_platform.py</code> <pre><code>class ScrapliCfgEOS(ScrapliCfgPlatform, ScrapliCfgEOSBase):\n    def __init__(\n        self,\n        conn: EOSDriver,\n        *,\n        config_sources: Optional[List[str]] = None,\n        on_prepare: Optional[Callable[..., Any]] = None,\n        dedicated_connection: bool = False,\n        ignore_version: bool = False,\n    ) -&gt; None:\n        if config_sources is None:\n            config_sources = CONFIG_SOURCES\n\n        super().__init__(\n            conn=conn,\n            config_sources=config_sources,\n            on_prepare=on_prepare,\n            dedicated_connection=dedicated_connection,\n            ignore_version=ignore_version,\n        )\n\n        self.conn: EOSDriver\n\n        self.config_session_name = \"\"\n\n    def _clear_config_session(self, session_name: str) -&gt; Response:\n\"\"\"\n        Clear a configuration session\n\n        Args:\n            session_name: name of session to clear\n\n        Returns:\n            Response: scrapli response from clearing the session\n\n        Raises:\n            N/A\n\n        \"\"\"\n        # Note, early versions of eos supporting config sessions cant be aborted like this, but\n        # i dont want to register a config session for each session we want to delete so we'll just\n        # roll w/ this for now\n        return self.conn.send_command(command=f\"configure session {session_name} abort\")\n\n    def clear_config_sessions(\n        self, session_name: str = \"\", session_prefix: str = \"\"\n    ) -&gt; ScrapliCfgResponse:\n\"\"\"\n        Clear a specific config session or all sessions with a prefix (ex: scrapli_cfg_)\n\n        Args:\n            session_name: name of specific config session to clear\n            session_prefix: prefix of session(s) to clear -- ignored if session_name is provided\n\n        Returns:\n            ScrapliCfgResponse: response object containing string of the target config source as the\n                `result` attribute\n\n        Raises:\n            N/A\n\n        \"\"\"\n        scrapli_responses = []\n        response = self._pre_clear_config_sessions()\n\n        try:\n            get_config_sessions_result = self.conn.send_command(\n                command=\"show config sessions | json\"\n            )\n            scrapli_responses.append(get_config_sessions_result)\n            if get_config_sessions_result.failed:\n                msg = \"failed to show current config sessions\"\n                self.logger.critical(msg)\n                raise ScrapliCfgException(msg)\n\n            config_session_names = self._parse_config_sessions(\n                device_output=get_config_sessions_result.result\n            )\n            for config_session in config_session_names:\n                if session_name:\n                    if config_session == session_name:\n                        clear_config_session_result = self._clear_config_session(\n                            session_name=session_name\n                        )\n                        scrapli_responses.append(clear_config_session_result)\n                else:\n                    if config_session.startswith(session_prefix):\n                        clear_config_session_result = self._clear_config_session(\n                            session_name=session_name\n                        )\n                        scrapli_responses.append(clear_config_session_result)\n\n        except ScrapliCfgException:\n            pass\n\n        return self._post_clear_config_sessions(\n            response=response, scrapli_responses=scrapli_responses\n        )\n\n    def get_version(self) -&gt; ScrapliCfgResponse:\n        response = self._pre_get_version()\n\n        version_result = self.conn.send_command(command=\"show version | i Software image version\")\n\n        return self._post_get_version(\n            response=response,\n            scrapli_responses=[version_result],\n            result=self._parse_version(device_output=version_result.result),\n        )\n\n    def get_config(self, source: str = \"running\") -&gt; ScrapliCfgResponse:\n        response = self._pre_get_config(source=source)\n\n        config_result = self.conn.send_command(command=self._get_config_command(source=source))\n\n        return self._post_get_config(\n            response=response,\n            source=source,\n            scrapli_responses=[config_result],\n            result=config_result.result,\n        )\n\n    def load_config(self, config: str, replace: bool = False, **kwargs: Any) -&gt; ScrapliCfgResponse:\n\"\"\"\n        Load configuration to a device\n\n        Supported kwargs:\n            N/A\n\n        Args:\n            config: string of the configuration to load\n            replace: replace the configuration or not, if false configuration will be loaded as a\n                merge operation\n            kwargs: additional kwargs that the implementing classes may need for their platform,\n                see above for eos supported kwargs\n\n        Returns:\n            ScrapliCfgResponse: response object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        scrapli_responses = []\n        response = self._pre_load_config(config=config)\n        (\n            config,\n            eager_config,\n            register_config_session,\n        ) = self._prepare_load_config_session_and_payload(config=config)\n\n        if register_config_session is True:\n            # only need to register a session if we havent -- we will reset session to an empty\n            # string after any commits/aborts so we know if we are doing \"new\" operations\n            self.conn.register_configuration_session(session_name=self.config_session_name)\n\n        try:\n            if replace:\n                # default the config session - we only need to do this if we are doing a REPLACE\n                rollback_clean_config_result = self.conn.send_config(\n                    config=\"rollback clean-config\", privilege_level=self.config_session_name\n                )\n                scrapli_responses.append(rollback_clean_config_result)\n                if rollback_clean_config_result.failed:\n                    msg = \"failed to load clean config in configuration session\"\n                    self.logger.critical(msg)\n                    raise LoadConfigError(msg)\n\n            config_result = self.conn.send_config(\n                config=config, privilege_level=self.config_session_name\n            )\n            scrapli_responses.append(config_result)\n            if config_result.failed:\n                msg = \"failed to load the candidate config into the config session\"\n                self.logger.critical(msg)\n                raise LoadConfigError(msg)\n\n            # eager cuz banners and such; perhaps if no banner/macro we can disable eager though....\n            if eager_config:\n                eager_config_result = self.conn.send_config(\n                    config=eager_config, privilege_level=self.config_session_name, eager=True\n                )\n                scrapli_responses.append(eager_config_result)\n                if eager_config_result.failed:\n                    msg = \"failed to load the candidate config into the config session\"\n                    self.logger.critical(msg)\n                    raise LoadConfigError(msg)\n\n        except LoadConfigError:\n            # we catch our own exception so we dont need to do any if failed checks along the way\n            # as soon as we hit this (or when we are done w/ the try block) we are done loading the\n            # config and can build and return a response object\n            pass\n\n        return self._post_load_config(\n            response=response,\n            scrapli_responses=scrapli_responses,\n        )\n\n    def abort_config(self) -&gt; ScrapliCfgResponse:\n        response = self._pre_abort_config(session_or_config_file=bool(self.config_session_name))\n\n        self.conn.acquire_priv(desired_priv=self.config_session_name)\n        self.conn._abort_config()  # pylint: disable=W0212\n        self._reset_config_session()\n\n        return self._post_abort_config(response=response, scrapli_responses=[])\n\n    def commit_config(self, source: str = \"running\") -&gt; ScrapliCfgResponse:\n        response = self._pre_commit_config(\n            source=source, session_or_config_file=bool(self.config_session_name)\n        )\n\n        commit_results = self.conn.send_commands(\n            commands=[\n                f\"configure session {self.config_session_name} commit\",\n                \"copy running-config startup-config\",\n            ]\n        )\n        self._reset_config_session()\n\n        return self._post_commit_config(response=response, scrapli_responses=[commit_results])\n\n    def diff_config(self, source: str = \"running\") -&gt; ScrapliCfgDiffResponse:\n        scrapli_responses = []\n        device_diff = \"\"\n        source_config = \"\"\n\n        diff_response = self._pre_diff_config(\n            source=source, session_or_config_file=bool(self.config_session_name)\n        )\n\n        try:\n            diff_result = self.conn.send_config(\n                config=\"show session-config diffs\", privilege_level=self.config_session_name\n            )\n            scrapli_responses.append(diff_result)\n            if diff_result.failed:\n                msg = \"failed generating diff for config session\"\n                self.logger.critical(msg)\n                raise DiffConfigError(msg)\n\n            device_diff = diff_result.result\n\n            source_config_result = self.get_config(source=source)\n            source_config = source_config_result.result\n\n            if isinstance(source_config_result.scrapli_responses, MultiResponse):\n                # in this case this will always be a multiresponse or nothing (failure) but mypy\n                # doesnt know that, hence the isinstance check\n                scrapli_responses.extend(source_config_result.scrapli_responses)\n\n            if source_config_result.failed:\n                msg = \"failed fetching source config for diff comparison\"\n                self.logger.critical(msg)\n                raise DiffConfigError(msg)\n\n        except DiffConfigError:\n            pass\n\n        return self._post_diff_config(\n            diff_response=diff_response,\n            scrapli_responses=scrapli_responses,\n            source_config=self.clean_config(source_config),\n            candidate_config=self.clean_config(self.candidate_config),\n            device_diff=device_diff,\n        )\n</code></pre>"},{"location":"reference/platform/core/arista_eos/sync_platform/#platform.core.arista_eos.sync_platform.ScrapliCfgEOS.clear_config_sessions","title":"<code>clear_config_sessions(session_name: str = '', session_prefix: str = '') -&gt; ScrapliCfgResponse</code>","text":"<p>Clear a specific config session or all sessions with a prefix (ex: scrapli_cfg_)</p> <p>Parameters:</p> Name Type Description Default <code>session_name</code> <code>str</code> <p>name of specific config session to clear</p> <code>''</code> <code>session_prefix</code> <code>str</code> <p>prefix of session(s) to clear -- ignored if session_name is provided</p> <code>''</code> <p>Returns:</p> Name Type Description <code>ScrapliCfgResponse</code> <code>ScrapliCfgResponse</code> <p>response object containing string of the target config source as the <code>result</code> attribute</p> Source code in <code>platform/core/arista_eos/sync_platform.py</code> <pre><code>def clear_config_sessions(\n    self, session_name: str = \"\", session_prefix: str = \"\"\n) -&gt; ScrapliCfgResponse:\n\"\"\"\n    Clear a specific config session or all sessions with a prefix (ex: scrapli_cfg_)\n\n    Args:\n        session_name: name of specific config session to clear\n        session_prefix: prefix of session(s) to clear -- ignored if session_name is provided\n\n    Returns:\n        ScrapliCfgResponse: response object containing string of the target config source as the\n            `result` attribute\n\n    Raises:\n        N/A\n\n    \"\"\"\n    scrapli_responses = []\n    response = self._pre_clear_config_sessions()\n\n    try:\n        get_config_sessions_result = self.conn.send_command(\n            command=\"show config sessions | json\"\n        )\n        scrapli_responses.append(get_config_sessions_result)\n        if get_config_sessions_result.failed:\n            msg = \"failed to show current config sessions\"\n            self.logger.critical(msg)\n            raise ScrapliCfgException(msg)\n\n        config_session_names = self._parse_config_sessions(\n            device_output=get_config_sessions_result.result\n        )\n        for config_session in config_session_names:\n            if session_name:\n                if config_session == session_name:\n                    clear_config_session_result = self._clear_config_session(\n                        session_name=session_name\n                    )\n                    scrapli_responses.append(clear_config_session_result)\n            else:\n                if config_session.startswith(session_prefix):\n                    clear_config_session_result = self._clear_config_session(\n                        session_name=session_name\n                    )\n                    scrapli_responses.append(clear_config_session_result)\n\n    except ScrapliCfgException:\n        pass\n\n    return self._post_clear_config_sessions(\n        response=response, scrapli_responses=scrapli_responses\n    )\n</code></pre>"},{"location":"reference/platform/core/arista_eos/sync_platform/#platform.core.arista_eos.sync_platform.ScrapliCfgEOS.load_config","title":"<code>load_config(config: str, replace: bool = False, **kwargs: Any) -&gt; ScrapliCfgResponse</code>","text":"<p>Load configuration to a device</p> Supported kwargs <p>N/A</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>str</code> <p>string of the configuration to load</p> required <code>replace</code> <code>bool</code> <p>replace the configuration or not, if false configuration will be loaded as a merge operation</p> <code>False</code> <code>kwargs</code> <p>additional kwargs that the implementing classes may need for their platform, see above for eos supported kwargs</p> required <p>Returns:</p> Name Type Description <code>ScrapliCfgResponse</code> <code>ScrapliCfgResponse</code> <p>response object</p> Source code in <code>platform/core/arista_eos/sync_platform.py</code> <pre><code>def load_config(self, config: str, replace: bool = False, **kwargs: Any) -&gt; ScrapliCfgResponse:\n\"\"\"\n    Load configuration to a device\n\n    Supported kwargs:\n        N/A\n\n    Args:\n        config: string of the configuration to load\n        replace: replace the configuration or not, if false configuration will be loaded as a\n            merge operation\n        kwargs: additional kwargs that the implementing classes may need for their platform,\n            see above for eos supported kwargs\n\n    Returns:\n        ScrapliCfgResponse: response object\n\n    Raises:\n        N/A\n\n    \"\"\"\n    scrapli_responses = []\n    response = self._pre_load_config(config=config)\n    (\n        config,\n        eager_config,\n        register_config_session,\n    ) = self._prepare_load_config_session_and_payload(config=config)\n\n    if register_config_session is True:\n        # only need to register a session if we havent -- we will reset session to an empty\n        # string after any commits/aborts so we know if we are doing \"new\" operations\n        self.conn.register_configuration_session(session_name=self.config_session_name)\n\n    try:\n        if replace:\n            # default the config session - we only need to do this if we are doing a REPLACE\n            rollback_clean_config_result = self.conn.send_config(\n                config=\"rollback clean-config\", privilege_level=self.config_session_name\n            )\n            scrapli_responses.append(rollback_clean_config_result)\n            if rollback_clean_config_result.failed:\n                msg = \"failed to load clean config in configuration session\"\n                self.logger.critical(msg)\n                raise LoadConfigError(msg)\n\n        config_result = self.conn.send_config(\n            config=config, privilege_level=self.config_session_name\n        )\n        scrapli_responses.append(config_result)\n        if config_result.failed:\n            msg = \"failed to load the candidate config into the config session\"\n            self.logger.critical(msg)\n            raise LoadConfigError(msg)\n\n        # eager cuz banners and such; perhaps if no banner/macro we can disable eager though....\n        if eager_config:\n            eager_config_result = self.conn.send_config(\n                config=eager_config, privilege_level=self.config_session_name, eager=True\n            )\n            scrapli_responses.append(eager_config_result)\n            if eager_config_result.failed:\n                msg = \"failed to load the candidate config into the config session\"\n                self.logger.critical(msg)\n                raise LoadConfigError(msg)\n\n    except LoadConfigError:\n        # we catch our own exception so we dont need to do any if failed checks along the way\n        # as soon as we hit this (or when we are done w/ the try block) we are done loading the\n        # config and can build and return a response object\n        pass\n\n    return self._post_load_config(\n        response=response,\n        scrapli_responses=scrapli_responses,\n    )\n</code></pre>"},{"location":"reference/platform/core/cisco_iosxe/","title":"Index","text":"<p>scrapli_cfg.platform.core.cisco_iosxe</p>"},{"location":"reference/platform/core/cisco_iosxe/async_platform/","title":"Async platform","text":"<p>scrapli_cfg.platform.core.cisco_iosxe.async_platform</p>"},{"location":"reference/platform/core/cisco_iosxe/async_platform/#platform.core.cisco_iosxe.async_platform.AsyncScrapliCfgIOSXE","title":"<code>AsyncScrapliCfgIOSXE</code>","text":"<p>         Bases: <code>AsyncScrapliCfgPlatform</code>, <code>ScrapliCfgIOSXEBase</code></p> Source code in <code>platform/core/cisco_iosxe/async_platform.py</code> <pre><code>class AsyncScrapliCfgIOSXE(AsyncScrapliCfgPlatform, ScrapliCfgIOSXEBase):\n    def __init__(\n        self,\n        conn: AsyncNetworkDriver,\n        *,\n        config_sources: Optional[List[str]] = None,\n        on_prepare: Optional[Callable[..., Any]] = None,\n        filesystem: str = \"flash:\",\n        cleanup_post_commit: bool = True,\n        dedicated_connection: bool = False,\n        ignore_version: bool = False,\n    ) -&gt; None:\n        if config_sources is None:\n            config_sources = CONFIG_SOURCES\n\n        super().__init__(\n            conn=conn,\n            config_sources=config_sources,\n            on_prepare=on_prepare,\n            dedicated_connection=dedicated_connection,\n            ignore_version=ignore_version,\n        )\n\n        self.filesystem = filesystem\n        self._filesystem_space_available_buffer_perc = 10\n\n        self._replace = False\n\n        self.candidate_config_filename = \"\"\n\n        self.cleanup_post_commit = cleanup_post_commit\n\n    async def _get_filesystem_space_available(self) -&gt; int:\n\"\"\"\n        Abort a configuration -- discards any loaded config\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            FailedToDetermineDeviceState: if unable to fetch file filesystem bytes available\n\n        \"\"\"\n        filesystem_size_result = await self.conn.send_command(\n            command=f\"dir {self.filesystem} | i bytes\"\n        )\n        if filesystem_size_result.failed:\n            raise FailedToDetermineDeviceState(\"failed to determine space available on filesystem\")\n\n        return self._post_get_filesystem_space_available(output=filesystem_size_result.result)\n\n    async def _determine_file_prompt_mode(self) -&gt; FilePromptMode:\n\"\"\"\n        Determine the device file prompt mode\n\n        Args:\n            N/A\n\n        Returns:\n            FilePromptMode: enum representing file prompt mode\n\n        Raises:\n            FailedToDetermineDeviceState: if unable to fetch file prompt mode\n\n        \"\"\"\n        file_prompt_mode_result = await self.conn.send_command(command=\"show run | i file prompt\")\n        if file_prompt_mode_result.failed:\n            raise FailedToDetermineDeviceState(\"failed to determine file prompt mode\")\n\n        return self._post_determine_file_prompt_mode(output=file_prompt_mode_result.result)\n\n    async def _delete_candidate_config(self) -&gt; Response:\n\"\"\"\n        Delete candidate config from the filesystem\n\n        Args:\n            N/A\n\n        Returns:\n            Response: response from deleting the candidate config\n\n        Raises:\n            N/A\n\n        \"\"\"\n        # have to check again because the candidate config may have changed this!\n        file_prompt_mode = await self._determine_file_prompt_mode()\n        if file_prompt_mode in (FilePromptMode.ALERT, FilePromptMode.NOISY):\n            delete_events = [\n                (\n                    f\"delete {self.filesystem}{self.candidate_config_filename}\",\n                    \"Delete filename\",\n                ),\n                (\n                    \"\",\n                    \"[confirm]\",\n                ),\n                (\"\", \"\"),\n            ]\n        else:\n            delete_events = [\n                (f\"delete {self.filesystem}{self.candidate_config_filename}\", \"[confirm]\"),\n                (\"\", \"\"),\n            ]\n        delete_result = await self.conn.send_interactive(interact_events=delete_events)\n        return delete_result\n\n    async def get_version(self) -&gt; ScrapliCfgResponse:\n        response = self._pre_get_version()\n\n        version_result = await self.conn.send_command(command=\"show version | i Version\")\n\n        return self._post_get_version(\n            response=response,\n            scrapli_responses=[version_result],\n            result=self._parse_version(device_output=version_result.result),\n        )\n\n    async def get_config(self, source: str = \"running\") -&gt; ScrapliCfgResponse:\n        response = self._pre_get_config(source=source)\n\n        config_result = await self.conn.send_command(\n            command=self._get_config_command(source=source)\n        )\n\n        return self._post_get_config(\n            response=response,\n            source=source,\n            scrapli_responses=[config_result],\n            result=config_result.result,\n        )\n\n    async def load_config(\n        self, config: str, replace: bool = False, **kwargs: Any\n    ) -&gt; ScrapliCfgResponse:\n\"\"\"\n        Load configuration to a device\n\n        Supported kwargs:\n            N/A\n\n        Args:\n            config: string of the configuration to load\n            replace: replace the configuration or not, if false configuration will be loaded as a\n                merge operation\n            kwargs: additional kwargs that the implementing classes may need for their platform,\n                see above for iosxe supported kwargs\n\n        Returns:\n            ScrapliCfgResponse: response object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        response = self._pre_load_config(config=config)\n\n        config = self._prepare_load_config(config=config, replace=replace)\n\n        filesystem_bytes_available = await self._get_filesystem_space_available()\n        self._space_available(filesystem_bytes_available=filesystem_bytes_available)\n\n        # when in tcl command mode or whatever it is, tcl wants \\r for return char, so stash the\n        # original return char and sub in \\r for a bit\n        original_return_char = self.conn.comms_return_char\n        tcl_comms_return_char = \"\\r\"\n\n        # pop into tclsh before swapping the return char just to be safe -- \\r or \\n should both be\n        # fine for up to here but who knows... :)\n        await self.conn.acquire_priv(desired_priv=\"tclsh\")\n        self.conn.comms_return_char = tcl_comms_return_char\n        config_result = await self.conn.send_config(config=config, privilege_level=\"tclsh\")\n\n        # reset the return char to the \"normal\" one and drop into whatever is the \"default\" priv\n        await self.conn.acquire_priv(desired_priv=self.conn.default_desired_privilege_level)\n        self.conn.comms_return_char = original_return_char\n\n        return self._post_load_config(\n            response=response,\n            scrapli_responses=[config_result],\n        )\n\n    async def abort_config(self) -&gt; ScrapliCfgResponse:\n        response = self._pre_abort_config(\n            session_or_config_file=bool(self.candidate_config_filename)\n        )\n\n        abort_result = await self._delete_candidate_config()\n        self._reset_config_session()\n\n        return self._post_abort_config(response=response, scrapli_responses=[abort_result])\n\n    async def save_config(self) -&gt; Response:\n\"\"\"\n        Save the config -- \"copy run start\"!\n\n        Args:\n             N/A\n\n        Returns:\n            Response: scrapli response object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        # we always re-check file prompt mode because it could have changed!\n        file_prompt_mode = await self._determine_file_prompt_mode()\n\n        if file_prompt_mode == FilePromptMode.ALERT:\n            save_events = [\n                (\n                    \"copy running-config startup-config\",\n                    \"Destination filename\",\n                ),\n                (\"\", \"\"),\n            ]\n        elif file_prompt_mode == FilePromptMode.NOISY:\n            save_events = [\n                (\n                    \"copy running-config startup-config\",\n                    \"Source filename\",\n                ),\n                (\n                    \"\",\n                    \"Destination filename\",\n                ),\n                (\"\", \"\"),\n            ]\n        else:\n            save_events = [(\"copy running-config startup-config\", \"\")]\n\n        save_result = await self.conn.send_interactive(interact_events=save_events)\n        return save_result\n\n    async def _commit_config_merge(\n        self, file_prompt_mode: Optional[FilePromptMode] = None\n    ) -&gt; Response:\n\"\"\"\n        Commit the configuration in merge mode\n\n        Args:\n             file_prompt_mode: optionally provide the file prompt mode, if its None we will fetch it\n                 to decide if we need to use interactive mode or not\n\n        Returns:\n            Response: scrapli response object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        if file_prompt_mode is None:\n            file_prompt_mode = await self._determine_file_prompt_mode()\n\n        if file_prompt_mode == FilePromptMode.ALERT:\n            merge_events = [\n                (\n                    f\"copy {self.filesystem}{self.candidate_config_filename} running-config\",\n                    \"Destination filename\",\n                ),\n                (\"\", \"\"),\n            ]\n        elif file_prompt_mode == FilePromptMode.NOISY:\n            merge_events = [\n                (\n                    f\"copy {self.filesystem}{self.candidate_config_filename} running-config\",\n                    \"Source filename\",\n                ),\n                (\n                    \"\",\n                    \"Destination filename\",\n                ),\n                (\"\", \"\"),\n            ]\n        else:\n            merge_events = [\n                (f\"copy {self.filesystem}{self.candidate_config_filename} running-config\", \"\")\n            ]\n\n        commit_result = await self.conn.send_interactive(interact_events=merge_events)\n        return commit_result\n\n    async def commit_config(self, source: str = \"running\") -&gt; ScrapliCfgResponse:\n        scrapli_responses = []\n        response = self._pre_commit_config(\n            source=source, session_or_config_file=bool(self.candidate_config_filename)\n        )\n\n        file_prompt_mode = await self._determine_file_prompt_mode()\n\n        if self._replace is True:\n            replace_command = (\n                f\"configure replace {self.filesystem}{self.candidate_config_filename} force\"\n            )\n            commit_result = await self.conn.send_command(command=replace_command)\n        else:\n            commit_result = await self._commit_config_merge(file_prompt_mode=file_prompt_mode)\n\n        scrapli_responses.append(commit_result)\n\n        save_config_result = await self.save_config()\n        scrapli_responses.append(save_config_result)\n\n        if self.cleanup_post_commit:\n            cleanup_result = await self._delete_candidate_config()\n            scrapli_responses.append(cleanup_result)\n\n        self._reset_config_session()\n\n        return self._post_load_config(\n            response=response,\n            scrapli_responses=scrapli_responses,\n        )\n\n    async def diff_config(self, source: str = \"running\") -&gt; ScrapliCfgDiffResponse:\n        scrapli_responses = []\n        device_diff = \"\"\n        source_config = \"\"\n\n        diff_response = self._pre_diff_config(\n            source=source, session_or_config_file=bool(self.candidate_config_filename)\n        )\n\n        try:\n            diff_result = await self.conn.send_command(\n                command=self._get_diff_command(source=source)\n            )\n            scrapli_responses.append(diff_result)\n            if diff_result.failed:\n                msg = \"failed generating diff for config session\"\n                self.logger.critical(msg)\n                raise DiffConfigError(msg)\n\n            device_diff = diff_result.result\n\n            source_config_result = await self.get_config(source=source)\n            source_config = source_config_result.result\n\n            if isinstance(source_config_result.scrapli_responses, list):\n                scrapli_responses.extend(source_config_result.scrapli_responses)\n\n            if source_config_result.failed:\n                msg = \"failed fetching source config for diff comparison\"\n                self.logger.critical(msg)\n                raise DiffConfigError(msg)\n\n        except DiffConfigError:\n            pass\n\n        return self._post_diff_config(\n            diff_response=diff_response,\n            scrapli_responses=scrapli_responses,\n            source_config=self.clean_config(source_config),\n            candidate_config=self.clean_config(self.candidate_config),\n            device_diff=device_diff,\n        )\n</code></pre>"},{"location":"reference/platform/core/cisco_iosxe/async_platform/#platform.core.cisco_iosxe.async_platform.AsyncScrapliCfgIOSXE.load_config","title":"<code>load_config(config: str, replace: bool = False, **kwargs: Any) -&gt; ScrapliCfgResponse</code>  <code>async</code>","text":"<p>Load configuration to a device</p> Supported kwargs <p>N/A</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>str</code> <p>string of the configuration to load</p> required <code>replace</code> <code>bool</code> <p>replace the configuration or not, if false configuration will be loaded as a merge operation</p> <code>False</code> <code>kwargs</code> <p>additional kwargs that the implementing classes may need for their platform, see above for iosxe supported kwargs</p> required <p>Returns:</p> Name Type Description <code>ScrapliCfgResponse</code> <code>ScrapliCfgResponse</code> <p>response object</p> Source code in <code>platform/core/cisco_iosxe/async_platform.py</code> <pre><code>async def load_config(\n    self, config: str, replace: bool = False, **kwargs: Any\n) -&gt; ScrapliCfgResponse:\n\"\"\"\n    Load configuration to a device\n\n    Supported kwargs:\n        N/A\n\n    Args:\n        config: string of the configuration to load\n        replace: replace the configuration or not, if false configuration will be loaded as a\n            merge operation\n        kwargs: additional kwargs that the implementing classes may need for their platform,\n            see above for iosxe supported kwargs\n\n    Returns:\n        ScrapliCfgResponse: response object\n\n    Raises:\n        N/A\n\n    \"\"\"\n    response = self._pre_load_config(config=config)\n\n    config = self._prepare_load_config(config=config, replace=replace)\n\n    filesystem_bytes_available = await self._get_filesystem_space_available()\n    self._space_available(filesystem_bytes_available=filesystem_bytes_available)\n\n    # when in tcl command mode or whatever it is, tcl wants \\r for return char, so stash the\n    # original return char and sub in \\r for a bit\n    original_return_char = self.conn.comms_return_char\n    tcl_comms_return_char = \"\\r\"\n\n    # pop into tclsh before swapping the return char just to be safe -- \\r or \\n should both be\n    # fine for up to here but who knows... :)\n    await self.conn.acquire_priv(desired_priv=\"tclsh\")\n    self.conn.comms_return_char = tcl_comms_return_char\n    config_result = await self.conn.send_config(config=config, privilege_level=\"tclsh\")\n\n    # reset the return char to the \"normal\" one and drop into whatever is the \"default\" priv\n    await self.conn.acquire_priv(desired_priv=self.conn.default_desired_privilege_level)\n    self.conn.comms_return_char = original_return_char\n\n    return self._post_load_config(\n        response=response,\n        scrapli_responses=[config_result],\n    )\n</code></pre>"},{"location":"reference/platform/core/cisco_iosxe/async_platform/#platform.core.cisco_iosxe.async_platform.AsyncScrapliCfgIOSXE.save_config","title":"<code>save_config() -&gt; Response</code>  <code>async</code>","text":"<p>Save the config -- \"copy run start\"!</p> <p>Returns:</p> Name Type Description <code>Response</code> <code>Response</code> <p>scrapli response object</p> Source code in <code>platform/core/cisco_iosxe/async_platform.py</code> <pre><code>async def save_config(self) -&gt; Response:\n\"\"\"\n    Save the config -- \"copy run start\"!\n\n    Args:\n         N/A\n\n    Returns:\n        Response: scrapli response object\n\n    Raises:\n        N/A\n\n    \"\"\"\n    # we always re-check file prompt mode because it could have changed!\n    file_prompt_mode = await self._determine_file_prompt_mode()\n\n    if file_prompt_mode == FilePromptMode.ALERT:\n        save_events = [\n            (\n                \"copy running-config startup-config\",\n                \"Destination filename\",\n            ),\n            (\"\", \"\"),\n        ]\n    elif file_prompt_mode == FilePromptMode.NOISY:\n        save_events = [\n            (\n                \"copy running-config startup-config\",\n                \"Source filename\",\n            ),\n            (\n                \"\",\n                \"Destination filename\",\n            ),\n            (\"\", \"\"),\n        ]\n    else:\n        save_events = [(\"copy running-config startup-config\", \"\")]\n\n    save_result = await self.conn.send_interactive(interact_events=save_events)\n    return save_result\n</code></pre>"},{"location":"reference/platform/core/cisco_iosxe/base_platform/","title":"Base platform","text":"<p>scrapli_cfg.platform.core.cisco_iosxe.base</p>"},{"location":"reference/platform/core/cisco_iosxe/base_platform/#platform.core.cisco_iosxe.base_platform.FilePromptMode","title":"<code>FilePromptMode</code>","text":"<p>         Bases: <code>Enum</code></p> <p>Enum representing file prompt modes</p> Source code in <code>platform/core/cisco_iosxe/base_platform.py</code> <pre><code>class FilePromptMode(Enum):\n\"\"\"Enum representing file prompt modes\"\"\"\n\n    NOISY = \"noisy\"\n    ALERT = \"alert\"\n    QUIET = \"quiet\"\n</code></pre>"},{"location":"reference/platform/core/cisco_iosxe/base_platform/#platform.core.cisco_iosxe.base_platform.ScrapliCfgIOSXEBase","title":"<code>ScrapliCfgIOSXEBase</code>","text":"Source code in <code>platform/core/cisco_iosxe/base_platform.py</code> <pre><code>class ScrapliCfgIOSXEBase:\n    logger: LoggerAdapterT\n    candidate_config: str\n    candidate_config_filename: str\n    _replace: bool\n    filesystem: str\n    _filesystem_space_available_buffer_perc: int\n\n    def _post_get_filesystem_space_available(self, output: str) -&gt; int:\n\"\"\"\n        Handle post \"get_filesystem_space_available\" operations for parity between sync and async\n\n        Args:\n            output: output that was fetched from the device\n\n        Returns:\n            int: bytes of space available on filesystem\n\n        Raises:\n            FailedToFetchSpaceAvailable: if could not determine space available... duh :)\n\n        \"\"\"\n        self.logger.info(\"determining space available from device output\")\n\n        bytes_available_match = re.search(pattern=BYTES_FREE, string=output)\n        if not bytes_available_match:\n            msg = \"could not determine space available on filesystem\"\n            self.logger.critical(msg)\n            raise FailedToFetchSpaceAvailable(msg)\n\n        return int(bytes_available_match.groupdict()[\"bytes_available\"])\n\n    def _space_available(self, filesystem_bytes_available: int) -&gt; None:\n\"\"\"\n        Space available operations for parity between sync and async\n\n        It seems that on iosxe the length of the config is near enough 1:1 to the size it takes up\n        on the disk... so roll w/ that plus a bit of buffer based on the available buffer perc\n\n        Args:\n            filesystem_bytes_available: bytes available on filesystem\n\n        Returns:\n            None\n\n        Raises:\n            InsufficientSpaceAvailable: if... insufficient space available....\n\n        \"\"\"\n        if filesystem_bytes_available &lt; (\n            len(self.candidate_config) / (self._filesystem_space_available_buffer_perc / 100)\n        ) + len(self.candidate_config):\n            # filesystem has less than candidate config file size + 10% (by default) space, bail out\n            msg = (\n                f\"insufficient space available for candidate config + \"\n                f\"{self._filesystem_space_available_buffer_perc}% (buffer)\"\n            )\n            self.logger.critical(msg)\n            raise InsufficientSpaceAvailable(msg)\n\n    def _post_determine_file_prompt_mode(self, output: str) -&gt; FilePromptMode:\n\"\"\"\n        Handle post \"determine_file_prompt_mode\" operations for parity between sync and async\n\n        Args:\n            output: output that was fetched from the device\n\n        Returns:\n            FilePromptMode: enum representing file prompt mode\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.logger.debug(\"determining file prompt mode from device output\")\n\n        file_prompt_match = re.search(pattern=FILE_PROMPT_MODE, string=output)\n        if not file_prompt_match:\n            return FilePromptMode.ALERT\n        prompt_mode = file_prompt_match.groupdict()[\"prompt_mode\"]\n        if prompt_mode == \"noisy\":\n            return FilePromptMode.NOISY\n        return FilePromptMode.QUIET\n\n    @staticmethod\n    def _parse_version(device_output: str) -&gt; str:\n\"\"\"\n        Parse version string out of device output\n\n        Args:\n            device_output: output from show version command\n\n        Returns:\n            str: device version string\n\n        Raises:\n            N/A\n\n        \"\"\"\n        version_string_search = re.search(pattern=VERSION_PATTERN, string=device_output)\n\n        if not version_string_search:\n            return \"\"\n\n        version_string = version_string_search.group(0) or \"\"\n        return version_string\n\n    def clean_config(self, config: str) -&gt; str:\n\"\"\"\n        Clean a configuration file of unwanted lines\n\n        Args:\n            config: configuration string to \"clean\"; cleaning removes lines that would prevent using\n                the provided configuration as a \"load_config\" source from working -- i.e. removes\n                the leading \"Building Configuration\" line\n\n        Returns:\n            str: cleaned configuration string\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.logger.debug(\"cleaning config file\")\n\n        return strip_blank_lines(\n            config=re.sub(pattern=OUTPUT_HEADER_PATTERN, string=config, repl=\"\", count=1)\n        )\n\n    def _reset_config_session(self) -&gt; None:\n\"\"\"\n        Reset config session info\n\n        Resets the candidate config and config session name attributes -- when these are \"empty\" we\n        know there is no current config session\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.logger.debug(\"resetting candidate config and candidate config file name\")\n        self.candidate_config = \"\"\n        self.candidate_config_filename = \"\"\n\n    @staticmethod\n    def _get_config_command(source: str) -&gt; str:\n\"\"\"\n        Return command to use to get config based on the provided source\n\n        Args:\n            source: name of the config source, generally running|startup\n\n        Returns:\n            str: command to use to fetch the requested config\n\n        Raises:\n            N/A\n\n        \"\"\"\n        if source == \"running\":\n            return \"show running-config\"\n        return \"show startup-config\"\n\n    def _get_diff_command(self, source: str) -&gt; str:\n\"\"\"\n        Return command to use to get config diff based on the provided source\n\n        Args:\n            source: name of the config source, generally running|startup\n\n        Returns:\n            str: command to use to fetch the requested config\n\n        Raises:\n            N/A\n\n        \"\"\"\n        if self._replace:\n            return (\n                f\"show archive config differences system:{source}-config {self.filesystem}\"\n                f\"{self.candidate_config_filename}\"\n            )\n        return (\n            f\"show archive config incremental-diffs {self.filesystem}\"\n            f\"{self.candidate_config_filename} ignorecase\"\n        )\n\n    def _prepare_config_payloads(self, config: str) -&gt; str:\n\"\"\"\n        Prepare a configuration so it can be nicely sent to the device via scrapli\n\n        Args:\n            config: configuration to prep\n\n        Returns:\n            str: string of config lines to write to candidate config file\n\n        Raises:\n            N/A\n\n        \"\"\"\n        tclsh_start_file = f'puts [open \"{self.filesystem}{self.candidate_config_filename}\" w+] {{'\n        tclsh_end_file = \"}\"\n        final_config = \"\\n\".join((tclsh_start_file, config, tclsh_end_file))\n\n        return final_config\n\n    def _prepare_load_config(self, config: str, replace: bool) -&gt; str:\n\"\"\"\n        Handle pre \"load_config\" operations for parity between sync and async\n\n        Args:\n            config: candidate config to load\n            replace: True/False replace the configuration; passed here so it can be set at the class\n                level as we need to stay in config mode and we need to know if we are doing a merge\n                or a replace when we go to diff things\n\n        Returns:\n            str: string of config to write to candidate config file\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.candidate_config = config\n\n        if not self.candidate_config_filename:\n            self.candidate_config_filename = f\"scrapli_cfg_{round(datetime.now().timestamp())}\"\n            self.logger.debug(\n                f\"candidate config file name will be '{self.candidate_config_filename}'\"\n            )\n\n        config = self._prepare_config_payloads(config=config)\n        self._replace = replace\n\n        return config\n\n    def _normalize_source_candidate_configs(self, source_config: str) -&gt; Tuple[str, str]:\n\"\"\"\n        Normalize candidate config and source config so that we can easily diff them\n\n        Args:\n            source_config: current config of the source config store\n\n        Returns:\n            ScrapliCfgDiff: scrapli cfg diff object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.logger.debug(\"normalizing source and candidate configs for diff object\")\n\n        # remove any of the leading timestamp/building config/config size/last change lines in\n        # both the source and candidate configs so they dont need to be compared\n        source_config = self.clean_config(config=source_config)\n        candidate_config = self.clean_config(config=self.candidate_config)\n\n        return source_config, candidate_config\n</code></pre>"},{"location":"reference/platform/core/cisco_iosxe/base_platform/#platform.core.cisco_iosxe.base_platform.ScrapliCfgIOSXEBase.clean_config","title":"<code>clean_config(config: str) -&gt; str</code>","text":"<p>Clean a configuration file of unwanted lines</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>str</code> <p>configuration string to \"clean\"; cleaning removes lines that would prevent using the provided configuration as a \"load_config\" source from working -- i.e. removes the leading \"Building Configuration\" line</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>cleaned configuration string</p> Source code in <code>platform/core/cisco_iosxe/base_platform.py</code> <pre><code>def clean_config(self, config: str) -&gt; str:\n\"\"\"\n    Clean a configuration file of unwanted lines\n\n    Args:\n        config: configuration string to \"clean\"; cleaning removes lines that would prevent using\n            the provided configuration as a \"load_config\" source from working -- i.e. removes\n            the leading \"Building Configuration\" line\n\n    Returns:\n        str: cleaned configuration string\n\n    Raises:\n        N/A\n\n    \"\"\"\n    self.logger.debug(\"cleaning config file\")\n\n    return strip_blank_lines(\n        config=re.sub(pattern=OUTPUT_HEADER_PATTERN, string=config, repl=\"\", count=1)\n    )\n</code></pre>"},{"location":"reference/platform/core/cisco_iosxe/patterns/","title":"Patterns","text":"<p>scrapli_cfg.platform.core.cisco_iosxe.patterns</p>"},{"location":"reference/platform/core/cisco_iosxe/sync_platform/","title":"Sync platform","text":"<p>scrapli_cfg.platform.core.cisco_iosxe.sync_platform</p>"},{"location":"reference/platform/core/cisco_iosxe/sync_platform/#platform.core.cisco_iosxe.sync_platform.ScrapliCfgIOSXE","title":"<code>ScrapliCfgIOSXE</code>","text":"<p>         Bases: <code>ScrapliCfgPlatform</code>, <code>ScrapliCfgIOSXEBase</code></p> Source code in <code>platform/core/cisco_iosxe/sync_platform.py</code> <pre><code>class ScrapliCfgIOSXE(ScrapliCfgPlatform, ScrapliCfgIOSXEBase):\n    def __init__(\n        self,\n        conn: NetworkDriver,\n        *,\n        config_sources: Optional[List[str]] = None,\n        on_prepare: Optional[Callable[..., Any]] = None,\n        filesystem: str = \"flash:\",\n        cleanup_post_commit: bool = True,\n        dedicated_connection: bool = False,\n        ignore_version: bool = False,\n    ) -&gt; None:\n        if config_sources is None:\n            config_sources = CONFIG_SOURCES\n\n        super().__init__(\n            conn=conn,\n            config_sources=config_sources,\n            on_prepare=on_prepare,\n            dedicated_connection=dedicated_connection,\n            ignore_version=ignore_version,\n        )\n\n        self.filesystem = filesystem\n        self._filesystem_space_available_buffer_perc = 10\n\n        self._replace = False\n\n        self.candidate_config_filename = \"\"\n\n        self.cleanup_post_commit = cleanup_post_commit\n\n    def _get_filesystem_space_available(self) -&gt; int:\n\"\"\"\n        Abort a configuration -- discards any loaded config\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            FailedToDetermineDeviceState: if unable to fetch file filesystem bytes available\n\n        \"\"\"\n        filesystem_size_result = self.conn.send_command(command=f\"dir {self.filesystem} | i bytes\")\n        if filesystem_size_result.failed:\n            raise FailedToDetermineDeviceState(\"failed to determine space available on filesystem\")\n\n        return self._post_get_filesystem_space_available(output=filesystem_size_result.result)\n\n    def _determine_file_prompt_mode(self) -&gt; FilePromptMode:\n\"\"\"\n        Determine the device file prompt mode\n\n        Args:\n            N/A\n\n        Returns:\n            FilePromptMode: enum representing file prompt mode\n\n        Raises:\n            FailedToDetermineDeviceState: if unable to fetch file prompt mode\n\n        \"\"\"\n        file_prompt_mode_result = self.conn.send_command(command=\"show run | i file prompt\")\n        if file_prompt_mode_result.failed:\n            raise FailedToDetermineDeviceState(\"failed to determine file prompt mode\")\n\n        return self._post_determine_file_prompt_mode(output=file_prompt_mode_result.result)\n\n    def _delete_candidate_config(self) -&gt; Response:\n\"\"\"\n        Delete candidate config from the filesystem\n\n        Args:\n            N/A\n\n        Returns:\n            Response: response from deleting the candidate config\n\n        Raises:\n            N/A\n\n        \"\"\"\n        # have to check again because the candidate config may have changed this!\n        file_prompt_mode = self._determine_file_prompt_mode()\n        if file_prompt_mode in (FilePromptMode.ALERT, FilePromptMode.NOISY):\n            delete_events = [\n                (\n                    f\"delete {self.filesystem}{self.candidate_config_filename}\",\n                    \"Delete filename\",\n                ),\n                (\n                    \"\",\n                    \"[confirm]\",\n                ),\n                (\"\", \"\"),\n            ]\n        else:\n            delete_events = [\n                (f\"delete {self.filesystem}{self.candidate_config_filename}\", \"[confirm]\"),\n                (\"\", \"\"),\n            ]\n        delete_result = self.conn.send_interactive(interact_events=delete_events)\n        return delete_result\n\n    def get_version(self) -&gt; ScrapliCfgResponse:\n        response = self._pre_get_version()\n\n        version_result = self.conn.send_command(command=\"show version | i Version\")\n\n        return self._post_get_version(\n            response=response,\n            scrapli_responses=[version_result],\n            result=self._parse_version(device_output=version_result.result),\n        )\n\n    def get_config(self, source: str = \"running\") -&gt; ScrapliCfgResponse:\n        response = self._pre_get_config(source=source)\n\n        config_result = self.conn.send_command(command=self._get_config_command(source=source))\n\n        return self._post_get_config(\n            response=response,\n            source=source,\n            scrapli_responses=[config_result],\n            result=config_result.result,\n        )\n\n    def load_config(self, config: str, replace: bool = False, **kwargs: Any) -&gt; ScrapliCfgResponse:\n\"\"\"\n        Load configuration to a device\n\n        Supported kwargs:\n            auto_clean: automatically \"clean\" any data that would be in a configuration from a\n                \"get_config\" operation that would prevent loading a config -- for example, things\n                like the \"Building Configuration\" lines in IOSXE output, etc.. Defaults to `True`\n\n        Args:\n            config: string of the configuration to load\n            replace: replace the configuration or not, if false configuration will be loaded as a\n                merge operation\n            kwargs: additional kwargs that the implementing classes may need for their platform,\n                see above for iosxe supported kwargs\n\n        Returns:\n            ScrapliCfgResponse: response object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        if kwargs.get(\"auto_clean\", True) is True:\n            config = self.clean_config(config=config)\n\n        response = self._pre_load_config(config=config)\n\n        config = self._prepare_load_config(config=config, replace=replace)\n\n        filesystem_bytes_available = self._get_filesystem_space_available()\n        self._space_available(filesystem_bytes_available=filesystem_bytes_available)\n\n        # when in tcl command mode or whatever it is, tcl wants \\r for return char, so stash the\n        # original return char and sub in \\r for a bit\n        original_return_char = self.conn.comms_return_char\n        tcl_comms_return_char = \"\\r\"\n\n        # pop into tclsh before swapping the return char just to be safe -- \\r or \\n should both be\n        # fine for up to here but who knows... :)\n        self.conn.acquire_priv(desired_priv=\"tclsh\")\n        self.conn.comms_return_char = tcl_comms_return_char\n        config_result = self.conn.send_config(config=config, privilege_level=\"tclsh\")\n\n        # reset the return char to the \"normal\" one and drop into whatever is the \"default\" priv\n        self.conn.acquire_priv(desired_priv=self.conn.default_desired_privilege_level)\n        self.conn.comms_return_char = original_return_char\n\n        return self._post_load_config(\n            response=response,\n            scrapli_responses=[config_result],\n        )\n\n    def abort_config(self) -&gt; ScrapliCfgResponse:\n        response = self._pre_abort_config(\n            session_or_config_file=bool(self.candidate_config_filename)\n        )\n\n        abort_result = self._delete_candidate_config()\n        self._reset_config_session()\n\n        return self._post_abort_config(response=response, scrapli_responses=[abort_result])\n\n    def save_config(self) -&gt; Response:\n\"\"\"\n        Save the config -- \"copy run start\"!\n\n        Args:\n             N/A\n\n        Returns:\n            Response: scrapli response object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        # we always re-check file prompt mode because it could have changed!\n        file_prompt_mode = self._determine_file_prompt_mode()\n\n        if file_prompt_mode == FilePromptMode.ALERT:\n            save_events = [\n                (\n                    \"copy running-config startup-config\",\n                    \"Destination filename\",\n                ),\n                (\"\", \"\"),\n            ]\n        elif file_prompt_mode == FilePromptMode.NOISY:\n            save_events = [\n                (\n                    \"copy running-config startup-config\",\n                    \"Source filename\",\n                ),\n                (\n                    \"\",\n                    \"Destination filename\",\n                ),\n                (\"\", \"\"),\n            ]\n        else:\n            save_events = [(\"copy running-config startup-config\", \"\")]\n\n        save_result = self.conn.send_interactive(interact_events=save_events)\n        return save_result\n\n    def _commit_config_merge(self, file_prompt_mode: Optional[FilePromptMode] = None) -&gt; Response:\n\"\"\"\n        Commit the configuration in merge mode\n\n        Args:\n             file_prompt_mode: optionally provide the file prompt mode, if its None we will fetch it\n                 to decide if we need to use interactive mode or not\n\n        Returns:\n            Response: scrapli response object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        if file_prompt_mode is None:\n            file_prompt_mode = self._determine_file_prompt_mode()\n\n        if file_prompt_mode == FilePromptMode.ALERT:\n            merge_events = [\n                (\n                    f\"copy {self.filesystem}{self.candidate_config_filename} running-config\",\n                    \"Destination filename\",\n                ),\n                (\"\", \"\"),\n            ]\n        elif file_prompt_mode == FilePromptMode.NOISY:\n            merge_events = [\n                (\n                    f\"copy {self.filesystem}{self.candidate_config_filename} running-config\",\n                    \"Source filename\",\n                ),\n                (\n                    \"\",\n                    \"Destination filename\",\n                ),\n                (\"\", \"\"),\n            ]\n        else:\n            merge_events = [\n                (f\"copy {self.filesystem}{self.candidate_config_filename} running-config\", \"\")\n            ]\n\n        commit_result = self.conn.send_interactive(interact_events=merge_events)\n        return commit_result\n\n    def commit_config(self, source: str = \"running\") -&gt; ScrapliCfgResponse:\n        scrapli_responses = []\n        response = self._pre_commit_config(\n            source=source, session_or_config_file=bool(self.candidate_config_filename)\n        )\n\n        file_prompt_mode = self._determine_file_prompt_mode()\n\n        if self._replace is True:\n            replace_command = (\n                f\"configure replace {self.filesystem}{self.candidate_config_filename} force\"\n            )\n            commit_result = self.conn.send_command(command=replace_command)\n        else:\n            commit_result = self._commit_config_merge(file_prompt_mode=file_prompt_mode)\n\n        scrapli_responses.append(commit_result)\n\n        save_config_result = self.save_config()\n        scrapli_responses.append(save_config_result)\n\n        if self.cleanup_post_commit:\n            cleanup_result = self._delete_candidate_config()\n            scrapli_responses.append(cleanup_result)\n\n        self._reset_config_session()\n\n        return self._post_load_config(\n            response=response,\n            scrapli_responses=scrapli_responses,\n        )\n\n    def diff_config(self, source: str = \"running\") -&gt; ScrapliCfgDiffResponse:\n        scrapli_responses = []\n        device_diff = \"\"\n        source_config = \"\"\n\n        diff_response = self._pre_diff_config(\n            source=source, session_or_config_file=bool(self.candidate_config_filename)\n        )\n\n        try:\n            diff_result = self.conn.send_command(command=self._get_diff_command(source=source))\n            scrapli_responses.append(diff_result)\n            if diff_result.failed:\n                msg = \"failed generating diff for config session\"\n                self.logger.critical(msg)\n                raise DiffConfigError(msg)\n\n            device_diff = diff_result.result\n\n            source_config_result = self.get_config(source=source)\n            source_config = source_config_result.result\n\n            if isinstance(source_config_result.scrapli_responses, MultiResponse):\n                # in this case this will always be a multiresponse or nothing (failure) but mypy\n                # doesnt know that, hence the isinstance check\n                scrapli_responses.extend(source_config_result.scrapli_responses)\n\n            if source_config_result.failed:\n                msg = \"failed fetching source config for diff comparison\"\n                self.logger.critical(msg)\n                raise DiffConfigError(msg)\n\n        except DiffConfigError:\n            pass\n\n        return self._post_diff_config(\n            diff_response=diff_response,\n            scrapli_responses=scrapli_responses,\n            source_config=self.clean_config(source_config),\n            candidate_config=self.clean_config(self.candidate_config),\n            device_diff=device_diff,\n        )\n</code></pre>"},{"location":"reference/platform/core/cisco_iosxe/sync_platform/#platform.core.cisco_iosxe.sync_platform.ScrapliCfgIOSXE.load_config","title":"<code>load_config(config: str, replace: bool = False, **kwargs: Any) -&gt; ScrapliCfgResponse</code>","text":"<p>Load configuration to a device</p> Supported kwargs <p>auto_clean: automatically \"clean\" any data that would be in a configuration from a     \"get_config\" operation that would prevent loading a config -- for example, things     like the \"Building Configuration\" lines in IOSXE output, etc.. Defaults to <code>True</code></p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>str</code> <p>string of the configuration to load</p> required <code>replace</code> <code>bool</code> <p>replace the configuration or not, if false configuration will be loaded as a merge operation</p> <code>False</code> <code>kwargs</code> <p>additional kwargs that the implementing classes may need for their platform, see above for iosxe supported kwargs</p> required <p>Returns:</p> Name Type Description <code>ScrapliCfgResponse</code> <code>ScrapliCfgResponse</code> <p>response object</p> Source code in <code>platform/core/cisco_iosxe/sync_platform.py</code> <pre><code>def load_config(self, config: str, replace: bool = False, **kwargs: Any) -&gt; ScrapliCfgResponse:\n\"\"\"\n    Load configuration to a device\n\n    Supported kwargs:\n        auto_clean: automatically \"clean\" any data that would be in a configuration from a\n            \"get_config\" operation that would prevent loading a config -- for example, things\n            like the \"Building Configuration\" lines in IOSXE output, etc.. Defaults to `True`\n\n    Args:\n        config: string of the configuration to load\n        replace: replace the configuration or not, if false configuration will be loaded as a\n            merge operation\n        kwargs: additional kwargs that the implementing classes may need for their platform,\n            see above for iosxe supported kwargs\n\n    Returns:\n        ScrapliCfgResponse: response object\n\n    Raises:\n        N/A\n\n    \"\"\"\n    if kwargs.get(\"auto_clean\", True) is True:\n        config = self.clean_config(config=config)\n\n    response = self._pre_load_config(config=config)\n\n    config = self._prepare_load_config(config=config, replace=replace)\n\n    filesystem_bytes_available = self._get_filesystem_space_available()\n    self._space_available(filesystem_bytes_available=filesystem_bytes_available)\n\n    # when in tcl command mode or whatever it is, tcl wants \\r for return char, so stash the\n    # original return char and sub in \\r for a bit\n    original_return_char = self.conn.comms_return_char\n    tcl_comms_return_char = \"\\r\"\n\n    # pop into tclsh before swapping the return char just to be safe -- \\r or \\n should both be\n    # fine for up to here but who knows... :)\n    self.conn.acquire_priv(desired_priv=\"tclsh\")\n    self.conn.comms_return_char = tcl_comms_return_char\n    config_result = self.conn.send_config(config=config, privilege_level=\"tclsh\")\n\n    # reset the return char to the \"normal\" one and drop into whatever is the \"default\" priv\n    self.conn.acquire_priv(desired_priv=self.conn.default_desired_privilege_level)\n    self.conn.comms_return_char = original_return_char\n\n    return self._post_load_config(\n        response=response,\n        scrapli_responses=[config_result],\n    )\n</code></pre>"},{"location":"reference/platform/core/cisco_iosxe/sync_platform/#platform.core.cisco_iosxe.sync_platform.ScrapliCfgIOSXE.save_config","title":"<code>save_config() -&gt; Response</code>","text":"<p>Save the config -- \"copy run start\"!</p> <p>Returns:</p> Name Type Description <code>Response</code> <code>Response</code> <p>scrapli response object</p> Source code in <code>platform/core/cisco_iosxe/sync_platform.py</code> <pre><code>def save_config(self) -&gt; Response:\n\"\"\"\n    Save the config -- \"copy run start\"!\n\n    Args:\n         N/A\n\n    Returns:\n        Response: scrapli response object\n\n    Raises:\n        N/A\n\n    \"\"\"\n    # we always re-check file prompt mode because it could have changed!\n    file_prompt_mode = self._determine_file_prompt_mode()\n\n    if file_prompt_mode == FilePromptMode.ALERT:\n        save_events = [\n            (\n                \"copy running-config startup-config\",\n                \"Destination filename\",\n            ),\n            (\"\", \"\"),\n        ]\n    elif file_prompt_mode == FilePromptMode.NOISY:\n        save_events = [\n            (\n                \"copy running-config startup-config\",\n                \"Source filename\",\n            ),\n            (\n                \"\",\n                \"Destination filename\",\n            ),\n            (\"\", \"\"),\n        ]\n    else:\n        save_events = [(\"copy running-config startup-config\", \"\")]\n\n    save_result = self.conn.send_interactive(interact_events=save_events)\n    return save_result\n</code></pre>"},{"location":"reference/platform/core/cisco_iosxr/","title":"Index","text":"<p>scrapli_cfg.platform.core.cisco_iosxr</p>"},{"location":"reference/platform/core/cisco_iosxr/async_platform/","title":"Async platform","text":"<p>scrapli_cfg.platform.core.cisco_iosxr.async_platform</p>"},{"location":"reference/platform/core/cisco_iosxr/async_platform/#platform.core.cisco_iosxr.async_platform.AsyncScrapliCfgIOSXR","title":"<code>AsyncScrapliCfgIOSXR</code>","text":"<p>         Bases: <code>AsyncScrapliCfgPlatform</code>, <code>ScrapliCfgIOSXRBase</code></p> Source code in <code>platform/core/cisco_iosxr/async_platform.py</code> <pre><code>class AsyncScrapliCfgIOSXR(AsyncScrapliCfgPlatform, ScrapliCfgIOSXRBase):\n    def __init__(\n        self,\n        conn: AsyncNetworkDriver,\n        *,\n        config_sources: Optional[List[str]] = None,\n        on_prepare: Optional[Callable[..., Any]] = None,\n        dedicated_connection: bool = False,\n        ignore_version: bool = False,\n    ) -&gt; None:\n        if config_sources is None:\n            config_sources = CONFIG_SOURCES\n\n        super().__init__(\n            conn=conn,\n            config_sources=config_sources,\n            on_prepare=on_prepare,\n            dedicated_connection=dedicated_connection,\n            ignore_version=ignore_version,\n        )\n\n        self._replace = False\n\n        self._in_configuration_session = False\n        self._config_privilege_level = \"configuration\"\n\n    async def get_version(self) -&gt; ScrapliCfgResponse:\n        response = self._pre_get_version()\n\n        version_result = await self.conn.send_command(command=\"show version | i Version\")\n\n        return self._post_get_version(\n            response=response,\n            scrapli_responses=[version_result],\n            result=self._parse_version(device_output=version_result.result),\n        )\n\n    async def get_config(self, source: str = \"running\") -&gt; ScrapliCfgResponse:\n        response = self._pre_get_config(source=source)\n\n        if not self._in_configuration_session:\n            config_result = await self.conn.send_command(command=\"show running-config\")\n        else:\n            config_result = await self.conn.send_config(\n                config=\"show running-config\", privilege_level=self._config_privilege_level\n            )\n\n        return self._post_get_config(\n            response=response,\n            source=source,\n            scrapli_responses=[config_result],\n            result=config_result.result,\n        )\n\n    async def load_config(\n        self, config: str, replace: bool = False, **kwargs: Any\n    ) -&gt; ScrapliCfgResponse:\n\"\"\"\n        Load configuration to a device\n\n        Supported kwargs:\n            exclusive: True/False use `configure exclusive` mode\n\n        Args:\n            config: string of the configuration to load\n            replace: replace the configuration or not, if false configuration will be loaded as a\n                merge operation\n            kwargs: additional kwargs that the implementing classes may need for their platform,\n                see above for iosxr supported kwargs\n\n        Returns:\n            ScrapliCfgResponse: response object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        scrapli_responses = []\n        response = self._pre_load_config(config=config)\n\n        exclusive = kwargs.get(\"exclusive\", False)\n\n        config, eager_config = self._prepare_load_config_session_and_payload(\n            config=config, replace=replace, exclusive=exclusive\n        )\n\n        try:\n            config_result = await self.conn.send_config(\n                config=config, privilege_level=self._config_privilege_level\n            )\n            scrapli_responses.append(config_result)\n            if config_result.failed:\n                msg = \"failed to load the candidate config into the config session\"\n                self.logger.critical(msg)\n                raise LoadConfigError(msg)\n\n            # eager cuz banners and such; perhaps if no banner/macro we can disable eager though....\n            if eager_config:\n                eager_config_result = await self.conn.send_config(\n                    config=eager_config, privilege_level=self._config_privilege_level, eager=True\n                )\n                scrapli_responses.append(eager_config_result)\n                if eager_config_result.failed:\n                    msg = \"failed to load the candidate config into the config session\"\n                    self.logger.critical(msg)\n                    raise LoadConfigError(msg)\n\n        except LoadConfigError:\n            pass\n\n        return self._post_load_config(\n            response=response,\n            scrapli_responses=scrapli_responses,\n        )\n\n    async def abort_config(self) -&gt; ScrapliCfgResponse:\n        response = self._pre_abort_config(session_or_config_file=self._in_configuration_session)\n\n        await self.conn._abort_config()  # pylint: disable=W0212\n        self._reset_config_session()\n\n        return self._post_abort_config(response=response, scrapli_responses=[])\n\n    async def commit_config(self, source: str = \"running\") -&gt; ScrapliCfgResponse:\n        scrapli_responses: List[Union[MultiResponse, Response]] = []\n        response = self._pre_commit_config(\n            source=source, session_or_config_file=self._in_configuration_session\n        )\n\n        if self._replace is True:\n            commit_events = [(\"commit replace\", \"proceed?\"), (\"yes\", \"\")]\n            commit_result = await self.conn.send_interactive(\n                interact_events=commit_events, privilege_level=self._config_privilege_level\n            )\n        else:\n            commit_result = await self.conn.send_config(config=\"commit\")\n\n        scrapli_responses.append(commit_result)\n        self._reset_config_session()\n\n        return self._post_commit_config(response=response, scrapli_responses=[commit_result])\n\n    async def diff_config(self, source: str = \"running\") -&gt; ScrapliCfgDiffResponse:\n        scrapli_responses = []\n        device_diff = \"\"\n        source_config = \"\"\n\n        diff_response = self._pre_diff_config(\n            source=source, session_or_config_file=self._in_configuration_session\n        )\n\n        try:\n            diff_result = await self.conn.send_config(\n                config=self._get_diff_command(), privilege_level=self._config_privilege_level\n            )\n            scrapli_responses.append(diff_result)\n            if diff_result.failed:\n                msg = \"failed generating diff for config session\"\n                self.logger.critical(msg)\n                raise DiffConfigError(msg)\n\n            device_diff = diff_result.result\n\n            source_config_result = await self.get_config(source=source)\n            source_config = source_config_result.result\n\n            if isinstance(source_config_result.scrapli_responses, MultiResponse):\n                # in this case this will always be a multiresponse or nothing (failure) but mypy\n                # doesnt know that, hence the isinstance check\n                scrapli_responses.extend(source_config_result.scrapli_responses)\n\n            if source_config_result.failed:\n                msg = \"failed fetching source config for diff comparison\"\n                self.logger.critical(msg)\n                raise DiffConfigError(msg)\n\n        except DiffConfigError:\n            pass\n\n        return self._post_diff_config(\n            diff_response=diff_response,\n            scrapli_responses=scrapli_responses,\n            source_config=self.clean_config(source_config),\n            candidate_config=self.clean_config(self.candidate_config),\n            device_diff=device_diff,\n        )\n</code></pre>"},{"location":"reference/platform/core/cisco_iosxr/async_platform/#platform.core.cisco_iosxr.async_platform.AsyncScrapliCfgIOSXR.load_config","title":"<code>load_config(config: str, replace: bool = False, **kwargs: Any) -&gt; ScrapliCfgResponse</code>  <code>async</code>","text":"<p>Load configuration to a device</p> Supported kwargs <p>exclusive: True/False use <code>configure exclusive</code> mode</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>str</code> <p>string of the configuration to load</p> required <code>replace</code> <code>bool</code> <p>replace the configuration or not, if false configuration will be loaded as a merge operation</p> <code>False</code> <code>kwargs</code> <p>additional kwargs that the implementing classes may need for their platform, see above for iosxr supported kwargs</p> required <p>Returns:</p> Name Type Description <code>ScrapliCfgResponse</code> <code>ScrapliCfgResponse</code> <p>response object</p> Source code in <code>platform/core/cisco_iosxr/async_platform.py</code> <pre><code>async def load_config(\n    self, config: str, replace: bool = False, **kwargs: Any\n) -&gt; ScrapliCfgResponse:\n\"\"\"\n    Load configuration to a device\n\n    Supported kwargs:\n        exclusive: True/False use `configure exclusive` mode\n\n    Args:\n        config: string of the configuration to load\n        replace: replace the configuration or not, if false configuration will be loaded as a\n            merge operation\n        kwargs: additional kwargs that the implementing classes may need for their platform,\n            see above for iosxr supported kwargs\n\n    Returns:\n        ScrapliCfgResponse: response object\n\n    Raises:\n        N/A\n\n    \"\"\"\n    scrapli_responses = []\n    response = self._pre_load_config(config=config)\n\n    exclusive = kwargs.get(\"exclusive\", False)\n\n    config, eager_config = self._prepare_load_config_session_and_payload(\n        config=config, replace=replace, exclusive=exclusive\n    )\n\n    try:\n        config_result = await self.conn.send_config(\n            config=config, privilege_level=self._config_privilege_level\n        )\n        scrapli_responses.append(config_result)\n        if config_result.failed:\n            msg = \"failed to load the candidate config into the config session\"\n            self.logger.critical(msg)\n            raise LoadConfigError(msg)\n\n        # eager cuz banners and such; perhaps if no banner/macro we can disable eager though....\n        if eager_config:\n            eager_config_result = await self.conn.send_config(\n                config=eager_config, privilege_level=self._config_privilege_level, eager=True\n            )\n            scrapli_responses.append(eager_config_result)\n            if eager_config_result.failed:\n                msg = \"failed to load the candidate config into the config session\"\n                self.logger.critical(msg)\n                raise LoadConfigError(msg)\n\n    except LoadConfigError:\n        pass\n\n    return self._post_load_config(\n        response=response,\n        scrapli_responses=scrapli_responses,\n    )\n</code></pre>"},{"location":"reference/platform/core/cisco_iosxr/base_platform/","title":"Base platform","text":"<p>scrapli_cfg.platform.core.cisco_iosxr.base_platform</p>"},{"location":"reference/platform/core/cisco_iosxr/base_platform/#platform.core.cisco_iosxr.base_platform.ScrapliCfgIOSXRBase","title":"<code>ScrapliCfgIOSXRBase</code>","text":"Source code in <code>platform/core/cisco_iosxr/base_platform.py</code> <pre><code>class ScrapliCfgIOSXRBase:\n    logger: LoggerAdapterT\n    _in_configuration_session: bool\n    _config_privilege_level: str\n    _replace: bool\n    candidate_config: str\n\n    @staticmethod\n    def _parse_version(device_output: str) -&gt; str:\n\"\"\"\n        Parse version string out of device output\n\n        Args:\n            device_output: output from show version command\n\n        Returns:\n            str: device version string\n\n        Raises:\n            N/A\n\n        \"\"\"\n        version_string_search = re.search(pattern=VERSION_PATTERN, string=device_output)\n\n        if not version_string_search:\n            return \"\"\n\n        version_string = version_string_search.group(0) or \"\"\n        return version_string\n\n    @staticmethod\n    def _prepare_config_payloads(config: str) -&gt; Tuple[str, str]:\n\"\"\"\n        Prepare a configuration so it can be nicely sent to the device via scrapli\n\n        Args:\n            config: configuration to prep\n\n        Returns:\n            tuple: tuple of \"normal\" config lines and \"eager\" config lines\n\n        Raises:\n            N/A\n\n        \"\"\"\n        # remove building config lines\n        config = re.sub(pattern=OUTPUT_HEADER_PATTERN, repl=\"!\", string=config)\n\n        # remove \"end\" at the end of config if present - if its present it will drop scrapli out\n        # of the config session which we do not want\n        config = re.sub(pattern=END_PATTERN, repl=\"!\", string=config)\n\n        # find all sections that need to be \"eagerly\" sent\n        eager_config = re.findall(pattern=BANNER_PATTERN, string=config)\n\n        for eager_section in eager_config:\n            # afaik cant backreference a non capturing group so we have an extra group per match\n            # that we ignore here (element 1)\n            config = config.replace(eager_section[0], \"!\")\n\n        joined_eager_config = \"\\n\".join(captured_section[0] for captured_section in eager_config)\n\n        return config, joined_eager_config\n\n    def _prepare_load_config_session_and_payload(\n        self, config: str, replace: bool, exclusive: bool\n    ) -&gt; Tuple[str, str]:\n\"\"\"\n        Handle pre \"load_config\" operations for parity between sync and async\n\n        Args:\n            config: candidate config to load\n            replace: True/False replace the configuration; passed here so it can be set at the class\n                level as we need to stay in config mode and we need to know if we are doing a merge\n                or a replace when we go to diff things\n            exclusive: True/False use exclusive config mode\n\n        Returns:\n            tuple: tuple containing \"normal\" config elements to send to the device and \"eager\" mode\n                config elements to send to the device (things like banners/macro that require\n                scrapli \"eager=True\")\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.candidate_config = config\n        config, eager_config = self._prepare_config_payloads(config=config)\n\n        self._in_configuration_session = True\n        self._config_privilege_level = \"configuration_exclusive\" if exclusive else \"configuration\"\n        self._replace = replace\n\n        return config, eager_config\n\n    def _reset_config_session(self) -&gt; None:\n\"\"\"\n        Reset config session info\n\n        Resets the candidate config and config session name attributes -- when these are \"empty\" we\n        know there is no current config session\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.logger.debug(\"resetting candidate config and config session name\")\n        self.candidate_config = \"\"\n        self._in_configuration_session = False\n        self._config_privilege_level = \"configuration\"\n\n    def _get_diff_command(self) -&gt; str:\n\"\"\"\n        Generate diff command based on source to diff and filesystem/candidate config name\n\n        Args:\n            N/A\n\n        Returns:\n            str: command to use to diff the configuration\n\n        Raises:\n            N/A\n\n        \"\"\"\n        if self._replace:\n            return \"show configuration changes diff\"\n        return \"show commit changes diff\"\n\n    def clean_config(self, config: str) -&gt; str:\n\"\"\"\n        Clean a configuration file of unwanted lines\n\n        Args:\n            config: configuration string to \"clean\"; cleaning removes leading timestamp/building\n                config/xr version/last change lines.\n\n        Returns:\n            str: cleaned configuration string\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.logger.debug(\"cleaning config file\")\n\n        # remove any of the leading timestamp/building config/xr version/last change lines in\n        # both the source and candidate configs so they dont need to be compared\n        return strip_blank_lines(\n            config=re.sub(pattern=OUTPUT_HEADER_PATTERN, string=config, repl=\"\")\n        )\n</code></pre>"},{"location":"reference/platform/core/cisco_iosxr/base_platform/#platform.core.cisco_iosxr.base_platform.ScrapliCfgIOSXRBase.clean_config","title":"<code>clean_config(config: str) -&gt; str</code>","text":"<p>Clean a configuration file of unwanted lines</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>str</code> <p>configuration string to \"clean\"; cleaning removes leading timestamp/building config/xr version/last change lines.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>cleaned configuration string</p> Source code in <code>platform/core/cisco_iosxr/base_platform.py</code> <pre><code>def clean_config(self, config: str) -&gt; str:\n\"\"\"\n    Clean a configuration file of unwanted lines\n\n    Args:\n        config: configuration string to \"clean\"; cleaning removes leading timestamp/building\n            config/xr version/last change lines.\n\n    Returns:\n        str: cleaned configuration string\n\n    Raises:\n        N/A\n\n    \"\"\"\n    self.logger.debug(\"cleaning config file\")\n\n    # remove any of the leading timestamp/building config/xr version/last change lines in\n    # both the source and candidate configs so they dont need to be compared\n    return strip_blank_lines(\n        config=re.sub(pattern=OUTPUT_HEADER_PATTERN, string=config, repl=\"\")\n    )\n</code></pre>"},{"location":"reference/platform/core/cisco_iosxr/patterns/","title":"Patterns","text":"<p>scrapli_cfg.platform.core.cisco_iosxr.patterns</p>"},{"location":"reference/platform/core/cisco_iosxr/sync_platform/","title":"Sync platform","text":"<p>scrapli_cfg.platform.core.cisco_iosxr.sync_platform</p>"},{"location":"reference/platform/core/cisco_iosxr/sync_platform/#platform.core.cisco_iosxr.sync_platform.ScrapliCfgIOSXR","title":"<code>ScrapliCfgIOSXR</code>","text":"<p>         Bases: <code>ScrapliCfgPlatform</code>, <code>ScrapliCfgIOSXRBase</code></p> Source code in <code>platform/core/cisco_iosxr/sync_platform.py</code> <pre><code>class ScrapliCfgIOSXR(ScrapliCfgPlatform, ScrapliCfgIOSXRBase):\n    def __init__(\n        self,\n        conn: NetworkDriver,\n        *,\n        config_sources: Optional[List[str]] = None,\n        on_prepare: Optional[Callable[..., Any]] = None,\n        dedicated_connection: bool = False,\n        ignore_version: bool = False,\n    ) -&gt; None:\n        if config_sources is None:\n            config_sources = CONFIG_SOURCES\n\n        super().__init__(\n            conn=conn,\n            config_sources=config_sources,\n            on_prepare=on_prepare,\n            dedicated_connection=dedicated_connection,\n            ignore_version=ignore_version,\n        )\n\n        self._replace = False\n\n        self._in_configuration_session = False\n        self._config_privilege_level = \"configuration\"\n\n    def get_version(self) -&gt; ScrapliCfgResponse:\n        response = self._pre_get_version()\n\n        version_result = self.conn.send_command(command=\"show version | i Version\")\n\n        return self._post_get_version(\n            response=response,\n            scrapli_responses=[version_result],\n            result=self._parse_version(device_output=version_result.result),\n        )\n\n    def get_config(self, source: str = \"running\") -&gt; ScrapliCfgResponse:\n        response = self._pre_get_config(source=source)\n\n        if not self._in_configuration_session:\n            config_result = self.conn.send_command(command=\"show running-config\")\n        else:\n            config_result = self.conn.send_config(\n                config=\"show running-config\", privilege_level=self._config_privilege_level\n            )\n\n        return self._post_get_config(\n            response=response,\n            source=source,\n            scrapli_responses=[config_result],\n            result=config_result.result,\n        )\n\n    def load_config(self, config: str, replace: bool = False, **kwargs: Any) -&gt; ScrapliCfgResponse:\n\"\"\"\n        Load configuration to a device\n\n        Supported kwargs:\n            exclusive: True/False use `configure exclusive` mode\n\n        Args:\n            config: string of the configuration to load\n            replace: replace the configuration or not, if false configuration will be loaded as a\n                merge operation\n            kwargs: additional kwargs that the implementing classes may need for their platform,\n                see above for iosxr supported kwargs\n\n        Returns:\n            ScrapliCfgResponse: response object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        scrapli_responses = []\n        response = self._pre_load_config(config=config)\n\n        exclusive = kwargs.get(\"exclusive\", False)\n\n        config, eager_config = self._prepare_load_config_session_and_payload(\n            config=config, replace=replace, exclusive=exclusive\n        )\n\n        try:\n            config_result = self.conn.send_config(\n                config=config, privilege_level=self._config_privilege_level\n            )\n            scrapli_responses.append(config_result)\n            if config_result.failed:\n                msg = \"failed to load the candidate config into the config session\"\n                self.logger.critical(msg)\n                raise LoadConfigError(msg)\n\n            # eager cuz banners and such; perhaps if no banner/macro we can disable eager though....\n            if eager_config:\n                eager_config_result = self.conn.send_config(\n                    config=eager_config, privilege_level=self._config_privilege_level, eager=True\n                )\n                scrapli_responses.append(eager_config_result)\n                if eager_config_result.failed:\n                    msg = \"failed to load the candidate config into the config session\"\n                    self.logger.critical(msg)\n                    raise LoadConfigError(msg)\n\n        except LoadConfigError:\n            pass\n\n        return self._post_load_config(\n            response=response,\n            scrapli_responses=scrapli_responses,\n        )\n\n    def abort_config(self) -&gt; ScrapliCfgResponse:\n        response = self._pre_abort_config(session_or_config_file=self._in_configuration_session)\n\n        self.conn._abort_config()  # pylint: disable=W0212\n        self._reset_config_session()\n\n        return self._post_abort_config(response=response, scrapli_responses=[])\n\n    def commit_config(self, source: str = \"running\") -&gt; ScrapliCfgResponse:\n        scrapli_responses: List[Union[MultiResponse, Response]] = []\n        response = self._pre_commit_config(\n            source=source, session_or_config_file=self._in_configuration_session\n        )\n\n        if self._replace is True:\n            commit_events = [(\"commit replace\", \"proceed?\"), (\"yes\", \"\")]\n            commit_result = self.conn.send_interactive(\n                interact_events=commit_events, privilege_level=self._config_privilege_level\n            )\n        else:\n            commit_result = self.conn.send_config(config=\"commit\")\n\n        scrapli_responses.append(commit_result)\n        self._reset_config_session()\n\n        return self._post_commit_config(response=response, scrapli_responses=scrapli_responses)\n\n    def diff_config(self, source: str = \"running\") -&gt; ScrapliCfgDiffResponse:\n        scrapli_responses = []\n        device_diff = \"\"\n        source_config = \"\"\n\n        diff_response = self._pre_diff_config(\n            source=source, session_or_config_file=self._in_configuration_session\n        )\n\n        try:\n            diff_result = self.conn.send_config(\n                config=self._get_diff_command(), privilege_level=self._config_privilege_level\n            )\n            scrapli_responses.append(diff_result)\n            if diff_result.failed:\n                msg = \"failed generating diff for config session\"\n                self.logger.critical(msg)\n                raise DiffConfigError(msg)\n\n            device_diff = diff_result.result\n\n            source_config_result = self.get_config(source=source)\n            source_config = source_config_result.result\n\n            if isinstance(source_config_result.scrapli_responses, MultiResponse):\n                # in this case this will always be a multiresponse or nothing (failure) but mypy\n                # doesnt know that, hence the isinstance check\n                scrapli_responses.extend(source_config_result.scrapli_responses)\n\n            if source_config_result.failed:\n                msg = \"failed fetching source config for diff comparison\"\n                self.logger.critical(msg)\n                raise DiffConfigError(msg)\n\n        except DiffConfigError:\n            pass\n\n        return self._post_diff_config(\n            diff_response=diff_response,\n            scrapli_responses=scrapli_responses,\n            source_config=self.clean_config(source_config),\n            candidate_config=self.clean_config(self.candidate_config),\n            device_diff=device_diff,\n        )\n</code></pre>"},{"location":"reference/platform/core/cisco_iosxr/sync_platform/#platform.core.cisco_iosxr.sync_platform.ScrapliCfgIOSXR.load_config","title":"<code>load_config(config: str, replace: bool = False, **kwargs: Any) -&gt; ScrapliCfgResponse</code>","text":"<p>Load configuration to a device</p> Supported kwargs <p>exclusive: True/False use <code>configure exclusive</code> mode</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>str</code> <p>string of the configuration to load</p> required <code>replace</code> <code>bool</code> <p>replace the configuration or not, if false configuration will be loaded as a merge operation</p> <code>False</code> <code>kwargs</code> <p>additional kwargs that the implementing classes may need for their platform, see above for iosxr supported kwargs</p> required <p>Returns:</p> Name Type Description <code>ScrapliCfgResponse</code> <code>ScrapliCfgResponse</code> <p>response object</p> Source code in <code>platform/core/cisco_iosxr/sync_platform.py</code> <pre><code>def load_config(self, config: str, replace: bool = False, **kwargs: Any) -&gt; ScrapliCfgResponse:\n\"\"\"\n    Load configuration to a device\n\n    Supported kwargs:\n        exclusive: True/False use `configure exclusive` mode\n\n    Args:\n        config: string of the configuration to load\n        replace: replace the configuration or not, if false configuration will be loaded as a\n            merge operation\n        kwargs: additional kwargs that the implementing classes may need for their platform,\n            see above for iosxr supported kwargs\n\n    Returns:\n        ScrapliCfgResponse: response object\n\n    Raises:\n        N/A\n\n    \"\"\"\n    scrapli_responses = []\n    response = self._pre_load_config(config=config)\n\n    exclusive = kwargs.get(\"exclusive\", False)\n\n    config, eager_config = self._prepare_load_config_session_and_payload(\n        config=config, replace=replace, exclusive=exclusive\n    )\n\n    try:\n        config_result = self.conn.send_config(\n            config=config, privilege_level=self._config_privilege_level\n        )\n        scrapli_responses.append(config_result)\n        if config_result.failed:\n            msg = \"failed to load the candidate config into the config session\"\n            self.logger.critical(msg)\n            raise LoadConfigError(msg)\n\n        # eager cuz banners and such; perhaps if no banner/macro we can disable eager though....\n        if eager_config:\n            eager_config_result = self.conn.send_config(\n                config=eager_config, privilege_level=self._config_privilege_level, eager=True\n            )\n            scrapli_responses.append(eager_config_result)\n            if eager_config_result.failed:\n                msg = \"failed to load the candidate config into the config session\"\n                self.logger.critical(msg)\n                raise LoadConfigError(msg)\n\n    except LoadConfigError:\n        pass\n\n    return self._post_load_config(\n        response=response,\n        scrapli_responses=scrapli_responses,\n    )\n</code></pre>"},{"location":"reference/platform/core/cisco_nxos/","title":"Index","text":"<p>scrapli_cfg.platform.core.cisco_nxos</p>"},{"location":"reference/platform/core/cisco_nxos/async_platform/","title":"Async platform","text":"<p>scrapli_cfg.platform.core.cisco_nxos.async_platform</p>"},{"location":"reference/platform/core/cisco_nxos/async_platform/#platform.core.cisco_nxos.async_platform.AsyncScrapliCfgNXOS","title":"<code>AsyncScrapliCfgNXOS</code>","text":"<p>         Bases: <code>AsyncScrapliCfgPlatform</code>, <code>ScrapliCfgNXOSBase</code></p> Source code in <code>platform/core/cisco_nxos/async_platform.py</code> <pre><code>class AsyncScrapliCfgNXOS(AsyncScrapliCfgPlatform, ScrapliCfgNXOSBase):\n    def __init__(\n        self,\n        conn: AsyncNXOSDriver,\n        *,\n        config_sources: Optional[List[str]] = None,\n        on_prepare: Optional[Callable[..., Any]] = None,\n        filesystem: str = \"bootflash:\",\n        cleanup_post_commit: bool = True,\n        dedicated_connection: bool = False,\n        ignore_version: bool = False,\n    ) -&gt; None:\n        if config_sources is None:\n            config_sources = CONFIG_SOURCES\n\n        super().__init__(\n            conn=conn,\n            config_sources=config_sources,\n            on_prepare=on_prepare,\n            dedicated_connection=dedicated_connection,\n            ignore_version=ignore_version,\n        )\n\n        self.filesystem = filesystem\n        self._filesystem_space_available_buffer_perc = 10\n\n        self._replace = False\n\n        self.candidate_config_filename = \"\"\n\n        self.cleanup_post_commit = cleanup_post_commit\n\n    async def _get_filesystem_space_available(self) -&gt; int:\n\"\"\"\n        Get available space on filesystem\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            FailedToDetermineDeviceState: if unable to fetch file filesystem bytes available\n\n        \"\"\"\n        filesystem_size_result = await self.conn.send_command(\n            command=f\"dir {self.filesystem} | i 'bytes free'\"\n        )\n        if filesystem_size_result.failed:\n            raise FailedToDetermineDeviceState(\"failed to determine space available on filesystem\")\n\n        return self._post_get_filesystem_space_available(output=filesystem_size_result.result)\n\n    async def _delete_candidate_config(self) -&gt; MultiResponse:\n\"\"\"\n        Delete candidate config from the filesystem\n\n        Args:\n            N/A\n\n        Returns:\n            MultiResponse: response from deleting the candidate config\n\n        Raises:\n            N/A\n\n        \"\"\"\n        delete_commands = [\n            \"terminal dont-ask\",\n            f\"delete {self.filesystem}{self.candidate_config_filename}\",\n        ]\n        delete_result = await self.conn.send_commands(commands=delete_commands)\n        return delete_result\n\n    async def get_checkpoint(self) -&gt; ScrapliCfgResponse:\n\"\"\"\n        Get device checkpoint file\n\n        Args:\n            N/A\n\n        Returns:\n            ScrapliCfgResponse: response object containing string of the target config source as the\n                `result` attribute\n\n        Raises:\n            N/A\n\n        \"\"\"\n        response, checkpoint_commands = self._pre_get_checkpoint(conn=self.conn)\n\n        checkpoint_results = await self.conn.send_commands(commands=checkpoint_commands)\n\n        try:\n            checkpoint: str = checkpoint_results[2].result\n        except IndexError:\n            checkpoint = \"\"\n\n        return self._post_get_config(\n            response=response,\n            source=\"running\",\n            scrapli_responses=[checkpoint_results],\n            result=checkpoint,\n        )\n\n    async def get_version(self) -&gt; ScrapliCfgResponse:\n        response = self._pre_get_version()\n\n        version_result = await self.conn.send_command(command='show version | i \"NXOS: version\"')\n\n        return self._post_get_version(\n            response=response,\n            scrapli_responses=[version_result],\n            result=self._parse_version(device_output=version_result.result),\n        )\n\n    async def get_config(self, source: str = \"running\") -&gt; ScrapliCfgResponse:\n        response = self._pre_get_config(source=source)\n\n        config_result = await self.conn.send_command(\n            command=self._get_config_command(source=source)\n        )\n\n        return self._post_get_config(\n            response=response,\n            source=source,\n            scrapli_responses=[config_result],\n            result=config_result.result,\n        )\n\n    async def load_config(\n        self, config: str, replace: bool = False, **kwargs: Any\n    ) -&gt; ScrapliCfgResponse:\n\"\"\"\n        Load configuration to a device\n\n        Supported kwargs:\n            N/A\n\n        Args:\n            config: string of the configuration to load\n            replace: replace the configuration or not, if false configuration will be loaded as a\n                merge operation\n            kwargs: additional kwargs that the implementing classes may need for their platform,\n                see above for nxos supported kwargs\n\n        Returns:\n            ScrapliCfgResponse: response object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        response = self._pre_load_config(config=config)\n\n        config = self._prepare_load_config(config=config, replace=replace)\n\n        filesystem_bytes_available = await self._get_filesystem_space_available()\n        self._space_available(filesystem_bytes_available=filesystem_bytes_available)\n\n        await self.conn.acquire_priv(desired_priv=\"tclsh\")\n        config_result = await self.conn.send_config(config=config, privilege_level=\"tclsh\")\n        await self.conn.acquire_priv(desired_priv=self.conn.default_desired_privilege_level)\n\n        return self._post_load_config(\n            response=response,\n            scrapli_responses=[config_result],\n        )\n\n    async def abort_config(self) -&gt; ScrapliCfgResponse:\n        response = self._pre_abort_config(\n            session_or_config_file=bool(self.candidate_config_filename)\n        )\n\n        abort_result = await self._delete_candidate_config()\n        self._reset_config_session()\n\n        return self._post_abort_config(response=response, scrapli_responses=[abort_result])\n\n    async def commit_config(self, source: str = \"running\") -&gt; ScrapliCfgResponse:\n        scrapli_responses: List[Union[MultiResponse, Response]] = []\n        response = self._pre_commit_config(\n            source=source, session_or_config_file=bool(self.candidate_config_filename)\n        )\n\n        if self._replace is True:\n            replace_command = (\n                f\"rollback running-config file {self.filesystem}{self.candidate_config_filename}\"\n            )\n            commit_result = await self.conn.send_command(command=replace_command)\n        else:\n            merge_command = f\"copy {self.filesystem}{self.candidate_config_filename} running-config\"\n            commit_result = await self.conn.send_command(command=merge_command)\n\n        scrapli_responses.append(commit_result)\n\n        save_config_result = await self.conn.send_command(\n            command=\"copy running-config startup-config\"\n        )\n        scrapli_responses.append(save_config_result)\n\n        if self.cleanup_post_commit:\n            cleanup_result = await self._delete_candidate_config()\n            scrapli_responses.append(cleanup_result)\n\n        self._reset_config_session()\n\n        return self._post_commit_config(\n            response=response,\n            scrapli_responses=scrapli_responses,\n        )\n\n    async def diff_config(self, source: str = \"running\") -&gt; ScrapliCfgDiffResponse:\n        scrapli_responses = []\n        device_diff = \"\"\n        source_config = \"\"\n\n        diff_response = self._pre_diff_config(\n            source=source, session_or_config_file=bool(self.candidate_config_filename)\n        )\n\n        try:\n            diff_command = self._get_diff_command(source=source)\n\n            if diff_command:\n                diff_result = await self.conn.send_command(command=diff_command)\n                scrapli_responses.append(diff_result)\n                if diff_result.failed:\n                    msg = \"failed generating diff for config session\"\n                    self.logger.critical(msg)\n                    raise DiffConfigError(msg)\n                device_diff = diff_result.result\n            else:\n                device_diff = \"\"\n\n            source_config_result = await self.get_config(source=source)\n            source_config = source_config_result.result\n\n            if isinstance(source_config_result.scrapli_responses, MultiResponse):\n                # in this case this will always be a multiresponse or nothing (failure) but mypy\n                # doesnt know that, hence the isinstance check\n                scrapli_responses.extend(source_config_result.scrapli_responses)\n\n            if source_config_result.failed:\n                msg = \"failed fetching source config for diff comparison\"\n                self.logger.critical(msg)\n                raise DiffConfigError(msg)\n\n        except DiffConfigError:\n            pass\n\n        return self._post_diff_config(\n            diff_response=diff_response,\n            scrapli_responses=scrapli_responses,\n            source_config=self.clean_config(source_config),\n            candidate_config=self.clean_config(self.candidate_config),\n            device_diff=device_diff,\n        )\n</code></pre>"},{"location":"reference/platform/core/cisco_nxos/async_platform/#platform.core.cisco_nxos.async_platform.AsyncScrapliCfgNXOS.get_checkpoint","title":"<code>get_checkpoint() -&gt; ScrapliCfgResponse</code>  <code>async</code>","text":"<p>Get device checkpoint file</p> <p>Returns:</p> Name Type Description <code>ScrapliCfgResponse</code> <code>ScrapliCfgResponse</code> <p>response object containing string of the target config source as the <code>result</code> attribute</p> Source code in <code>platform/core/cisco_nxos/async_platform.py</code> <pre><code>async def get_checkpoint(self) -&gt; ScrapliCfgResponse:\n\"\"\"\n    Get device checkpoint file\n\n    Args:\n        N/A\n\n    Returns:\n        ScrapliCfgResponse: response object containing string of the target config source as the\n            `result` attribute\n\n    Raises:\n        N/A\n\n    \"\"\"\n    response, checkpoint_commands = self._pre_get_checkpoint(conn=self.conn)\n\n    checkpoint_results = await self.conn.send_commands(commands=checkpoint_commands)\n\n    try:\n        checkpoint: str = checkpoint_results[2].result\n    except IndexError:\n        checkpoint = \"\"\n\n    return self._post_get_config(\n        response=response,\n        source=\"running\",\n        scrapli_responses=[checkpoint_results],\n        result=checkpoint,\n    )\n</code></pre>"},{"location":"reference/platform/core/cisco_nxos/async_platform/#platform.core.cisco_nxos.async_platform.AsyncScrapliCfgNXOS.load_config","title":"<code>load_config(config: str, replace: bool = False, **kwargs: Any) -&gt; ScrapliCfgResponse</code>  <code>async</code>","text":"<p>Load configuration to a device</p> Supported kwargs <p>N/A</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>str</code> <p>string of the configuration to load</p> required <code>replace</code> <code>bool</code> <p>replace the configuration or not, if false configuration will be loaded as a merge operation</p> <code>False</code> <code>kwargs</code> <p>additional kwargs that the implementing classes may need for their platform, see above for nxos supported kwargs</p> required <p>Returns:</p> Name Type Description <code>ScrapliCfgResponse</code> <code>ScrapliCfgResponse</code> <p>response object</p> Source code in <code>platform/core/cisco_nxos/async_platform.py</code> <pre><code>async def load_config(\n    self, config: str, replace: bool = False, **kwargs: Any\n) -&gt; ScrapliCfgResponse:\n\"\"\"\n    Load configuration to a device\n\n    Supported kwargs:\n        N/A\n\n    Args:\n        config: string of the configuration to load\n        replace: replace the configuration or not, if false configuration will be loaded as a\n            merge operation\n        kwargs: additional kwargs that the implementing classes may need for their platform,\n            see above for nxos supported kwargs\n\n    Returns:\n        ScrapliCfgResponse: response object\n\n    Raises:\n        N/A\n\n    \"\"\"\n    response = self._pre_load_config(config=config)\n\n    config = self._prepare_load_config(config=config, replace=replace)\n\n    filesystem_bytes_available = await self._get_filesystem_space_available()\n    self._space_available(filesystem_bytes_available=filesystem_bytes_available)\n\n    await self.conn.acquire_priv(desired_priv=\"tclsh\")\n    config_result = await self.conn.send_config(config=config, privilege_level=\"tclsh\")\n    await self.conn.acquire_priv(desired_priv=self.conn.default_desired_privilege_level)\n\n    return self._post_load_config(\n        response=response,\n        scrapli_responses=[config_result],\n    )\n</code></pre>"},{"location":"reference/platform/core/cisco_nxos/base_platform/","title":"Base platform","text":"<p>scrapli_cfg.platform.core.cisco_nxos.base_platform</p>"},{"location":"reference/platform/core/cisco_nxos/base_platform/#platform.core.cisco_nxos.base_platform.ScrapliCfgNXOSBase","title":"<code>ScrapliCfgNXOSBase</code>","text":"Source code in <code>platform/core/cisco_nxos/base_platform.py</code> <pre><code>class ScrapliCfgNXOSBase:\n    logger: LoggerAdapterT\n    candidate_config: str\n    candidate_config_filename: str\n    _replace: bool\n    filesystem: str\n    _filesystem_space_available_buffer_perc: int\n\n    def _post_get_filesystem_space_available(self, output: str) -&gt; int:\n\"\"\"\n        Handle post \"get_filesystem_space_available\" operations for parity between sync and async\n\n        Args:\n            output: output that was fetched from the device\n\n        Returns:\n            int: bytes of space available on filesystem\n\n        Raises:\n            FailedToFetchSpaceAvailable: if could not determine space available... duh :)\n\n        \"\"\"\n        self.logger.info(\"determining space available from device output\")\n\n        bytes_available_match = re.search(pattern=BYTES_FREE, string=output)\n        if not bytes_available_match:\n            msg = \"could not determine space available on filesystem\"\n            self.logger.critical(msg)\n            raise FailedToFetchSpaceAvailable(msg)\n\n        return int(bytes_available_match.groupdict()[\"bytes_available\"])\n\n    def _space_available(self, filesystem_bytes_available: int) -&gt; None:\n\"\"\"\n        Space available operations for parity between sync and async\n\n        It seems that the length of the config is near enough 1:1 to the size it takes up\n        on the disk... so roll w/ that plus a bit of buffer based on the available buffer perc\n\n        Args:\n            filesystem_bytes_available: bytes available on filesystem\n\n        Returns:\n            None\n\n        Raises:\n            InsufficientSpaceAvailable: if... insufficient space available....\n\n        \"\"\"\n        if filesystem_bytes_available &lt; (\n            len(self.candidate_config) / (self._filesystem_space_available_buffer_perc / 100)\n        ) + len(self.candidate_config):\n            # filesystem has less than candidate config file size + 10% (by default) space, bail out\n            msg = (\n                f\"insufficient space available for candidate config + \"\n                f\"{self._filesystem_space_available_buffer_perc}% (buffer)\"\n            )\n            self.logger.critical(msg)\n            raise InsufficientSpaceAvailable(msg)\n\n    @staticmethod\n    def _parse_version(device_output: str) -&gt; str:\n\"\"\"\n        Parse version string out of device output\n\n        Args:\n            device_output: output from show version command\n\n        Returns:\n            str: device version string\n\n        Raises:\n            N/A\n\n        \"\"\"\n        version_string_search = re.search(pattern=VERSION_PATTERN, string=device_output)\n\n        if not version_string_search:\n            return \"\"\n\n        version_string = version_string_search.group(0) or \"\"\n        return version_string\n\n    def _reset_config_session(self) -&gt; None:\n\"\"\"\n        Reset config session info\n\n        Resets the candidate config and config session name attributes -- when these are \"empty\" we\n        know there is no current config session\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.logger.debug(\"resetting candidate config and config session name\")\n        self.candidate_config = \"\"\n        self.candidate_config_filename = \"\"\n\n    @staticmethod\n    def _get_config_command(source: str) -&gt; str:\n\"\"\"\n        Return command to use to get config based on the provided source\n\n        Args:\n            source: name of the config source, generally running|startup\n\n        Returns:\n            str: command to use to fetch the requested config\n\n        Raises:\n            N/A\n\n        \"\"\"\n        if source == \"running\":\n            return \"show running-config\"\n        return \"show startup-config\"\n\n    def _get_diff_command(self, source: str) -&gt; str:\n\"\"\"\n        Generate diff command based on source to diff and filesystem/candidate config name\n\n        Args:\n            source: config source to gen diff for\n\n        Returns:\n            str: command to use to diff the configuration\n\n        Raises:\n            N/A\n\n        \"\"\"\n        if self._replace:\n            return (\n                f\"show diff rollback-patch {source}-config file {self.filesystem}\"\n                f\"{self.candidate_config_filename}\"\n            )\n        return \"\"\n\n    def _prepare_config_payloads(self, config: str) -&gt; str:\n\"\"\"\n        Prepare a configuration so it can be nicely sent to the device via scrapli\n\n        Args:\n            config: configuration to prep\n\n        Returns:\n            str: string of config lines to write to candidate config file\n\n        Raises:\n            N/A\n\n        \"\"\"\n        # with the \"normal\" method (the way iosxe does this) it seems to want to stop at 250ish\n        # lines... so this works but its kinda wonky... the actual lines we want to put in the text\n        # file are enclosed in curly braces for tcl-reasons i guess\n        tclsh_filesystem = f\"/{self.filesystem.strip(':')}/\"\n        tclsh_start_file = f'set fl [open \"{tclsh_filesystem}{self.candidate_config_filename}\" wb+]'\n        tcl_config = \"\\n\".join(\n            [f\"puts -nonewline $fl {{{line}\\r}}\" for line in config.splitlines()]\n        )\n        tclsh_end_file = \"close $fl\"\n        final_config = \"\\n\".join((tclsh_start_file, tcl_config, tclsh_end_file))\n\n        return final_config\n\n    def _prepare_load_config(self, config: str, replace: bool) -&gt; str:\n\"\"\"\n        Handle pre \"load_config\" operations for parity between sync and async\n\n        Args:\n            config: candidate config to load\n            replace: True/False replace the configuration; passed here so it can be set at the class\n                level as we need to stay in config mode and we need to know if we are doing a merge\n                or a replace when we go to diff things\n\n        Returns:\n            str: string of config to write to candidate config file\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.candidate_config = config\n\n        if not self.candidate_config_filename:\n            self.candidate_config_filename = f\"scrapli_cfg_{round(datetime.now().timestamp())}\"\n            self.logger.debug(\n                f\"candidate config file name will be '{self.candidate_config_filename}'\"\n            )\n\n        config = self._prepare_config_payloads(config=config)\n        self._replace = replace\n\n        return config\n\n    def clean_config(self, config: str) -&gt; str:\n\"\"\"\n        Clean a configuration file of unwanted lines\n\n        Args:\n            config: configuration string to \"clean\"\n\n        Returns:\n            str: cleaned configuration string\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.logger.debug(\"cleaning config file\")\n\n        config = re.sub(pattern=CHECKPOINT_LINE, string=config, repl=\"\")\n        config = re.sub(pattern=OUTPUT_HEADER_PATTERN, string=config, repl=\"\")\n        return strip_blank_lines(config=config)\n\n    def _pre_get_checkpoint(\n        self, conn: Union[AsyncNetworkDriver, NetworkDriver]\n    ) -&gt; Tuple[ScrapliCfgResponse, List[str]]:\n\"\"\"\n        Handle pre \"get_checkpoint\" operations for parity between sync and async\n\n        Args:\n            conn: connection from the sync or async platform; passed in explicitly to maintain\n                typing sanity\n\n        Returns:\n            list: list of commands needed to generate checkpoint and show it\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.logger.info(\"get_checkpoint requested\")\n\n        tmp_timestamp = round(datetime.now().timestamp())\n        checkpoint_commands = [\n            \"terminal dont-ask\",\n            f\"checkpoint file {self.filesystem}scrapli_cfg_tmp_{tmp_timestamp}\",\n            f\"show file {self.filesystem}scrapli_cfg_tmp_{tmp_timestamp}\",\n            f\"delete {self.filesystem}scrapli_cfg_tmp_{tmp_timestamp}\",\n        ]\n\n        response = ScrapliCfgResponse(host=conn.host, raise_for_status_exception=GetConfigError)\n\n        return response, checkpoint_commands\n</code></pre>"},{"location":"reference/platform/core/cisco_nxos/base_platform/#platform.core.cisco_nxos.base_platform.ScrapliCfgNXOSBase.clean_config","title":"<code>clean_config(config: str) -&gt; str</code>","text":"<p>Clean a configuration file of unwanted lines</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>str</code> <p>configuration string to \"clean\"</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>cleaned configuration string</p> Source code in <code>platform/core/cisco_nxos/base_platform.py</code> <pre><code>def clean_config(self, config: str) -&gt; str:\n\"\"\"\n    Clean a configuration file of unwanted lines\n\n    Args:\n        config: configuration string to \"clean\"\n\n    Returns:\n        str: cleaned configuration string\n\n    Raises:\n        N/A\n\n    \"\"\"\n    self.logger.debug(\"cleaning config file\")\n\n    config = re.sub(pattern=CHECKPOINT_LINE, string=config, repl=\"\")\n    config = re.sub(pattern=OUTPUT_HEADER_PATTERN, string=config, repl=\"\")\n    return strip_blank_lines(config=config)\n</code></pre>"},{"location":"reference/platform/core/cisco_nxos/patterns/","title":"Patterns","text":"<p>scrapli_cfg.platforms.cisco_nxos.patterns</p>"},{"location":"reference/platform/core/cisco_nxos/sync_platform/","title":"Sync platform","text":"<p>scrapli_cfg.platform.core.cisco_nxos.sync_platform</p>"},{"location":"reference/platform/core/cisco_nxos/sync_platform/#platform.core.cisco_nxos.sync_platform.ScrapliCfgNXOS","title":"<code>ScrapliCfgNXOS</code>","text":"<p>         Bases: <code>ScrapliCfgNXOSBase</code>, <code>ScrapliCfgPlatform</code></p> Source code in <code>platform/core/cisco_nxos/sync_platform.py</code> <pre><code>class ScrapliCfgNXOS(ScrapliCfgNXOSBase, ScrapliCfgPlatform):\n    def __init__(\n        self,\n        conn: NXOSDriver,\n        *,\n        config_sources: Optional[List[str]] = None,\n        on_prepare: Optional[Callable[..., Any]] = None,\n        filesystem: str = \"bootflash:\",\n        cleanup_post_commit: bool = True,\n        dedicated_connection: bool = False,\n        ignore_version: bool = False,\n    ) -&gt; None:\n        if config_sources is None:\n            config_sources = CONFIG_SOURCES\n\n        super().__init__(\n            conn=conn,\n            config_sources=config_sources,\n            on_prepare=on_prepare,\n            dedicated_connection=dedicated_connection,\n            ignore_version=ignore_version,\n        )\n\n        self.filesystem = filesystem\n        self._filesystem_space_available_buffer_perc = 10\n\n        self._replace = False\n\n        self.candidate_config_filename = \"\"\n\n        self.cleanup_post_commit = cleanup_post_commit\n\n    def _get_filesystem_space_available(self) -&gt; int:\n\"\"\"\n        Get available space on filesystem\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            FailedToDetermineDeviceState: if unable to fetch file filesystem bytes available\n\n        \"\"\"\n        filesystem_size_result = self.conn.send_command(\n            command=f\"dir {self.filesystem} | i 'bytes free'\"\n        )\n        if filesystem_size_result.failed:\n            raise FailedToDetermineDeviceState(\"failed to determine space available on filesystem\")\n\n        return self._post_get_filesystem_space_available(output=filesystem_size_result.result)\n\n    def _delete_candidate_config(self) -&gt; MultiResponse:\n\"\"\"\n        Delete candidate config from the filesystem\n\n        Args:\n            N/A\n\n        Returns:\n            MultiResponse: response from deleting the candidate config\n\n        Raises:\n            N/A\n\n        \"\"\"\n        delete_commands = [\n            \"terminal dont-ask\",\n            f\"delete {self.filesystem}{self.candidate_config_filename}\",\n        ]\n        delete_result = self.conn.send_commands(commands=delete_commands)\n        return delete_result\n\n    def get_checkpoint(self) -&gt; ScrapliCfgResponse:\n\"\"\"\n        Get device checkpoint file\n\n        Args:\n            N/A\n\n        Returns:\n            ScrapliCfgResponse: response object containing string of the target config source as the\n                `result` attribute\n\n        Raises:\n            N/A\n\n        \"\"\"\n        response, checkpoint_commands = self._pre_get_checkpoint(conn=self.conn)\n\n        checkpoint_results = self.conn.send_commands(commands=checkpoint_commands)\n\n        try:\n            checkpoint: str = checkpoint_results[2].result\n        except IndexError:\n            checkpoint = \"\"\n\n        return self._post_get_config(\n            response=response,\n            source=\"running\",\n            scrapli_responses=[checkpoint_results],\n            result=checkpoint,\n        )\n\n    def get_version(self) -&gt; ScrapliCfgResponse:\n        response = self._pre_get_version()\n\n        version_result = self.conn.send_command(command='show version | i \"NXOS: version\"')\n\n        return self._post_get_version(\n            response=response,\n            scrapli_responses=[version_result],\n            result=self._parse_version(device_output=version_result.result),\n        )\n\n    def get_config(self, source: str = \"running\") -&gt; ScrapliCfgResponse:\n        response = self._pre_get_config(source=source)\n\n        config_result = self.conn.send_command(command=self._get_config_command(source=source))\n\n        return self._post_get_config(\n            response=response,\n            source=source,\n            scrapli_responses=[config_result],\n            result=config_result.result,\n        )\n\n    def load_config(self, config: str, replace: bool = False, **kwargs: Any) -&gt; ScrapliCfgResponse:\n\"\"\"\n        Load configuration to a device\n\n        Supported kwargs:\n            N/A\n\n        Args:\n            config: string of the configuration to load\n            replace: replace the configuration or not, if false configuration will be loaded as a\n                merge operation\n            kwargs: additional kwargs that the implementing classes may need for their platform,\n                see above for nxos supported kwargs\n\n        Returns:\n            ScrapliCfgResponse: response object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        response = self._pre_load_config(config=config)\n\n        config = self._prepare_load_config(config=config, replace=replace)\n\n        filesystem_bytes_available = self._get_filesystem_space_available()\n        self._space_available(filesystem_bytes_available=filesystem_bytes_available)\n\n        self.conn.acquire_priv(desired_priv=\"tclsh\")\n        config_result = self.conn.send_config(config=config, privilege_level=\"tclsh\")\n        self.conn.acquire_priv(desired_priv=self.conn.default_desired_privilege_level)\n\n        return self._post_load_config(\n            response=response,\n            scrapli_responses=[config_result],\n        )\n\n    def abort_config(self) -&gt; ScrapliCfgResponse:\n        response = self._pre_abort_config(\n            session_or_config_file=bool(self.candidate_config_filename)\n        )\n\n        abort_result = self._delete_candidate_config()\n        self._reset_config_session()\n\n        return self._post_abort_config(response=response, scrapli_responses=[abort_result])\n\n    def commit_config(self, source: str = \"running\") -&gt; ScrapliCfgResponse:\n        scrapli_responses: List[Union[MultiResponse, Response]] = []\n        response = self._pre_commit_config(\n            source=source, session_or_config_file=bool(self.candidate_config_filename)\n        )\n\n        if self._replace is True:\n            replace_command = (\n                f\"rollback running-config file {self.filesystem}{self.candidate_config_filename}\"\n            )\n            commit_result = self.conn.send_command(command=replace_command)\n        else:\n            merge_command = f\"copy {self.filesystem}{self.candidate_config_filename} running-config\"\n            commit_result = self.conn.send_command(command=merge_command)\n\n        scrapli_responses.append(commit_result)\n\n        save_config_result = self.conn.send_command(command=\"copy running-config startup-config\")\n        scrapli_responses.append(save_config_result)\n\n        if self.cleanup_post_commit:\n            cleanup_result = self._delete_candidate_config()\n            scrapli_responses.append(cleanup_result)\n\n        self._reset_config_session()\n\n        return self._post_commit_config(\n            response=response,\n            scrapli_responses=scrapli_responses,\n        )\n\n    def diff_config(self, source: str = \"running\") -&gt; ScrapliCfgDiffResponse:\n        scrapli_responses = []\n        device_diff = \"\"\n        source_config = \"\"\n\n        diff_response = self._pre_diff_config(\n            source=source, session_or_config_file=bool(self.candidate_config_filename)\n        )\n\n        try:\n            diff_command = self._get_diff_command(source=source)\n\n            if diff_command:\n                diff_result = self.conn.send_command(command=diff_command)\n                scrapli_responses.append(diff_result)\n                if diff_result.failed:\n                    msg = \"failed generating diff for config session\"\n                    self.logger.critical(msg)\n                    raise DiffConfigError(msg)\n                device_diff = diff_result.result\n            else:\n                device_diff = \"\"\n\n            source_config_result = self.get_config(source=source)\n            source_config = source_config_result.result\n\n            if isinstance(source_config_result.scrapli_responses, MultiResponse):\n                # in this case this will always be a multiresponse or nothing (failure) but mypy\n                # doesnt know that, hence the isinstance check\n                scrapli_responses.extend(source_config_result.scrapli_responses)\n\n            if source_config_result.failed:\n                msg = \"failed fetching source config for diff comparison\"\n                self.logger.critical(msg)\n                raise DiffConfigError(msg)\n\n        except DiffConfigError:\n            pass\n\n        return self._post_diff_config(\n            diff_response=diff_response,\n            scrapli_responses=scrapli_responses,\n            source_config=self.clean_config(source_config),\n            candidate_config=self.clean_config(self.candidate_config),\n            device_diff=device_diff,\n        )\n</code></pre>"},{"location":"reference/platform/core/cisco_nxos/sync_platform/#platform.core.cisco_nxos.sync_platform.ScrapliCfgNXOS.get_checkpoint","title":"<code>get_checkpoint() -&gt; ScrapliCfgResponse</code>","text":"<p>Get device checkpoint file</p> <p>Returns:</p> Name Type Description <code>ScrapliCfgResponse</code> <code>ScrapliCfgResponse</code> <p>response object containing string of the target config source as the <code>result</code> attribute</p> Source code in <code>platform/core/cisco_nxos/sync_platform.py</code> <pre><code>def get_checkpoint(self) -&gt; ScrapliCfgResponse:\n\"\"\"\n    Get device checkpoint file\n\n    Args:\n        N/A\n\n    Returns:\n        ScrapliCfgResponse: response object containing string of the target config source as the\n            `result` attribute\n\n    Raises:\n        N/A\n\n    \"\"\"\n    response, checkpoint_commands = self._pre_get_checkpoint(conn=self.conn)\n\n    checkpoint_results = self.conn.send_commands(commands=checkpoint_commands)\n\n    try:\n        checkpoint: str = checkpoint_results[2].result\n    except IndexError:\n        checkpoint = \"\"\n\n    return self._post_get_config(\n        response=response,\n        source=\"running\",\n        scrapli_responses=[checkpoint_results],\n        result=checkpoint,\n    )\n</code></pre>"},{"location":"reference/platform/core/cisco_nxos/sync_platform/#platform.core.cisco_nxos.sync_platform.ScrapliCfgNXOS.load_config","title":"<code>load_config(config: str, replace: bool = False, **kwargs: Any) -&gt; ScrapliCfgResponse</code>","text":"<p>Load configuration to a device</p> Supported kwargs <p>N/A</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>str</code> <p>string of the configuration to load</p> required <code>replace</code> <code>bool</code> <p>replace the configuration or not, if false configuration will be loaded as a merge operation</p> <code>False</code> <code>kwargs</code> <p>additional kwargs that the implementing classes may need for their platform, see above for nxos supported kwargs</p> required <p>Returns:</p> Name Type Description <code>ScrapliCfgResponse</code> <code>ScrapliCfgResponse</code> <p>response object</p> Source code in <code>platform/core/cisco_nxos/sync_platform.py</code> <pre><code>def load_config(self, config: str, replace: bool = False, **kwargs: Any) -&gt; ScrapliCfgResponse:\n\"\"\"\n    Load configuration to a device\n\n    Supported kwargs:\n        N/A\n\n    Args:\n        config: string of the configuration to load\n        replace: replace the configuration or not, if false configuration will be loaded as a\n            merge operation\n        kwargs: additional kwargs that the implementing classes may need for their platform,\n            see above for nxos supported kwargs\n\n    Returns:\n        ScrapliCfgResponse: response object\n\n    Raises:\n        N/A\n\n    \"\"\"\n    response = self._pre_load_config(config=config)\n\n    config = self._prepare_load_config(config=config, replace=replace)\n\n    filesystem_bytes_available = self._get_filesystem_space_available()\n    self._space_available(filesystem_bytes_available=filesystem_bytes_available)\n\n    self.conn.acquire_priv(desired_priv=\"tclsh\")\n    config_result = self.conn.send_config(config=config, privilege_level=\"tclsh\")\n    self.conn.acquire_priv(desired_priv=self.conn.default_desired_privilege_level)\n\n    return self._post_load_config(\n        response=response,\n        scrapli_responses=[config_result],\n    )\n</code></pre>"},{"location":"reference/platform/core/juniper_junos/","title":"Index","text":"<p>scrapli_cfg.platform.core.juniper_junos</p>"},{"location":"reference/platform/core/juniper_junos/async_platform/","title":"Async platform","text":"<p>scrapli_cfg.platform.core.juniper_junos.async_platform</p>"},{"location":"reference/platform/core/juniper_junos/async_platform/#platform.core.juniper_junos.async_platform.AsyncScrapliCfgJunos","title":"<code>AsyncScrapliCfgJunos</code>","text":"<p>         Bases: <code>AsyncScrapliCfgPlatform</code>, <code>ScrapliCfgJunosBase</code></p> Source code in <code>platform/core/juniper_junos/async_platform.py</code> <pre><code>class AsyncScrapliCfgJunos(AsyncScrapliCfgPlatform, ScrapliCfgJunosBase):\n    def __init__(\n        self,\n        conn: AsyncNetworkDriver,\n        *,\n        config_sources: Optional[List[str]] = None,\n        on_prepare: Optional[Callable[..., Any]] = None,\n        filesystem: str = \"/config/\",\n        cleanup_post_commit: bool = True,\n        dedicated_connection: bool = False,\n        ignore_version: bool = False,\n    ) -&gt; None:\n        if config_sources is None:\n            config_sources = CONFIG_SOURCES\n\n        super().__init__(\n            conn=conn,\n            config_sources=config_sources,\n            on_prepare=on_prepare,\n            dedicated_connection=dedicated_connection,\n            ignore_version=ignore_version,\n        )\n\n        self.filesystem = filesystem\n\n        self._replace = False\n        self._set = False\n\n        self.candidate_config_filename = \"\"\n        self._in_configuration_session = False\n\n        self.cleanup_post_commit = cleanup_post_commit\n\n    async def _delete_candidate_config(self) -&gt; Response:\n\"\"\"\n        Delete candidate config from the filesystem\n\n        Args:\n            N/A\n\n        Returns:\n            Response: response from deleting the candidate config\n\n        Raises:\n            N/A\n\n        \"\"\"\n        delete_result = await self.conn.send_config(\n            config=f\"rm {self.filesystem}{self.candidate_config_filename}\",\n            privilege_level=\"root_shell\",\n        )\n        return delete_result\n\n    async def get_version(self) -&gt; ScrapliCfgResponse:\n        response = self._pre_get_version()\n\n        version_result = await self.conn.send_command(command=\"show version | grep junos:\")\n\n        return self._post_get_version(\n            response=response,\n            scrapli_responses=[version_result],\n            result=self._parse_version(device_output=version_result.result),\n        )\n\n    async def get_config(self, source: str = \"running\") -&gt; ScrapliCfgResponse:\n        response = self._pre_get_config(source=source)\n\n        if self._in_configuration_session is True:\n            config_result = await self.conn.send_config(config=\"run show configuration\")\n        else:\n            config_result = await self.conn.send_command(command=\"show configuration\")\n\n        return self._post_get_config(\n            response=response,\n            source=source,\n            scrapli_responses=[config_result],\n            result=config_result.result,\n        )\n\n    async def load_config(\n        self, config: str, replace: bool = False, **kwargs: Any\n    ) -&gt; ScrapliCfgResponse:\n\"\"\"\n        Load configuration to a device\n\n        Supported kwargs:\n            set: bool indicating config is a \"set\" style config (ignored if replace is True)\n\n        Args:\n            config: string of the configuration to load\n            replace: replace the configuration or not, if false configuration will be loaded as a\n                merge operation\n            kwargs: additional kwargs that the implementing classes may need for their platform,\n                see above for junos supported kwargs\n\n        Returns:\n            ScrapliCfgResponse: response object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self._set = kwargs.get(\"set\", False)\n\n        response = self._pre_load_config(config=config)\n\n        config = self._prepare_load_config(config=config, replace=replace)\n\n        config_result = await self.conn.send_config(config=config, privilege_level=\"root_shell\")\n\n        if self._replace is True:\n            load_config = f\"load override {self.filesystem}{self.candidate_config_filename}\"\n        else:\n            if self._set is True:\n                load_config = f\"load set {self.filesystem}{self.candidate_config_filename}\"\n            else:\n                load_config = f\"load merge {self.filesystem}{self.candidate_config_filename}\"\n\n        load_result = await self.conn.send_config(config=load_config)\n        self._in_configuration_session = True\n\n        return self._post_load_config(\n            response=response,\n            scrapli_responses=[config_result, load_result],\n        )\n\n    async def abort_config(self) -&gt; ScrapliCfgResponse:\n        response = self._pre_abort_config(\n            session_or_config_file=bool(self.candidate_config_filename)\n        )\n\n        rollback_result = await self.conn.send_config(config=\"rollback 0\")\n        abort_result = await self._delete_candidate_config()\n        self._reset_config_session()\n\n        return self._post_abort_config(\n            response=response, scrapli_responses=[rollback_result, abort_result]\n        )\n\n    async def commit_config(self, source: str = \"running\") -&gt; ScrapliCfgResponse:\n        scrapli_responses = []\n        response = self._pre_commit_config(\n            source=source, session_or_config_file=bool(self.candidate_config_filename)\n        )\n\n        commit_result = await self.conn.send_config(config=\"commit\")\n        scrapli_responses.append(commit_result)\n\n        if self.cleanup_post_commit:\n            cleanup_result = await self._delete_candidate_config()\n            scrapli_responses.append(cleanup_result)\n\n        self._reset_config_session()\n\n        return self._post_load_config(\n            response=response,\n            scrapli_responses=scrapli_responses,\n        )\n\n    async def diff_config(self, source: str = \"running\") -&gt; ScrapliCfgDiffResponse:\n        scrapli_responses = []\n        device_diff = \"\"\n        source_config = \"\"\n\n        diff_response = self._pre_diff_config(\n            source=source, session_or_config_file=bool(self.candidate_config_filename)\n        )\n\n        try:\n            diff_result = await self.conn.send_config(config=\"show | compare\")\n            scrapli_responses.append(diff_result)\n            if diff_result.failed:\n                msg = \"failed generating diff for config session\"\n                self.logger.critical(msg)\n                raise DiffConfigError(msg)\n\n            device_diff = diff_result.result\n\n            source_config_result = await self.get_config(source=source)\n            source_config = source_config_result.result\n\n            if isinstance(source_config_result.scrapli_responses, MultiResponse):\n                # in this case this will always be a multiresponse or nothing (failure) but mypy\n                # doesnt know that, hence the isinstance check\n                scrapli_responses.extend(source_config_result.scrapli_responses)\n\n            if source_config_result.failed:\n                msg = \"failed fetching source config for diff comparison\"\n                self.logger.critical(msg)\n                raise DiffConfigError(msg)\n\n        except DiffConfigError:\n            pass\n\n        return self._post_diff_config(\n            diff_response=diff_response,\n            scrapli_responses=scrapli_responses,\n            source_config=self.clean_config(source_config),\n            candidate_config=self.clean_config(self.candidate_config),\n            device_diff=device_diff,\n        )\n</code></pre>"},{"location":"reference/platform/core/juniper_junos/async_platform/#platform.core.juniper_junos.async_platform.AsyncScrapliCfgJunos.load_config","title":"<code>load_config(config: str, replace: bool = False, **kwargs: Any) -&gt; ScrapliCfgResponse</code>  <code>async</code>","text":"<p>Load configuration to a device</p> Supported kwargs <p>set: bool indicating config is a \"set\" style config (ignored if replace is True)</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>str</code> <p>string of the configuration to load</p> required <code>replace</code> <code>bool</code> <p>replace the configuration or not, if false configuration will be loaded as a merge operation</p> <code>False</code> <code>kwargs</code> <p>additional kwargs that the implementing classes may need for their platform, see above for junos supported kwargs</p> required <p>Returns:</p> Name Type Description <code>ScrapliCfgResponse</code> <code>ScrapliCfgResponse</code> <p>response object</p> Source code in <code>platform/core/juniper_junos/async_platform.py</code> <pre><code>async def load_config(\n    self, config: str, replace: bool = False, **kwargs: Any\n) -&gt; ScrapliCfgResponse:\n\"\"\"\n    Load configuration to a device\n\n    Supported kwargs:\n        set: bool indicating config is a \"set\" style config (ignored if replace is True)\n\n    Args:\n        config: string of the configuration to load\n        replace: replace the configuration or not, if false configuration will be loaded as a\n            merge operation\n        kwargs: additional kwargs that the implementing classes may need for their platform,\n            see above for junos supported kwargs\n\n    Returns:\n        ScrapliCfgResponse: response object\n\n    Raises:\n        N/A\n\n    \"\"\"\n    self._set = kwargs.get(\"set\", False)\n\n    response = self._pre_load_config(config=config)\n\n    config = self._prepare_load_config(config=config, replace=replace)\n\n    config_result = await self.conn.send_config(config=config, privilege_level=\"root_shell\")\n\n    if self._replace is True:\n        load_config = f\"load override {self.filesystem}{self.candidate_config_filename}\"\n    else:\n        if self._set is True:\n            load_config = f\"load set {self.filesystem}{self.candidate_config_filename}\"\n        else:\n            load_config = f\"load merge {self.filesystem}{self.candidate_config_filename}\"\n\n    load_result = await self.conn.send_config(config=load_config)\n    self._in_configuration_session = True\n\n    return self._post_load_config(\n        response=response,\n        scrapli_responses=[config_result, load_result],\n    )\n</code></pre>"},{"location":"reference/platform/core/juniper_junos/base_platform/","title":"Base platform","text":"<p>scrapli_cfg.platform.core.juniper_junos.base_platform</p>"},{"location":"reference/platform/core/juniper_junos/base_platform/#platform.core.juniper_junos.base_platform.ScrapliCfgJunosBase","title":"<code>ScrapliCfgJunosBase</code>","text":"Source code in <code>platform/core/juniper_junos/base_platform.py</code> <pre><code>class ScrapliCfgJunosBase:\n    logger: LoggerAdapterT\n    candidate_config: str\n    candidate_config_filename: str\n    _in_configuration_session: bool\n    _replace: bool\n    _set: bool\n    filesystem: str\n\n    @staticmethod\n    def _parse_version(device_output: str) -&gt; str:\n\"\"\"\n        Parse version string out of device output\n\n        Args:\n            device_output: output from show version command\n\n        Returns:\n            str: device version string\n\n        Raises:\n            N/A\n\n        \"\"\"\n        version_string_search = re.search(pattern=VERSION_PATTERN, string=device_output)\n\n        if not version_string_search:\n            return \"\"\n\n        version_string = version_string_search.group(0) or \"\"\n        return version_string\n\n    def _reset_config_session(self) -&gt; None:\n\"\"\"\n        Reset config session info\n\n        Resets the candidate config and config session name attributes -- when these are \"empty\" we\n        know there is no current config session\n\n        Args:\n            N/A\n\n        Returns:\n            None\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.logger.debug(\"resetting candidate config and candidate config file name\")\n        self.candidate_config = \"\"\n        self.candidate_config_filename = \"\"\n        self._in_configuration_session = False\n        self._set = False\n\n    def _prepare_config_payloads(self, config: str) -&gt; str:\n\"\"\"\n        Prepare a configuration so it can be nicely sent to the device via scrapli\n\n        Args:\n            config: configuration to prep\n\n        Returns:\n            str: string of config lines to write to candidate config file\n\n        Raises:\n            N/A\n\n        \"\"\"\n        final_config_list = []\n        for config_line in config.splitlines():\n            final_config_list.append(\n                f\"echo &gt;&gt; {self.filesystem}{self.candidate_config_filename} '{config_line}'\"\n            )\n\n        final_config = \"\\n\".join(final_config_list)\n\n        return final_config\n\n    def _prepare_load_config(self, config: str, replace: bool) -&gt; str:\n\"\"\"\n        Handle pre \"load_config\" operations for parity between sync and async\n\n        Args:\n            config: candidate config to load\n            replace: True/False replace the configuration; passed here so it can be set at the class\n                level as we need to stay in config mode and we need to know if we are doing a merge\n                or a replace when we go to diff things\n\n        Returns:\n            str: string of config to write to candidate config file\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.candidate_config = config\n\n        if not self.candidate_config_filename:\n            self.candidate_config_filename = f\"scrapli_cfg_{round(datetime.now().timestamp())}\"\n            self.logger.debug(\n                f\"candidate config file name will be '{self.candidate_config_filename}'\"\n            )\n\n        config = self._prepare_config_payloads(config=config)\n        self._replace = replace\n\n        return config\n\n    def clean_config(self, config: str) -&gt; str:\n\"\"\"\n        Clean a configuration file of unwanted lines\n\n        Args:\n            config: configuration string to \"clean\"\n\n        Returns:\n            str: cleaned configuration string\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self.logger.debug(\"cleaning config file\")\n\n        config = re.sub(pattern=OUTPUT_HEADER_PATTERN, string=config, repl=\"\")\n        config = re.sub(pattern=EDIT_PATTERN, string=config, repl=\"\")\n        return strip_blank_lines(config=config)\n</code></pre>"},{"location":"reference/platform/core/juniper_junos/base_platform/#platform.core.juniper_junos.base_platform.ScrapliCfgJunosBase.clean_config","title":"<code>clean_config(config: str) -&gt; str</code>","text":"<p>Clean a configuration file of unwanted lines</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>str</code> <p>configuration string to \"clean\"</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>cleaned configuration string</p> Source code in <code>platform/core/juniper_junos/base_platform.py</code> <pre><code>def clean_config(self, config: str) -&gt; str:\n\"\"\"\n    Clean a configuration file of unwanted lines\n\n    Args:\n        config: configuration string to \"clean\"\n\n    Returns:\n        str: cleaned configuration string\n\n    Raises:\n        N/A\n\n    \"\"\"\n    self.logger.debug(\"cleaning config file\")\n\n    config = re.sub(pattern=OUTPUT_HEADER_PATTERN, string=config, repl=\"\")\n    config = re.sub(pattern=EDIT_PATTERN, string=config, repl=\"\")\n    return strip_blank_lines(config=config)\n</code></pre>"},{"location":"reference/platform/core/juniper_junos/patterns/","title":"Patterns","text":"<p>scrapli_cfg.platform.core.juniper_junos.patterns</p>"},{"location":"reference/platform/core/juniper_junos/sync_platform/","title":"Sync platform","text":"<p>scrapli_cfg.platform.core.juniper_junos.sync_platform</p>"},{"location":"reference/platform/core/juniper_junos/sync_platform/#platform.core.juniper_junos.sync_platform.ScrapliCfgJunos","title":"<code>ScrapliCfgJunos</code>","text":"<p>         Bases: <code>ScrapliCfgPlatform</code>, <code>ScrapliCfgJunosBase</code></p> Source code in <code>platform/core/juniper_junos/sync_platform.py</code> <pre><code>class ScrapliCfgJunos(ScrapliCfgPlatform, ScrapliCfgJunosBase):\n    def __init__(\n        self,\n        conn: NetworkDriver,\n        *,\n        config_sources: Optional[List[str]] = None,\n        on_prepare: Optional[Callable[..., Any]] = None,\n        filesystem: str = \"/config/\",\n        cleanup_post_commit: bool = True,\n        dedicated_connection: bool = False,\n        ignore_version: bool = False,\n    ) -&gt; None:\n        if config_sources is None:\n            config_sources = CONFIG_SOURCES\n\n        super().__init__(\n            conn=conn,\n            config_sources=config_sources,\n            on_prepare=on_prepare,\n            dedicated_connection=dedicated_connection,\n            ignore_version=ignore_version,\n        )\n\n        self.filesystem = filesystem\n\n        self._replace = False\n        self._set = False\n\n        self.candidate_config_filename = \"\"\n        self._in_configuration_session = False\n\n        self.cleanup_post_commit = cleanup_post_commit\n\n    def _delete_candidate_config(self) -&gt; Response:\n\"\"\"\n        Delete candidate config from the filesystem\n\n        Args:\n            N/A\n\n        Returns:\n            Response: response from deleting the candidate config\n\n        Raises:\n            N/A\n\n        \"\"\"\n        delete_result = self.conn.send_config(\n            config=f\"rm {self.filesystem}{self.candidate_config_filename}\",\n            privilege_level=\"root_shell\",\n        )\n        return delete_result\n\n    def get_version(self) -&gt; ScrapliCfgResponse:\n        response = self._pre_get_version()\n\n        version_result = self.conn.send_command(command=\"show version | grep junos:\")\n\n        return self._post_get_version(\n            response=response,\n            scrapli_responses=[version_result],\n            result=self._parse_version(device_output=version_result.result),\n        )\n\n    def get_config(self, source: str = \"running\") -&gt; ScrapliCfgResponse:\n        response = self._pre_get_config(source=source)\n\n        if self._in_configuration_session is True:\n            config_result = self.conn.send_config(config=\"run show configuration\")\n        else:\n            config_result = self.conn.send_command(command=\"show configuration\")\n\n        return self._post_get_config(\n            response=response,\n            source=source,\n            scrapli_responses=[config_result],\n            result=config_result.result,\n        )\n\n    def load_config(self, config: str, replace: bool = False, **kwargs: Any) -&gt; ScrapliCfgResponse:\n\"\"\"\n        Load configuration to a device\n\n        Supported kwargs:\n            set: bool indicating config is a \"set\" style config (ignored if replace is True)\n\n        Args:\n            config: string of the configuration to load\n            replace: replace the configuration or not, if false configuration will be loaded as a\n                merge operation\n            kwargs: additional kwargs that the implementing classes may need for their platform,\n                see above for junos supported kwargs\n\n        Returns:\n            ScrapliCfgResponse: response object\n\n        Raises:\n            N/A\n\n        \"\"\"\n        self._set = kwargs.get(\"set\", False)\n\n        response = self._pre_load_config(config=config)\n\n        config = self._prepare_load_config(config=config, replace=replace)\n\n        config_result = self.conn.send_config(config=config, privilege_level=\"root_shell\")\n\n        if self._replace is True:\n            load_config = f\"load override {self.filesystem}{self.candidate_config_filename}\"\n        else:\n            if self._set is True:\n                load_config = f\"load set {self.filesystem}{self.candidate_config_filename}\"\n            else:\n                load_config = f\"load merge {self.filesystem}{self.candidate_config_filename}\"\n\n        load_result = self.conn.send_config(config=load_config)\n        self._in_configuration_session = True\n\n        return self._post_load_config(\n            response=response,\n            scrapli_responses=[config_result, load_result],\n        )\n\n    def abort_config(self) -&gt; ScrapliCfgResponse:\n        response = self._pre_abort_config(\n            session_or_config_file=bool(self.candidate_config_filename)\n        )\n\n        rollback_result = self.conn.send_config(config=\"rollback 0\")\n        abort_result = self._delete_candidate_config()\n        self._reset_config_session()\n\n        return self._post_abort_config(\n            response=response, scrapli_responses=[rollback_result, abort_result]\n        )\n\n    def commit_config(self, source: str = \"running\") -&gt; ScrapliCfgResponse:\n        scrapli_responses = []\n        response = self._pre_commit_config(\n            source=source, session_or_config_file=bool(self.candidate_config_filename)\n        )\n\n        commit_result = self.conn.send_config(config=\"commit\")\n        scrapli_responses.append(commit_result)\n\n        if self.cleanup_post_commit:\n            cleanup_result = self._delete_candidate_config()\n            scrapli_responses.append(cleanup_result)\n\n        self._reset_config_session()\n\n        return self._post_load_config(\n            response=response,\n            scrapli_responses=scrapli_responses,\n        )\n\n    def diff_config(self, source: str = \"running\") -&gt; ScrapliCfgDiffResponse:\n        scrapli_responses = []\n        device_diff = \"\"\n        source_config = \"\"\n\n        diff_response = self._pre_diff_config(\n            source=source, session_or_config_file=bool(self.candidate_config_filename)\n        )\n\n        try:\n            diff_result = self.conn.send_config(config=\"show | compare\")\n            scrapli_responses.append(diff_result)\n            if diff_result.failed:\n                msg = \"failed generating diff for config session\"\n                self.logger.critical(msg)\n                raise DiffConfigError(msg)\n\n            device_diff = diff_result.result\n\n            source_config_result = self.get_config(source=source)\n            source_config = source_config_result.result\n\n            if isinstance(source_config_result.scrapli_responses, MultiResponse):\n                # in this case this will always be a multiresponse or nothing (failure) but mypy\n                # doesnt know that, hence the isinstance check\n                scrapli_responses.extend(source_config_result.scrapli_responses)\n\n            if source_config_result.failed:\n                msg = \"failed fetching source config for diff comparison\"\n                self.logger.critical(msg)\n                raise DiffConfigError(msg)\n\n        except DiffConfigError:\n            pass\n\n        return self._post_diff_config(\n            diff_response=diff_response,\n            scrapli_responses=scrapli_responses,\n            source_config=self.clean_config(source_config),\n            candidate_config=self.clean_config(self.candidate_config),\n            device_diff=device_diff,\n        )\n</code></pre>"},{"location":"reference/platform/core/juniper_junos/sync_platform/#platform.core.juniper_junos.sync_platform.ScrapliCfgJunos.load_config","title":"<code>load_config(config: str, replace: bool = False, **kwargs: Any) -&gt; ScrapliCfgResponse</code>","text":"<p>Load configuration to a device</p> Supported kwargs <p>set: bool indicating config is a \"set\" style config (ignored if replace is True)</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>str</code> <p>string of the configuration to load</p> required <code>replace</code> <code>bool</code> <p>replace the configuration or not, if false configuration will be loaded as a merge operation</p> <code>False</code> <code>kwargs</code> <p>additional kwargs that the implementing classes may need for their platform, see above for junos supported kwargs</p> required <p>Returns:</p> Name Type Description <code>ScrapliCfgResponse</code> <code>ScrapliCfgResponse</code> <p>response object</p> Source code in <code>platform/core/juniper_junos/sync_platform.py</code> <pre><code>def load_config(self, config: str, replace: bool = False, **kwargs: Any) -&gt; ScrapliCfgResponse:\n\"\"\"\n    Load configuration to a device\n\n    Supported kwargs:\n        set: bool indicating config is a \"set\" style config (ignored if replace is True)\n\n    Args:\n        config: string of the configuration to load\n        replace: replace the configuration or not, if false configuration will be loaded as a\n            merge operation\n        kwargs: additional kwargs that the implementing classes may need for their platform,\n            see above for junos supported kwargs\n\n    Returns:\n        ScrapliCfgResponse: response object\n\n    Raises:\n        N/A\n\n    \"\"\"\n    self._set = kwargs.get(\"set\", False)\n\n    response = self._pre_load_config(config=config)\n\n    config = self._prepare_load_config(config=config, replace=replace)\n\n    config_result = self.conn.send_config(config=config, privilege_level=\"root_shell\")\n\n    if self._replace is True:\n        load_config = f\"load override {self.filesystem}{self.candidate_config_filename}\"\n    else:\n        if self._set is True:\n            load_config = f\"load set {self.filesystem}{self.candidate_config_filename}\"\n        else:\n            load_config = f\"load merge {self.filesystem}{self.candidate_config_filename}\"\n\n    load_result = self.conn.send_config(config=load_config)\n    self._in_configuration_session = True\n\n    return self._post_load_config(\n        response=response,\n        scrapli_responses=[config_result, load_result],\n    )\n</code></pre>"},{"location":"user_guide/basic_usage/","title":"Basic Usage","text":""},{"location":"user_guide/basic_usage/#picking-the-right-driver","title":"Picking the right Driver","text":"<p>When using scrapli_cfg, you will need to ensure that you are building a scrapli_cfg object specific to the target  device. You can create your connection object directly from the appropriate scrapli_cfg class, i.e.,  <code>ScrapliCfgIOSXE</code>, or you can use the \"factory\" function to appropriately dispatch the class type based on a provided  <code>conn</code> object (scrapli connection object). A simple example of creating a scrapli_cfg object by both methods is below:</p> <pre><code>from scrapli import Scrapli\nfrom scrapli_cfg.platform.core.cisco_iosxe import ScrapliCfgIOSXE\nfrom scrapli_cfg import ScrapliCfg\n\ndevice = {\n   \"host\": \"172.18.0.11\",\n   \"auth_username\": \"vrnetlab\",\n   \"auth_password\": \"VR-netlab9\",\n   \"auth_strict_key\": False,\n   \"platform\": \"cisco_iosxe\"\n}\nconn = Scrapli(**device)\ncfg_conn_from_specific_platform_class = ScrapliCfgIOSXE(conn=conn)\ncfg_conn_from_factory = ScrapliCfg(conn=conn)\n</code></pre> <p>The available platform names are:</p> <ul> <li><code>arista_eos</code></li> <li><code>cisco_iosxe</code></li> <li><code>cisco_iosxr</code></li> <li><code>cisco_nxos</code></li> <li><code>juniper_junos</code></li> </ul>"},{"location":"user_guide/basic_usage/#driver-arguments","title":"Driver Arguments","text":"<p>scrapli_cfg doesn't have a ton of arguments/options that you need to worry about! The most important argument is the  <code>conn</code> argument -- which is expecting a scrapli connection that is built from the <code>NetworkDriver</code>. This connection  must be from one of the \"core\" scrapli platforms (EOS, IOSXE, IOSXR, NXOS, JunOS).</p> <p>The other remaining primary arguments are as follows:</p> <ul> <li><code>config_sources</code>: Generally ignored/handled by the platform implementation for you. A list of strings representing    the valid config sources, i.e. \"running\", \"candidate\", or \"startup\"</li> <li><code>on_prepare</code>: A callable (sync or async depending on your code of course) that is executed during the <code>prepare</code>    method; initially scrapli-cfg contained a default callable that would disable console logging (in most cases),    however as this actually made changes to your device that were somewhat \"magic\" it was removed. Now, users can    pass an <code>on_prepare</code> callable to disable console logging, or really anything else they want. This callable should    accept <code>cls</code> as the first argument which is a reference to the scrapli-cfg object itself (and thus has access to    the underlying scrapli connection). More on this in the <code>on_prepare</code> section.</li> <li><code>dedicated_connection</code>: If <code>False</code> (default value) scrapli cfg will not open or close the underlying scrapli    connection and will raise an exception if the scrapli connection is not open. If <code>True</code> it will automatically open    and close the scrapli connection when using with a context manager, <code>prepare</code> will open the scrapli connection (if    not already open), and <code>close</code> will close the scrapli connection.</li> <li><code>ignore_version</code>: Ignore checking device version support; currently this just means that scrapli-cfg will not    fetch the device version during the prepare phase, however this will (hopefully) be used in the future to limit    what methods can be used against a target device. For example, for EOS devices we need &gt; 4.14 to load configs; so    if a device is encountered at 4.13 the version check would raise an exception rather than just failing in a    potentially awkward fashion.</li> </ul> <p>There are no additional arguments for creating a scrapli_cfg object, though each platform may have other  optional arguments as necessary -- check the docs/class for those.</p>"},{"location":"user_guide/basic_usage/#scrapli_cfg-methods","title":"scrapli_cfg Methods","text":"<p>scrapli_cfg methods are mostly intended at managing device configuration, though there are a few extra methods in  there as well. The following sections provide a brief description and example of how to use the main public methods.</p> <p>Note that nearly all public methods in scrapli_cfg will return a <code>ScrapliCfgResponse</code> object that will contain a  <code>result</code> attribute of the result of the given task, as well as the underlying scrapli <code>Response</code> object, and the  usual scrapli attributes like start/finish/elapsed time, a <code>failed</code> attribute, and a <code>raise_for_status</code> method.</p>"},{"location":"user_guide/basic_usage/#get-version","title":"Get Version","text":"<p>The <code>get_version</code> method does exactly what you would expect it to -- it fetches the version string from the target  device. scrapli_cfg very intentionally has no \"getters\" (in the NAPALM-sense) except for <code>get_version</code>  and <code>get_config</code> -- this is because there is no desire to maintain support for getters across a huge variety of  versions/platforms. That said, the <code>get_version</code> method was implemented in order to (obviously) fetch device  versions to (in the future) be used to validate the target device version supports all features that scrapli_cfg  needs in order to manage the configurations. </p> <p>A simple example of fetching and printing the device version:</p> <pre><code>from scrapli import Scrapli\nfrom scrapli_cfg import ScrapliCfg\n\ndevice = {\n   \"host\": \"172.18.0.11\",\n   \"auth_username\": \"vrnetlab\",\n   \"auth_password\": \"VR-netlab9\",\n   \"auth_strict_key\": False,\n   \"platform\": \"cisco_iosxe\"\n}\nwith Scrapli(**device) as conn:\n    cfg_conn = ScrapliCfg(conn=conn)\n    cfg_conn.prepare()\n    version_result = cfg_conn.get_version()\n    print(version_result.result)\n</code></pre>"},{"location":"user_guide/basic_usage/#get-config","title":"Get Config","text":"<p>The <code>get_config</code> method does exactly what you would think it does, it fetches the device configuration as a string.  This method supports a <code>source</code> argument to which you can provide a string representing the source config you would  like to get -- generally this will be either \"startup\" or \"running\".</p> <p>A simple example of fetching and printing the device startup configuration:</p> <pre><code>from scrapli import Scrapli\nfrom scrapli_cfg import ScrapliCfg\n\ndevice = {\n   \"host\": \"172.18.0.11\",\n   \"auth_username\": \"vrnetlab\",\n   \"auth_password\": \"VR-netlab9\",\n   \"auth_strict_key\": False,\n   \"platform\": \"cisco_iosxe\"\n}\nwith Scrapli(**device) as conn:\n    cfg_conn = ScrapliCfg(conn=conn)\n    cfg_conn.prepare()\n    cfg_result = cfg_conn.get_config(source=\"startup\")\n    print(cfg_result.result)\n</code></pre>"},{"location":"user_guide/basic_usage/#get-checkpoint-nxos-only","title":"Get Checkpoint (NXOS Only)","text":"<p>NXOS can be a little... difficult with configuration replacement operations. It expects to be fed \"checkpoint\" files  instead of \"normal\" configuration text. In order to make life a bit easier the NXOS platform supports a  <code>get_checkpoint</code> method that fetches a checkpoint file from the device. This is basically the same overall behavior  as <code>get_config</code>, just resulting in fetching a checkpoint file. Some details about checkpoints can be found  here.</p> <p>A simple example of fetching and printing a checkpoint file from an NXOS device:</p> <pre><code>from scrapli import Scrapli\nfrom scrapli_cfg import ScrapliCfg\n\ndevice = {\n   \"host\": \"172.18.0.12\",\n   \"auth_username\": \"vrnetlab\",\n   \"auth_password\": \"VR-netlab9\",\n   \"auth_strict_key\": False,\n   \"platform\": \"cisco_nxos\"\n}\nwith Scrapli(**device) as conn:\n    cfg_conn = ScrapliCfg(conn=conn)\n    cfg_conn.prepare()\n    chkpoint_result = cfg_conn.get_checkpoint()\n    print(chkpoint_result.result)\n</code></pre>"},{"location":"user_guide/basic_usage/#load-config","title":"Load Config","text":"<p>Another, hopefully very obviously named method! <code>load_config</code> does what it sounds like. <code>load_config</code> accepts a  configuration to load (as a string; note that if you are doing config replace with NXOS you should use a checkpoint  file!), optionally a bool indicating if the operation is a \"replace\" operation (default is <code>False</code> it is a merge  operation), and lastly some optional keyword arguments that vary from platform to platform.</p> <p>If <code>replace</code> is <code>False</code> (default) then the config will be loaded as a merge candidate, otherwise it will be loaded  as a full replace candidate.</p> <pre><code>from scrapli import Scrapli\nfrom scrapli_cfg import ScrapliCfg\n\nwith open(\"config\", \"r\") as f:\n    my_config = f.read()\n\ndevice = {\n   \"host\": \"172.18.0.11\",\n   \"auth_username\": \"vrnetlab\",\n   \"auth_password\": \"VR-netlab9\",\n   \"auth_strict_key\": False,\n   \"platform\": \"cisco_iosxe\"\n}\nwith Scrapli(**device) as conn:\n    cfg_conn = ScrapliCfg(conn=conn)\n    cfg_conn.prepare()\n    load_result = cfg_conn.load_config(config=my_config, replace=True)\n    print(load_result)\n</code></pre> <p>Note that loading a configuration does not apply the configuration! This simply will create a configuration  session or a file on the device (depending on the specific platform type) that can be used to merge/replace the config.</p>"},{"location":"user_guide/basic_usage/#abort-config","title":"Abort Config","text":"<p>If you've loaded a configuration but don't want to commit it, you can call <code>abort_config</code> which will delete the  candidate config/delete config sessions used to load the config.</p> <pre><code>from scrapli import Scrapli\nfrom scrapli_cfg import ScrapliCfg\n\nwith open(\"config\", \"r\") as f:\n    my_config = f.read()\n\ndevice = {\n   \"host\": \"172.18.0.11\",\n   \"auth_username\": \"vrnetlab\",\n   \"auth_password\": \"VR-netlab9\",\n   \"auth_strict_key\": False,\n   \"platform\": \"cisco_iosxe\"\n}\nwith Scrapli(**device) as conn:\n    cfg_conn = ScrapliCfg(conn=conn)\n    cfg_conn.prepare()\n    load_result = cfg_conn.load_config(config=my_config, replace=True)\n    print(load_result)\n    abort_result = cfg_conn.abort_config()\n    print(abort_result)\n</code></pre>"},{"location":"user_guide/basic_usage/#commit-config","title":"Commit Config","text":"<p>If you've loaded a config and want to save/commit it you can do so with the <code>commit_config</code> method:</p> <pre><code>from scrapli import Scrapli\nfrom scrapli_cfg import ScrapliCfg\n\nwith open(\"config\", \"r\") as f:\n    my_config = f.read()\n\ndevice = {\n   \"host\": \"172.18.0.11\",\n   \"auth_username\": \"vrnetlab\",\n   \"auth_password\": \"VR-netlab9\",\n   \"auth_strict_key\": False,\n   \"platform\": \"cisco_iosxe\"\n}\nwith Scrapli(**device) as conn:\n    cfg_conn = ScrapliCfg(conn=conn)\n    cfg_conn.prepare()\n    load_result = cfg_conn.load_config(config=my_config, replace=True)\n    print(load_result)\n    commit_result = cfg_conn.commit_config()\n    print(commit_result)\n</code></pre>"},{"location":"user_guide/basic_usage/#diff-config","title":"Diff Config","text":"<p>Perhaps the most interesting/handy method of all: <code>diff_config</code>! Just like the other methods, this method does  exactly what it sounds like it would. There is one important difference between this method and the others, however;  the <code>diff_config</code> method returns a <code>ScrapliCfgDiffResponse</code> object instead of a <code>ScrapliCfgResponse</code> object. The  <code>ScrapliCfgDiffResponse</code> object is mostly the same as a normal scrapli_cfg response, but it also contains some  properties that contain the diff output.</p> <p>scrapli_cfg always tries to get a diff from the device itself -- from whatever means are available on box, but also  builds some basic diffs of its own. The diffs that scrapli_cfg builds are fairly simple and will show the difference  between the candidate config and the target config, but will have no context about merge vs replace operations, so  the diff will always show the \"full\" configuration diff (with colorful output though!). </p> <p>You can see each of the diffs like so:</p> <pre><code>from scrapli import Scrapli\nfrom scrapli_cfg import ScrapliCfg\n\nwith open(\"config\", \"r\") as f:\n    my_config = f.read()\n\ndevice = {\n   \"host\": \"172.18.0.11\",\n   \"auth_username\": \"vrnetlab\",\n   \"auth_password\": \"VR-netlab9\",\n   \"auth_strict_key\": False,\n   \"platform\": \"cisco_iosxe\"\n}\nwith Scrapli(**device) as conn:\n    cfg_conn = ScrapliCfg(conn=conn)\n    cfg_conn.prepare()\n    load_result = cfg_conn.load_config(config=my_config, replace=True)\n    print(load_result)\n    diff_result = cfg_conn.diff_config()\n    print(diff_result.device_diff)\n    print(diff_result.unified_diff)\n    print(diff_result.side_by_side_diff)\n</code></pre>"},{"location":"user_guide/basic_usage/#render-substituted-config","title":"Render Substituted Config","text":"<p>The <code>render_substituted_config</code> method is used to (based on user provided regex) auto merge a candidate  configuration with sections of the current device configuration. This is meant to allow users an easy-ish way to  start doing config replace operations, without having to have a template that covers all aspects of the device  configuration.</p> <p>For example, let's say you want to manage everything on a switch except the interfaces. Maybe you want to do this  because managing loads of templates for all the different types of interfaces/platforms is a pain, or maybe a  different team manages that part of the config... whatever the case you want to be able to do full config replaces,  but leave that part of the config completely untouched. This is what the <code>render_substitued_config</code> method is  designed to help you with.</p> <p>Here is an example of using this method:</p> <pre><code>from scrapli import Scrapli\nfrom scrapli_cfg import ScrapliCfg\nfrom scrapli_cfg.platform.core.arista_eos.patterns import ETHERNET_INTERFACES\n\n\nwith open(\"config\", \"r\") as f:\n    my_config = f.read()\n\ndevice = {\n   \"host\": \"172.18.0.14\",\n   \"auth_username\": \"vrnetlab\",\n   \"auth_password\": \"VR-netlab9\",\n   \"auth_strict_key\": False,\n   \"platform\": \"arista_eos\"\n}\nwith Scrapli(**device) as conn:\n    cfg_conn = ScrapliCfg(conn=conn)\n    cfg_conn.prepare()\n    rendered_config = cfg_conn.render_substituted_config(\n        config_template=my_config, substitutes=[(\"ethernet_interfaces\", ETHERNET_INTERFACES)]\n    )\n    load_result = cfg_conn.load_config(config=my_config, replace=True)\n    print(load_result)\n</code></pre> <p>In the above example we have a fairly \"normal\" scrapli_cfg setup -- create a connection and open it. Once the  connection is opened we call the <code>render_substituted_config</code> and we pass a <code>config_template</code> and a list of  <code>substitutes</code> to it. The config template is what it sounds like -- a template (that looks like a jinja2 template).  In this case, this template has a variable <code>ethernet_interfaces</code> in the file where the ethernet interfaces would  go, so instead of something like this:</p> <pre><code>username vrnetlab role network-admin secret sha512 $6$8zrJ4ESW2fqG2QqH$9u768TvLXXDeUJmG2Std71EX1ip6q4MoJrMwDng1cmpuSYc9ECWytRjvXpMH7C3dzSdoEv0MxAUiAZeeTre3h.\n!\ninterface Ethernet 1\n  description tacocat\n!\n&lt;&lt; SNIP &gt;&gt;\ninterface Management1\n</code></pre> <p>We have something like this:</p> <pre><code>username vrnetlab role network-admin secret sha512 $6$8zrJ4ESW2fqG2QqH$9u768TvLXXDeUJmG2Std71EX1ip6q4MoJrMwDng1cmpuSYc9ECWytRjvXpMH7C3dzSdoEv0MxAUiAZeeTre3h.\n!\n{{ ethernet_interfaces }}\ninterface Management1\n</code></pre> <p>The <code>substitutes</code> we passed into the <code>render_substituted_config</code> method is a list of tuples, where the first item in  the tuple is the variable we want to replace (<code>ethernet_interfaces</code> in this case) and the second value is a regular  expression that matches the section of the real running config that we want to put into this variable.</p> <p>Ultimately, using this example, if we had a \"real\" running configuration containing the following interface section  (just using one interface to keep things simple) that looked like this:</p> <pre><code>username vrnetlab role network-admin secret sha512 $6$8zrJ4ESW2fqG2QqH$9u768TvLXXDeUJmG2Std71EX1ip6q4MoJrMwDng1cmpuSYc9ECWytRjvXpMH7C3dzSdoEv0MxAUiAZeeTre3h.\n!\ninterface Ethernet 1\n  description tacocat\n!\ninterface Management1\n</code></pre> <p>Our rendered template would end up looking just like that. Again, the point of this method is to allow you to more  easily do configuration replaces without having to fully template out device configs. The obvious downside to this  method is that it may require fairly complicated regular expressions in order to properly slice and dice the real  config.</p>"},{"location":"user_guide/basic_usage/#on-prepare","title":"On Prepare","text":"<p>The <code>on_prepare</code> argument of the scrapli-cfg objects gives users the opportunity to pass a callable that will be  executed prior to any operations occurring (this happens during the aptly named \"prepare\" method which you should be  calling prior to using scrapli_cfg operations -- note that if you use the context manager functionality this will  already be called for you!). The purpose of this <code>on_prepare</code> callable is to... prepare a device for config  operations. Initially scrapli_cfg platforms contained a sane default <code>on_prepare</code> function that basically just  disabled console logging. The reasoning for disabling console logging is to ensure that any <code>get_config</code> operations  don't have log messages garbling up the output.</p> <p>This \"sane default\" setting has since been removed as it was a bit too much \"magic\" -- meaning that it felt wrong  for scrapli_cfg to be making any kind of persistent configuration changes to your devices potentially without users  being aware that was happening. As such, it would be a good idea to provide an <code>on_prepare</code> callable to at the very  least disable console logging.</p>"},{"location":"user_guide/installation/","title":"Installation","text":""},{"location":"user_guide/installation/#standard-installation","title":"Standard Installation","text":"<p>As outlined in the quick start, you should be able to pip install scrapli \"normally\":</p> <pre><code>pip install scrapli-cfg\n</code></pre>"},{"location":"user_guide/installation/#installing-current-master-branch","title":"Installing current master branch","text":"<p>To install from the source repositories master branch:</p> <pre><code>pip install git+https://github.com/scrapli/scrapli_cfg\n</code></pre>"},{"location":"user_guide/installation/#installing-current-develop-branch","title":"Installing current develop branch","text":"<p>To install from the source repositories develop branch:</p> <pre><code>pip install -e git+https://github.com/scrapli/scrapli_cfg.git@develop#egg=scrapli_cfg\n</code></pre>"},{"location":"user_guide/installation/#installation-from-source","title":"Installation from Source","text":"<p>To install from source:</p> <pre><code>git clone https://github.com/scrapli/scrapli_cfg\ncd scrapli_cfg\npython setup.py install\n</code></pre>"},{"location":"user_guide/installation/#supported-platforms","title":"Supported Platforms","text":"<p>As for platforms to run scrapli on -- it has and will be tested on MacOS and Ubuntu regularly and should work on any  POSIX system. Windows at one point was being tested very minimally via GitHub Actions builds, however this is no   longer the case as it is just not worth the effort. While scrapli should work on Windows when using the paramiko or    ssh2-python transport drivers, it is not \"officially\" supported. It is strongly recommended/preferred for folks     to use WSL/Cygwin instead of Windows.</p>"},{"location":"user_guide/project_details/","title":"Project Details","text":""},{"location":"user_guide/project_details/#what-is-scrapli_cfg","title":"What is scrapli_cfg","text":"<p>scrapli_cfg is a library that sits \"on top\" of scrapli \"core\" and  makes merging or replacing device configurations over Telnet or SSH easy. Why over Telnet or SSH? Because you pretty  much will always have one of these options available to you, whereas you may not have eAPI or NETCONF ready and  enabled (think day zero provisioning, or crazy security requirements locking down ports).</p>"},{"location":"user_guide/project_details/#so-its-like-napalm","title":"So its like NAPALM?","text":"<p>If you are familiar with the configuration management abilities of the excellent  NAPALM library then you are already generally familiar with what  scrapli_cfg is capable of. The primary differences between scrapli_cfg and NAPALM are as follows:</p> <ol> <li>scrapli_cfg has, and never will (unless I change my mind), have \"getters\" outside the \"get_config\" and     \"get_version\" getters. This means there will not be anything like \"get_interfaces\" in scrapli_cfg. </li> <li>scrapli_cfg has no dependency on any APIs being available -- configurations are all handled via Telnet or SSH.     This may sound \"bad\" because the cli is so \"bad\", but it means that there are no requirements for additional     ports to be opened or services to be enabled (i.e. eAPI or NETCONF), it even means (with a bit of work to handle     initially logging into a terminal server and getting to the right port) you could use scrapli_cfg to fully manage     device configuration over terminal server connections.</li> <li>scrapli_cfg has no Python dependencies other than scrapli -- this means there are no vendor libraries necessary,     no eznc, no pyeapi, and no pyiosxr. Fewer dependencies isn't a huge deal, but it does mean that the scrapli     community is fully \"in control\" of all requirements which is pretty nice!</li> <li>scrapli_cfg, just like \"normal\" scrapli provides supports both synchronous and asynchronous code with the same API</li> <li>scrapli_cfg, provides a <code>render_substituted_config</code> method that helps you easily merge templated configurations     with real device configuration -- so you can do \"full config replace\" without having to template out every last     line of config!</li> </ol>"},{"location":"user_guide/project_details/#supported-platforms","title":"Supported Platforms","text":"<p>Just like scrapli \"core\", scrapli_cfg covers the \"core\" NAPALM platforms -- Cisco IOS-XE, IOS-XR, NX-OS,  Arista EOS, and Juniper JunOS (eventually, no JunOS support just yet). Below are the core driver platforms and  regularly tested version.</p> <p>Cisco IOS-XE (tested on: 16.12.03) Cisco NX-OS (tested on: 9.2.4) Juniper JunOS (tested on: 17.3R2.10) Cisco IOS-XR (tested on: 6.5.3) Arista EOS (tested on: 4.22.1F)</p> <p>Specific platform support requirements are listed below.</p>"},{"location":"user_guide/project_details/#arista-eos","title":"Arista EOS","text":"<p>scrapli_cfg uses configuration sessions in EOS, this feature was added somewhere around the 4.14 release. Early  versions of EOS that support configuration sessions did not allow configuration sessions to be aborted from  privilege exec, the <code>clear_config_sessions</code> will not work on these versions, however all other scrapli_cfg features  should work.</p>"},{"location":"user_guide/project_details/#cisco-iosxe","title":"Cisco IOSXE","text":"<p>IOSXE behavior is very similar to NAPALM, using the archive feature to help with config management and diffs, as  such scrapli_cfg requires IOS versions &gt; 12.4(20)T -- all IOSXE versions should be supported (please open an issue  or find me on Slack/Twitter if this is incorrect!).</p>"},{"location":"user_guide/project_details/#cisco-iosxr","title":"Cisco IOSXR","text":"<p>scrapli_cfg has worked on every IOSXR version that it has been tested on -- due to IOSXR natively supporting  configuration merging/replacing this should work on most IOSXR devices.</p>"},{"location":"user_guide/project_details/#cisco-nxos","title":"Cisco NXOS","text":"<p>scrapli_cfg should work on most versions of NXOS, there is no requirement for NX-API, instead scrapli_cfg simply  relies on the tclsh.</p>"},{"location":"user_guide/project_details/#juniper-junos","title":"Juniper JunOS","text":"<p>scrapli_cfg should work on JunOS too -- though JunOS has likely received the least amount of testing at this point.</p>"},{"location":"user_guide/quickstart/","title":"Quick Start Guide","text":""},{"location":"user_guide/quickstart/#installation","title":"Installation","text":"<p>In most cases installation via pip is the simplest and best way to install scrapli_cfg. See here for advanced installation details.</p> <pre><code>pip install scrapli-cfg\n</code></pre>"},{"location":"user_guide/quickstart/#a-simple-example","title":"A Simple Example","text":"<pre><code>from scrapli import Scrapli\nfrom scrapli_cfg import ScrapliCfg\n\ndevice = {\n   \"host\": \"172.18.0.11\",\n   \"auth_username\": \"vrnetlab\",\n   \"auth_password\": \"VR-netlab9\",\n   \"auth_strict_key\": False,\n   \"platform\": \"cisco_iosxe\"\n}\n\nwith open(\"myconfig\", \"r\") as f:\n    my_config = f.read()\n\nwith Scrapli(**device) as conn:\n    cfg_conn = ScrapliCfg(conn=conn)\n    cfg_conn.prepare()\n    cfg_conn.load_config(config=my_config, replace=True)\n    diff = cfg_conn.diff_config()\n    print(diff.side_by_side_diff)\n    cfg_conn.commit_config()\n</code></pre>"},{"location":"user_guide/quickstart/#more-examples","title":"More Examples","text":"<ul> <li>Basic Usage</li> <li>Selective Configuration Replace</li> </ul>"},{"location":"user_guide/versioning/","title":"Versioning","text":"<p>Just like scrapli, scrapli_cfg uses the CalVer versioning standard. All release versions  follow the format <code>YYYY.MM.DD</code>, however PyPi will shorten/standardize this to remove leading zeros.</p> <p>The reason for choosing CalVer is simply to make it very clear how old a given release of scrapli is. While there are  clearly some potential challenges around indicating when a \"breaking\" change occurs due to there not being the   concept of a \"major\" version, this is hopefully not too big a deal for scrapli, and thus far the \"core\" API has    been very stable -- there are only so many things you can/need to do over SSH after all!</p> <p>Please also note that the CHANGELOG contains notes about each version (and is updated in develop branch  while updates are happening). Releases will be made semi-yearly; if you need a feature between releases, there will  be periodic pre-releases cut so that folks can easily pip install the prerelease versions for testing and getting  any new features/fixes.</p> <p>A final note regarding versioning: scrapli updates are released as often as necessary/there are things to update . This means you should ALWAYS PIN YOUR REQUIREMENTS when using scrapli!! As stated, the \"core\" API has been very  stable, but things will change over time -- always pin your requirements, and keep an eye on the changelog/api docs   -- you can \"watch\" this repository to ensure you are notified of any releases.</p>"}]}