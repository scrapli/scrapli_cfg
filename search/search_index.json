{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"scrapli_cfg \u00b6 scrapli_cfg makes merging or replacing device configurations over Telnet or SSH easy. Why over Telnet or SSH? Because you pretty much will always have one of these options available to you, whereas you may not have eAPI or NETCONF ready and enabled (think day zero provisioning, or crazy security requirements locking down ports). scrapli_cfg is built on top of scrapli \"core\" and continues the \"look and feel\" of scrapli into the config management side of things.","title":"Scrapli Cfg"},{"location":"#scrapli_cfg","text":"scrapli_cfg makes merging or replacing device configurations over Telnet or SSH easy. Why over Telnet or SSH? Because you pretty much will always have one of these options available to you, whereas you may not have eAPI or NETCONF ready and enabled (think day zero provisioning, or crazy security requirements locking down ports). scrapli_cfg is built on top of scrapli \"core\" and continues the \"look and feel\" of scrapli into the config management side of things.","title":"scrapli_cfg"},{"location":"changelog/","text":"Changelog \u00b6 2022.07.30 \u00b6 Fix from @WillIrvine to sort a very bad (carl's fault) regex overly aggressive matching -- see #41 2022.01.30 \u00b6 Revised juniper abort config to remove candidate config file after rollback 0 to avoid issues where junos would prompt for confirmation when exiting config mode to go delete the candidate config file prompting timeouts. Dropped Python3.6 support as it is now EOL! Of course, scrapli probably still works just fine with 3.6 (if you install the old 3.6 requirements), but we won't test/support it anymore. Wow, pretty empty here... guess that's a good sign things have been working :p 2021.07.30 \u00b6 Initial release!","title":"Changelog"},{"location":"changelog/#changelog","text":"","title":"Changelog"},{"location":"changelog/#20220730","text":"Fix from @WillIrvine to sort a very bad (carl's fault) regex overly aggressive matching -- see #41","title":"2022.07.30"},{"location":"changelog/#20220130","text":"Revised juniper abort config to remove candidate config file after rollback 0 to avoid issues where junos would prompt for confirmation when exiting config mode to go delete the candidate config file prompting timeouts. Dropped Python3.6 support as it is now EOL! Of course, scrapli probably still works just fine with 3.6 (if you install the old 3.6 requirements), but we won't test/support it anymore. Wow, pretty empty here... guess that's a good sign things have been working :p","title":"2022.01.30"},{"location":"changelog/#20210730","text":"Initial release!","title":"2021.07.30"},{"location":"about/code_of_conduct/","text":"Code of Conduct \u00b6 Be excellent to each other!","title":"Code of Conduct"},{"location":"about/code_of_conduct/#code-of-conduct","text":"Be excellent to each other!","title":"Code of Conduct"},{"location":"about/contributing/","text":"Contributing \u00b6 Thanks for thinking about contributing! Contributions are not expected, but are quite welcome. Contributions of all kinds are welcomed -- typos, doc updates, adding examples, bug fixes, and feature adds. Some notes on contributing: Please open a GitHub discussion topic for any potential feature adds/changes to discuss them prior to opening a PR, this way everyone has a chance to chime in and make sure we're all on the same page! Please open an issue to discuss any bugs/bug fixes prior to opening a PR. Once we all have discussed any adds/changes, pull requests are very much welcome and appreciated! All PRs should pass tests/CI linting -- checkout the Makefile for some shortcuts for linting and testing. Please include tests! Even simple/basic tests are better than nothing -- it helps make sure changes in the future don't break functionality or make things act in unexpected ways!","title":"Contributing"},{"location":"about/contributing/#contributing","text":"Thanks for thinking about contributing! Contributions are not expected, but are quite welcome. Contributions of all kinds are welcomed -- typos, doc updates, adding examples, bug fixes, and feature adds. Some notes on contributing: Please open a GitHub discussion topic for any potential feature adds/changes to discuss them prior to opening a PR, this way everyone has a chance to chime in and make sure we're all on the same page! Please open an issue to discuss any bugs/bug fixes prior to opening a PR. Once we all have discussed any adds/changes, pull requests are very much welcome and appreciated! All PRs should pass tests/CI linting -- checkout the Makefile for some shortcuts for linting and testing. Please include tests! Even simple/basic tests are better than nothing -- it helps make sure changes in the future don't break functionality or make things act in unexpected ways!","title":"Contributing"},{"location":"api_docs/diff/","text":"window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting()) Module scrapli_cfg.diff \u00b6 scrapli_cfg.diff Expand source code \"\"\"scrapli_cfg.diff\"\"\" import difflib import shutil from typing import List, Tuple from scrapli_cfg.exceptions import DiffConfigError from scrapli_cfg.response import ScrapliCfgResponse GREEN = \"\\033[92m\" RED = \"\\033[91m\" YELLOW = \"\\033[93m\" END_COLOR = \"\\033[0m\" class ScrapliCfgDiffResponse(ScrapliCfgResponse): def __init__( self, host: str, source: str, colorize: bool = True, side_by_side_diff_width: int = 0 ) -> None: \"\"\" Scrapli config diff object Args: host: host the diff is for source: source config store from the device, typically running|startup colorize: True/False colorize diff output side_by_side_diff_width: width to use to generate the side-by-side diff, if not provided will fetch the current terminal width Returns: N/A Raises: N/A \"\"\" super().__init__(host=host, raise_for_status_exception=DiffConfigError) self.colorize = colorize self.side_by_side_diff_width = side_by_side_diff_width self.source = source self.source_config = \"\" self.candidate_config = \"\" self.device_diff = \"\" self._difflines: List[str] = [] self.additions = \"\" self.subtractions = \"\" self._unified_diff = \"\" self._side_by_side_diff = \"\" def __repr__(self) -> str: \"\"\" Magic repr method for ScrapliCfgResponse class Args: N/A Returns: str: repr for class object Raises: N/A \"\"\" return f\"ScrapliCfgDiffResponse \" def __str__(self) -> str: \"\"\" Magic str method for ScrapliCfgDiffResponse class Args: N/A Returns: str: str for class object Raises: N/A \"\"\" return f\"ScrapliCfgDiffResponse \" def record_diff_response( self, source_config: str, candidate_config: str, device_diff: str ) -> None: \"\"\" Scrapli config diff object Args: source_config: the actual contents of the source config candidate_config: the scrapli_cfg candidate config device_diff: diff generated by the device itself (if applicable) Returns: N/A Raises: N/A \"\"\" self.source_config = source_config self.candidate_config = candidate_config self.device_diff = device_diff _differ = difflib.Differ() self._difflines = list( _differ.compare( self.source_config.splitlines(keepends=True), self.candidate_config.splitlines(keepends=True), ) ) self.additions = \"\".join([line[2:] for line in self._difflines if line[:2] == \"+ \"]) self.subtractions = \"\".join([line[2:] for line in self._difflines if line[:2] == \"- \"]) def _generate_colors(self) -> Tuple[str, str, str, str]: \"\"\" Generate the necessary strings for colorizing or not output Args: N/A Returns: tuple: tuple of strings for colorizing (or not) output Raises: N/A \"\"\" yellow = YELLOW if self.colorize else \"? \" red = RED if self.colorize else \"- \" green = GREEN if self.colorize else \"+ \" end = END_COLOR if self.colorize else \"\" return yellow, red, green, end @property def side_by_side_diff(self) -> str: \"\"\" Generate a side-by-side diff of source vs candidate Args: N/A Returns: str: unified diff text Raises: N/A \"\"\" if self._side_by_side_diff: return self._side_by_side_diff yellow, red, green, end = self._generate_colors() term_width = self.side_by_side_diff_width or shutil.get_terminal_size().columns half_term_width = int(term_width / 2) diff_side_width = int(half_term_width - 5) side_by_side_diff_lines = [] for line in self._difflines: if line[:2] == \"? \": current = ( yellow + f\"{line[2:][:diff_side_width].rstrip() : < {half_term_width}}\" + end ) candidate = yellow + f\"{line[2:][:diff_side_width].rstrip()}\" + end elif line[:2] == \"- \": current = red + f\"{line[2:][:diff_side_width].rstrip() : < {half_term_width}}\" + end candidate = \"\" elif line[:2] == \"+ \": current = f\"{'' : < {half_term_width}}\" candidate = green + f\"{line[2:][:diff_side_width].rstrip()}\" + end else: current = f\"{line[2:][:diff_side_width].rstrip() : < {half_term_width}}\" candidate = f\"{line[2:][:diff_side_width].rstrip()}\" side_by_side_diff_lines.append(current + candidate) joined_side_by_side_diff = \"\\n\".join(side_by_side_diff_lines) self._side_by_side_diff = joined_side_by_side_diff return self._side_by_side_diff @property def unified_diff(self) -> str: \"\"\" Generate a unified diff of source vs candidate Args: N/A Returns: str: unified diff text Raises: N/A \"\"\" if self._unified_diff: return self._unified_diff yellow, red, green, end = self._generate_colors() unified_diff = [ yellow + line[2:] + end if line[:2] == \"? \" else red + line[2:] + end if line[:2] == \"- \" else green + line[2:] + end if line[:2] == \"+ \" else line[2:] for line in self._difflines ] joined_unified_diff = \"\".join(unified_diff) self._unified_diff = joined_unified_diff return self._unified_diff Classes \u00b6 ScrapliCfgDiffResponse \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 Scrapli config diff object Args: host: host the diff is for source: source config store from the device, typically running|startup colorize: True/False colorize diff output side_by_side_diff_width: width to use to generate the side-by-side diff, if not provided will fetch the current terminal width Returns: N/A Raises: N/A Expand source code class ScrapliCfgDiffResponse(ScrapliCfgResponse): def __init__( self, host: str, source: str, colorize: bool = True, side_by_side_diff_width: int = 0 ) -> None: \"\"\" Scrapli config diff object Args: host: host the diff is for source: source config store from the device, typically running|startup colorize: True/False colorize diff output side_by_side_diff_width: width to use to generate the side-by-side diff, if not provided will fetch the current terminal width Returns: N/A Raises: N/A \"\"\" super().__init__(host=host, raise_for_status_exception=DiffConfigError) self.colorize = colorize self.side_by_side_diff_width = side_by_side_diff_width self.source = source self.source_config = \"\" self.candidate_config = \"\" self.device_diff = \"\" self._difflines: List[str] = [] self.additions = \"\" self.subtractions = \"\" self._unified_diff = \"\" self._side_by_side_diff = \"\" def __repr__(self) -> str: \"\"\" Magic repr method for ScrapliCfgResponse class Args: N/A Returns: str: repr for class object Raises: N/A \"\"\" return f\"ScrapliCfgDiffResponse \" def __str__(self) -> str: \"\"\" Magic str method for ScrapliCfgDiffResponse class Args: N/A Returns: str: str for class object Raises: N/A \"\"\" return f\"ScrapliCfgDiffResponse \" def record_diff_response( self, source_config: str, candidate_config: str, device_diff: str ) -> None: \"\"\" Scrapli config diff object Args: source_config: the actual contents of the source config candidate_config: the scrapli_cfg candidate config device_diff: diff generated by the device itself (if applicable) Returns: N/A Raises: N/A \"\"\" self.source_config = source_config self.candidate_config = candidate_config self.device_diff = device_diff _differ = difflib.Differ() self._difflines = list( _differ.compare( self.source_config.splitlines(keepends=True), self.candidate_config.splitlines(keepends=True), ) ) self.additions = \"\".join([line[2:] for line in self._difflines if line[:2] == \"+ \"]) self.subtractions = \"\".join([line[2:] for line in self._difflines if line[:2] == \"- \"]) def _generate_colors(self) -> Tuple[str, str, str, str]: \"\"\" Generate the necessary strings for colorizing or not output Args: N/A Returns: tuple: tuple of strings for colorizing (or not) output Raises: N/A \"\"\" yellow = YELLOW if self.colorize else \"? \" red = RED if self.colorize else \"- \" green = GREEN if self.colorize else \"+ \" end = END_COLOR if self.colorize else \"\" return yellow, red, green, end @property def side_by_side_diff(self) -> str: \"\"\" Generate a side-by-side diff of source vs candidate Args: N/A Returns: str: unified diff text Raises: N/A \"\"\" if self._side_by_side_diff: return self._side_by_side_diff yellow, red, green, end = self._generate_colors() term_width = self.side_by_side_diff_width or shutil.get_terminal_size().columns half_term_width = int(term_width / 2) diff_side_width = int(half_term_width - 5) side_by_side_diff_lines = [] for line in self._difflines: if line[:2] == \"? \": current = ( yellow + f\"{line[2:][:diff_side_width].rstrip() : < {half_term_width}}\" + end ) candidate = yellow + f\"{line[2:][:diff_side_width].rstrip()}\" + end elif line[:2] == \"- \": current = red + f\"{line[2:][:diff_side_width].rstrip() : < {half_term_width}}\" + end candidate = \"\" elif line[:2] == \"+ \": current = f\"{'' : < {half_term_width}}\" candidate = green + f\"{line[2:][:diff_side_width].rstrip()}\" + end else: current = f\"{line[2:][:diff_side_width].rstrip() : < {half_term_width}}\" candidate = f\"{line[2:][:diff_side_width].rstrip()}\" side_by_side_diff_lines.append(current + candidate) joined_side_by_side_diff = \"\\n\".join(side_by_side_diff_lines) self._side_by_side_diff = joined_side_by_side_diff return self._side_by_side_diff @property def unified_diff(self) -> str: \"\"\" Generate a unified diff of source vs candidate Args: N/A Returns: str: unified diff text Raises: N/A \"\"\" if self._unified_diff: return self._unified_diff yellow, red, green, end = self._generate_colors() unified_diff = [ yellow + line[2:] + end if line[:2] == \"? \" else red + line[2:] + end if line[:2] == \"- \" else green + line[2:] + end if line[:2] == \"+ \" else line[2:] for line in self._difflines ] joined_unified_diff = \"\".join(unified_diff) self._unified_diff = joined_unified_diff return self._unified_diff Ancestors (in MRO) \u00b6 scrapli_cfg.response.ScrapliCfgResponse Instance variables \u00b6 side_by_side_diff: str 1 2 3 4 5 6 7 8 9 10 Generate a side-by-side diff of source vs candidate Args: N/A Returns: str: unified diff text Raises: N/A unified_diff: str 1 2 3 4 5 6 7 8 9 10 Generate a unified diff of source vs candidate Args: N/A Returns: str: unified diff text Raises: N/A Methods \u00b6 record_diff_response \u00b6 record_diff_response(self, source_config: str, candidate_config: str, device_diff: str) \u2011> None 1 2 3 4 5 6 7 8 9 10 11 12 Scrapli config diff object Args: source_config: the actual contents of the source config candidate_config: the scrapli_cfg candidate config device_diff: diff generated by the device itself (if applicable) Returns: N/A Raises: N/A","title":"Diff"},{"location":"api_docs/diff/#module-scrapli_cfgdiff","text":"scrapli_cfg.diff Expand source code \"\"\"scrapli_cfg.diff\"\"\" import difflib import shutil from typing import List, Tuple from scrapli_cfg.exceptions import DiffConfigError from scrapli_cfg.response import ScrapliCfgResponse GREEN = \"\\033[92m\" RED = \"\\033[91m\" YELLOW = \"\\033[93m\" END_COLOR = \"\\033[0m\" class ScrapliCfgDiffResponse(ScrapliCfgResponse): def __init__( self, host: str, source: str, colorize: bool = True, side_by_side_diff_width: int = 0 ) -> None: \"\"\" Scrapli config diff object Args: host: host the diff is for source: source config store from the device, typically running|startup colorize: True/False colorize diff output side_by_side_diff_width: width to use to generate the side-by-side diff, if not provided will fetch the current terminal width Returns: N/A Raises: N/A \"\"\" super().__init__(host=host, raise_for_status_exception=DiffConfigError) self.colorize = colorize self.side_by_side_diff_width = side_by_side_diff_width self.source = source self.source_config = \"\" self.candidate_config = \"\" self.device_diff = \"\" self._difflines: List[str] = [] self.additions = \"\" self.subtractions = \"\" self._unified_diff = \"\" self._side_by_side_diff = \"\" def __repr__(self) -> str: \"\"\" Magic repr method for ScrapliCfgResponse class Args: N/A Returns: str: repr for class object Raises: N/A \"\"\" return f\"ScrapliCfgDiffResponse \" def __str__(self) -> str: \"\"\" Magic str method for ScrapliCfgDiffResponse class Args: N/A Returns: str: str for class object Raises: N/A \"\"\" return f\"ScrapliCfgDiffResponse \" def record_diff_response( self, source_config: str, candidate_config: str, device_diff: str ) -> None: \"\"\" Scrapli config diff object Args: source_config: the actual contents of the source config candidate_config: the scrapli_cfg candidate config device_diff: diff generated by the device itself (if applicable) Returns: N/A Raises: N/A \"\"\" self.source_config = source_config self.candidate_config = candidate_config self.device_diff = device_diff _differ = difflib.Differ() self._difflines = list( _differ.compare( self.source_config.splitlines(keepends=True), self.candidate_config.splitlines(keepends=True), ) ) self.additions = \"\".join([line[2:] for line in self._difflines if line[:2] == \"+ \"]) self.subtractions = \"\".join([line[2:] for line in self._difflines if line[:2] == \"- \"]) def _generate_colors(self) -> Tuple[str, str, str, str]: \"\"\" Generate the necessary strings for colorizing or not output Args: N/A Returns: tuple: tuple of strings for colorizing (or not) output Raises: N/A \"\"\" yellow = YELLOW if self.colorize else \"? \" red = RED if self.colorize else \"- \" green = GREEN if self.colorize else \"+ \" end = END_COLOR if self.colorize else \"\" return yellow, red, green, end @property def side_by_side_diff(self) -> str: \"\"\" Generate a side-by-side diff of source vs candidate Args: N/A Returns: str: unified diff text Raises: N/A \"\"\" if self._side_by_side_diff: return self._side_by_side_diff yellow, red, green, end = self._generate_colors() term_width = self.side_by_side_diff_width or shutil.get_terminal_size().columns half_term_width = int(term_width / 2) diff_side_width = int(half_term_width - 5) side_by_side_diff_lines = [] for line in self._difflines: if line[:2] == \"? \": current = ( yellow + f\"{line[2:][:diff_side_width].rstrip() : < {half_term_width}}\" + end ) candidate = yellow + f\"{line[2:][:diff_side_width].rstrip()}\" + end elif line[:2] == \"- \": current = red + f\"{line[2:][:diff_side_width].rstrip() : < {half_term_width}}\" + end candidate = \"\" elif line[:2] == \"+ \": current = f\"{'' : < {half_term_width}}\" candidate = green + f\"{line[2:][:diff_side_width].rstrip()}\" + end else: current = f\"{line[2:][:diff_side_width].rstrip() : < {half_term_width}}\" candidate = f\"{line[2:][:diff_side_width].rstrip()}\" side_by_side_diff_lines.append(current + candidate) joined_side_by_side_diff = \"\\n\".join(side_by_side_diff_lines) self._side_by_side_diff = joined_side_by_side_diff return self._side_by_side_diff @property def unified_diff(self) -> str: \"\"\" Generate a unified diff of source vs candidate Args: N/A Returns: str: unified diff text Raises: N/A \"\"\" if self._unified_diff: return self._unified_diff yellow, red, green, end = self._generate_colors() unified_diff = [ yellow + line[2:] + end if line[:2] == \"? \" else red + line[2:] + end if line[:2] == \"- \" else green + line[2:] + end if line[:2] == \"+ \" else line[2:] for line in self._difflines ] joined_unified_diff = \"\".join(unified_diff) self._unified_diff = joined_unified_diff return self._unified_diff","title":"Module scrapli_cfg.diff"},{"location":"api_docs/diff/#classes","text":"","title":"Classes"},{"location":"api_docs/diff/#scraplicfgdiffresponse","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 Scrapli config diff object Args: host: host the diff is for source: source config store from the device, typically running|startup colorize: True/False colorize diff output side_by_side_diff_width: width to use to generate the side-by-side diff, if not provided will fetch the current terminal width Returns: N/A Raises: N/A Expand source code class ScrapliCfgDiffResponse(ScrapliCfgResponse): def __init__( self, host: str, source: str, colorize: bool = True, side_by_side_diff_width: int = 0 ) -> None: \"\"\" Scrapli config diff object Args: host: host the diff is for source: source config store from the device, typically running|startup colorize: True/False colorize diff output side_by_side_diff_width: width to use to generate the side-by-side diff, if not provided will fetch the current terminal width Returns: N/A Raises: N/A \"\"\" super().__init__(host=host, raise_for_status_exception=DiffConfigError) self.colorize = colorize self.side_by_side_diff_width = side_by_side_diff_width self.source = source self.source_config = \"\" self.candidate_config = \"\" self.device_diff = \"\" self._difflines: List[str] = [] self.additions = \"\" self.subtractions = \"\" self._unified_diff = \"\" self._side_by_side_diff = \"\" def __repr__(self) -> str: \"\"\" Magic repr method for ScrapliCfgResponse class Args: N/A Returns: str: repr for class object Raises: N/A \"\"\" return f\"ScrapliCfgDiffResponse \" def __str__(self) -> str: \"\"\" Magic str method for ScrapliCfgDiffResponse class Args: N/A Returns: str: str for class object Raises: N/A \"\"\" return f\"ScrapliCfgDiffResponse \" def record_diff_response( self, source_config: str, candidate_config: str, device_diff: str ) -> None: \"\"\" Scrapli config diff object Args: source_config: the actual contents of the source config candidate_config: the scrapli_cfg candidate config device_diff: diff generated by the device itself (if applicable) Returns: N/A Raises: N/A \"\"\" self.source_config = source_config self.candidate_config = candidate_config self.device_diff = device_diff _differ = difflib.Differ() self._difflines = list( _differ.compare( self.source_config.splitlines(keepends=True), self.candidate_config.splitlines(keepends=True), ) ) self.additions = \"\".join([line[2:] for line in self._difflines if line[:2] == \"+ \"]) self.subtractions = \"\".join([line[2:] for line in self._difflines if line[:2] == \"- \"]) def _generate_colors(self) -> Tuple[str, str, str, str]: \"\"\" Generate the necessary strings for colorizing or not output Args: N/A Returns: tuple: tuple of strings for colorizing (or not) output Raises: N/A \"\"\" yellow = YELLOW if self.colorize else \"? \" red = RED if self.colorize else \"- \" green = GREEN if self.colorize else \"+ \" end = END_COLOR if self.colorize else \"\" return yellow, red, green, end @property def side_by_side_diff(self) -> str: \"\"\" Generate a side-by-side diff of source vs candidate Args: N/A Returns: str: unified diff text Raises: N/A \"\"\" if self._side_by_side_diff: return self._side_by_side_diff yellow, red, green, end = self._generate_colors() term_width = self.side_by_side_diff_width or shutil.get_terminal_size().columns half_term_width = int(term_width / 2) diff_side_width = int(half_term_width - 5) side_by_side_diff_lines = [] for line in self._difflines: if line[:2] == \"? \": current = ( yellow + f\"{line[2:][:diff_side_width].rstrip() : < {half_term_width}}\" + end ) candidate = yellow + f\"{line[2:][:diff_side_width].rstrip()}\" + end elif line[:2] == \"- \": current = red + f\"{line[2:][:diff_side_width].rstrip() : < {half_term_width}}\" + end candidate = \"\" elif line[:2] == \"+ \": current = f\"{'' : < {half_term_width}}\" candidate = green + f\"{line[2:][:diff_side_width].rstrip()}\" + end else: current = f\"{line[2:][:diff_side_width].rstrip() : < {half_term_width}}\" candidate = f\"{line[2:][:diff_side_width].rstrip()}\" side_by_side_diff_lines.append(current + candidate) joined_side_by_side_diff = \"\\n\".join(side_by_side_diff_lines) self._side_by_side_diff = joined_side_by_side_diff return self._side_by_side_diff @property def unified_diff(self) -> str: \"\"\" Generate a unified diff of source vs candidate Args: N/A Returns: str: unified diff text Raises: N/A \"\"\" if self._unified_diff: return self._unified_diff yellow, red, green, end = self._generate_colors() unified_diff = [ yellow + line[2:] + end if line[:2] == \"? \" else red + line[2:] + end if line[:2] == \"- \" else green + line[2:] + end if line[:2] == \"+ \" else line[2:] for line in self._difflines ] joined_unified_diff = \"\".join(unified_diff) self._unified_diff = joined_unified_diff return self._unified_diff","title":"ScrapliCfgDiffResponse"},{"location":"api_docs/diff/#ancestors-in-mro","text":"scrapli_cfg.response.ScrapliCfgResponse","title":"Ancestors (in MRO)"},{"location":"api_docs/diff/#instance-variables","text":"side_by_side_diff: str 1 2 3 4 5 6 7 8 9 10 Generate a side-by-side diff of source vs candidate Args: N/A Returns: str: unified diff text Raises: N/A unified_diff: str 1 2 3 4 5 6 7 8 9 10 Generate a unified diff of source vs candidate Args: N/A Returns: str: unified diff text Raises: N/A","title":"Instance variables"},{"location":"api_docs/diff/#methods","text":"","title":"Methods"},{"location":"api_docs/diff/#record_diff_response","text":"record_diff_response(self, source_config: str, candidate_config: str, device_diff: str) \u2011> None 1 2 3 4 5 6 7 8 9 10 11 12 Scrapli config diff object Args: source_config: the actual contents of the source config candidate_config: the scrapli_cfg candidate config device_diff: diff generated by the device itself (if applicable) Returns: N/A Raises: N/A","title":"record_diff_response"},{"location":"api_docs/exceptions/","text":"window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting()) Module scrapli_cfg.exceptions \u00b6 scrapli_cfg.exceptions Expand source code \"\"\"scrapli_cfg.exceptions\"\"\" from scrapli.exceptions import ScrapliException class ScrapliCfgException(ScrapliException): \"\"\"Base scrapli_cfg exception\"\"\" class PrepareNotCalled(ScrapliCfgException): \"\"\" Raised when the `prepare` method has not been called This will only be raised in two scenarios: 1) an `on_prepare` callable has been provided, yet `prepare` was not called 2) `ignore_version` is False and `prepare` was not called If using a context manager this should never be raised as the enter method will handle things for you \"\"\" class TemplateError(ScrapliCfgException): \"\"\"For errors relating to configuration templates\"\"\" class FailedToDetermineDeviceState(ScrapliCfgException): \"\"\"For issues determining device state (i.e. what mode is file prompt in, etc.)\"\"\" class VersionError(ScrapliCfgException): \"\"\"For errors related to getting/parsing/invalid versions\"\"\" class ConfigError(ScrapliCfgException): \"\"\"For configuration operation related errors\"\"\" class InvalidConfigTarget(ConfigError): \"\"\"User has provided an invalid configuration target\"\"\" class FailedToFetchSpaceAvailable(ConfigError): \"\"\"Unable to determine space available on filesystem\"\"\" class InsufficientSpaceAvailable(ConfigError): \"\"\"If space available on filesystem is insufficient\"\"\" class GetConfigError(ConfigError): \"\"\"For errors getting configuration from a device\"\"\" class LoadConfigError(ConfigError): \"\"\"For errors loading a configuration\"\"\" class DiffConfigError(ConfigError): \"\"\"For errors diffing a configuration\"\"\" class AbortConfigError(ConfigError): \"\"\"For errors aborting a configuration\"\"\" class CommitConfigError(ConfigError): \"\"\"For errors committing a configuration\"\"\" class CleanupError(ScrapliCfgException): \"\"\"For errors during cleanup (i.e. removing candidate config, etc.)\"\"\" Classes \u00b6 AbortConfigError \u00b6 1 For errors aborting a configuration Expand source code class AbortConfigError(ConfigError): \"\"\"For errors aborting a configuration\"\"\" Ancestors (in MRO) \u00b6 scrapli_cfg.exceptions.ConfigError scrapli_cfg.exceptions.ScrapliCfgException scrapli.exceptions.ScrapliException builtins.Exception builtins.BaseException CleanupError \u00b6 1 For errors during cleanup (i.e. removing candidate config, etc.) Expand source code class CleanupError(ScrapliCfgException): \"\"\"For errors during cleanup (i.e. removing candidate config, etc.)\"\"\" Ancestors (in MRO) \u00b6 scrapli_cfg.exceptions.ScrapliCfgException scrapli.exceptions.ScrapliException builtins.Exception builtins.BaseException CommitConfigError \u00b6 1 For errors committing a configuration Expand source code class CommitConfigError(ConfigError): \"\"\"For errors committing a configuration\"\"\" Ancestors (in MRO) \u00b6 scrapli_cfg.exceptions.ConfigError scrapli_cfg.exceptions.ScrapliCfgException scrapli.exceptions.ScrapliException builtins.Exception builtins.BaseException ConfigError \u00b6 1 For configuration operation related errors Expand source code class ConfigError(ScrapliCfgException): \"\"\"For configuration operation related errors\"\"\" Ancestors (in MRO) \u00b6 scrapli_cfg.exceptions.ScrapliCfgException scrapli.exceptions.ScrapliException builtins.Exception builtins.BaseException Descendants \u00b6 scrapli_cfg.exceptions.AbortConfigError scrapli_cfg.exceptions.CommitConfigError scrapli_cfg.exceptions.DiffConfigError scrapli_cfg.exceptions.FailedToFetchSpaceAvailable scrapli_cfg.exceptions.GetConfigError scrapli_cfg.exceptions.InsufficientSpaceAvailable scrapli_cfg.exceptions.InvalidConfigTarget scrapli_cfg.exceptions.LoadConfigError DiffConfigError \u00b6 1 For errors diffing a configuration Expand source code class DiffConfigError(ConfigError): \"\"\"For errors diffing a configuration\"\"\" Ancestors (in MRO) \u00b6 scrapli_cfg.exceptions.ConfigError scrapli_cfg.exceptions.ScrapliCfgException scrapli.exceptions.ScrapliException builtins.Exception builtins.BaseException FailedToDetermineDeviceState \u00b6 1 For issues determining device state (i.e. what mode is file prompt in, etc.) Expand source code class FailedToDetermineDeviceState(ScrapliCfgException): \"\"\"For issues determining device state (i.e. what mode is file prompt in, etc.)\"\"\" Ancestors (in MRO) \u00b6 scrapli_cfg.exceptions.ScrapliCfgException scrapli.exceptions.ScrapliException builtins.Exception builtins.BaseException FailedToFetchSpaceAvailable \u00b6 1 Unable to determine space available on filesystem Expand source code class FailedToFetchSpaceAvailable(ConfigError): \"\"\"Unable to determine space available on filesystem\"\"\" Ancestors (in MRO) \u00b6 scrapli_cfg.exceptions.ConfigError scrapli_cfg.exceptions.ScrapliCfgException scrapli.exceptions.ScrapliException builtins.Exception builtins.BaseException GetConfigError \u00b6 1 For errors getting configuration from a device Expand source code class GetConfigError(ConfigError): \"\"\"For errors getting configuration from a device\"\"\" Ancestors (in MRO) \u00b6 scrapli_cfg.exceptions.ConfigError scrapli_cfg.exceptions.ScrapliCfgException scrapli.exceptions.ScrapliException builtins.Exception builtins.BaseException InsufficientSpaceAvailable \u00b6 1 If space available on filesystem is insufficient Expand source code class InsufficientSpaceAvailable(ConfigError): \"\"\"If space available on filesystem is insufficient\"\"\" Ancestors (in MRO) \u00b6 scrapli_cfg.exceptions.ConfigError scrapli_cfg.exceptions.ScrapliCfgException scrapli.exceptions.ScrapliException builtins.Exception builtins.BaseException InvalidConfigTarget \u00b6 1 User has provided an invalid configuration target Expand source code class InvalidConfigTarget(ConfigError): \"\"\"User has provided an invalid configuration target\"\"\" Ancestors (in MRO) \u00b6 scrapli_cfg.exceptions.ConfigError scrapli_cfg.exceptions.ScrapliCfgException scrapli.exceptions.ScrapliException builtins.Exception builtins.BaseException LoadConfigError \u00b6 1 For errors loading a configuration Expand source code class LoadConfigError(ConfigError): \"\"\"For errors loading a configuration\"\"\" Ancestors (in MRO) \u00b6 scrapli_cfg.exceptions.ConfigError scrapli_cfg.exceptions.ScrapliCfgException scrapli.exceptions.ScrapliException builtins.Exception builtins.BaseException PrepareNotCalled \u00b6 1 2 3 4 5 6 7 8 Raised when the `prepare` method has not been called This will only be raised in two scenarios: 1) an `on_prepare` callable has been provided, yet `prepare` was not called 2) `ignore_version` is False and `prepare` was not called If using a context manager this should never be raised as the enter method will handle things for you Expand source code class PrepareNotCalled(ScrapliCfgException): \"\"\" Raised when the `prepare` method has not been called This will only be raised in two scenarios: 1) an `on_prepare` callable has been provided, yet `prepare` was not called 2) `ignore_version` is False and `prepare` was not called If using a context manager this should never be raised as the enter method will handle things for you \"\"\" Ancestors (in MRO) \u00b6 scrapli_cfg.exceptions.ScrapliCfgException scrapli.exceptions.ScrapliException builtins.Exception builtins.BaseException ScrapliCfgException \u00b6 1 Base scrapli_cfg exception Expand source code class ScrapliCfgException(ScrapliException): \"\"\"Base scrapli_cfg exception\"\"\" Ancestors (in MRO) \u00b6 scrapli.exceptions.ScrapliException builtins.Exception builtins.BaseException Descendants \u00b6 scrapli_cfg.exceptions.CleanupError scrapli_cfg.exceptions.ConfigError scrapli_cfg.exceptions.FailedToDetermineDeviceState scrapli_cfg.exceptions.PrepareNotCalled scrapli_cfg.exceptions.TemplateError scrapli_cfg.exceptions.VersionError TemplateError \u00b6 1 For errors relating to configuration templates Expand source code class TemplateError(ScrapliCfgException): \"\"\"For errors relating to configuration templates\"\"\" Ancestors (in MRO) \u00b6 scrapli_cfg.exceptions.ScrapliCfgException scrapli.exceptions.ScrapliException builtins.Exception builtins.BaseException VersionError \u00b6 1 For errors related to getting/parsing/invalid versions Expand source code class VersionError(ScrapliCfgException): \"\"\"For errors related to getting/parsing/invalid versions\"\"\" Ancestors (in MRO) \u00b6 scrapli_cfg.exceptions.ScrapliCfgException scrapli.exceptions.ScrapliException builtins.Exception builtins.BaseException","title":"Exceptions"},{"location":"api_docs/exceptions/#module-scrapli_cfgexceptions","text":"scrapli_cfg.exceptions Expand source code \"\"\"scrapli_cfg.exceptions\"\"\" from scrapli.exceptions import ScrapliException class ScrapliCfgException(ScrapliException): \"\"\"Base scrapli_cfg exception\"\"\" class PrepareNotCalled(ScrapliCfgException): \"\"\" Raised when the `prepare` method has not been called This will only be raised in two scenarios: 1) an `on_prepare` callable has been provided, yet `prepare` was not called 2) `ignore_version` is False and `prepare` was not called If using a context manager this should never be raised as the enter method will handle things for you \"\"\" class TemplateError(ScrapliCfgException): \"\"\"For errors relating to configuration templates\"\"\" class FailedToDetermineDeviceState(ScrapliCfgException): \"\"\"For issues determining device state (i.e. what mode is file prompt in, etc.)\"\"\" class VersionError(ScrapliCfgException): \"\"\"For errors related to getting/parsing/invalid versions\"\"\" class ConfigError(ScrapliCfgException): \"\"\"For configuration operation related errors\"\"\" class InvalidConfigTarget(ConfigError): \"\"\"User has provided an invalid configuration target\"\"\" class FailedToFetchSpaceAvailable(ConfigError): \"\"\"Unable to determine space available on filesystem\"\"\" class InsufficientSpaceAvailable(ConfigError): \"\"\"If space available on filesystem is insufficient\"\"\" class GetConfigError(ConfigError): \"\"\"For errors getting configuration from a device\"\"\" class LoadConfigError(ConfigError): \"\"\"For errors loading a configuration\"\"\" class DiffConfigError(ConfigError): \"\"\"For errors diffing a configuration\"\"\" class AbortConfigError(ConfigError): \"\"\"For errors aborting a configuration\"\"\" class CommitConfigError(ConfigError): \"\"\"For errors committing a configuration\"\"\" class CleanupError(ScrapliCfgException): \"\"\"For errors during cleanup (i.e. removing candidate config, etc.)\"\"\"","title":"Module scrapli_cfg.exceptions"},{"location":"api_docs/exceptions/#classes","text":"","title":"Classes"},{"location":"api_docs/exceptions/#abortconfigerror","text":"1 For errors aborting a configuration Expand source code class AbortConfigError(ConfigError): \"\"\"For errors aborting a configuration\"\"\"","title":"AbortConfigError"},{"location":"api_docs/exceptions/#ancestors-in-mro","text":"scrapli_cfg.exceptions.ConfigError scrapli_cfg.exceptions.ScrapliCfgException scrapli.exceptions.ScrapliException builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"api_docs/exceptions/#cleanuperror","text":"1 For errors during cleanup (i.e. removing candidate config, etc.) Expand source code class CleanupError(ScrapliCfgException): \"\"\"For errors during cleanup (i.e. removing candidate config, etc.)\"\"\"","title":"CleanupError"},{"location":"api_docs/exceptions/#ancestors-in-mro_1","text":"scrapli_cfg.exceptions.ScrapliCfgException scrapli.exceptions.ScrapliException builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"api_docs/exceptions/#commitconfigerror","text":"1 For errors committing a configuration Expand source code class CommitConfigError(ConfigError): \"\"\"For errors committing a configuration\"\"\"","title":"CommitConfigError"},{"location":"api_docs/exceptions/#ancestors-in-mro_2","text":"scrapli_cfg.exceptions.ConfigError scrapli_cfg.exceptions.ScrapliCfgException scrapli.exceptions.ScrapliException builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"api_docs/exceptions/#configerror","text":"1 For configuration operation related errors Expand source code class ConfigError(ScrapliCfgException): \"\"\"For configuration operation related errors\"\"\"","title":"ConfigError"},{"location":"api_docs/exceptions/#ancestors-in-mro_3","text":"scrapli_cfg.exceptions.ScrapliCfgException scrapli.exceptions.ScrapliException builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"api_docs/exceptions/#descendants","text":"scrapli_cfg.exceptions.AbortConfigError scrapli_cfg.exceptions.CommitConfigError scrapli_cfg.exceptions.DiffConfigError scrapli_cfg.exceptions.FailedToFetchSpaceAvailable scrapli_cfg.exceptions.GetConfigError scrapli_cfg.exceptions.InsufficientSpaceAvailable scrapli_cfg.exceptions.InvalidConfigTarget scrapli_cfg.exceptions.LoadConfigError","title":"Descendants"},{"location":"api_docs/exceptions/#diffconfigerror","text":"1 For errors diffing a configuration Expand source code class DiffConfigError(ConfigError): \"\"\"For errors diffing a configuration\"\"\"","title":"DiffConfigError"},{"location":"api_docs/exceptions/#ancestors-in-mro_4","text":"scrapli_cfg.exceptions.ConfigError scrapli_cfg.exceptions.ScrapliCfgException scrapli.exceptions.ScrapliException builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"api_docs/exceptions/#failedtodeterminedevicestate","text":"1 For issues determining device state (i.e. what mode is file prompt in, etc.) Expand source code class FailedToDetermineDeviceState(ScrapliCfgException): \"\"\"For issues determining device state (i.e. what mode is file prompt in, etc.)\"\"\"","title":"FailedToDetermineDeviceState"},{"location":"api_docs/exceptions/#ancestors-in-mro_5","text":"scrapli_cfg.exceptions.ScrapliCfgException scrapli.exceptions.ScrapliException builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"api_docs/exceptions/#failedtofetchspaceavailable","text":"1 Unable to determine space available on filesystem Expand source code class FailedToFetchSpaceAvailable(ConfigError): \"\"\"Unable to determine space available on filesystem\"\"\"","title":"FailedToFetchSpaceAvailable"},{"location":"api_docs/exceptions/#ancestors-in-mro_6","text":"scrapli_cfg.exceptions.ConfigError scrapli_cfg.exceptions.ScrapliCfgException scrapli.exceptions.ScrapliException builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"api_docs/exceptions/#getconfigerror","text":"1 For errors getting configuration from a device Expand source code class GetConfigError(ConfigError): \"\"\"For errors getting configuration from a device\"\"\"","title":"GetConfigError"},{"location":"api_docs/exceptions/#ancestors-in-mro_7","text":"scrapli_cfg.exceptions.ConfigError scrapli_cfg.exceptions.ScrapliCfgException scrapli.exceptions.ScrapliException builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"api_docs/exceptions/#insufficientspaceavailable","text":"1 If space available on filesystem is insufficient Expand source code class InsufficientSpaceAvailable(ConfigError): \"\"\"If space available on filesystem is insufficient\"\"\"","title":"InsufficientSpaceAvailable"},{"location":"api_docs/exceptions/#ancestors-in-mro_8","text":"scrapli_cfg.exceptions.ConfigError scrapli_cfg.exceptions.ScrapliCfgException scrapli.exceptions.ScrapliException builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"api_docs/exceptions/#invalidconfigtarget","text":"1 User has provided an invalid configuration target Expand source code class InvalidConfigTarget(ConfigError): \"\"\"User has provided an invalid configuration target\"\"\"","title":"InvalidConfigTarget"},{"location":"api_docs/exceptions/#ancestors-in-mro_9","text":"scrapli_cfg.exceptions.ConfigError scrapli_cfg.exceptions.ScrapliCfgException scrapli.exceptions.ScrapliException builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"api_docs/exceptions/#loadconfigerror","text":"1 For errors loading a configuration Expand source code class LoadConfigError(ConfigError): \"\"\"For errors loading a configuration\"\"\"","title":"LoadConfigError"},{"location":"api_docs/exceptions/#ancestors-in-mro_10","text":"scrapli_cfg.exceptions.ConfigError scrapli_cfg.exceptions.ScrapliCfgException scrapli.exceptions.ScrapliException builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"api_docs/exceptions/#preparenotcalled","text":"1 2 3 4 5 6 7 8 Raised when the `prepare` method has not been called This will only be raised in two scenarios: 1) an `on_prepare` callable has been provided, yet `prepare` was not called 2) `ignore_version` is False and `prepare` was not called If using a context manager this should never be raised as the enter method will handle things for you Expand source code class PrepareNotCalled(ScrapliCfgException): \"\"\" Raised when the `prepare` method has not been called This will only be raised in two scenarios: 1) an `on_prepare` callable has been provided, yet `prepare` was not called 2) `ignore_version` is False and `prepare` was not called If using a context manager this should never be raised as the enter method will handle things for you \"\"\"","title":"PrepareNotCalled"},{"location":"api_docs/exceptions/#ancestors-in-mro_11","text":"scrapli_cfg.exceptions.ScrapliCfgException scrapli.exceptions.ScrapliException builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"api_docs/exceptions/#scraplicfgexception","text":"1 Base scrapli_cfg exception Expand source code class ScrapliCfgException(ScrapliException): \"\"\"Base scrapli_cfg exception\"\"\"","title":"ScrapliCfgException"},{"location":"api_docs/exceptions/#ancestors-in-mro_12","text":"scrapli.exceptions.ScrapliException builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"api_docs/exceptions/#descendants_1","text":"scrapli_cfg.exceptions.CleanupError scrapli_cfg.exceptions.ConfigError scrapli_cfg.exceptions.FailedToDetermineDeviceState scrapli_cfg.exceptions.PrepareNotCalled scrapli_cfg.exceptions.TemplateError scrapli_cfg.exceptions.VersionError","title":"Descendants"},{"location":"api_docs/exceptions/#templateerror","text":"1 For errors relating to configuration templates Expand source code class TemplateError(ScrapliCfgException): \"\"\"For errors relating to configuration templates\"\"\"","title":"TemplateError"},{"location":"api_docs/exceptions/#ancestors-in-mro_13","text":"scrapli_cfg.exceptions.ScrapliCfgException scrapli.exceptions.ScrapliException builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"api_docs/exceptions/#versionerror","text":"1 For errors related to getting/parsing/invalid versions Expand source code class VersionError(ScrapliCfgException): \"\"\"For errors related to getting/parsing/invalid versions\"\"\"","title":"VersionError"},{"location":"api_docs/exceptions/#ancestors-in-mro_14","text":"scrapli_cfg.exceptions.ScrapliCfgException scrapli.exceptions.ScrapliException builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"api_docs/factory/","text":"window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting()) Module scrapli_cfg.factory \u00b6 scrapli_cfg.factory Expand source code \"\"\"scrapli_cfg.factory\"\"\" from typing import TYPE_CHECKING, Any, Callable, List, Optional from scrapli.driver.core import ( AsyncEOSDriver, AsyncIOSXEDriver, AsyncIOSXRDriver, AsyncJunosDriver, AsyncNXOSDriver, EOSDriver, IOSXEDriver, IOSXRDriver, JunosDriver, NXOSDriver, ) from scrapli.driver.network import AsyncNetworkDriver, NetworkDriver from scrapli_cfg.exceptions import ScrapliCfgException from scrapli_cfg.logging import logger from scrapli_cfg.platform.core.arista_eos import AsyncScrapliCfgEOS, ScrapliCfgEOS from scrapli_cfg.platform.core.cisco_iosxe import AsyncScrapliCfgIOSXE, ScrapliCfgIOSXE from scrapli_cfg.platform.core.cisco_iosxr import AsyncScrapliCfgIOSXR, ScrapliCfgIOSXR from scrapli_cfg.platform.core.cisco_nxos import AsyncScrapliCfgNXOS, ScrapliCfgNXOS from scrapli_cfg.platform.core.juniper_junos import AsyncScrapliCfgJunos, ScrapliCfgJunos if TYPE_CHECKING: from scrapli_cfg.platform.base.async_platform import AsyncScrapliCfgPlatform # pragma: no cover from scrapli_cfg.platform.base.sync_platform import ScrapliCfgPlatform # pragma: no cover ASYNC_CORE_PLATFORM_MAP = { AsyncEOSDriver: AsyncScrapliCfgEOS, AsyncIOSXEDriver: AsyncScrapliCfgIOSXE, AsyncIOSXRDriver: AsyncScrapliCfgIOSXR, AsyncNXOSDriver: AsyncScrapliCfgNXOS, AsyncJunosDriver: AsyncScrapliCfgJunos, } SYNC_CORE_PLATFORM_MAP = { EOSDriver: ScrapliCfgEOS, IOSXEDriver: ScrapliCfgIOSXE, IOSXRDriver: ScrapliCfgIOSXR, NXOSDriver: ScrapliCfgNXOS, JunosDriver: ScrapliCfgJunos, } def ScrapliCfg( conn: NetworkDriver, *, config_sources: Optional[List[str]] = None, on_prepare: Optional[Callable[..., Any]] = None, dedicated_connection: bool = False, ignore_version: bool = False, **kwargs: Any, ) -> \"ScrapliCfgPlatform\": \"\"\" Scrapli Config Sync Factory Return a sync scrapli config object for the provided platform. Prefer to use factory classes just so that the naming convention (w/ upper case things) is \"right\", but given that the class version inherited from the base ScrapliCfgPlatform and did not implement the abstract methods this felt like a better move. Args: conn: scrapli connection to use config_sources: list of config sources on_prepare: optional callable to run at connection `prepare` dedicated_connection: if `False` (default value) scrapli cfg will not open or close the underlying scrapli connection and will raise an exception if the scrapli connection is not open. If `True` will automatically open and close the scrapli connection when using with a context manager, `prepare` will open the scrapli connection (if not already open), and `close` will close the scrapli connection. ignore_version: ignore checking device version support; currently this just means that scrapli-cfg will not fetch the device version during the prepare phase, however this will (hopefully) be used in the future to limit what methods can be used against a target device. For example, for EOS devices we need > 4.14 to load configs; so if a device is encountered at 4.13 the version check would raise an exception rather than just failing in a potentially awkward fashion. kwargs: keyword args to pass to the scrapli_cfg object (for things like iosxe 'filesystem' argument) Returns: ScrapliCfg: sync scrapli cfg object Raises: ScrapliCfgException: if provided connection object is async ScrapliCfgException: if provided connection object is sync but is not a supported (\"core\") platform type \"\"\" logger.debug(\"ScrapliCfg factory initialized\") if isinstance(conn, AsyncNetworkDriver): raise ScrapliCfgException( \"provided scrapli connection is sync but using 'AsyncScrapliCfg' -- you must use an \" \"async connection with 'AsyncScrapliCfg'!\" ) platform_class = SYNC_CORE_PLATFORM_MAP.get(type(conn)) if not platform_class: raise ScrapliCfgException( f\"scrapli connection object type '{type(conn)}' not a supported scrapli-cfg type\" ) final_platform: \"ScrapliCfgPlatform\" = platform_class( conn=conn, config_sources=config_sources, on_prepare=on_prepare, dedicated_connection=dedicated_connection, ignore_version=ignore_version, **kwargs, ) return final_platform def AsyncScrapliCfg( conn: AsyncNetworkDriver, *, config_sources: Optional[List[str]] = None, on_prepare: Optional[Callable[..., Any]] = None, dedicated_connection: bool = False, ignore_version: bool = False, **kwargs: Any, ) -> \"AsyncScrapliCfgPlatform\": \"\"\" Scrapli Config Async Factory Return a async scrapli config object for the provided platform. Prefer to use factory classes just so that the naming convention (w/ upper case things) is \"right\", but given that the class version inherited from the base ScrapliCfgPlatform and did not implement the abstract methods this felt like a better move. Args: conn: scrapli connection to use config_sources: list of config sources on_prepare: optional callable to run at connection `prepare` dedicated_connection: if `False` (default value) scrapli cfg will not open or close the underlying scrapli connection and will raise an exception if the scrapli connection is not open. If `True` will automatically open and close the scrapli connection when using with a context manager, `prepare` will open the scrapli connection (if not already open), and `close` will close the scrapli connection. ignore_version: ignore checking device version support; currently this just means that scrapli-cfg will not fetch the device version during the prepare phase, however this will (hopefully) be used in the future to limit what methods can be used against a target device. For example, for EOS devices we need > 4.14 to load configs; so if a device is encountered at 4.13 the version check would raise an exception rather than just failing in a potentially awkward fashion. kwargs: keyword args to pass to the scrapli_cfg object (for things like iosxe 'filesystem' argument) Returns: AsyncScrapliCfg: async scrapli cfg object Raises: ScrapliCfgException: if provided connection object is sync ScrapliCfgException: if provided connection object is async but is not a supported (\"core\") platform type \"\"\" logger.debug(\"AsyncScrapliCfg factory initialized\") if isinstance(conn, NetworkDriver): raise ScrapliCfgException( \"provided scrapli connection is sync but using 'AsyncScrapliCfg' -- you must use an \" \"async connection with 'AsyncScrapliCfg'!\" ) platform_class = ASYNC_CORE_PLATFORM_MAP.get(type(conn)) if not platform_class: raise ScrapliCfgException( f\"scrapli connection object type '{type(conn)}' not a supported scrapli-cfg type\" ) final_platform: \"AsyncScrapliCfgPlatform\" = platform_class( conn=conn, config_sources=config_sources, on_prepare=on_prepare, dedicated_connection=dedicated_connection, ignore_version=ignore_version, **kwargs, ) return final_platform Functions \u00b6 AsyncScrapliCfg \u00b6 AsyncScrapliCfg(conn: scrapli.driver.network.async_driver.AsyncNetworkDriver, *, config_sources: Optional[List[str]] = None, on_prepare: Optional[Callable[..., Any]] = None, dedicated_connection: bool = False, ignore_version: bool = False, **kwargs: Any) \u2011> AsyncScrapliCfgPlatform 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 Scrapli Config Async Factory Return a async scrapli config object for the provided platform. Prefer to use factory classes just so that the naming convention (w/ upper case things) is \"right\", but given that the class version inherited from the base ScrapliCfgPlatform and did not implement the abstract methods this felt like a better move. Args: conn: scrapli connection to use config_sources: list of config sources on_prepare: optional callable to run at connection `prepare` dedicated_connection: if `False` (default value) scrapli cfg will not open or close the underlying scrapli connection and will raise an exception if the scrapli connection is not open. If `True` will automatically open and close the scrapli connection when using with a context manager, `prepare` will open the scrapli connection (if not already open), and `close` will close the scrapli connection. ignore_version: ignore checking device version support; currently this just means that scrapli-cfg will not fetch the device version during the prepare phase, however this will (hopefully) be used in the future to limit what methods can be used against a target device. For example, for EOS devices we need > 4.14 to load configs; so if a device is encountered at 4.13 the version check would raise an exception rather than just failing in a potentially awkward fashion. kwargs: keyword args to pass to the scrapli_cfg object (for things like iosxe 'filesystem' argument) Returns: AsyncScrapliCfg: async scrapli cfg object Raises: ScrapliCfgException: if provided connection object is sync ScrapliCfgException: if provided connection object is async but is not a supported (\"core\") platform type ScrapliCfg \u00b6 ScrapliCfg(conn: scrapli.driver.network.sync_driver.NetworkDriver, *, config_sources: Optional[List[str]] = None, on_prepare: Optional[Callable[..., Any]] = None, dedicated_connection: bool = False, ignore_version: bool = False, **kwargs: Any) \u2011> ScrapliCfgPlatform 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 Scrapli Config Sync Factory Return a sync scrapli config object for the provided platform. Prefer to use factory classes just so that the naming convention (w/ upper case things) is \"right\", but given that the class version inherited from the base ScrapliCfgPlatform and did not implement the abstract methods this felt like a better move. Args: conn: scrapli connection to use config_sources: list of config sources on_prepare: optional callable to run at connection `prepare` dedicated_connection: if `False` (default value) scrapli cfg will not open or close the underlying scrapli connection and will raise an exception if the scrapli connection is not open. If `True` will automatically open and close the scrapli connection when using with a context manager, `prepare` will open the scrapli connection (if not already open), and `close` will close the scrapli connection. ignore_version: ignore checking device version support; currently this just means that scrapli-cfg will not fetch the device version during the prepare phase, however this will (hopefully) be used in the future to limit what methods can be used against a target device. For example, for EOS devices we need > 4.14 to load configs; so if a device is encountered at 4.13 the version check would raise an exception rather than just failing in a potentially awkward fashion. kwargs: keyword args to pass to the scrapli_cfg object (for things like iosxe 'filesystem' argument) Returns: ScrapliCfg: sync scrapli cfg object Raises: ScrapliCfgException: if provided connection object is async ScrapliCfgException: if provided connection object is sync but is not a supported (\"core\") platform type","title":"Factory"},{"location":"api_docs/factory/#module-scrapli_cfgfactory","text":"scrapli_cfg.factory Expand source code \"\"\"scrapli_cfg.factory\"\"\" from typing import TYPE_CHECKING, Any, Callable, List, Optional from scrapli.driver.core import ( AsyncEOSDriver, AsyncIOSXEDriver, AsyncIOSXRDriver, AsyncJunosDriver, AsyncNXOSDriver, EOSDriver, IOSXEDriver, IOSXRDriver, JunosDriver, NXOSDriver, ) from scrapli.driver.network import AsyncNetworkDriver, NetworkDriver from scrapli_cfg.exceptions import ScrapliCfgException from scrapli_cfg.logging import logger from scrapli_cfg.platform.core.arista_eos import AsyncScrapliCfgEOS, ScrapliCfgEOS from scrapli_cfg.platform.core.cisco_iosxe import AsyncScrapliCfgIOSXE, ScrapliCfgIOSXE from scrapli_cfg.platform.core.cisco_iosxr import AsyncScrapliCfgIOSXR, ScrapliCfgIOSXR from scrapli_cfg.platform.core.cisco_nxos import AsyncScrapliCfgNXOS, ScrapliCfgNXOS from scrapli_cfg.platform.core.juniper_junos import AsyncScrapliCfgJunos, ScrapliCfgJunos if TYPE_CHECKING: from scrapli_cfg.platform.base.async_platform import AsyncScrapliCfgPlatform # pragma: no cover from scrapli_cfg.platform.base.sync_platform import ScrapliCfgPlatform # pragma: no cover ASYNC_CORE_PLATFORM_MAP = { AsyncEOSDriver: AsyncScrapliCfgEOS, AsyncIOSXEDriver: AsyncScrapliCfgIOSXE, AsyncIOSXRDriver: AsyncScrapliCfgIOSXR, AsyncNXOSDriver: AsyncScrapliCfgNXOS, AsyncJunosDriver: AsyncScrapliCfgJunos, } SYNC_CORE_PLATFORM_MAP = { EOSDriver: ScrapliCfgEOS, IOSXEDriver: ScrapliCfgIOSXE, IOSXRDriver: ScrapliCfgIOSXR, NXOSDriver: ScrapliCfgNXOS, JunosDriver: ScrapliCfgJunos, } def ScrapliCfg( conn: NetworkDriver, *, config_sources: Optional[List[str]] = None, on_prepare: Optional[Callable[..., Any]] = None, dedicated_connection: bool = False, ignore_version: bool = False, **kwargs: Any, ) -> \"ScrapliCfgPlatform\": \"\"\" Scrapli Config Sync Factory Return a sync scrapli config object for the provided platform. Prefer to use factory classes just so that the naming convention (w/ upper case things) is \"right\", but given that the class version inherited from the base ScrapliCfgPlatform and did not implement the abstract methods this felt like a better move. Args: conn: scrapli connection to use config_sources: list of config sources on_prepare: optional callable to run at connection `prepare` dedicated_connection: if `False` (default value) scrapli cfg will not open or close the underlying scrapli connection and will raise an exception if the scrapli connection is not open. If `True` will automatically open and close the scrapli connection when using with a context manager, `prepare` will open the scrapli connection (if not already open), and `close` will close the scrapli connection. ignore_version: ignore checking device version support; currently this just means that scrapli-cfg will not fetch the device version during the prepare phase, however this will (hopefully) be used in the future to limit what methods can be used against a target device. For example, for EOS devices we need > 4.14 to load configs; so if a device is encountered at 4.13 the version check would raise an exception rather than just failing in a potentially awkward fashion. kwargs: keyword args to pass to the scrapli_cfg object (for things like iosxe 'filesystem' argument) Returns: ScrapliCfg: sync scrapli cfg object Raises: ScrapliCfgException: if provided connection object is async ScrapliCfgException: if provided connection object is sync but is not a supported (\"core\") platform type \"\"\" logger.debug(\"ScrapliCfg factory initialized\") if isinstance(conn, AsyncNetworkDriver): raise ScrapliCfgException( \"provided scrapli connection is sync but using 'AsyncScrapliCfg' -- you must use an \" \"async connection with 'AsyncScrapliCfg'!\" ) platform_class = SYNC_CORE_PLATFORM_MAP.get(type(conn)) if not platform_class: raise ScrapliCfgException( f\"scrapli connection object type '{type(conn)}' not a supported scrapli-cfg type\" ) final_platform: \"ScrapliCfgPlatform\" = platform_class( conn=conn, config_sources=config_sources, on_prepare=on_prepare, dedicated_connection=dedicated_connection, ignore_version=ignore_version, **kwargs, ) return final_platform def AsyncScrapliCfg( conn: AsyncNetworkDriver, *, config_sources: Optional[List[str]] = None, on_prepare: Optional[Callable[..., Any]] = None, dedicated_connection: bool = False, ignore_version: bool = False, **kwargs: Any, ) -> \"AsyncScrapliCfgPlatform\": \"\"\" Scrapli Config Async Factory Return a async scrapli config object for the provided platform. Prefer to use factory classes just so that the naming convention (w/ upper case things) is \"right\", but given that the class version inherited from the base ScrapliCfgPlatform and did not implement the abstract methods this felt like a better move. Args: conn: scrapli connection to use config_sources: list of config sources on_prepare: optional callable to run at connection `prepare` dedicated_connection: if `False` (default value) scrapli cfg will not open or close the underlying scrapli connection and will raise an exception if the scrapli connection is not open. If `True` will automatically open and close the scrapli connection when using with a context manager, `prepare` will open the scrapli connection (if not already open), and `close` will close the scrapli connection. ignore_version: ignore checking device version support; currently this just means that scrapli-cfg will not fetch the device version during the prepare phase, however this will (hopefully) be used in the future to limit what methods can be used against a target device. For example, for EOS devices we need > 4.14 to load configs; so if a device is encountered at 4.13 the version check would raise an exception rather than just failing in a potentially awkward fashion. kwargs: keyword args to pass to the scrapli_cfg object (for things like iosxe 'filesystem' argument) Returns: AsyncScrapliCfg: async scrapli cfg object Raises: ScrapliCfgException: if provided connection object is sync ScrapliCfgException: if provided connection object is async but is not a supported (\"core\") platform type \"\"\" logger.debug(\"AsyncScrapliCfg factory initialized\") if isinstance(conn, NetworkDriver): raise ScrapliCfgException( \"provided scrapli connection is sync but using 'AsyncScrapliCfg' -- you must use an \" \"async connection with 'AsyncScrapliCfg'!\" ) platform_class = ASYNC_CORE_PLATFORM_MAP.get(type(conn)) if not platform_class: raise ScrapliCfgException( f\"scrapli connection object type '{type(conn)}' not a supported scrapli-cfg type\" ) final_platform: \"AsyncScrapliCfgPlatform\" = platform_class( conn=conn, config_sources=config_sources, on_prepare=on_prepare, dedicated_connection=dedicated_connection, ignore_version=ignore_version, **kwargs, ) return final_platform","title":"Module scrapli_cfg.factory"},{"location":"api_docs/factory/#functions","text":"","title":"Functions"},{"location":"api_docs/factory/#asyncscraplicfg","text":"AsyncScrapliCfg(conn: scrapli.driver.network.async_driver.AsyncNetworkDriver, *, config_sources: Optional[List[str]] = None, on_prepare: Optional[Callable[..., Any]] = None, dedicated_connection: bool = False, ignore_version: bool = False, **kwargs: Any) \u2011> AsyncScrapliCfgPlatform 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 Scrapli Config Async Factory Return a async scrapli config object for the provided platform. Prefer to use factory classes just so that the naming convention (w/ upper case things) is \"right\", but given that the class version inherited from the base ScrapliCfgPlatform and did not implement the abstract methods this felt like a better move. Args: conn: scrapli connection to use config_sources: list of config sources on_prepare: optional callable to run at connection `prepare` dedicated_connection: if `False` (default value) scrapli cfg will not open or close the underlying scrapli connection and will raise an exception if the scrapli connection is not open. If `True` will automatically open and close the scrapli connection when using with a context manager, `prepare` will open the scrapli connection (if not already open), and `close` will close the scrapli connection. ignore_version: ignore checking device version support; currently this just means that scrapli-cfg will not fetch the device version during the prepare phase, however this will (hopefully) be used in the future to limit what methods can be used against a target device. For example, for EOS devices we need > 4.14 to load configs; so if a device is encountered at 4.13 the version check would raise an exception rather than just failing in a potentially awkward fashion. kwargs: keyword args to pass to the scrapli_cfg object (for things like iosxe 'filesystem' argument) Returns: AsyncScrapliCfg: async scrapli cfg object Raises: ScrapliCfgException: if provided connection object is sync ScrapliCfgException: if provided connection object is async but is not a supported (\"core\") platform type","title":"AsyncScrapliCfg"},{"location":"api_docs/factory/#scraplicfg","text":"ScrapliCfg(conn: scrapli.driver.network.sync_driver.NetworkDriver, *, config_sources: Optional[List[str]] = None, on_prepare: Optional[Callable[..., Any]] = None, dedicated_connection: bool = False, ignore_version: bool = False, **kwargs: Any) \u2011> ScrapliCfgPlatform 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 Scrapli Config Sync Factory Return a sync scrapli config object for the provided platform. Prefer to use factory classes just so that the naming convention (w/ upper case things) is \"right\", but given that the class version inherited from the base ScrapliCfgPlatform and did not implement the abstract methods this felt like a better move. Args: conn: scrapli connection to use config_sources: list of config sources on_prepare: optional callable to run at connection `prepare` dedicated_connection: if `False` (default value) scrapli cfg will not open or close the underlying scrapli connection and will raise an exception if the scrapli connection is not open. If `True` will automatically open and close the scrapli connection when using with a context manager, `prepare` will open the scrapli connection (if not already open), and `close` will close the scrapli connection. ignore_version: ignore checking device version support; currently this just means that scrapli-cfg will not fetch the device version during the prepare phase, however this will (hopefully) be used in the future to limit what methods can be used against a target device. For example, for EOS devices we need > 4.14 to load configs; so if a device is encountered at 4.13 the version check would raise an exception rather than just failing in a potentially awkward fashion. kwargs: keyword args to pass to the scrapli_cfg object (for things like iosxe 'filesystem' argument) Returns: ScrapliCfg: sync scrapli cfg object Raises: ScrapliCfgException: if provided connection object is async ScrapliCfgException: if provided connection object is sync but is not a supported (\"core\") platform type","title":"ScrapliCfg"},{"location":"api_docs/logging/","text":"window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting()) Module scrapli_cfg.logging \u00b6 scrapli_cfg.logging Expand source code \"\"\"scrapli_cfg.logging\"\"\" from logging import FileHandler, NullHandler, getLogger from typing import Union from scrapli.logging import ScrapliFileHandler, ScrapliFormatter def enable_basic_logging( file: Union[str, bool] = False, level: str = \"info\", caller_info: bool = False, buffer_log: bool = True, ) -> None: \"\"\" Enable opinionated logging for scrapli_cfg Uses scrapli \"core\" formatter/file handler Args: file: True to output to default log path (\"scrapli.log\"), otherwise string path to write log file to level: string name of logging level to use, i.e. \"info\", \"debug\", etc. caller_info: add info about module/function/line in the log entry buffer_log: buffer log read outputs Returns: None Raises: N/A \"\"\" logger.propagate = False logger.setLevel(level=level.upper()) scrapli_formatter = ScrapliFormatter(caller_info=caller_info) if file: if isinstance(file, bool): filename = \"scrapli_cfg.log\" else: filename = file if not buffer_log: fh = FileHandler(filename=filename, mode=\"w\") else: fh = ScrapliFileHandler(filename=filename, mode=\"w\") fh.setFormatter(scrapli_formatter) logger.addHandler(fh) logger = getLogger(\"scrapli_cfg\") logger.addHandler(NullHandler()) Functions \u00b6 enable_basic_logging \u00b6 enable_basic_logging(file: Union[str, bool] = False, level: str = 'info', caller_info: bool = False, buffer_log: bool = True) \u2011> None 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 Enable opinionated logging for scrapli_cfg Uses scrapli \"core\" formatter/file handler Args: file: True to output to default log path (\"scrapli.log\"), otherwise string path to write log file to level: string name of logging level to use, i.e. \"info\", \"debug\", etc. caller_info: add info about module/function/line in the log entry buffer_log: buffer log read outputs Returns: None Raises: N/A","title":"Logging"},{"location":"api_docs/logging/#module-scrapli_cfglogging","text":"scrapli_cfg.logging Expand source code \"\"\"scrapli_cfg.logging\"\"\" from logging import FileHandler, NullHandler, getLogger from typing import Union from scrapli.logging import ScrapliFileHandler, ScrapliFormatter def enable_basic_logging( file: Union[str, bool] = False, level: str = \"info\", caller_info: bool = False, buffer_log: bool = True, ) -> None: \"\"\" Enable opinionated logging for scrapli_cfg Uses scrapli \"core\" formatter/file handler Args: file: True to output to default log path (\"scrapli.log\"), otherwise string path to write log file to level: string name of logging level to use, i.e. \"info\", \"debug\", etc. caller_info: add info about module/function/line in the log entry buffer_log: buffer log read outputs Returns: None Raises: N/A \"\"\" logger.propagate = False logger.setLevel(level=level.upper()) scrapli_formatter = ScrapliFormatter(caller_info=caller_info) if file: if isinstance(file, bool): filename = \"scrapli_cfg.log\" else: filename = file if not buffer_log: fh = FileHandler(filename=filename, mode=\"w\") else: fh = ScrapliFileHandler(filename=filename, mode=\"w\") fh.setFormatter(scrapli_formatter) logger.addHandler(fh) logger = getLogger(\"scrapli_cfg\") logger.addHandler(NullHandler())","title":"Module scrapli_cfg.logging"},{"location":"api_docs/logging/#functions","text":"","title":"Functions"},{"location":"api_docs/logging/#enable_basic_logging","text":"enable_basic_logging(file: Union[str, bool] = False, level: str = 'info', caller_info: bool = False, buffer_log: bool = True) \u2011> None 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 Enable opinionated logging for scrapli_cfg Uses scrapli \"core\" formatter/file handler Args: file: True to output to default log path (\"scrapli.log\"), otherwise string path to write log file to level: string name of logging level to use, i.e. \"info\", \"debug\", etc. caller_info: add info about module/function/line in the log entry buffer_log: buffer log read outputs Returns: None Raises: N/A","title":"enable_basic_logging"},{"location":"api_docs/response/","text":"window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting()) Module scrapli_cfg.response \u00b6 scrapli_cfg.response Expand source code \"\"\"scrapli_cfg.response\"\"\" from datetime import datetime from typing import Iterable, List, Optional, Type, Union from scrapli.response import MultiResponse, Response from scrapli_cfg.exceptions import ScrapliCfgException class ScrapliCfgResponse: def __init__( self, host: str, raise_for_status_exception: Type[Exception] = ScrapliCfgException ) -> None: \"\"\" Scrapli CFG Response object Args: host: host that was operated on raise_for_status_exception: exception to raise if response is failed and user calls `raise_for_status` Returns: N/A Raises: N/A \"\"\" self.host = host self.start_time = datetime.now() self.finish_time: Optional[datetime] = None self.elapsed_time: Optional[float] = None # scrapli_responses is a \"flattened\" list of responses from all operations that were # performed; meaning that if we used any plural operations like send_commands we'll flatten # the MultiResponse bits into a list of singular response objects and store them here self.scrapli_responses: List[Response] = [] self.result: str = \"\" self.raise_for_status_exception = raise_for_status_exception self.failed = True def __bool__(self) -> bool: \"\"\" Magic bool method based on operation being failed or not Args: N/A Returns: bool: True/False if channel_input failed Raises: N/A \"\"\" return self.failed def __repr__(self) -> str: \"\"\" Magic repr method for ScrapliCfgResponse class Args: N/A Returns: str: repr for class object Raises: N/A \"\"\" return f\"ScrapliCfgResponse \" def __str__(self) -> str: \"\"\" Magic str method for ScrapliCfgResponse class Args: N/A Returns: str: str for class object Raises: N/A \"\"\" return f\"ScrapliCfgResponse \" def record_response( self, scrapli_responses: Iterable[Union[Response, MultiResponse]], result: str = \"\" ) -> None: \"\"\" Record channel_input results and elapsed time of channel input/reading output Args: scrapli_responses: list of scrapli response/multiresponse objects result: string to assign to final result for the scrapli cfg response object Returns: None Raises: N/A \"\"\" self.finish_time = datetime.now() self.elapsed_time = (self.finish_time - self.start_time).total_seconds() for response in scrapli_responses: if isinstance(response, Response): self.scrapli_responses.append(response) elif isinstance(response, MultiResponse): for sub_response in response: self.scrapli_responses.append(sub_response) self.result = result if not any(response.failed for response in self.scrapli_responses): self.failed = False def raise_for_status(self) -> None: \"\"\" Raise a `ScrapliCommandFailure` if command/config failed Args: N/A Returns: None Raises: raise_for_status_exception: exception raised is dependent on the type of response object \"\"\" if self.failed: raise self.raise_for_status_exception() Classes \u00b6 ScrapliCfgResponse \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 Scrapli CFG Response object Args: host: host that was operated on raise_for_status_exception: exception to raise if response is failed and user calls `raise_for_status` Returns: N/A Raises: N/A Expand source code class ScrapliCfgResponse: def __init__( self, host: str, raise_for_status_exception: Type[Exception] = ScrapliCfgException ) -> None: \"\"\" Scrapli CFG Response object Args: host: host that was operated on raise_for_status_exception: exception to raise if response is failed and user calls `raise_for_status` Returns: N/A Raises: N/A \"\"\" self.host = host self.start_time = datetime.now() self.finish_time: Optional[datetime] = None self.elapsed_time: Optional[float] = None # scrapli_responses is a \"flattened\" list of responses from all operations that were # performed; meaning that if we used any plural operations like send_commands we'll flatten # the MultiResponse bits into a list of singular response objects and store them here self.scrapli_responses: List[Response] = [] self.result: str = \"\" self.raise_for_status_exception = raise_for_status_exception self.failed = True def __bool__(self) -> bool: \"\"\" Magic bool method based on operation being failed or not Args: N/A Returns: bool: True/False if channel_input failed Raises: N/A \"\"\" return self.failed def __repr__(self) -> str: \"\"\" Magic repr method for ScrapliCfgResponse class Args: N/A Returns: str: repr for class object Raises: N/A \"\"\" return f\"ScrapliCfgResponse \" def __str__(self) -> str: \"\"\" Magic str method for ScrapliCfgResponse class Args: N/A Returns: str: str for class object Raises: N/A \"\"\" return f\"ScrapliCfgResponse \" def record_response( self, scrapli_responses: Iterable[Union[Response, MultiResponse]], result: str = \"\" ) -> None: \"\"\" Record channel_input results and elapsed time of channel input/reading output Args: scrapli_responses: list of scrapli response/multiresponse objects result: string to assign to final result for the scrapli cfg response object Returns: None Raises: N/A \"\"\" self.finish_time = datetime.now() self.elapsed_time = (self.finish_time - self.start_time).total_seconds() for response in scrapli_responses: if isinstance(response, Response): self.scrapli_responses.append(response) elif isinstance(response, MultiResponse): for sub_response in response: self.scrapli_responses.append(sub_response) self.result = result if not any(response.failed for response in self.scrapli_responses): self.failed = False def raise_for_status(self) -> None: \"\"\" Raise a `ScrapliCommandFailure` if command/config failed Args: N/A Returns: None Raises: raise_for_status_exception: exception raised is dependent on the type of response object \"\"\" if self.failed: raise self.raise_for_status_exception() Descendants \u00b6 scrapli_cfg.diff.ScrapliCfgDiffResponse Methods \u00b6 raise_for_status \u00b6 raise_for_status(self) \u2011> None 1 2 3 4 5 6 7 8 9 10 Raise a `ScrapliCommandFailure` if command/config failed Args: N/A Returns: None Raises: raise_for_status_exception: exception raised is dependent on the type of response object record_response \u00b6 record_response(self, scrapli_responses: Iterable[Union[scrapli.response.Response, scrapli.response.MultiResponse]], result: str = '') \u2011> None 1 2 3 4 5 6 7 8 9 10 11 Record channel_input results and elapsed time of channel input/reading output Args: scrapli_responses: list of scrapli response/multiresponse objects result: string to assign to final result for the scrapli cfg response object Returns: None Raises: N/A","title":"Response"},{"location":"api_docs/response/#module-scrapli_cfgresponse","text":"scrapli_cfg.response Expand source code \"\"\"scrapli_cfg.response\"\"\" from datetime import datetime from typing import Iterable, List, Optional, Type, Union from scrapli.response import MultiResponse, Response from scrapli_cfg.exceptions import ScrapliCfgException class ScrapliCfgResponse: def __init__( self, host: str, raise_for_status_exception: Type[Exception] = ScrapliCfgException ) -> None: \"\"\" Scrapli CFG Response object Args: host: host that was operated on raise_for_status_exception: exception to raise if response is failed and user calls `raise_for_status` Returns: N/A Raises: N/A \"\"\" self.host = host self.start_time = datetime.now() self.finish_time: Optional[datetime] = None self.elapsed_time: Optional[float] = None # scrapli_responses is a \"flattened\" list of responses from all operations that were # performed; meaning that if we used any plural operations like send_commands we'll flatten # the MultiResponse bits into a list of singular response objects and store them here self.scrapli_responses: List[Response] = [] self.result: str = \"\" self.raise_for_status_exception = raise_for_status_exception self.failed = True def __bool__(self) -> bool: \"\"\" Magic bool method based on operation being failed or not Args: N/A Returns: bool: True/False if channel_input failed Raises: N/A \"\"\" return self.failed def __repr__(self) -> str: \"\"\" Magic repr method for ScrapliCfgResponse class Args: N/A Returns: str: repr for class object Raises: N/A \"\"\" return f\"ScrapliCfgResponse \" def __str__(self) -> str: \"\"\" Magic str method for ScrapliCfgResponse class Args: N/A Returns: str: str for class object Raises: N/A \"\"\" return f\"ScrapliCfgResponse \" def record_response( self, scrapli_responses: Iterable[Union[Response, MultiResponse]], result: str = \"\" ) -> None: \"\"\" Record channel_input results and elapsed time of channel input/reading output Args: scrapli_responses: list of scrapli response/multiresponse objects result: string to assign to final result for the scrapli cfg response object Returns: None Raises: N/A \"\"\" self.finish_time = datetime.now() self.elapsed_time = (self.finish_time - self.start_time).total_seconds() for response in scrapli_responses: if isinstance(response, Response): self.scrapli_responses.append(response) elif isinstance(response, MultiResponse): for sub_response in response: self.scrapli_responses.append(sub_response) self.result = result if not any(response.failed for response in self.scrapli_responses): self.failed = False def raise_for_status(self) -> None: \"\"\" Raise a `ScrapliCommandFailure` if command/config failed Args: N/A Returns: None Raises: raise_for_status_exception: exception raised is dependent on the type of response object \"\"\" if self.failed: raise self.raise_for_status_exception()","title":"Module scrapli_cfg.response"},{"location":"api_docs/response/#classes","text":"","title":"Classes"},{"location":"api_docs/response/#scraplicfgresponse","text":"1 2 3 4 5 6 7 8 9 10 11 12 Scrapli CFG Response object Args: host: host that was operated on raise_for_status_exception: exception to raise if response is failed and user calls `raise_for_status` Returns: N/A Raises: N/A Expand source code class ScrapliCfgResponse: def __init__( self, host: str, raise_for_status_exception: Type[Exception] = ScrapliCfgException ) -> None: \"\"\" Scrapli CFG Response object Args: host: host that was operated on raise_for_status_exception: exception to raise if response is failed and user calls `raise_for_status` Returns: N/A Raises: N/A \"\"\" self.host = host self.start_time = datetime.now() self.finish_time: Optional[datetime] = None self.elapsed_time: Optional[float] = None # scrapli_responses is a \"flattened\" list of responses from all operations that were # performed; meaning that if we used any plural operations like send_commands we'll flatten # the MultiResponse bits into a list of singular response objects and store them here self.scrapli_responses: List[Response] = [] self.result: str = \"\" self.raise_for_status_exception = raise_for_status_exception self.failed = True def __bool__(self) -> bool: \"\"\" Magic bool method based on operation being failed or not Args: N/A Returns: bool: True/False if channel_input failed Raises: N/A \"\"\" return self.failed def __repr__(self) -> str: \"\"\" Magic repr method for ScrapliCfgResponse class Args: N/A Returns: str: repr for class object Raises: N/A \"\"\" return f\"ScrapliCfgResponse \" def __str__(self) -> str: \"\"\" Magic str method for ScrapliCfgResponse class Args: N/A Returns: str: str for class object Raises: N/A \"\"\" return f\"ScrapliCfgResponse \" def record_response( self, scrapli_responses: Iterable[Union[Response, MultiResponse]], result: str = \"\" ) -> None: \"\"\" Record channel_input results and elapsed time of channel input/reading output Args: scrapli_responses: list of scrapli response/multiresponse objects result: string to assign to final result for the scrapli cfg response object Returns: None Raises: N/A \"\"\" self.finish_time = datetime.now() self.elapsed_time = (self.finish_time - self.start_time).total_seconds() for response in scrapli_responses: if isinstance(response, Response): self.scrapli_responses.append(response) elif isinstance(response, MultiResponse): for sub_response in response: self.scrapli_responses.append(sub_response) self.result = result if not any(response.failed for response in self.scrapli_responses): self.failed = False def raise_for_status(self) -> None: \"\"\" Raise a `ScrapliCommandFailure` if command/config failed Args: N/A Returns: None Raises: raise_for_status_exception: exception raised is dependent on the type of response object \"\"\" if self.failed: raise self.raise_for_status_exception()","title":"ScrapliCfgResponse"},{"location":"api_docs/response/#descendants","text":"scrapli_cfg.diff.ScrapliCfgDiffResponse","title":"Descendants"},{"location":"api_docs/response/#methods","text":"","title":"Methods"},{"location":"api_docs/response/#raise_for_status","text":"raise_for_status(self) \u2011> None 1 2 3 4 5 6 7 8 9 10 Raise a `ScrapliCommandFailure` if command/config failed Args: N/A Returns: None Raises: raise_for_status_exception: exception raised is dependent on the type of response object","title":"raise_for_status"},{"location":"api_docs/response/#record_response","text":"record_response(self, scrapli_responses: Iterable[Union[scrapli.response.Response, scrapli.response.MultiResponse]], result: str = '') \u2011> None 1 2 3 4 5 6 7 8 9 10 11 Record channel_input results and elapsed time of channel input/reading output Args: scrapli_responses: list of scrapli response/multiresponse objects result: string to assign to final result for the scrapli cfg response object Returns: None Raises: N/A","title":"record_response"},{"location":"api_docs/platform/base/async_platform/","text":"window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting()) Module scrapli_cfg.platform.base.async_platform \u00b6 scrapli_cfg.platform.async_platform Expand source code \"\"\"scrapli_cfg.platform.async_platform\"\"\" from abc import ABC, abstractmethod from types import TracebackType from typing import Any, Callable, List, Optional, Pattern, Tuple, Type from scrapli.driver import AsyncNetworkDriver from scrapli_cfg.diff import ScrapliCfgDiffResponse from scrapli_cfg.exceptions import ScrapliCfgException from scrapli_cfg.platform.base.base_platform import ScrapliCfgBase from scrapli_cfg.response import ScrapliCfgResponse class AsyncScrapliCfgPlatform(ABC, ScrapliCfgBase): def __init__( self, conn: AsyncNetworkDriver, config_sources: List[str], on_prepare: Optional[Callable[..., Any]], dedicated_connection: bool, ignore_version: bool, ) -> None: \"\"\" Scrapli Config async base class Args: conn: scrapli connection to use config_sources: list of config sources on_prepare: optional callable to run at connection `prepare` dedicated_connection: if `False` (default value) scrapli cfg will not open or close the underlying scrapli connection and will raise an exception if the scrapli connection is not open. If `True` will automatically open and close the scrapli connection when using with a context manager, `prepare` will open the scrapli connection (if not already open), and `close` will close the scrapli connection. ignore_version: ignore checking device version support; currently this just means that scrapli-cfg will not fetch the device version during the prepare phase, however this will (hopefully) be used in the future to limit what methods can be used against a target device. For example, for EOS devices we need > 4.14 to load configs; so if a device is encountered at 4.13 the version check would raise an exception rather than just failing in a potentially awkward fashion. Returns: None Raises: N/A \"\"\" self.conn: AsyncNetworkDriver = conn self.dedicated_connection = dedicated_connection self.on_prepare = on_prepare super().__init__(config_sources=config_sources, ignore_version=ignore_version) async def __aenter__(self) -> \"AsyncScrapliCfgPlatform\": \"\"\" Enter method for async context manager Args: N/A Returns: AsyncScrapliCfg: opened AsyncScrapliCfg object Raises: N/A \"\"\" await self.prepare() return self async def __aexit__( self, exception_type: Optional[Type[BaseException]], exception_value: Optional[BaseException], traceback: Optional[TracebackType], ) -> None: \"\"\" Exit method to cleanup for async context manager Args: exception_type: exception type being raised exception_value: message from exception being raised traceback: traceback from exception being raised Returns: None Raises: N/A \"\"\" await self.cleanup() async def _open(self) -> None: \"\"\" Handle opening (or raising exception if not open) of underlying scrapli connection Args: N/A Returns: None Raises: ScrapliCfgException: if scrapli connection is not open and auto_open_connection is False \"\"\" if self.conn.isalive(): return if self.dedicated_connection: self.logger.info( \"underlying scrapli connection is not alive... opening scrapli connection\" ) await self.conn.open() return raise ScrapliCfgException( \"underlying scrapli connection is not open and `dedicated_connection` is False, \" \"cannot continue!\" ) async def _close(self) -> None: \"\"\" Close the scrapli connection Args: N/A Returns: None Raises: N/A \"\"\" if self.dedicated_connection is True and self.conn.isalive(): self.logger.info(\"dedicated_connection is True, closing scrapli connection\") await self.conn.close() async def prepare(self) -> None: \"\"\" Prepare connection for scrapli_cfg operations Args: N/A Returns: None Raises: N/A \"\"\" self.logger.info(\"preparing scrapli_cfg connection\") await self._open() if self.ignore_version is False: self.logger.debug(\"ignore_version is False, fetching device version\") version_response = await self.get_version() self._validate_and_set_version(version_response=version_response) if self.on_prepare is not None: self.logger.debug(\"on_prepare provided, executing now\") await self.on_prepare(self) self._prepared = True async def cleanup(self) -> None: \"\"\" Cleanup after scrapli-cfg operations Generally this can be skipped, however it will be executed if using a context manager. The purpose of this method is to close the underlying scrapli connection (if in \"dedicated_connection\" mode), and to reset the internally used `_version_string`, attribute. All this is done so that this cfg connection, if re-used later (as in later in that script using the same object) starts with a fresh slate. Args: N/A Returns: None Raises: N/A \"\"\" await self._close() # reset the version string/prepare flag so we know we need to re-fetch/re-run if user # re-opens connection self._version_string = \"\" self._prepared = False # this has *probably* been reset already, but reset it just in case user re-opens connection # we can have a clean slate to work with try: self._reset_config_session() # type: ignore except AttributeError: pass @abstractmethod async def get_version(self) -> ScrapliCfgResponse: \"\"\" Get device version string Args: N/A Returns: ScrapliCfgResponse: response object where result is the string of the primary version (as in the \"main\" os version) of the device Raises: N/A \"\"\" @abstractmethod async def get_config(self, source: str = \"running\") -> ScrapliCfgResponse: \"\"\" Get device configuration Args: source: name of the config source, generally running|startup Returns: ScrapliCfgResponse: response object containing string of the target config source as the `result` attribute Raises: N/A \"\"\" @abstractmethod async def load_config( self, config: str, replace: bool = False, **kwargs: Any ) -> ScrapliCfgResponse: \"\"\" Load configuration to a device Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see your specific platform for details Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" @abstractmethod async def abort_config(self) -> ScrapliCfgResponse: \"\"\" Abort a configuration -- discards any loaded config Args: N/A Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" @abstractmethod async def commit_config(self, source: str = \"running\") -> ScrapliCfgResponse: \"\"\" Commit a loaded configuration Args: source: name of the config source to commit against, generally running|startup Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" @abstractmethod async def diff_config(self, source: str = \"running\") -> ScrapliCfgDiffResponse: \"\"\" Diff a loaded configuration against the source config store Args: source: name of the config source to diff against, generally running|startup -- device diffs will generally not care about this argument, but the built in scrapli differ will Returns: ScrapliCfgDiffResponse: scrapli cfg diff object Raises: N/A \"\"\" async def render_substituted_config( self, config_template: str, substitutes: List[Tuple[str, Pattern[str]]], source: str = \"running\", ) -> str: \"\"\" Render a substituted configuration file Renders a configuration based on a user template, substitutes, and a target config from the device. Args: config_template: config file to use as the base for substitutions -- should contain jinja2-like variables that will be replaced with data fetched from the source config by the substitutes patterns substitutes: tuple of name, pattern -- where name matches the jinja2-like variable in the config_template file, and pattern is a compiled regular expression pattern to be used to fetch that section from the source config source: config source to use for the substitution efforts, typically running|startup Returns: str: substituted/rendered config Raises: N/A \"\"\" self.logger.info(\"fetching configuration and replacing with provided substitutes\") source_config = await self.get_config(source=source) return self._render_substituted_config( config_template=config_template, substitutes=substitutes, source_config=source_config.result, ) Classes \u00b6 AsyncScrapliCfgPlatform \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 Helper class that provides a standard way to create an ABC using inheritance. Scrapli Config async base class Args: conn: scrapli connection to use config_sources: list of config sources on_prepare: optional callable to run at connection `prepare` dedicated_connection: if `False` (default value) scrapli cfg will not open or close the underlying scrapli connection and will raise an exception if the scrapli connection is not open. If `True` will automatically open and close the scrapli connection when using with a context manager, `prepare` will open the scrapli connection (if not already open), and `close` will close the scrapli connection. ignore_version: ignore checking device version support; currently this just means that scrapli-cfg will not fetch the device version during the prepare phase, however this will (hopefully) be used in the future to limit what methods can be used against a target device. For example, for EOS devices we need > 4.14 to load configs; so if a device is encountered at 4.13 the version check would raise an exception rather than just failing in a potentially awkward fashion. Returns: None Raises: N/A Expand source code class AsyncScrapliCfgPlatform(ABC, ScrapliCfgBase): def __init__( self, conn: AsyncNetworkDriver, config_sources: List[str], on_prepare: Optional[Callable[..., Any]], dedicated_connection: bool, ignore_version: bool, ) -> None: \"\"\" Scrapli Config async base class Args: conn: scrapli connection to use config_sources: list of config sources on_prepare: optional callable to run at connection `prepare` dedicated_connection: if `False` (default value) scrapli cfg will not open or close the underlying scrapli connection and will raise an exception if the scrapli connection is not open. If `True` will automatically open and close the scrapli connection when using with a context manager, `prepare` will open the scrapli connection (if not already open), and `close` will close the scrapli connection. ignore_version: ignore checking device version support; currently this just means that scrapli-cfg will not fetch the device version during the prepare phase, however this will (hopefully) be used in the future to limit what methods can be used against a target device. For example, for EOS devices we need > 4.14 to load configs; so if a device is encountered at 4.13 the version check would raise an exception rather than just failing in a potentially awkward fashion. Returns: None Raises: N/A \"\"\" self.conn: AsyncNetworkDriver = conn self.dedicated_connection = dedicated_connection self.on_prepare = on_prepare super().__init__(config_sources=config_sources, ignore_version=ignore_version) async def __aenter__(self) -> \"AsyncScrapliCfgPlatform\": \"\"\" Enter method for async context manager Args: N/A Returns: AsyncScrapliCfg: opened AsyncScrapliCfg object Raises: N/A \"\"\" await self.prepare() return self async def __aexit__( self, exception_type: Optional[Type[BaseException]], exception_value: Optional[BaseException], traceback: Optional[TracebackType], ) -> None: \"\"\" Exit method to cleanup for async context manager Args: exception_type: exception type being raised exception_value: message from exception being raised traceback: traceback from exception being raised Returns: None Raises: N/A \"\"\" await self.cleanup() async def _open(self) -> None: \"\"\" Handle opening (or raising exception if not open) of underlying scrapli connection Args: N/A Returns: None Raises: ScrapliCfgException: if scrapli connection is not open and auto_open_connection is False \"\"\" if self.conn.isalive(): return if self.dedicated_connection: self.logger.info( \"underlying scrapli connection is not alive... opening scrapli connection\" ) await self.conn.open() return raise ScrapliCfgException( \"underlying scrapli connection is not open and `dedicated_connection` is False, \" \"cannot continue!\" ) async def _close(self) -> None: \"\"\" Close the scrapli connection Args: N/A Returns: None Raises: N/A \"\"\" if self.dedicated_connection is True and self.conn.isalive(): self.logger.info(\"dedicated_connection is True, closing scrapli connection\") await self.conn.close() async def prepare(self) -> None: \"\"\" Prepare connection for scrapli_cfg operations Args: N/A Returns: None Raises: N/A \"\"\" self.logger.info(\"preparing scrapli_cfg connection\") await self._open() if self.ignore_version is False: self.logger.debug(\"ignore_version is False, fetching device version\") version_response = await self.get_version() self._validate_and_set_version(version_response=version_response) if self.on_prepare is not None: self.logger.debug(\"on_prepare provided, executing now\") await self.on_prepare(self) self._prepared = True async def cleanup(self) -> None: \"\"\" Cleanup after scrapli-cfg operations Generally this can be skipped, however it will be executed if using a context manager. The purpose of this method is to close the underlying scrapli connection (if in \"dedicated_connection\" mode), and to reset the internally used `_version_string`, attribute. All this is done so that this cfg connection, if re-used later (as in later in that script using the same object) starts with a fresh slate. Args: N/A Returns: None Raises: N/A \"\"\" await self._close() # reset the version string/prepare flag so we know we need to re-fetch/re-run if user # re-opens connection self._version_string = \"\" self._prepared = False # this has *probably* been reset already, but reset it just in case user re-opens connection # we can have a clean slate to work with try: self._reset_config_session() # type: ignore except AttributeError: pass @abstractmethod async def get_version(self) -> ScrapliCfgResponse: \"\"\" Get device version string Args: N/A Returns: ScrapliCfgResponse: response object where result is the string of the primary version (as in the \"main\" os version) of the device Raises: N/A \"\"\" @abstractmethod async def get_config(self, source: str = \"running\") -> ScrapliCfgResponse: \"\"\" Get device configuration Args: source: name of the config source, generally running|startup Returns: ScrapliCfgResponse: response object containing string of the target config source as the `result` attribute Raises: N/A \"\"\" @abstractmethod async def load_config( self, config: str, replace: bool = False, **kwargs: Any ) -> ScrapliCfgResponse: \"\"\" Load configuration to a device Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see your specific platform for details Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" @abstractmethod async def abort_config(self) -> ScrapliCfgResponse: \"\"\" Abort a configuration -- discards any loaded config Args: N/A Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" @abstractmethod async def commit_config(self, source: str = \"running\") -> ScrapliCfgResponse: \"\"\" Commit a loaded configuration Args: source: name of the config source to commit against, generally running|startup Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" @abstractmethod async def diff_config(self, source: str = \"running\") -> ScrapliCfgDiffResponse: \"\"\" Diff a loaded configuration against the source config store Args: source: name of the config source to diff against, generally running|startup -- device diffs will generally not care about this argument, but the built in scrapli differ will Returns: ScrapliCfgDiffResponse: scrapli cfg diff object Raises: N/A \"\"\" async def render_substituted_config( self, config_template: str, substitutes: List[Tuple[str, Pattern[str]]], source: str = \"running\", ) -> str: \"\"\" Render a substituted configuration file Renders a configuration based on a user template, substitutes, and a target config from the device. Args: config_template: config file to use as the base for substitutions -- should contain jinja2-like variables that will be replaced with data fetched from the source config by the substitutes patterns substitutes: tuple of name, pattern -- where name matches the jinja2-like variable in the config_template file, and pattern is a compiled regular expression pattern to be used to fetch that section from the source config source: config source to use for the substitution efforts, typically running|startup Returns: str: substituted/rendered config Raises: N/A \"\"\" self.logger.info(\"fetching configuration and replacing with provided substitutes\") source_config = await self.get_config(source=source) return self._render_substituted_config( config_template=config_template, substitutes=substitutes, source_config=source_config.result, ) Ancestors (in MRO) \u00b6 abc.ABC scrapli_cfg.platform.base.base_platform.ScrapliCfgBase Descendants \u00b6 scrapli_cfg.platform.core.arista_eos.async_platform.AsyncScrapliCfgEOS scrapli_cfg.platform.core.cisco_iosxe.async_platform.AsyncScrapliCfgIOSXE scrapli_cfg.platform.core.cisco_iosxr.async_platform.AsyncScrapliCfgIOSXR scrapli_cfg.platform.core.cisco_nxos.async_platform.AsyncScrapliCfgNXOS scrapli_cfg.platform.core.juniper_junos.async_platform.AsyncScrapliCfgJunos Class variables \u00b6 conn: Union[scrapli.driver.network.sync_driver.NetworkDriver, scrapli.driver.network.async_driver.AsyncNetworkDriver] Methods \u00b6 abort_config \u00b6 abort_config(self) \u2011> scrapli_cfg.response.ScrapliCfgResponse 1 2 3 4 5 6 7 8 9 10 Abort a configuration -- discards any loaded config Args: N/A Returns: ScrapliCfgResponse: response object Raises: N/A cleanup \u00b6 cleanup(self) \u2011> None 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 Cleanup after scrapli-cfg operations Generally this can be skipped, however it will be executed if using a context manager. The purpose of this method is to close the underlying scrapli connection (if in \"dedicated_connection\" mode), and to reset the internally used `_version_string`, attribute. All this is done so that this cfg connection, if re-used later (as in later in that script using the same object) starts with a fresh slate. Args: N/A Returns: None Raises: N/A commit_config \u00b6 commit_config(self, source: str = 'running') \u2011> scrapli_cfg.response.ScrapliCfgResponse 1 2 3 4 5 6 7 8 9 10 Commit a loaded configuration Args: source: name of the config source to commit against, generally running|startup Returns: ScrapliCfgResponse: response object Raises: N/A diff_config \u00b6 diff_config(self, source: str = 'running') \u2011> scrapli_cfg.diff.ScrapliCfgDiffResponse 1 2 3 4 5 6 7 8 9 10 11 12 Diff a loaded configuration against the source config store Args: source: name of the config source to diff against, generally running|startup -- device diffs will generally not care about this argument, but the built in scrapli differ will Returns: ScrapliCfgDiffResponse: scrapli cfg diff object Raises: N/A get_config \u00b6 get_config(self, source: str = 'running') \u2011> scrapli_cfg.response.ScrapliCfgResponse 1 2 3 4 5 6 7 8 9 10 11 Get device configuration Args: source: name of the config source, generally running|startup Returns: ScrapliCfgResponse: response object containing string of the target config source as the `result` attribute Raises: N/A get_version \u00b6 get_version(self) \u2011> scrapli_cfg.response.ScrapliCfgResponse 1 2 3 4 5 6 7 8 9 10 11 Get device version string Args: N/A Returns: ScrapliCfgResponse: response object where result is the string of the primary version (as in the \"main\" os version) of the device Raises: N/A load_config \u00b6 load_config(self, config: str, replace: bool = False, **kwargs: Any) \u2011> scrapli_cfg.response.ScrapliCfgResponse 1 2 3 4 5 6 7 8 9 10 11 12 13 14 Load configuration to a device Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see your specific platform for details Returns: ScrapliCfgResponse: response object Raises: N/A prepare \u00b6 prepare(self) \u2011> None 1 2 3 4 5 6 7 8 9 10 Prepare connection for scrapli_cfg operations Args: N/A Returns: None Raises: N/A render_substituted_config \u00b6 render_substituted_config(self, config_template: str, substitutes: List[Tuple[str, Pattern[str]]], source: str = 'running') \u2011> str 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 Render a substituted configuration file Renders a configuration based on a user template, substitutes, and a target config from the device. Args: config_template: config file to use as the base for substitutions -- should contain jinja2-like variables that will be replaced with data fetched from the source config by the substitutes patterns substitutes: tuple of name, pattern -- where name matches the jinja2-like variable in the config_template file, and pattern is a compiled regular expression pattern to be used to fetch that section from the source config source: config source to use for the substitution efforts, typically running|startup Returns: str: substituted/rendered config Raises: N/A","title":"Async Platform"},{"location":"api_docs/platform/base/async_platform/#module-scrapli_cfgplatformbaseasync_platform","text":"scrapli_cfg.platform.async_platform Expand source code \"\"\"scrapli_cfg.platform.async_platform\"\"\" from abc import ABC, abstractmethod from types import TracebackType from typing import Any, Callable, List, Optional, Pattern, Tuple, Type from scrapli.driver import AsyncNetworkDriver from scrapli_cfg.diff import ScrapliCfgDiffResponse from scrapli_cfg.exceptions import ScrapliCfgException from scrapli_cfg.platform.base.base_platform import ScrapliCfgBase from scrapli_cfg.response import ScrapliCfgResponse class AsyncScrapliCfgPlatform(ABC, ScrapliCfgBase): def __init__( self, conn: AsyncNetworkDriver, config_sources: List[str], on_prepare: Optional[Callable[..., Any]], dedicated_connection: bool, ignore_version: bool, ) -> None: \"\"\" Scrapli Config async base class Args: conn: scrapli connection to use config_sources: list of config sources on_prepare: optional callable to run at connection `prepare` dedicated_connection: if `False` (default value) scrapli cfg will not open or close the underlying scrapli connection and will raise an exception if the scrapli connection is not open. If `True` will automatically open and close the scrapli connection when using with a context manager, `prepare` will open the scrapli connection (if not already open), and `close` will close the scrapli connection. ignore_version: ignore checking device version support; currently this just means that scrapli-cfg will not fetch the device version during the prepare phase, however this will (hopefully) be used in the future to limit what methods can be used against a target device. For example, for EOS devices we need > 4.14 to load configs; so if a device is encountered at 4.13 the version check would raise an exception rather than just failing in a potentially awkward fashion. Returns: None Raises: N/A \"\"\" self.conn: AsyncNetworkDriver = conn self.dedicated_connection = dedicated_connection self.on_prepare = on_prepare super().__init__(config_sources=config_sources, ignore_version=ignore_version) async def __aenter__(self) -> \"AsyncScrapliCfgPlatform\": \"\"\" Enter method for async context manager Args: N/A Returns: AsyncScrapliCfg: opened AsyncScrapliCfg object Raises: N/A \"\"\" await self.prepare() return self async def __aexit__( self, exception_type: Optional[Type[BaseException]], exception_value: Optional[BaseException], traceback: Optional[TracebackType], ) -> None: \"\"\" Exit method to cleanup for async context manager Args: exception_type: exception type being raised exception_value: message from exception being raised traceback: traceback from exception being raised Returns: None Raises: N/A \"\"\" await self.cleanup() async def _open(self) -> None: \"\"\" Handle opening (or raising exception if not open) of underlying scrapli connection Args: N/A Returns: None Raises: ScrapliCfgException: if scrapli connection is not open and auto_open_connection is False \"\"\" if self.conn.isalive(): return if self.dedicated_connection: self.logger.info( \"underlying scrapli connection is not alive... opening scrapli connection\" ) await self.conn.open() return raise ScrapliCfgException( \"underlying scrapli connection is not open and `dedicated_connection` is False, \" \"cannot continue!\" ) async def _close(self) -> None: \"\"\" Close the scrapli connection Args: N/A Returns: None Raises: N/A \"\"\" if self.dedicated_connection is True and self.conn.isalive(): self.logger.info(\"dedicated_connection is True, closing scrapli connection\") await self.conn.close() async def prepare(self) -> None: \"\"\" Prepare connection for scrapli_cfg operations Args: N/A Returns: None Raises: N/A \"\"\" self.logger.info(\"preparing scrapli_cfg connection\") await self._open() if self.ignore_version is False: self.logger.debug(\"ignore_version is False, fetching device version\") version_response = await self.get_version() self._validate_and_set_version(version_response=version_response) if self.on_prepare is not None: self.logger.debug(\"on_prepare provided, executing now\") await self.on_prepare(self) self._prepared = True async def cleanup(self) -> None: \"\"\" Cleanup after scrapli-cfg operations Generally this can be skipped, however it will be executed if using a context manager. The purpose of this method is to close the underlying scrapli connection (if in \"dedicated_connection\" mode), and to reset the internally used `_version_string`, attribute. All this is done so that this cfg connection, if re-used later (as in later in that script using the same object) starts with a fresh slate. Args: N/A Returns: None Raises: N/A \"\"\" await self._close() # reset the version string/prepare flag so we know we need to re-fetch/re-run if user # re-opens connection self._version_string = \"\" self._prepared = False # this has *probably* been reset already, but reset it just in case user re-opens connection # we can have a clean slate to work with try: self._reset_config_session() # type: ignore except AttributeError: pass @abstractmethod async def get_version(self) -> ScrapliCfgResponse: \"\"\" Get device version string Args: N/A Returns: ScrapliCfgResponse: response object where result is the string of the primary version (as in the \"main\" os version) of the device Raises: N/A \"\"\" @abstractmethod async def get_config(self, source: str = \"running\") -> ScrapliCfgResponse: \"\"\" Get device configuration Args: source: name of the config source, generally running|startup Returns: ScrapliCfgResponse: response object containing string of the target config source as the `result` attribute Raises: N/A \"\"\" @abstractmethod async def load_config( self, config: str, replace: bool = False, **kwargs: Any ) -> ScrapliCfgResponse: \"\"\" Load configuration to a device Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see your specific platform for details Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" @abstractmethod async def abort_config(self) -> ScrapliCfgResponse: \"\"\" Abort a configuration -- discards any loaded config Args: N/A Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" @abstractmethod async def commit_config(self, source: str = \"running\") -> ScrapliCfgResponse: \"\"\" Commit a loaded configuration Args: source: name of the config source to commit against, generally running|startup Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" @abstractmethod async def diff_config(self, source: str = \"running\") -> ScrapliCfgDiffResponse: \"\"\" Diff a loaded configuration against the source config store Args: source: name of the config source to diff against, generally running|startup -- device diffs will generally not care about this argument, but the built in scrapli differ will Returns: ScrapliCfgDiffResponse: scrapli cfg diff object Raises: N/A \"\"\" async def render_substituted_config( self, config_template: str, substitutes: List[Tuple[str, Pattern[str]]], source: str = \"running\", ) -> str: \"\"\" Render a substituted configuration file Renders a configuration based on a user template, substitutes, and a target config from the device. Args: config_template: config file to use as the base for substitutions -- should contain jinja2-like variables that will be replaced with data fetched from the source config by the substitutes patterns substitutes: tuple of name, pattern -- where name matches the jinja2-like variable in the config_template file, and pattern is a compiled regular expression pattern to be used to fetch that section from the source config source: config source to use for the substitution efforts, typically running|startup Returns: str: substituted/rendered config Raises: N/A \"\"\" self.logger.info(\"fetching configuration and replacing with provided substitutes\") source_config = await self.get_config(source=source) return self._render_substituted_config( config_template=config_template, substitutes=substitutes, source_config=source_config.result, )","title":"Module scrapli_cfg.platform.base.async_platform"},{"location":"api_docs/platform/base/async_platform/#classes","text":"","title":"Classes"},{"location":"api_docs/platform/base/async_platform/#asyncscraplicfgplatform","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 Helper class that provides a standard way to create an ABC using inheritance. Scrapli Config async base class Args: conn: scrapli connection to use config_sources: list of config sources on_prepare: optional callable to run at connection `prepare` dedicated_connection: if `False` (default value) scrapli cfg will not open or close the underlying scrapli connection and will raise an exception if the scrapli connection is not open. If `True` will automatically open and close the scrapli connection when using with a context manager, `prepare` will open the scrapli connection (if not already open), and `close` will close the scrapli connection. ignore_version: ignore checking device version support; currently this just means that scrapli-cfg will not fetch the device version during the prepare phase, however this will (hopefully) be used in the future to limit what methods can be used against a target device. For example, for EOS devices we need > 4.14 to load configs; so if a device is encountered at 4.13 the version check would raise an exception rather than just failing in a potentially awkward fashion. Returns: None Raises: N/A Expand source code class AsyncScrapliCfgPlatform(ABC, ScrapliCfgBase): def __init__( self, conn: AsyncNetworkDriver, config_sources: List[str], on_prepare: Optional[Callable[..., Any]], dedicated_connection: bool, ignore_version: bool, ) -> None: \"\"\" Scrapli Config async base class Args: conn: scrapli connection to use config_sources: list of config sources on_prepare: optional callable to run at connection `prepare` dedicated_connection: if `False` (default value) scrapli cfg will not open or close the underlying scrapli connection and will raise an exception if the scrapli connection is not open. If `True` will automatically open and close the scrapli connection when using with a context manager, `prepare` will open the scrapli connection (if not already open), and `close` will close the scrapli connection. ignore_version: ignore checking device version support; currently this just means that scrapli-cfg will not fetch the device version during the prepare phase, however this will (hopefully) be used in the future to limit what methods can be used against a target device. For example, for EOS devices we need > 4.14 to load configs; so if a device is encountered at 4.13 the version check would raise an exception rather than just failing in a potentially awkward fashion. Returns: None Raises: N/A \"\"\" self.conn: AsyncNetworkDriver = conn self.dedicated_connection = dedicated_connection self.on_prepare = on_prepare super().__init__(config_sources=config_sources, ignore_version=ignore_version) async def __aenter__(self) -> \"AsyncScrapliCfgPlatform\": \"\"\" Enter method for async context manager Args: N/A Returns: AsyncScrapliCfg: opened AsyncScrapliCfg object Raises: N/A \"\"\" await self.prepare() return self async def __aexit__( self, exception_type: Optional[Type[BaseException]], exception_value: Optional[BaseException], traceback: Optional[TracebackType], ) -> None: \"\"\" Exit method to cleanup for async context manager Args: exception_type: exception type being raised exception_value: message from exception being raised traceback: traceback from exception being raised Returns: None Raises: N/A \"\"\" await self.cleanup() async def _open(self) -> None: \"\"\" Handle opening (or raising exception if not open) of underlying scrapli connection Args: N/A Returns: None Raises: ScrapliCfgException: if scrapli connection is not open and auto_open_connection is False \"\"\" if self.conn.isalive(): return if self.dedicated_connection: self.logger.info( \"underlying scrapli connection is not alive... opening scrapli connection\" ) await self.conn.open() return raise ScrapliCfgException( \"underlying scrapli connection is not open and `dedicated_connection` is False, \" \"cannot continue!\" ) async def _close(self) -> None: \"\"\" Close the scrapli connection Args: N/A Returns: None Raises: N/A \"\"\" if self.dedicated_connection is True and self.conn.isalive(): self.logger.info(\"dedicated_connection is True, closing scrapli connection\") await self.conn.close() async def prepare(self) -> None: \"\"\" Prepare connection for scrapli_cfg operations Args: N/A Returns: None Raises: N/A \"\"\" self.logger.info(\"preparing scrapli_cfg connection\") await self._open() if self.ignore_version is False: self.logger.debug(\"ignore_version is False, fetching device version\") version_response = await self.get_version() self._validate_and_set_version(version_response=version_response) if self.on_prepare is not None: self.logger.debug(\"on_prepare provided, executing now\") await self.on_prepare(self) self._prepared = True async def cleanup(self) -> None: \"\"\" Cleanup after scrapli-cfg operations Generally this can be skipped, however it will be executed if using a context manager. The purpose of this method is to close the underlying scrapli connection (if in \"dedicated_connection\" mode), and to reset the internally used `_version_string`, attribute. All this is done so that this cfg connection, if re-used later (as in later in that script using the same object) starts with a fresh slate. Args: N/A Returns: None Raises: N/A \"\"\" await self._close() # reset the version string/prepare flag so we know we need to re-fetch/re-run if user # re-opens connection self._version_string = \"\" self._prepared = False # this has *probably* been reset already, but reset it just in case user re-opens connection # we can have a clean slate to work with try: self._reset_config_session() # type: ignore except AttributeError: pass @abstractmethod async def get_version(self) -> ScrapliCfgResponse: \"\"\" Get device version string Args: N/A Returns: ScrapliCfgResponse: response object where result is the string of the primary version (as in the \"main\" os version) of the device Raises: N/A \"\"\" @abstractmethod async def get_config(self, source: str = \"running\") -> ScrapliCfgResponse: \"\"\" Get device configuration Args: source: name of the config source, generally running|startup Returns: ScrapliCfgResponse: response object containing string of the target config source as the `result` attribute Raises: N/A \"\"\" @abstractmethod async def load_config( self, config: str, replace: bool = False, **kwargs: Any ) -> ScrapliCfgResponse: \"\"\" Load configuration to a device Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see your specific platform for details Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" @abstractmethod async def abort_config(self) -> ScrapliCfgResponse: \"\"\" Abort a configuration -- discards any loaded config Args: N/A Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" @abstractmethod async def commit_config(self, source: str = \"running\") -> ScrapliCfgResponse: \"\"\" Commit a loaded configuration Args: source: name of the config source to commit against, generally running|startup Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" @abstractmethod async def diff_config(self, source: str = \"running\") -> ScrapliCfgDiffResponse: \"\"\" Diff a loaded configuration against the source config store Args: source: name of the config source to diff against, generally running|startup -- device diffs will generally not care about this argument, but the built in scrapli differ will Returns: ScrapliCfgDiffResponse: scrapli cfg diff object Raises: N/A \"\"\" async def render_substituted_config( self, config_template: str, substitutes: List[Tuple[str, Pattern[str]]], source: str = \"running\", ) -> str: \"\"\" Render a substituted configuration file Renders a configuration based on a user template, substitutes, and a target config from the device. Args: config_template: config file to use as the base for substitutions -- should contain jinja2-like variables that will be replaced with data fetched from the source config by the substitutes patterns substitutes: tuple of name, pattern -- where name matches the jinja2-like variable in the config_template file, and pattern is a compiled regular expression pattern to be used to fetch that section from the source config source: config source to use for the substitution efforts, typically running|startup Returns: str: substituted/rendered config Raises: N/A \"\"\" self.logger.info(\"fetching configuration and replacing with provided substitutes\") source_config = await self.get_config(source=source) return self._render_substituted_config( config_template=config_template, substitutes=substitutes, source_config=source_config.result, )","title":"AsyncScrapliCfgPlatform"},{"location":"api_docs/platform/base/async_platform/#ancestors-in-mro","text":"abc.ABC scrapli_cfg.platform.base.base_platform.ScrapliCfgBase","title":"Ancestors (in MRO)"},{"location":"api_docs/platform/base/async_platform/#descendants","text":"scrapli_cfg.platform.core.arista_eos.async_platform.AsyncScrapliCfgEOS scrapli_cfg.platform.core.cisco_iosxe.async_platform.AsyncScrapliCfgIOSXE scrapli_cfg.platform.core.cisco_iosxr.async_platform.AsyncScrapliCfgIOSXR scrapli_cfg.platform.core.cisco_nxos.async_platform.AsyncScrapliCfgNXOS scrapli_cfg.platform.core.juniper_junos.async_platform.AsyncScrapliCfgJunos","title":"Descendants"},{"location":"api_docs/platform/base/async_platform/#class-variables","text":"conn: Union[scrapli.driver.network.sync_driver.NetworkDriver, scrapli.driver.network.async_driver.AsyncNetworkDriver]","title":"Class variables"},{"location":"api_docs/platform/base/async_platform/#methods","text":"","title":"Methods"},{"location":"api_docs/platform/base/async_platform/#abort_config","text":"abort_config(self) \u2011> scrapli_cfg.response.ScrapliCfgResponse 1 2 3 4 5 6 7 8 9 10 Abort a configuration -- discards any loaded config Args: N/A Returns: ScrapliCfgResponse: response object Raises: N/A","title":"abort_config"},{"location":"api_docs/platform/base/async_platform/#cleanup","text":"cleanup(self) \u2011> None 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 Cleanup after scrapli-cfg operations Generally this can be skipped, however it will be executed if using a context manager. The purpose of this method is to close the underlying scrapli connection (if in \"dedicated_connection\" mode), and to reset the internally used `_version_string`, attribute. All this is done so that this cfg connection, if re-used later (as in later in that script using the same object) starts with a fresh slate. Args: N/A Returns: None Raises: N/A","title":"cleanup"},{"location":"api_docs/platform/base/async_platform/#commit_config","text":"commit_config(self, source: str = 'running') \u2011> scrapli_cfg.response.ScrapliCfgResponse 1 2 3 4 5 6 7 8 9 10 Commit a loaded configuration Args: source: name of the config source to commit against, generally running|startup Returns: ScrapliCfgResponse: response object Raises: N/A","title":"commit_config"},{"location":"api_docs/platform/base/async_platform/#diff_config","text":"diff_config(self, source: str = 'running') \u2011> scrapli_cfg.diff.ScrapliCfgDiffResponse 1 2 3 4 5 6 7 8 9 10 11 12 Diff a loaded configuration against the source config store Args: source: name of the config source to diff against, generally running|startup -- device diffs will generally not care about this argument, but the built in scrapli differ will Returns: ScrapliCfgDiffResponse: scrapli cfg diff object Raises: N/A","title":"diff_config"},{"location":"api_docs/platform/base/async_platform/#get_config","text":"get_config(self, source: str = 'running') \u2011> scrapli_cfg.response.ScrapliCfgResponse 1 2 3 4 5 6 7 8 9 10 11 Get device configuration Args: source: name of the config source, generally running|startup Returns: ScrapliCfgResponse: response object containing string of the target config source as the `result` attribute Raises: N/A","title":"get_config"},{"location":"api_docs/platform/base/async_platform/#get_version","text":"get_version(self) \u2011> scrapli_cfg.response.ScrapliCfgResponse 1 2 3 4 5 6 7 8 9 10 11 Get device version string Args: N/A Returns: ScrapliCfgResponse: response object where result is the string of the primary version (as in the \"main\" os version) of the device Raises: N/A","title":"get_version"},{"location":"api_docs/platform/base/async_platform/#load_config","text":"load_config(self, config: str, replace: bool = False, **kwargs: Any) \u2011> scrapli_cfg.response.ScrapliCfgResponse 1 2 3 4 5 6 7 8 9 10 11 12 13 14 Load configuration to a device Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see your specific platform for details Returns: ScrapliCfgResponse: response object Raises: N/A","title":"load_config"},{"location":"api_docs/platform/base/async_platform/#prepare","text":"prepare(self) \u2011> None 1 2 3 4 5 6 7 8 9 10 Prepare connection for scrapli_cfg operations Args: N/A Returns: None Raises: N/A","title":"prepare"},{"location":"api_docs/platform/base/async_platform/#render_substituted_config","text":"render_substituted_config(self, config_template: str, substitutes: List[Tuple[str, Pattern[str]]], source: str = 'running') \u2011> str 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 Render a substituted configuration file Renders a configuration based on a user template, substitutes, and a target config from the device. Args: config_template: config file to use as the base for substitutions -- should contain jinja2-like variables that will be replaced with data fetched from the source config by the substitutes patterns substitutes: tuple of name, pattern -- where name matches the jinja2-like variable in the config_template file, and pattern is a compiled regular expression pattern to be used to fetch that section from the source config source: config source to use for the substitution efforts, typically running|startup Returns: str: substituted/rendered config Raises: N/A","title":"render_substituted_config"},{"location":"api_docs/platform/base/base_platform/","text":"window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting()) Module scrapli_cfg.platform.base.base_platform \u00b6 scrapli_cfg.platforms.base_platform Expand source code \"\"\"scrapli_cfg.platforms.base_platform\"\"\" import re from typing import List, Pattern, Tuple, Union from scrapli.driver import AsyncNetworkDriver, NetworkDriver from scrapli.logging import get_instance_logger from scrapli.response import MultiResponse, Response from scrapli_cfg.diff import ScrapliCfgDiffResponse from scrapli_cfg.exceptions import ( AbortConfigError, CommitConfigError, DiffConfigError, GetConfigError, InvalidConfigTarget, LoadConfigError, PrepareNotCalled, TemplateError, VersionError, ) from scrapli_cfg.response import ScrapliCfgResponse class ScrapliCfgBase: conn: Union[NetworkDriver, AsyncNetworkDriver] def __init__(self, config_sources: List[str], ignore_version: bool = False) -> None: \"\"\" Base class for all CFG platforms Args: config_sources: list of allowed config sources ignore_version: ignore platform version check or not Returns: None Raises: N/A \"\"\" self.logger = get_instance_logger( instance_name=\"scrapli_cfg.platform\", host=self.conn.host, port=self.conn.port ) self.config_sources = config_sources self.candidate_config = \"\" self.ignore_version = ignore_version self._get_version_command = \"\" self._version_string = \"\" # bool indicated if a `on_prepare` callable has been executed or not self._prepared = False def _render_substituted_config( self, config_template: str, substitutes: List[Tuple[str, Pattern[str]]], source_config: str ) -> str: \"\"\" Render a substituted configuration file Renders a configuration based on a user template, substitutes, and a target config from the device. Args: config_template: config file to use as the base for substitutions -- should contain jinja2-like variables that will be replaced with data fetched from the source config by the substitutes patterns substitutes: tuple of name, pattern -- where name matches the jinja2-like variable in the config_template file, and pattern is a compiled regular expression pattern to be used to fetch that section from the source config source_config: current source config to use in substitution process Returns: None Raises: TemplateError: if no substitute sections are provided TemplateError: if one or more of the substitute sections is missing in the template TemplateError: if a substitute pattern is not found in the config template \"\"\" self.logger.debug(\"rendering substituted config\") if not substitutes: msg = \"no substitutes provided...\" self.logger.critical(msg) raise TemplateError(msg) if not all(f\"{{{{ {name} }}}}\" in config_template for name, _ in substitutes): msg = \"missing one or more of the provided substitutions from the config template\" self.logger.critical(msg) raise TemplateError(msg) replace_sections = [ (name, re.search(pattern=pattern, string=source_config)) for name, pattern in substitutes ] rendered_config = \"\" for name, replace_section in replace_sections: if not replace_section: msg = ( f\"substitution pattern {name} was unable to find a match in the target config\" \" source\" ) self.logger.critical(msg) raise TemplateError(msg) replace_group = replace_section.group() rendered_config = config_template.replace(f\"{{{{ {name} }}}}\", replace_group) # remove any totally empty lines (from bad regex, or just device spitting out lines w/ # nothing on it rendered_config = \"\\n\".join(line for line in rendered_config.splitlines() if line) self.logger.debug(\"rendering substituted config complete\") return rendered_config def _validate_and_set_version(self, version_response: ScrapliCfgResponse) -> None: \"\"\" Ensure version was fetched successfully and set internal version attribute Args: version_response: scrapli cfg response from get version operation Returns: None Raises: VersionError: if fetching version failed or failed to parse version \"\"\" if version_response.failed: msg = \"failed getting version from device\" self.logger.critical(msg) raise VersionError(msg) if not version_response.result: msg = \"failed parsing version string from device output\" self.logger.critical(msg) raise VersionError(msg) self._version_string = version_response.result def _prepare_ok(self) -> None: \"\"\" Determine if prepare is \"OK\" for a given operation Checks if an `on_prepare` callable has been provided, and if so, if it has been executed. This is meant to help force users into calling `prepare` or using the context manager prior to running any methods. Args: N/A Returns: None Raises: PrepareNotCalled: if `on_prepare` is not None and `_prepared` is False \"\"\" # ignoring type/complaints as `on_prepare` will always be set in the sync/async classes; # but is not set here since in one its a coroutine and the other not _on_prepare = self.on_prepare # type: ignore # noqa if _on_prepare is not None and self._prepared is False: raise PrepareNotCalled( \"on_prepare callable provided, but prepare method not called. call prepare method \" \"or use context manager to ensure it is called for you\" ) def _version_ok(self) -> None: \"\"\" Determine if version is \"OK\" for a given operation Should be overridden and super'd to by platforms that implement version constraints, will simply check that if `ignore_version` is `False` we have set the internal `_version_string` attribute, if not, will raise `PrepareNotCalled` exception. Args: N/A Returns: None Raises: PrepareNotCalled: if ignore version is False and _version_string not set \"\"\" if self.ignore_version is False and not self._version_string: raise PrepareNotCalled( \"ignore_version is False, but version has not yet been fetched. call prepare method\" \" or use context manager to ensure that version is properly gathered\" ) def _operation_ok(self) -> None: \"\"\" Determine if all values are \"OK\" for a given operation Checks if version and prepare are ok. Convenience func to just have one thing to call in the `_pre` operation methods. Args: N/A Returns: None Raises: N/A \"\"\" self._prepare_ok() self._version_ok() def _pre_get_version(self) -> ScrapliCfgResponse: \"\"\" Handle pre \"get_version\" operations for parity between sync and async Args: N/A Returns: ScrapliCfgResponse: new response object to update w/ get results Raises: N/A \"\"\" self.logger.info(\"get_version requested\") response = ScrapliCfgResponse(host=self.conn.host, raise_for_status_exception=VersionError) return response def _post_get_version( self, response: ScrapliCfgResponse, scrapli_responses: List[Response], result: str, ) -> ScrapliCfgResponse: \"\"\" Handle post \"get_version\" operations for parity between sync and async Args: response: response object to update scrapli_responses: list of scrapli response objects from fetching the version result: final version string of the device Returns: ScrapliCfgResponse: response object containing string of the version as the `result` attribute Raises: N/A \"\"\" response.record_response(scrapli_responses=scrapli_responses, result=result) if response.failed: msg = \"failed to get version from device\" self.logger.critical(msg) return response def _pre_get_config(self, source: str) -> ScrapliCfgResponse: \"\"\" Handle pre \"get_config\" operations for parity between sync and async Args: source: name of the config source, generally running|startup Returns: ScrapliCfgResponse: new response object to update w/ get results Raises: InvalidConfigTarget: if the requested config source is not valid \"\"\" self.logger.info(f\"get_config for config source '{source}' requested\") self._operation_ok() if source not in self.config_sources: msg = ( f\"provided config source '{source}' not valid, must be one of {self.config_sources}\" ) self.logger.critical(msg) raise InvalidConfigTarget(msg) response = ScrapliCfgResponse( host=self.conn.host, raise_for_status_exception=GetConfigError ) return response def _post_get_config( self, response: ScrapliCfgResponse, source: str, scrapli_responses: List[Union[Response, MultiResponse]], result: str, ) -> ScrapliCfgResponse: \"\"\" Handle post \"get_config\" operations for parity between sync and async Args: response: response object to update source: name of the config source, generally running|startup scrapli_responses: list of scrapli response objects from fetching the config result: final string of the \"get_config\" result Returns: ScrapliCfgResponse: response object containing string of the target config source as the `result` attribute Raises: N/A \"\"\" response.record_response(scrapli_responses=scrapli_responses, result=result) if response.failed: msg = f\"failed to get {source} config\" self.logger.critical(msg) return response def _pre_load_config(self, config: str) -> ScrapliCfgResponse: \"\"\" Handle pre \"load_config\" operations for parity between sync and async Args: config: candidate config to load Returns: ScrapliCfgResponse: new response object for load operation Raises: N/A \"\"\" self.logger.info(\"load_config requested\") self._operation_ok() self.candidate_config = config response = ScrapliCfgResponse( host=self.conn.host, raise_for_status_exception=LoadConfigError ) return response def _post_load_config( self, response: ScrapliCfgResponse, scrapli_responses: List[Response], ) -> ScrapliCfgResponse: \"\"\" Handle post \"get_config\" operations for parity between sync and async Args: response: response object to update scrapli_responses: list of scrapli response objects from fetching the config Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" response.record_response(scrapli_responses=scrapli_responses) if response.failed: msg = \"failed to load candidate config\" self.logger.critical(msg) return response def _pre_abort_config(self, session_or_config_file: bool) -> ScrapliCfgResponse: \"\"\" Handle pre \"abort_config\" operations for parity between sync and async Args: session_or_config_file: bool indicating if a session or candidate config file has been loaded -- in other words, is there anything to abort right now Returns: ScrapliCfgResponse: response object for abort operation Raises: AbortConfigError: if no config session or config file exists then we have no config to abort! \"\"\" self.logger.info(\"abort_config requested\") self._operation_ok() if session_or_config_file is False: msg = ( \"no configuration session or candidate configuration file exists, you must load a \" \"config in order to abort it!\" ) self.logger.critical(msg) raise AbortConfigError(msg) response = ScrapliCfgResponse( host=self.conn.host, raise_for_status_exception=AbortConfigError ) return response def _post_abort_config( self, response: ScrapliCfgResponse, scrapli_responses: List[Union[Response, MultiResponse]], ) -> ScrapliCfgResponse: \"\"\" Handle post \"abort_config\" operations for parity between sync and async Args: response: response object to update scrapli_responses: list of scrapli response objects from aborting the config Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" response.record_response(scrapli_responses=scrapli_responses) if response.failed: msg = \"failed to abort config\" self.logger.critical(msg) return response def _pre_commit_config(self, source: str, session_or_config_file: bool) -> ScrapliCfgResponse: \"\"\" Handle pre \"commit_config\" operations for parity between sync and async Args: source: name of the config source, generally running|startup session_or_config_file: bool indicating if a session or candidate config file has been loaded -- in other words, is there anything to commit right now Returns: ScrapliCfgResponse: new response object to update w/ commit results Raises: InvalidConfigTarget: if the requested config source is not valid CommitConfigError: if no config session/file exists to commit \"\"\" self.logger.info(f\"get_config for config source '{source}' requested\") self._operation_ok() if source not in self.config_sources: msg = ( f\"provided config source '{source}' not valid, must be one of {self.config_sources}\" ) self.logger.critical(msg) raise InvalidConfigTarget(msg) if session_or_config_file is False: msg = ( \"no configuration session or candidate configuration file exists, you must load a \" \"config in order to commit it!\" ) self.logger.critical(msg) raise CommitConfigError(msg) response = ScrapliCfgResponse( host=self.conn.host, raise_for_status_exception=CommitConfigError ) return response def _post_commit_config( self, response: ScrapliCfgResponse, scrapli_responses: List[Union[Response, MultiResponse]], ) -> ScrapliCfgResponse: \"\"\" Handle post \"commit_config\" operations for parity between sync and async Args: response: response object to update scrapli_responses: list of scrapli response objects from committing the config Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" response.record_response(scrapli_responses=scrapli_responses) if response.failed: msg = \"failed to commit config\" self.logger.critical(msg) return response def _pre_diff_config(self, source: str, session_or_config_file: bool) -> ScrapliCfgDiffResponse: \"\"\" Handle pre \"diff_config\" operations for parity between sync and async Args: source: config source to diff against session_or_config_file: bool of config_session_name or candidate_config_filename Returns: ScrapliCfgDiffResponse: diff object for diff operation Raises: InvalidConfigTarget: if trying to diff against an invalid config target DiffConfigError: if no config session or config file exists then we have no config to diff! \"\"\" self.logger.info(\"diff_config requested\") self._operation_ok() if source not in self.config_sources: msg = ( f\"provided config source '{source}' not valid, must be one of {self.config_sources}\" ) self.logger.critical(msg) raise InvalidConfigTarget(msg) if session_or_config_file is False: msg = ( \"no configuration session or candidate configuration file exists, you must load a \" \"config in order to diff it!\" ) self.logger.critical(msg) raise DiffConfigError(msg) diff_response = ScrapliCfgDiffResponse(host=self.conn.host, source=source) return diff_response def _post_diff_config( self, diff_response: ScrapliCfgDiffResponse, scrapli_responses: List[Response], source_config: str, candidate_config: str, device_diff: str, ) -> ScrapliCfgDiffResponse: \"\"\" Handle post \"diff_config\" operations for parity between sync and async Args: diff_response: response object to update scrapli_responses: list of scrapli response objects from committing the config source_config: previous source config from the device candidate_config: user provided configuration device_diff: diff generated from the device itself Returns: ScrapliCfgDiffResponse: diff object for diff operation Raises: N/A \"\"\" diff_response.record_response(scrapli_responses=scrapli_responses) diff_response.record_diff_response( source_config=source_config + \"\\n\", candidate_config=candidate_config + \"\\n\", device_diff=device_diff, ) if diff_response.failed: msg = \"failed to diff config\" self.logger.critical(msg) return diff_response Classes \u00b6 ScrapliCfgBase \u00b6 1 2 3 4 5 6 7 8 9 10 11 Base class for all CFG platforms Args: config_sources: list of allowed config sources ignore_version: ignore platform version check or not Returns: None Raises: N/A Expand source code class ScrapliCfgBase: conn: Union[NetworkDriver, AsyncNetworkDriver] def __init__(self, config_sources: List[str], ignore_version: bool = False) -> None: \"\"\" Base class for all CFG platforms Args: config_sources: list of allowed config sources ignore_version: ignore platform version check or not Returns: None Raises: N/A \"\"\" self.logger = get_instance_logger( instance_name=\"scrapli_cfg.platform\", host=self.conn.host, port=self.conn.port ) self.config_sources = config_sources self.candidate_config = \"\" self.ignore_version = ignore_version self._get_version_command = \"\" self._version_string = \"\" # bool indicated if a `on_prepare` callable has been executed or not self._prepared = False def _render_substituted_config( self, config_template: str, substitutes: List[Tuple[str, Pattern[str]]], source_config: str ) -> str: \"\"\" Render a substituted configuration file Renders a configuration based on a user template, substitutes, and a target config from the device. Args: config_template: config file to use as the base for substitutions -- should contain jinja2-like variables that will be replaced with data fetched from the source config by the substitutes patterns substitutes: tuple of name, pattern -- where name matches the jinja2-like variable in the config_template file, and pattern is a compiled regular expression pattern to be used to fetch that section from the source config source_config: current source config to use in substitution process Returns: None Raises: TemplateError: if no substitute sections are provided TemplateError: if one or more of the substitute sections is missing in the template TemplateError: if a substitute pattern is not found in the config template \"\"\" self.logger.debug(\"rendering substituted config\") if not substitutes: msg = \"no substitutes provided...\" self.logger.critical(msg) raise TemplateError(msg) if not all(f\"{{{{ {name} }}}}\" in config_template for name, _ in substitutes): msg = \"missing one or more of the provided substitutions from the config template\" self.logger.critical(msg) raise TemplateError(msg) replace_sections = [ (name, re.search(pattern=pattern, string=source_config)) for name, pattern in substitutes ] rendered_config = \"\" for name, replace_section in replace_sections: if not replace_section: msg = ( f\"substitution pattern {name} was unable to find a match in the target config\" \" source\" ) self.logger.critical(msg) raise TemplateError(msg) replace_group = replace_section.group() rendered_config = config_template.replace(f\"{{{{ {name} }}}}\", replace_group) # remove any totally empty lines (from bad regex, or just device spitting out lines w/ # nothing on it rendered_config = \"\\n\".join(line for line in rendered_config.splitlines() if line) self.logger.debug(\"rendering substituted config complete\") return rendered_config def _validate_and_set_version(self, version_response: ScrapliCfgResponse) -> None: \"\"\" Ensure version was fetched successfully and set internal version attribute Args: version_response: scrapli cfg response from get version operation Returns: None Raises: VersionError: if fetching version failed or failed to parse version \"\"\" if version_response.failed: msg = \"failed getting version from device\" self.logger.critical(msg) raise VersionError(msg) if not version_response.result: msg = \"failed parsing version string from device output\" self.logger.critical(msg) raise VersionError(msg) self._version_string = version_response.result def _prepare_ok(self) -> None: \"\"\" Determine if prepare is \"OK\" for a given operation Checks if an `on_prepare` callable has been provided, and if so, if it has been executed. This is meant to help force users into calling `prepare` or using the context manager prior to running any methods. Args: N/A Returns: None Raises: PrepareNotCalled: if `on_prepare` is not None and `_prepared` is False \"\"\" # ignoring type/complaints as `on_prepare` will always be set in the sync/async classes; # but is not set here since in one its a coroutine and the other not _on_prepare = self.on_prepare # type: ignore # noqa if _on_prepare is not None and self._prepared is False: raise PrepareNotCalled( \"on_prepare callable provided, but prepare method not called. call prepare method \" \"or use context manager to ensure it is called for you\" ) def _version_ok(self) -> None: \"\"\" Determine if version is \"OK\" for a given operation Should be overridden and super'd to by platforms that implement version constraints, will simply check that if `ignore_version` is `False` we have set the internal `_version_string` attribute, if not, will raise `PrepareNotCalled` exception. Args: N/A Returns: None Raises: PrepareNotCalled: if ignore version is False and _version_string not set \"\"\" if self.ignore_version is False and not self._version_string: raise PrepareNotCalled( \"ignore_version is False, but version has not yet been fetched. call prepare method\" \" or use context manager to ensure that version is properly gathered\" ) def _operation_ok(self) -> None: \"\"\" Determine if all values are \"OK\" for a given operation Checks if version and prepare are ok. Convenience func to just have one thing to call in the `_pre` operation methods. Args: N/A Returns: None Raises: N/A \"\"\" self._prepare_ok() self._version_ok() def _pre_get_version(self) -> ScrapliCfgResponse: \"\"\" Handle pre \"get_version\" operations for parity between sync and async Args: N/A Returns: ScrapliCfgResponse: new response object to update w/ get results Raises: N/A \"\"\" self.logger.info(\"get_version requested\") response = ScrapliCfgResponse(host=self.conn.host, raise_for_status_exception=VersionError) return response def _post_get_version( self, response: ScrapliCfgResponse, scrapli_responses: List[Response], result: str, ) -> ScrapliCfgResponse: \"\"\" Handle post \"get_version\" operations for parity between sync and async Args: response: response object to update scrapli_responses: list of scrapli response objects from fetching the version result: final version string of the device Returns: ScrapliCfgResponse: response object containing string of the version as the `result` attribute Raises: N/A \"\"\" response.record_response(scrapli_responses=scrapli_responses, result=result) if response.failed: msg = \"failed to get version from device\" self.logger.critical(msg) return response def _pre_get_config(self, source: str) -> ScrapliCfgResponse: \"\"\" Handle pre \"get_config\" operations for parity between sync and async Args: source: name of the config source, generally running|startup Returns: ScrapliCfgResponse: new response object to update w/ get results Raises: InvalidConfigTarget: if the requested config source is not valid \"\"\" self.logger.info(f\"get_config for config source '{source}' requested\") self._operation_ok() if source not in self.config_sources: msg = ( f\"provided config source '{source}' not valid, must be one of {self.config_sources}\" ) self.logger.critical(msg) raise InvalidConfigTarget(msg) response = ScrapliCfgResponse( host=self.conn.host, raise_for_status_exception=GetConfigError ) return response def _post_get_config( self, response: ScrapliCfgResponse, source: str, scrapli_responses: List[Union[Response, MultiResponse]], result: str, ) -> ScrapliCfgResponse: \"\"\" Handle post \"get_config\" operations for parity between sync and async Args: response: response object to update source: name of the config source, generally running|startup scrapli_responses: list of scrapli response objects from fetching the config result: final string of the \"get_config\" result Returns: ScrapliCfgResponse: response object containing string of the target config source as the `result` attribute Raises: N/A \"\"\" response.record_response(scrapli_responses=scrapli_responses, result=result) if response.failed: msg = f\"failed to get {source} config\" self.logger.critical(msg) return response def _pre_load_config(self, config: str) -> ScrapliCfgResponse: \"\"\" Handle pre \"load_config\" operations for parity between sync and async Args: config: candidate config to load Returns: ScrapliCfgResponse: new response object for load operation Raises: N/A \"\"\" self.logger.info(\"load_config requested\") self._operation_ok() self.candidate_config = config response = ScrapliCfgResponse( host=self.conn.host, raise_for_status_exception=LoadConfigError ) return response def _post_load_config( self, response: ScrapliCfgResponse, scrapli_responses: List[Response], ) -> ScrapliCfgResponse: \"\"\" Handle post \"get_config\" operations for parity between sync and async Args: response: response object to update scrapli_responses: list of scrapli response objects from fetching the config Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" response.record_response(scrapli_responses=scrapli_responses) if response.failed: msg = \"failed to load candidate config\" self.logger.critical(msg) return response def _pre_abort_config(self, session_or_config_file: bool) -> ScrapliCfgResponse: \"\"\" Handle pre \"abort_config\" operations for parity between sync and async Args: session_or_config_file: bool indicating if a session or candidate config file has been loaded -- in other words, is there anything to abort right now Returns: ScrapliCfgResponse: response object for abort operation Raises: AbortConfigError: if no config session or config file exists then we have no config to abort! \"\"\" self.logger.info(\"abort_config requested\") self._operation_ok() if session_or_config_file is False: msg = ( \"no configuration session or candidate configuration file exists, you must load a \" \"config in order to abort it!\" ) self.logger.critical(msg) raise AbortConfigError(msg) response = ScrapliCfgResponse( host=self.conn.host, raise_for_status_exception=AbortConfigError ) return response def _post_abort_config( self, response: ScrapliCfgResponse, scrapli_responses: List[Union[Response, MultiResponse]], ) -> ScrapliCfgResponse: \"\"\" Handle post \"abort_config\" operations for parity between sync and async Args: response: response object to update scrapli_responses: list of scrapli response objects from aborting the config Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" response.record_response(scrapli_responses=scrapli_responses) if response.failed: msg = \"failed to abort config\" self.logger.critical(msg) return response def _pre_commit_config(self, source: str, session_or_config_file: bool) -> ScrapliCfgResponse: \"\"\" Handle pre \"commit_config\" operations for parity between sync and async Args: source: name of the config source, generally running|startup session_or_config_file: bool indicating if a session or candidate config file has been loaded -- in other words, is there anything to commit right now Returns: ScrapliCfgResponse: new response object to update w/ commit results Raises: InvalidConfigTarget: if the requested config source is not valid CommitConfigError: if no config session/file exists to commit \"\"\" self.logger.info(f\"get_config for config source '{source}' requested\") self._operation_ok() if source not in self.config_sources: msg = ( f\"provided config source '{source}' not valid, must be one of {self.config_sources}\" ) self.logger.critical(msg) raise InvalidConfigTarget(msg) if session_or_config_file is False: msg = ( \"no configuration session or candidate configuration file exists, you must load a \" \"config in order to commit it!\" ) self.logger.critical(msg) raise CommitConfigError(msg) response = ScrapliCfgResponse( host=self.conn.host, raise_for_status_exception=CommitConfigError ) return response def _post_commit_config( self, response: ScrapliCfgResponse, scrapli_responses: List[Union[Response, MultiResponse]], ) -> ScrapliCfgResponse: \"\"\" Handle post \"commit_config\" operations for parity between sync and async Args: response: response object to update scrapli_responses: list of scrapli response objects from committing the config Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" response.record_response(scrapli_responses=scrapli_responses) if response.failed: msg = \"failed to commit config\" self.logger.critical(msg) return response def _pre_diff_config(self, source: str, session_or_config_file: bool) -> ScrapliCfgDiffResponse: \"\"\" Handle pre \"diff_config\" operations for parity between sync and async Args: source: config source to diff against session_or_config_file: bool of config_session_name or candidate_config_filename Returns: ScrapliCfgDiffResponse: diff object for diff operation Raises: InvalidConfigTarget: if trying to diff against an invalid config target DiffConfigError: if no config session or config file exists then we have no config to diff! \"\"\" self.logger.info(\"diff_config requested\") self._operation_ok() if source not in self.config_sources: msg = ( f\"provided config source '{source}' not valid, must be one of {self.config_sources}\" ) self.logger.critical(msg) raise InvalidConfigTarget(msg) if session_or_config_file is False: msg = ( \"no configuration session or candidate configuration file exists, you must load a \" \"config in order to diff it!\" ) self.logger.critical(msg) raise DiffConfigError(msg) diff_response = ScrapliCfgDiffResponse(host=self.conn.host, source=source) return diff_response def _post_diff_config( self, diff_response: ScrapliCfgDiffResponse, scrapli_responses: List[Response], source_config: str, candidate_config: str, device_diff: str, ) -> ScrapliCfgDiffResponse: \"\"\" Handle post \"diff_config\" operations for parity between sync and async Args: diff_response: response object to update scrapli_responses: list of scrapli response objects from committing the config source_config: previous source config from the device candidate_config: user provided configuration device_diff: diff generated from the device itself Returns: ScrapliCfgDiffResponse: diff object for diff operation Raises: N/A \"\"\" diff_response.record_response(scrapli_responses=scrapli_responses) diff_response.record_diff_response( source_config=source_config + \"\\n\", candidate_config=candidate_config + \"\\n\", device_diff=device_diff, ) if diff_response.failed: msg = \"failed to diff config\" self.logger.critical(msg) return diff_response Descendants \u00b6 scrapli_cfg.platform.base.async_platform.AsyncScrapliCfgPlatform scrapli_cfg.platform.base.sync_platform.ScrapliCfgPlatform Class variables \u00b6 conn: Union[scrapli.driver.network.sync_driver.NetworkDriver, scrapli.driver.network.async_driver.AsyncNetworkDriver]","title":"Base platform"},{"location":"api_docs/platform/base/base_platform/#module-scrapli_cfgplatformbasebase_platform","text":"scrapli_cfg.platforms.base_platform Expand source code \"\"\"scrapli_cfg.platforms.base_platform\"\"\" import re from typing import List, Pattern, Tuple, Union from scrapli.driver import AsyncNetworkDriver, NetworkDriver from scrapli.logging import get_instance_logger from scrapli.response import MultiResponse, Response from scrapli_cfg.diff import ScrapliCfgDiffResponse from scrapli_cfg.exceptions import ( AbortConfigError, CommitConfigError, DiffConfigError, GetConfigError, InvalidConfigTarget, LoadConfigError, PrepareNotCalled, TemplateError, VersionError, ) from scrapli_cfg.response import ScrapliCfgResponse class ScrapliCfgBase: conn: Union[NetworkDriver, AsyncNetworkDriver] def __init__(self, config_sources: List[str], ignore_version: bool = False) -> None: \"\"\" Base class for all CFG platforms Args: config_sources: list of allowed config sources ignore_version: ignore platform version check or not Returns: None Raises: N/A \"\"\" self.logger = get_instance_logger( instance_name=\"scrapli_cfg.platform\", host=self.conn.host, port=self.conn.port ) self.config_sources = config_sources self.candidate_config = \"\" self.ignore_version = ignore_version self._get_version_command = \"\" self._version_string = \"\" # bool indicated if a `on_prepare` callable has been executed or not self._prepared = False def _render_substituted_config( self, config_template: str, substitutes: List[Tuple[str, Pattern[str]]], source_config: str ) -> str: \"\"\" Render a substituted configuration file Renders a configuration based on a user template, substitutes, and a target config from the device. Args: config_template: config file to use as the base for substitutions -- should contain jinja2-like variables that will be replaced with data fetched from the source config by the substitutes patterns substitutes: tuple of name, pattern -- where name matches the jinja2-like variable in the config_template file, and pattern is a compiled regular expression pattern to be used to fetch that section from the source config source_config: current source config to use in substitution process Returns: None Raises: TemplateError: if no substitute sections are provided TemplateError: if one or more of the substitute sections is missing in the template TemplateError: if a substitute pattern is not found in the config template \"\"\" self.logger.debug(\"rendering substituted config\") if not substitutes: msg = \"no substitutes provided...\" self.logger.critical(msg) raise TemplateError(msg) if not all(f\"{{{{ {name} }}}}\" in config_template for name, _ in substitutes): msg = \"missing one or more of the provided substitutions from the config template\" self.logger.critical(msg) raise TemplateError(msg) replace_sections = [ (name, re.search(pattern=pattern, string=source_config)) for name, pattern in substitutes ] rendered_config = \"\" for name, replace_section in replace_sections: if not replace_section: msg = ( f\"substitution pattern {name} was unable to find a match in the target config\" \" source\" ) self.logger.critical(msg) raise TemplateError(msg) replace_group = replace_section.group() rendered_config = config_template.replace(f\"{{{{ {name} }}}}\", replace_group) # remove any totally empty lines (from bad regex, or just device spitting out lines w/ # nothing on it rendered_config = \"\\n\".join(line for line in rendered_config.splitlines() if line) self.logger.debug(\"rendering substituted config complete\") return rendered_config def _validate_and_set_version(self, version_response: ScrapliCfgResponse) -> None: \"\"\" Ensure version was fetched successfully and set internal version attribute Args: version_response: scrapli cfg response from get version operation Returns: None Raises: VersionError: if fetching version failed or failed to parse version \"\"\" if version_response.failed: msg = \"failed getting version from device\" self.logger.critical(msg) raise VersionError(msg) if not version_response.result: msg = \"failed parsing version string from device output\" self.logger.critical(msg) raise VersionError(msg) self._version_string = version_response.result def _prepare_ok(self) -> None: \"\"\" Determine if prepare is \"OK\" for a given operation Checks if an `on_prepare` callable has been provided, and if so, if it has been executed. This is meant to help force users into calling `prepare` or using the context manager prior to running any methods. Args: N/A Returns: None Raises: PrepareNotCalled: if `on_prepare` is not None and `_prepared` is False \"\"\" # ignoring type/complaints as `on_prepare` will always be set in the sync/async classes; # but is not set here since in one its a coroutine and the other not _on_prepare = self.on_prepare # type: ignore # noqa if _on_prepare is not None and self._prepared is False: raise PrepareNotCalled( \"on_prepare callable provided, but prepare method not called. call prepare method \" \"or use context manager to ensure it is called for you\" ) def _version_ok(self) -> None: \"\"\" Determine if version is \"OK\" for a given operation Should be overridden and super'd to by platforms that implement version constraints, will simply check that if `ignore_version` is `False` we have set the internal `_version_string` attribute, if not, will raise `PrepareNotCalled` exception. Args: N/A Returns: None Raises: PrepareNotCalled: if ignore version is False and _version_string not set \"\"\" if self.ignore_version is False and not self._version_string: raise PrepareNotCalled( \"ignore_version is False, but version has not yet been fetched. call prepare method\" \" or use context manager to ensure that version is properly gathered\" ) def _operation_ok(self) -> None: \"\"\" Determine if all values are \"OK\" for a given operation Checks if version and prepare are ok. Convenience func to just have one thing to call in the `_pre` operation methods. Args: N/A Returns: None Raises: N/A \"\"\" self._prepare_ok() self._version_ok() def _pre_get_version(self) -> ScrapliCfgResponse: \"\"\" Handle pre \"get_version\" operations for parity between sync and async Args: N/A Returns: ScrapliCfgResponse: new response object to update w/ get results Raises: N/A \"\"\" self.logger.info(\"get_version requested\") response = ScrapliCfgResponse(host=self.conn.host, raise_for_status_exception=VersionError) return response def _post_get_version( self, response: ScrapliCfgResponse, scrapli_responses: List[Response], result: str, ) -> ScrapliCfgResponse: \"\"\" Handle post \"get_version\" operations for parity between sync and async Args: response: response object to update scrapli_responses: list of scrapli response objects from fetching the version result: final version string of the device Returns: ScrapliCfgResponse: response object containing string of the version as the `result` attribute Raises: N/A \"\"\" response.record_response(scrapli_responses=scrapli_responses, result=result) if response.failed: msg = \"failed to get version from device\" self.logger.critical(msg) return response def _pre_get_config(self, source: str) -> ScrapliCfgResponse: \"\"\" Handle pre \"get_config\" operations for parity between sync and async Args: source: name of the config source, generally running|startup Returns: ScrapliCfgResponse: new response object to update w/ get results Raises: InvalidConfigTarget: if the requested config source is not valid \"\"\" self.logger.info(f\"get_config for config source '{source}' requested\") self._operation_ok() if source not in self.config_sources: msg = ( f\"provided config source '{source}' not valid, must be one of {self.config_sources}\" ) self.logger.critical(msg) raise InvalidConfigTarget(msg) response = ScrapliCfgResponse( host=self.conn.host, raise_for_status_exception=GetConfigError ) return response def _post_get_config( self, response: ScrapliCfgResponse, source: str, scrapli_responses: List[Union[Response, MultiResponse]], result: str, ) -> ScrapliCfgResponse: \"\"\" Handle post \"get_config\" operations for parity between sync and async Args: response: response object to update source: name of the config source, generally running|startup scrapli_responses: list of scrapli response objects from fetching the config result: final string of the \"get_config\" result Returns: ScrapliCfgResponse: response object containing string of the target config source as the `result` attribute Raises: N/A \"\"\" response.record_response(scrapli_responses=scrapli_responses, result=result) if response.failed: msg = f\"failed to get {source} config\" self.logger.critical(msg) return response def _pre_load_config(self, config: str) -> ScrapliCfgResponse: \"\"\" Handle pre \"load_config\" operations for parity between sync and async Args: config: candidate config to load Returns: ScrapliCfgResponse: new response object for load operation Raises: N/A \"\"\" self.logger.info(\"load_config requested\") self._operation_ok() self.candidate_config = config response = ScrapliCfgResponse( host=self.conn.host, raise_for_status_exception=LoadConfigError ) return response def _post_load_config( self, response: ScrapliCfgResponse, scrapli_responses: List[Response], ) -> ScrapliCfgResponse: \"\"\" Handle post \"get_config\" operations for parity between sync and async Args: response: response object to update scrapli_responses: list of scrapli response objects from fetching the config Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" response.record_response(scrapli_responses=scrapli_responses) if response.failed: msg = \"failed to load candidate config\" self.logger.critical(msg) return response def _pre_abort_config(self, session_or_config_file: bool) -> ScrapliCfgResponse: \"\"\" Handle pre \"abort_config\" operations for parity between sync and async Args: session_or_config_file: bool indicating if a session or candidate config file has been loaded -- in other words, is there anything to abort right now Returns: ScrapliCfgResponse: response object for abort operation Raises: AbortConfigError: if no config session or config file exists then we have no config to abort! \"\"\" self.logger.info(\"abort_config requested\") self._operation_ok() if session_or_config_file is False: msg = ( \"no configuration session or candidate configuration file exists, you must load a \" \"config in order to abort it!\" ) self.logger.critical(msg) raise AbortConfigError(msg) response = ScrapliCfgResponse( host=self.conn.host, raise_for_status_exception=AbortConfigError ) return response def _post_abort_config( self, response: ScrapliCfgResponse, scrapli_responses: List[Union[Response, MultiResponse]], ) -> ScrapliCfgResponse: \"\"\" Handle post \"abort_config\" operations for parity between sync and async Args: response: response object to update scrapli_responses: list of scrapli response objects from aborting the config Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" response.record_response(scrapli_responses=scrapli_responses) if response.failed: msg = \"failed to abort config\" self.logger.critical(msg) return response def _pre_commit_config(self, source: str, session_or_config_file: bool) -> ScrapliCfgResponse: \"\"\" Handle pre \"commit_config\" operations for parity between sync and async Args: source: name of the config source, generally running|startup session_or_config_file: bool indicating if a session or candidate config file has been loaded -- in other words, is there anything to commit right now Returns: ScrapliCfgResponse: new response object to update w/ commit results Raises: InvalidConfigTarget: if the requested config source is not valid CommitConfigError: if no config session/file exists to commit \"\"\" self.logger.info(f\"get_config for config source '{source}' requested\") self._operation_ok() if source not in self.config_sources: msg = ( f\"provided config source '{source}' not valid, must be one of {self.config_sources}\" ) self.logger.critical(msg) raise InvalidConfigTarget(msg) if session_or_config_file is False: msg = ( \"no configuration session or candidate configuration file exists, you must load a \" \"config in order to commit it!\" ) self.logger.critical(msg) raise CommitConfigError(msg) response = ScrapliCfgResponse( host=self.conn.host, raise_for_status_exception=CommitConfigError ) return response def _post_commit_config( self, response: ScrapliCfgResponse, scrapli_responses: List[Union[Response, MultiResponse]], ) -> ScrapliCfgResponse: \"\"\" Handle post \"commit_config\" operations for parity between sync and async Args: response: response object to update scrapli_responses: list of scrapli response objects from committing the config Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" response.record_response(scrapli_responses=scrapli_responses) if response.failed: msg = \"failed to commit config\" self.logger.critical(msg) return response def _pre_diff_config(self, source: str, session_or_config_file: bool) -> ScrapliCfgDiffResponse: \"\"\" Handle pre \"diff_config\" operations for parity between sync and async Args: source: config source to diff against session_or_config_file: bool of config_session_name or candidate_config_filename Returns: ScrapliCfgDiffResponse: diff object for diff operation Raises: InvalidConfigTarget: if trying to diff against an invalid config target DiffConfigError: if no config session or config file exists then we have no config to diff! \"\"\" self.logger.info(\"diff_config requested\") self._operation_ok() if source not in self.config_sources: msg = ( f\"provided config source '{source}' not valid, must be one of {self.config_sources}\" ) self.logger.critical(msg) raise InvalidConfigTarget(msg) if session_or_config_file is False: msg = ( \"no configuration session or candidate configuration file exists, you must load a \" \"config in order to diff it!\" ) self.logger.critical(msg) raise DiffConfigError(msg) diff_response = ScrapliCfgDiffResponse(host=self.conn.host, source=source) return diff_response def _post_diff_config( self, diff_response: ScrapliCfgDiffResponse, scrapli_responses: List[Response], source_config: str, candidate_config: str, device_diff: str, ) -> ScrapliCfgDiffResponse: \"\"\" Handle post \"diff_config\" operations for parity between sync and async Args: diff_response: response object to update scrapli_responses: list of scrapli response objects from committing the config source_config: previous source config from the device candidate_config: user provided configuration device_diff: diff generated from the device itself Returns: ScrapliCfgDiffResponse: diff object for diff operation Raises: N/A \"\"\" diff_response.record_response(scrapli_responses=scrapli_responses) diff_response.record_diff_response( source_config=source_config + \"\\n\", candidate_config=candidate_config + \"\\n\", device_diff=device_diff, ) if diff_response.failed: msg = \"failed to diff config\" self.logger.critical(msg) return diff_response","title":"Module scrapli_cfg.platform.base.base_platform"},{"location":"api_docs/platform/base/base_platform/#classes","text":"","title":"Classes"},{"location":"api_docs/platform/base/base_platform/#scraplicfgbase","text":"1 2 3 4 5 6 7 8 9 10 11 Base class for all CFG platforms Args: config_sources: list of allowed config sources ignore_version: ignore platform version check or not Returns: None Raises: N/A Expand source code class ScrapliCfgBase: conn: Union[NetworkDriver, AsyncNetworkDriver] def __init__(self, config_sources: List[str], ignore_version: bool = False) -> None: \"\"\" Base class for all CFG platforms Args: config_sources: list of allowed config sources ignore_version: ignore platform version check or not Returns: None Raises: N/A \"\"\" self.logger = get_instance_logger( instance_name=\"scrapli_cfg.platform\", host=self.conn.host, port=self.conn.port ) self.config_sources = config_sources self.candidate_config = \"\" self.ignore_version = ignore_version self._get_version_command = \"\" self._version_string = \"\" # bool indicated if a `on_prepare` callable has been executed or not self._prepared = False def _render_substituted_config( self, config_template: str, substitutes: List[Tuple[str, Pattern[str]]], source_config: str ) -> str: \"\"\" Render a substituted configuration file Renders a configuration based on a user template, substitutes, and a target config from the device. Args: config_template: config file to use as the base for substitutions -- should contain jinja2-like variables that will be replaced with data fetched from the source config by the substitutes patterns substitutes: tuple of name, pattern -- where name matches the jinja2-like variable in the config_template file, and pattern is a compiled regular expression pattern to be used to fetch that section from the source config source_config: current source config to use in substitution process Returns: None Raises: TemplateError: if no substitute sections are provided TemplateError: if one or more of the substitute sections is missing in the template TemplateError: if a substitute pattern is not found in the config template \"\"\" self.logger.debug(\"rendering substituted config\") if not substitutes: msg = \"no substitutes provided...\" self.logger.critical(msg) raise TemplateError(msg) if not all(f\"{{{{ {name} }}}}\" in config_template for name, _ in substitutes): msg = \"missing one or more of the provided substitutions from the config template\" self.logger.critical(msg) raise TemplateError(msg) replace_sections = [ (name, re.search(pattern=pattern, string=source_config)) for name, pattern in substitutes ] rendered_config = \"\" for name, replace_section in replace_sections: if not replace_section: msg = ( f\"substitution pattern {name} was unable to find a match in the target config\" \" source\" ) self.logger.critical(msg) raise TemplateError(msg) replace_group = replace_section.group() rendered_config = config_template.replace(f\"{{{{ {name} }}}}\", replace_group) # remove any totally empty lines (from bad regex, or just device spitting out lines w/ # nothing on it rendered_config = \"\\n\".join(line for line in rendered_config.splitlines() if line) self.logger.debug(\"rendering substituted config complete\") return rendered_config def _validate_and_set_version(self, version_response: ScrapliCfgResponse) -> None: \"\"\" Ensure version was fetched successfully and set internal version attribute Args: version_response: scrapli cfg response from get version operation Returns: None Raises: VersionError: if fetching version failed or failed to parse version \"\"\" if version_response.failed: msg = \"failed getting version from device\" self.logger.critical(msg) raise VersionError(msg) if not version_response.result: msg = \"failed parsing version string from device output\" self.logger.critical(msg) raise VersionError(msg) self._version_string = version_response.result def _prepare_ok(self) -> None: \"\"\" Determine if prepare is \"OK\" for a given operation Checks if an `on_prepare` callable has been provided, and if so, if it has been executed. This is meant to help force users into calling `prepare` or using the context manager prior to running any methods. Args: N/A Returns: None Raises: PrepareNotCalled: if `on_prepare` is not None and `_prepared` is False \"\"\" # ignoring type/complaints as `on_prepare` will always be set in the sync/async classes; # but is not set here since in one its a coroutine and the other not _on_prepare = self.on_prepare # type: ignore # noqa if _on_prepare is not None and self._prepared is False: raise PrepareNotCalled( \"on_prepare callable provided, but prepare method not called. call prepare method \" \"or use context manager to ensure it is called for you\" ) def _version_ok(self) -> None: \"\"\" Determine if version is \"OK\" for a given operation Should be overridden and super'd to by platforms that implement version constraints, will simply check that if `ignore_version` is `False` we have set the internal `_version_string` attribute, if not, will raise `PrepareNotCalled` exception. Args: N/A Returns: None Raises: PrepareNotCalled: if ignore version is False and _version_string not set \"\"\" if self.ignore_version is False and not self._version_string: raise PrepareNotCalled( \"ignore_version is False, but version has not yet been fetched. call prepare method\" \" or use context manager to ensure that version is properly gathered\" ) def _operation_ok(self) -> None: \"\"\" Determine if all values are \"OK\" for a given operation Checks if version and prepare are ok. Convenience func to just have one thing to call in the `_pre` operation methods. Args: N/A Returns: None Raises: N/A \"\"\" self._prepare_ok() self._version_ok() def _pre_get_version(self) -> ScrapliCfgResponse: \"\"\" Handle pre \"get_version\" operations for parity between sync and async Args: N/A Returns: ScrapliCfgResponse: new response object to update w/ get results Raises: N/A \"\"\" self.logger.info(\"get_version requested\") response = ScrapliCfgResponse(host=self.conn.host, raise_for_status_exception=VersionError) return response def _post_get_version( self, response: ScrapliCfgResponse, scrapli_responses: List[Response], result: str, ) -> ScrapliCfgResponse: \"\"\" Handle post \"get_version\" operations for parity between sync and async Args: response: response object to update scrapli_responses: list of scrapli response objects from fetching the version result: final version string of the device Returns: ScrapliCfgResponse: response object containing string of the version as the `result` attribute Raises: N/A \"\"\" response.record_response(scrapli_responses=scrapli_responses, result=result) if response.failed: msg = \"failed to get version from device\" self.logger.critical(msg) return response def _pre_get_config(self, source: str) -> ScrapliCfgResponse: \"\"\" Handle pre \"get_config\" operations for parity between sync and async Args: source: name of the config source, generally running|startup Returns: ScrapliCfgResponse: new response object to update w/ get results Raises: InvalidConfigTarget: if the requested config source is not valid \"\"\" self.logger.info(f\"get_config for config source '{source}' requested\") self._operation_ok() if source not in self.config_sources: msg = ( f\"provided config source '{source}' not valid, must be one of {self.config_sources}\" ) self.logger.critical(msg) raise InvalidConfigTarget(msg) response = ScrapliCfgResponse( host=self.conn.host, raise_for_status_exception=GetConfigError ) return response def _post_get_config( self, response: ScrapliCfgResponse, source: str, scrapli_responses: List[Union[Response, MultiResponse]], result: str, ) -> ScrapliCfgResponse: \"\"\" Handle post \"get_config\" operations for parity between sync and async Args: response: response object to update source: name of the config source, generally running|startup scrapli_responses: list of scrapli response objects from fetching the config result: final string of the \"get_config\" result Returns: ScrapliCfgResponse: response object containing string of the target config source as the `result` attribute Raises: N/A \"\"\" response.record_response(scrapli_responses=scrapli_responses, result=result) if response.failed: msg = f\"failed to get {source} config\" self.logger.critical(msg) return response def _pre_load_config(self, config: str) -> ScrapliCfgResponse: \"\"\" Handle pre \"load_config\" operations for parity between sync and async Args: config: candidate config to load Returns: ScrapliCfgResponse: new response object for load operation Raises: N/A \"\"\" self.logger.info(\"load_config requested\") self._operation_ok() self.candidate_config = config response = ScrapliCfgResponse( host=self.conn.host, raise_for_status_exception=LoadConfigError ) return response def _post_load_config( self, response: ScrapliCfgResponse, scrapli_responses: List[Response], ) -> ScrapliCfgResponse: \"\"\" Handle post \"get_config\" operations for parity between sync and async Args: response: response object to update scrapli_responses: list of scrapli response objects from fetching the config Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" response.record_response(scrapli_responses=scrapli_responses) if response.failed: msg = \"failed to load candidate config\" self.logger.critical(msg) return response def _pre_abort_config(self, session_or_config_file: bool) -> ScrapliCfgResponse: \"\"\" Handle pre \"abort_config\" operations for parity between sync and async Args: session_or_config_file: bool indicating if a session or candidate config file has been loaded -- in other words, is there anything to abort right now Returns: ScrapliCfgResponse: response object for abort operation Raises: AbortConfigError: if no config session or config file exists then we have no config to abort! \"\"\" self.logger.info(\"abort_config requested\") self._operation_ok() if session_or_config_file is False: msg = ( \"no configuration session or candidate configuration file exists, you must load a \" \"config in order to abort it!\" ) self.logger.critical(msg) raise AbortConfigError(msg) response = ScrapliCfgResponse( host=self.conn.host, raise_for_status_exception=AbortConfigError ) return response def _post_abort_config( self, response: ScrapliCfgResponse, scrapli_responses: List[Union[Response, MultiResponse]], ) -> ScrapliCfgResponse: \"\"\" Handle post \"abort_config\" operations for parity between sync and async Args: response: response object to update scrapli_responses: list of scrapli response objects from aborting the config Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" response.record_response(scrapli_responses=scrapli_responses) if response.failed: msg = \"failed to abort config\" self.logger.critical(msg) return response def _pre_commit_config(self, source: str, session_or_config_file: bool) -> ScrapliCfgResponse: \"\"\" Handle pre \"commit_config\" operations for parity between sync and async Args: source: name of the config source, generally running|startup session_or_config_file: bool indicating if a session or candidate config file has been loaded -- in other words, is there anything to commit right now Returns: ScrapliCfgResponse: new response object to update w/ commit results Raises: InvalidConfigTarget: if the requested config source is not valid CommitConfigError: if no config session/file exists to commit \"\"\" self.logger.info(f\"get_config for config source '{source}' requested\") self._operation_ok() if source not in self.config_sources: msg = ( f\"provided config source '{source}' not valid, must be one of {self.config_sources}\" ) self.logger.critical(msg) raise InvalidConfigTarget(msg) if session_or_config_file is False: msg = ( \"no configuration session or candidate configuration file exists, you must load a \" \"config in order to commit it!\" ) self.logger.critical(msg) raise CommitConfigError(msg) response = ScrapliCfgResponse( host=self.conn.host, raise_for_status_exception=CommitConfigError ) return response def _post_commit_config( self, response: ScrapliCfgResponse, scrapli_responses: List[Union[Response, MultiResponse]], ) -> ScrapliCfgResponse: \"\"\" Handle post \"commit_config\" operations for parity between sync and async Args: response: response object to update scrapli_responses: list of scrapli response objects from committing the config Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" response.record_response(scrapli_responses=scrapli_responses) if response.failed: msg = \"failed to commit config\" self.logger.critical(msg) return response def _pre_diff_config(self, source: str, session_or_config_file: bool) -> ScrapliCfgDiffResponse: \"\"\" Handle pre \"diff_config\" operations for parity between sync and async Args: source: config source to diff against session_or_config_file: bool of config_session_name or candidate_config_filename Returns: ScrapliCfgDiffResponse: diff object for diff operation Raises: InvalidConfigTarget: if trying to diff against an invalid config target DiffConfigError: if no config session or config file exists then we have no config to diff! \"\"\" self.logger.info(\"diff_config requested\") self._operation_ok() if source not in self.config_sources: msg = ( f\"provided config source '{source}' not valid, must be one of {self.config_sources}\" ) self.logger.critical(msg) raise InvalidConfigTarget(msg) if session_or_config_file is False: msg = ( \"no configuration session or candidate configuration file exists, you must load a \" \"config in order to diff it!\" ) self.logger.critical(msg) raise DiffConfigError(msg) diff_response = ScrapliCfgDiffResponse(host=self.conn.host, source=source) return diff_response def _post_diff_config( self, diff_response: ScrapliCfgDiffResponse, scrapli_responses: List[Response], source_config: str, candidate_config: str, device_diff: str, ) -> ScrapliCfgDiffResponse: \"\"\" Handle post \"diff_config\" operations for parity between sync and async Args: diff_response: response object to update scrapli_responses: list of scrapli response objects from committing the config source_config: previous source config from the device candidate_config: user provided configuration device_diff: diff generated from the device itself Returns: ScrapliCfgDiffResponse: diff object for diff operation Raises: N/A \"\"\" diff_response.record_response(scrapli_responses=scrapli_responses) diff_response.record_diff_response( source_config=source_config + \"\\n\", candidate_config=candidate_config + \"\\n\", device_diff=device_diff, ) if diff_response.failed: msg = \"failed to diff config\" self.logger.critical(msg) return diff_response","title":"ScrapliCfgBase"},{"location":"api_docs/platform/base/base_platform/#descendants","text":"scrapli_cfg.platform.base.async_platform.AsyncScrapliCfgPlatform scrapli_cfg.platform.base.sync_platform.ScrapliCfgPlatform","title":"Descendants"},{"location":"api_docs/platform/base/base_platform/#class-variables","text":"conn: Union[scrapli.driver.network.sync_driver.NetworkDriver, scrapli.driver.network.async_driver.AsyncNetworkDriver]","title":"Class variables"},{"location":"api_docs/platform/base/sync_platform/","text":"window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting()) Module scrapli_cfg.platform.base.sync_platform \u00b6 scrapli_cfg.platform.sync_platform Expand source code \"\"\"scrapli_cfg.platform.sync_platform\"\"\" from abc import ABC, abstractmethod from types import TracebackType from typing import Any, Callable, List, Optional, Pattern, Tuple, Type from scrapli.driver import NetworkDriver from scrapli_cfg.diff import ScrapliCfgDiffResponse from scrapli_cfg.exceptions import ScrapliCfgException from scrapli_cfg.platform.base.base_platform import ScrapliCfgBase from scrapli_cfg.response import ScrapliCfgResponse class ScrapliCfgPlatform(ABC, ScrapliCfgBase): def __init__( self, conn: NetworkDriver, config_sources: List[str], on_prepare: Optional[Callable[..., Any]], dedicated_connection: bool, ignore_version: bool, ) -> None: \"\"\" Scrapli Config base class Args: conn: scrapli connection to use config_sources: list of config sources on_prepare: optional callable to run at connection `prepare` dedicated_connection: if `False` (default value) scrapli cfg will not open or close the underlying scrapli connection and will raise an exception if the scrapli connection is not open. If `True` will automatically open and close the scrapli connection when using with a context manager, `prepare` will open the scrapli connection (if not already open), and `close` will close the scrapli connection. ignore_version: ignore checking device version support; currently this just means that scrapli-cfg will not fetch the device version during the prepare phase, however this will (hopefully) be used in the future to limit what methods can be used against a target device. For example, for EOS devices we need > 4.14 to load configs; so if a device is encountered at 4.13 the version check would raise an exception rather than just failing in a potentially awkward fashion. Returns: None Raises: N/A \"\"\" self.conn: NetworkDriver = conn self.dedicated_connection = dedicated_connection self.on_prepare = on_prepare super().__init__(config_sources=config_sources, ignore_version=ignore_version) def __enter__(self) -> \"ScrapliCfgPlatform\": \"\"\" Enter method for context manager Args: N/A Returns: ScrapliCfg: opened ScrapliCfg object Raises: N/A \"\"\" self.prepare() return self def __exit__( self, exception_type: Optional[Type[BaseException]], exception_value: Optional[BaseException], traceback: Optional[TracebackType], ) -> None: \"\"\" Exit method to cleanup for context manager Args: exception_type: exception type being raised exception_value: message from exception being raised traceback: traceback from exception being raised Returns: None Raises: N/A \"\"\" self.cleanup() def _open(self) -> None: \"\"\" Handle opening (or raising exception if not open) of underlying scrapli connection Args: N/A Returns: None Raises: ScrapliCfgException: if scrapli connection is not open and auto_open_connection is False \"\"\" if self.conn.isalive(): return if self.dedicated_connection: self.logger.info( \"underlying scrapli connection is not alive... opening scrapli connection\" ) self.conn.open() return raise ScrapliCfgException( \"underlying scrapli connection is not open and `dedicated_connection` is False, \" \"cannot continue!\" ) def _close(self) -> None: \"\"\" Close the scrapli connection Args: N/A Returns: None Raises: N/A \"\"\" if self.dedicated_connection is True and self.conn.isalive(): self.logger.info(\"dedicated_connection is True, closing scrapli connection\") self.conn.close() def prepare(self) -> None: \"\"\" Prepare connection for scrapli_cfg operations Args: N/A Returns: None Raises: N/A \"\"\" self.logger.info(\"preparing scrapli_cfg connection\") self._open() if self.ignore_version is False: self.logger.debug(\"ignore_version is False, fetching device version\") version_response = self.get_version() self._validate_and_set_version(version_response=version_response) if self.on_prepare is not None: self.logger.debug(\"on_prepare provided, executing now\") self.on_prepare(self) self._prepared = True def cleanup(self) -> None: \"\"\" Cleanup after scrapli-cfg operations Generally this can be skipped, however it will be executed if using a context manager. The purpose of this method is to close the underlying scrapli connection (if in \"dedicated_connection\" mode), and to reset the internally used `_version_string`, attribute. All this is done so that this cfg connection, if re-used later (as in later in that script using the same object) starts with a fresh slate. Args: N/A Returns: None Raises: N/A \"\"\" self._close() # reset the version string/prepare flag so we know we need to re-fetch/re-run if user # re-opens connection self._version_string = \"\" self._prepared = False # this has *probably* been reset already, but reset it just in case user re-opens connection # we can have a clean slate to work with try: self._reset_config_session() # type: ignore except AttributeError: pass @abstractmethod def get_version(self) -> ScrapliCfgResponse: \"\"\" Get device version string Args: N/A Returns: ScrapliCfgResponse: response object where result is the string of the primary version (as in the \"main\" os version) of the device Raises: N/A \"\"\" @abstractmethod def get_config(self, source: str = \"running\") -> ScrapliCfgResponse: \"\"\" Get device configuration Args: source: name of the config source, generally running|startup Returns: ScrapliCfgResponse: response object containing string of the target config source as the `result` attribute Raises: N/A \"\"\" @abstractmethod def load_config(self, config: str, replace: bool = False, **kwargs: Any) -> ScrapliCfgResponse: \"\"\" Load configuration to a device Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see your specific platform for details Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" @abstractmethod def abort_config(self) -> ScrapliCfgResponse: \"\"\" Abort a configuration -- discards any loaded config Args: N/A Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" @abstractmethod def commit_config(self, source: str = \"running\") -> ScrapliCfgResponse: \"\"\" Commit a loaded configuration Args: source: name of the config source to commit against, generally running|startup Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" @abstractmethod def diff_config(self, source: str = \"running\") -> ScrapliCfgDiffResponse: \"\"\" Diff a loaded configuration against the source config store Args: source: name of the config source to diff against, generally running|startup -- device diffs will generally not care about this argument, but the built in scrapli differ will Returns: ScrapliCfgDiffResponse: scrapli cfg diff object Raises: N/A \"\"\" def render_substituted_config( self, config_template: str, substitutes: List[Tuple[str, Pattern[str]]], source: str = \"running\", ) -> str: \"\"\" Render a substituted configuration file Renders a configuration based on a user template, substitutes, and a target config from the device. Args: config_template: config file to use as the base for substitutions -- should contain jinja2-like variables that will be replaced with data fetched from the source config by the substitutes patterns substitutes: tuple of name, pattern -- where name matches the jinja2-like variable in the config_template file, and pattern is a compiled regular expression pattern to be used to fetch that section from the source config source: config source to use for the substitution efforts, typically running|startup Returns: str: substituted/rendered config Raises: N/A \"\"\" self.logger.info(\"fetching configuration and replacing with provided substitutes\") source_config = self.get_config(source=source) return self._render_substituted_config( config_template=config_template, substitutes=substitutes, source_config=source_config.result, ) Classes \u00b6 ScrapliCfgPlatform \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 Helper class that provides a standard way to create an ABC using inheritance. Scrapli Config base class Args: conn: scrapli connection to use config_sources: list of config sources on_prepare: optional callable to run at connection `prepare` dedicated_connection: if `False` (default value) scrapli cfg will not open or close the underlying scrapli connection and will raise an exception if the scrapli connection is not open. If `True` will automatically open and close the scrapli connection when using with a context manager, `prepare` will open the scrapli connection (if not already open), and `close` will close the scrapli connection. ignore_version: ignore checking device version support; currently this just means that scrapli-cfg will not fetch the device version during the prepare phase, however this will (hopefully) be used in the future to limit what methods can be used against a target device. For example, for EOS devices we need > 4.14 to load configs; so if a device is encountered at 4.13 the version check would raise an exception rather than just failing in a potentially awkward fashion. Returns: None Raises: N/A Expand source code class ScrapliCfgPlatform(ABC, ScrapliCfgBase): def __init__( self, conn: NetworkDriver, config_sources: List[str], on_prepare: Optional[Callable[..., Any]], dedicated_connection: bool, ignore_version: bool, ) -> None: \"\"\" Scrapli Config base class Args: conn: scrapli connection to use config_sources: list of config sources on_prepare: optional callable to run at connection `prepare` dedicated_connection: if `False` (default value) scrapli cfg will not open or close the underlying scrapli connection and will raise an exception if the scrapli connection is not open. If `True` will automatically open and close the scrapli connection when using with a context manager, `prepare` will open the scrapli connection (if not already open), and `close` will close the scrapli connection. ignore_version: ignore checking device version support; currently this just means that scrapli-cfg will not fetch the device version during the prepare phase, however this will (hopefully) be used in the future to limit what methods can be used against a target device. For example, for EOS devices we need > 4.14 to load configs; so if a device is encountered at 4.13 the version check would raise an exception rather than just failing in a potentially awkward fashion. Returns: None Raises: N/A \"\"\" self.conn: NetworkDriver = conn self.dedicated_connection = dedicated_connection self.on_prepare = on_prepare super().__init__(config_sources=config_sources, ignore_version=ignore_version) def __enter__(self) -> \"ScrapliCfgPlatform\": \"\"\" Enter method for context manager Args: N/A Returns: ScrapliCfg: opened ScrapliCfg object Raises: N/A \"\"\" self.prepare() return self def __exit__( self, exception_type: Optional[Type[BaseException]], exception_value: Optional[BaseException], traceback: Optional[TracebackType], ) -> None: \"\"\" Exit method to cleanup for context manager Args: exception_type: exception type being raised exception_value: message from exception being raised traceback: traceback from exception being raised Returns: None Raises: N/A \"\"\" self.cleanup() def _open(self) -> None: \"\"\" Handle opening (or raising exception if not open) of underlying scrapli connection Args: N/A Returns: None Raises: ScrapliCfgException: if scrapli connection is not open and auto_open_connection is False \"\"\" if self.conn.isalive(): return if self.dedicated_connection: self.logger.info( \"underlying scrapli connection is not alive... opening scrapli connection\" ) self.conn.open() return raise ScrapliCfgException( \"underlying scrapli connection is not open and `dedicated_connection` is False, \" \"cannot continue!\" ) def _close(self) -> None: \"\"\" Close the scrapli connection Args: N/A Returns: None Raises: N/A \"\"\" if self.dedicated_connection is True and self.conn.isalive(): self.logger.info(\"dedicated_connection is True, closing scrapli connection\") self.conn.close() def prepare(self) -> None: \"\"\" Prepare connection for scrapli_cfg operations Args: N/A Returns: None Raises: N/A \"\"\" self.logger.info(\"preparing scrapli_cfg connection\") self._open() if self.ignore_version is False: self.logger.debug(\"ignore_version is False, fetching device version\") version_response = self.get_version() self._validate_and_set_version(version_response=version_response) if self.on_prepare is not None: self.logger.debug(\"on_prepare provided, executing now\") self.on_prepare(self) self._prepared = True def cleanup(self) -> None: \"\"\" Cleanup after scrapli-cfg operations Generally this can be skipped, however it will be executed if using a context manager. The purpose of this method is to close the underlying scrapli connection (if in \"dedicated_connection\" mode), and to reset the internally used `_version_string`, attribute. All this is done so that this cfg connection, if re-used later (as in later in that script using the same object) starts with a fresh slate. Args: N/A Returns: None Raises: N/A \"\"\" self._close() # reset the version string/prepare flag so we know we need to re-fetch/re-run if user # re-opens connection self._version_string = \"\" self._prepared = False # this has *probably* been reset already, but reset it just in case user re-opens connection # we can have a clean slate to work with try: self._reset_config_session() # type: ignore except AttributeError: pass @abstractmethod def get_version(self) -> ScrapliCfgResponse: \"\"\" Get device version string Args: N/A Returns: ScrapliCfgResponse: response object where result is the string of the primary version (as in the \"main\" os version) of the device Raises: N/A \"\"\" @abstractmethod def get_config(self, source: str = \"running\") -> ScrapliCfgResponse: \"\"\" Get device configuration Args: source: name of the config source, generally running|startup Returns: ScrapliCfgResponse: response object containing string of the target config source as the `result` attribute Raises: N/A \"\"\" @abstractmethod def load_config(self, config: str, replace: bool = False, **kwargs: Any) -> ScrapliCfgResponse: \"\"\" Load configuration to a device Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see your specific platform for details Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" @abstractmethod def abort_config(self) -> ScrapliCfgResponse: \"\"\" Abort a configuration -- discards any loaded config Args: N/A Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" @abstractmethod def commit_config(self, source: str = \"running\") -> ScrapliCfgResponse: \"\"\" Commit a loaded configuration Args: source: name of the config source to commit against, generally running|startup Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" @abstractmethod def diff_config(self, source: str = \"running\") -> ScrapliCfgDiffResponse: \"\"\" Diff a loaded configuration against the source config store Args: source: name of the config source to diff against, generally running|startup -- device diffs will generally not care about this argument, but the built in scrapli differ will Returns: ScrapliCfgDiffResponse: scrapli cfg diff object Raises: N/A \"\"\" def render_substituted_config( self, config_template: str, substitutes: List[Tuple[str, Pattern[str]]], source: str = \"running\", ) -> str: \"\"\" Render a substituted configuration file Renders a configuration based on a user template, substitutes, and a target config from the device. Args: config_template: config file to use as the base for substitutions -- should contain jinja2-like variables that will be replaced with data fetched from the source config by the substitutes patterns substitutes: tuple of name, pattern -- where name matches the jinja2-like variable in the config_template file, and pattern is a compiled regular expression pattern to be used to fetch that section from the source config source: config source to use for the substitution efforts, typically running|startup Returns: str: substituted/rendered config Raises: N/A \"\"\" self.logger.info(\"fetching configuration and replacing with provided substitutes\") source_config = self.get_config(source=source) return self._render_substituted_config( config_template=config_template, substitutes=substitutes, source_config=source_config.result, ) Ancestors (in MRO) \u00b6 abc.ABC scrapli_cfg.platform.base.base_platform.ScrapliCfgBase Descendants \u00b6 scrapli_cfg.platform.core.arista_eos.sync_platform.ScrapliCfgEOS scrapli_cfg.platform.core.cisco_iosxe.sync_platform.ScrapliCfgIOSXE scrapli_cfg.platform.core.cisco_iosxr.sync_platform.ScrapliCfgIOSXR scrapli_cfg.platform.core.cisco_nxos.sync_platform.ScrapliCfgNXOS scrapli_cfg.platform.core.juniper_junos.sync_platform.ScrapliCfgJunos Class variables \u00b6 conn: Union[scrapli.driver.network.sync_driver.NetworkDriver, scrapli.driver.network.async_driver.AsyncNetworkDriver] Methods \u00b6 abort_config \u00b6 abort_config(self) \u2011> scrapli_cfg.response.ScrapliCfgResponse 1 2 3 4 5 6 7 8 9 10 Abort a configuration -- discards any loaded config Args: N/A Returns: ScrapliCfgResponse: response object Raises: N/A cleanup \u00b6 cleanup(self) \u2011> None 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 Cleanup after scrapli-cfg operations Generally this can be skipped, however it will be executed if using a context manager. The purpose of this method is to close the underlying scrapli connection (if in \"dedicated_connection\" mode), and to reset the internally used `_version_string`, attribute. All this is done so that this cfg connection, if re-used later (as in later in that script using the same object) starts with a fresh slate. Args: N/A Returns: None Raises: N/A commit_config \u00b6 commit_config(self, source: str = 'running') \u2011> scrapli_cfg.response.ScrapliCfgResponse 1 2 3 4 5 6 7 8 9 10 Commit a loaded configuration Args: source: name of the config source to commit against, generally running|startup Returns: ScrapliCfgResponse: response object Raises: N/A diff_config \u00b6 diff_config(self, source: str = 'running') \u2011> scrapli_cfg.diff.ScrapliCfgDiffResponse 1 2 3 4 5 6 7 8 9 10 11 12 Diff a loaded configuration against the source config store Args: source: name of the config source to diff against, generally running|startup -- device diffs will generally not care about this argument, but the built in scrapli differ will Returns: ScrapliCfgDiffResponse: scrapli cfg diff object Raises: N/A get_config \u00b6 get_config(self, source: str = 'running') \u2011> scrapli_cfg.response.ScrapliCfgResponse 1 2 3 4 5 6 7 8 9 10 11 Get device configuration Args: source: name of the config source, generally running|startup Returns: ScrapliCfgResponse: response object containing string of the target config source as the `result` attribute Raises: N/A get_version \u00b6 get_version(self) \u2011> scrapli_cfg.response.ScrapliCfgResponse 1 2 3 4 5 6 7 8 9 10 11 Get device version string Args: N/A Returns: ScrapliCfgResponse: response object where result is the string of the primary version (as in the \"main\" os version) of the device Raises: N/A load_config \u00b6 load_config(self, config: str, replace: bool = False, **kwargs: Any) \u2011> scrapli_cfg.response.ScrapliCfgResponse 1 2 3 4 5 6 7 8 9 10 11 12 13 14 Load configuration to a device Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see your specific platform for details Returns: ScrapliCfgResponse: response object Raises: N/A prepare \u00b6 prepare(self) \u2011> None 1 2 3 4 5 6 7 8 9 10 Prepare connection for scrapli_cfg operations Args: N/A Returns: None Raises: N/A render_substituted_config \u00b6 render_substituted_config(self, config_template: str, substitutes: List[Tuple[str, Pattern[str]]], source: str = 'running') \u2011> str 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 Render a substituted configuration file Renders a configuration based on a user template, substitutes, and a target config from the device. Args: config_template: config file to use as the base for substitutions -- should contain jinja2-like variables that will be replaced with data fetched from the source config by the substitutes patterns substitutes: tuple of name, pattern -- where name matches the jinja2-like variable in the config_template file, and pattern is a compiled regular expression pattern to be used to fetch that section from the source config source: config source to use for the substitution efforts, typically running|startup Returns: str: substituted/rendered config Raises: N/A","title":"Sync Platform"},{"location":"api_docs/platform/base/sync_platform/#module-scrapli_cfgplatformbasesync_platform","text":"scrapli_cfg.platform.sync_platform Expand source code \"\"\"scrapli_cfg.platform.sync_platform\"\"\" from abc import ABC, abstractmethod from types import TracebackType from typing import Any, Callable, List, Optional, Pattern, Tuple, Type from scrapli.driver import NetworkDriver from scrapli_cfg.diff import ScrapliCfgDiffResponse from scrapli_cfg.exceptions import ScrapliCfgException from scrapli_cfg.platform.base.base_platform import ScrapliCfgBase from scrapli_cfg.response import ScrapliCfgResponse class ScrapliCfgPlatform(ABC, ScrapliCfgBase): def __init__( self, conn: NetworkDriver, config_sources: List[str], on_prepare: Optional[Callable[..., Any]], dedicated_connection: bool, ignore_version: bool, ) -> None: \"\"\" Scrapli Config base class Args: conn: scrapli connection to use config_sources: list of config sources on_prepare: optional callable to run at connection `prepare` dedicated_connection: if `False` (default value) scrapli cfg will not open or close the underlying scrapli connection and will raise an exception if the scrapli connection is not open. If `True` will automatically open and close the scrapli connection when using with a context manager, `prepare` will open the scrapli connection (if not already open), and `close` will close the scrapli connection. ignore_version: ignore checking device version support; currently this just means that scrapli-cfg will not fetch the device version during the prepare phase, however this will (hopefully) be used in the future to limit what methods can be used against a target device. For example, for EOS devices we need > 4.14 to load configs; so if a device is encountered at 4.13 the version check would raise an exception rather than just failing in a potentially awkward fashion. Returns: None Raises: N/A \"\"\" self.conn: NetworkDriver = conn self.dedicated_connection = dedicated_connection self.on_prepare = on_prepare super().__init__(config_sources=config_sources, ignore_version=ignore_version) def __enter__(self) -> \"ScrapliCfgPlatform\": \"\"\" Enter method for context manager Args: N/A Returns: ScrapliCfg: opened ScrapliCfg object Raises: N/A \"\"\" self.prepare() return self def __exit__( self, exception_type: Optional[Type[BaseException]], exception_value: Optional[BaseException], traceback: Optional[TracebackType], ) -> None: \"\"\" Exit method to cleanup for context manager Args: exception_type: exception type being raised exception_value: message from exception being raised traceback: traceback from exception being raised Returns: None Raises: N/A \"\"\" self.cleanup() def _open(self) -> None: \"\"\" Handle opening (or raising exception if not open) of underlying scrapli connection Args: N/A Returns: None Raises: ScrapliCfgException: if scrapli connection is not open and auto_open_connection is False \"\"\" if self.conn.isalive(): return if self.dedicated_connection: self.logger.info( \"underlying scrapli connection is not alive... opening scrapli connection\" ) self.conn.open() return raise ScrapliCfgException( \"underlying scrapli connection is not open and `dedicated_connection` is False, \" \"cannot continue!\" ) def _close(self) -> None: \"\"\" Close the scrapli connection Args: N/A Returns: None Raises: N/A \"\"\" if self.dedicated_connection is True and self.conn.isalive(): self.logger.info(\"dedicated_connection is True, closing scrapli connection\") self.conn.close() def prepare(self) -> None: \"\"\" Prepare connection for scrapli_cfg operations Args: N/A Returns: None Raises: N/A \"\"\" self.logger.info(\"preparing scrapli_cfg connection\") self._open() if self.ignore_version is False: self.logger.debug(\"ignore_version is False, fetching device version\") version_response = self.get_version() self._validate_and_set_version(version_response=version_response) if self.on_prepare is not None: self.logger.debug(\"on_prepare provided, executing now\") self.on_prepare(self) self._prepared = True def cleanup(self) -> None: \"\"\" Cleanup after scrapli-cfg operations Generally this can be skipped, however it will be executed if using a context manager. The purpose of this method is to close the underlying scrapli connection (if in \"dedicated_connection\" mode), and to reset the internally used `_version_string`, attribute. All this is done so that this cfg connection, if re-used later (as in later in that script using the same object) starts with a fresh slate. Args: N/A Returns: None Raises: N/A \"\"\" self._close() # reset the version string/prepare flag so we know we need to re-fetch/re-run if user # re-opens connection self._version_string = \"\" self._prepared = False # this has *probably* been reset already, but reset it just in case user re-opens connection # we can have a clean slate to work with try: self._reset_config_session() # type: ignore except AttributeError: pass @abstractmethod def get_version(self) -> ScrapliCfgResponse: \"\"\" Get device version string Args: N/A Returns: ScrapliCfgResponse: response object where result is the string of the primary version (as in the \"main\" os version) of the device Raises: N/A \"\"\" @abstractmethod def get_config(self, source: str = \"running\") -> ScrapliCfgResponse: \"\"\" Get device configuration Args: source: name of the config source, generally running|startup Returns: ScrapliCfgResponse: response object containing string of the target config source as the `result` attribute Raises: N/A \"\"\" @abstractmethod def load_config(self, config: str, replace: bool = False, **kwargs: Any) -> ScrapliCfgResponse: \"\"\" Load configuration to a device Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see your specific platform for details Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" @abstractmethod def abort_config(self) -> ScrapliCfgResponse: \"\"\" Abort a configuration -- discards any loaded config Args: N/A Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" @abstractmethod def commit_config(self, source: str = \"running\") -> ScrapliCfgResponse: \"\"\" Commit a loaded configuration Args: source: name of the config source to commit against, generally running|startup Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" @abstractmethod def diff_config(self, source: str = \"running\") -> ScrapliCfgDiffResponse: \"\"\" Diff a loaded configuration against the source config store Args: source: name of the config source to diff against, generally running|startup -- device diffs will generally not care about this argument, but the built in scrapli differ will Returns: ScrapliCfgDiffResponse: scrapli cfg diff object Raises: N/A \"\"\" def render_substituted_config( self, config_template: str, substitutes: List[Tuple[str, Pattern[str]]], source: str = \"running\", ) -> str: \"\"\" Render a substituted configuration file Renders a configuration based on a user template, substitutes, and a target config from the device. Args: config_template: config file to use as the base for substitutions -- should contain jinja2-like variables that will be replaced with data fetched from the source config by the substitutes patterns substitutes: tuple of name, pattern -- where name matches the jinja2-like variable in the config_template file, and pattern is a compiled regular expression pattern to be used to fetch that section from the source config source: config source to use for the substitution efforts, typically running|startup Returns: str: substituted/rendered config Raises: N/A \"\"\" self.logger.info(\"fetching configuration and replacing with provided substitutes\") source_config = self.get_config(source=source) return self._render_substituted_config( config_template=config_template, substitutes=substitutes, source_config=source_config.result, )","title":"Module scrapli_cfg.platform.base.sync_platform"},{"location":"api_docs/platform/base/sync_platform/#classes","text":"","title":"Classes"},{"location":"api_docs/platform/base/sync_platform/#scraplicfgplatform","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 Helper class that provides a standard way to create an ABC using inheritance. Scrapli Config base class Args: conn: scrapli connection to use config_sources: list of config sources on_prepare: optional callable to run at connection `prepare` dedicated_connection: if `False` (default value) scrapli cfg will not open or close the underlying scrapli connection and will raise an exception if the scrapli connection is not open. If `True` will automatically open and close the scrapli connection when using with a context manager, `prepare` will open the scrapli connection (if not already open), and `close` will close the scrapli connection. ignore_version: ignore checking device version support; currently this just means that scrapli-cfg will not fetch the device version during the prepare phase, however this will (hopefully) be used in the future to limit what methods can be used against a target device. For example, for EOS devices we need > 4.14 to load configs; so if a device is encountered at 4.13 the version check would raise an exception rather than just failing in a potentially awkward fashion. Returns: None Raises: N/A Expand source code class ScrapliCfgPlatform(ABC, ScrapliCfgBase): def __init__( self, conn: NetworkDriver, config_sources: List[str], on_prepare: Optional[Callable[..., Any]], dedicated_connection: bool, ignore_version: bool, ) -> None: \"\"\" Scrapli Config base class Args: conn: scrapli connection to use config_sources: list of config sources on_prepare: optional callable to run at connection `prepare` dedicated_connection: if `False` (default value) scrapli cfg will not open or close the underlying scrapli connection and will raise an exception if the scrapli connection is not open. If `True` will automatically open and close the scrapli connection when using with a context manager, `prepare` will open the scrapli connection (if not already open), and `close` will close the scrapli connection. ignore_version: ignore checking device version support; currently this just means that scrapli-cfg will not fetch the device version during the prepare phase, however this will (hopefully) be used in the future to limit what methods can be used against a target device. For example, for EOS devices we need > 4.14 to load configs; so if a device is encountered at 4.13 the version check would raise an exception rather than just failing in a potentially awkward fashion. Returns: None Raises: N/A \"\"\" self.conn: NetworkDriver = conn self.dedicated_connection = dedicated_connection self.on_prepare = on_prepare super().__init__(config_sources=config_sources, ignore_version=ignore_version) def __enter__(self) -> \"ScrapliCfgPlatform\": \"\"\" Enter method for context manager Args: N/A Returns: ScrapliCfg: opened ScrapliCfg object Raises: N/A \"\"\" self.prepare() return self def __exit__( self, exception_type: Optional[Type[BaseException]], exception_value: Optional[BaseException], traceback: Optional[TracebackType], ) -> None: \"\"\" Exit method to cleanup for context manager Args: exception_type: exception type being raised exception_value: message from exception being raised traceback: traceback from exception being raised Returns: None Raises: N/A \"\"\" self.cleanup() def _open(self) -> None: \"\"\" Handle opening (or raising exception if not open) of underlying scrapli connection Args: N/A Returns: None Raises: ScrapliCfgException: if scrapli connection is not open and auto_open_connection is False \"\"\" if self.conn.isalive(): return if self.dedicated_connection: self.logger.info( \"underlying scrapli connection is not alive... opening scrapli connection\" ) self.conn.open() return raise ScrapliCfgException( \"underlying scrapli connection is not open and `dedicated_connection` is False, \" \"cannot continue!\" ) def _close(self) -> None: \"\"\" Close the scrapli connection Args: N/A Returns: None Raises: N/A \"\"\" if self.dedicated_connection is True and self.conn.isalive(): self.logger.info(\"dedicated_connection is True, closing scrapli connection\") self.conn.close() def prepare(self) -> None: \"\"\" Prepare connection for scrapli_cfg operations Args: N/A Returns: None Raises: N/A \"\"\" self.logger.info(\"preparing scrapli_cfg connection\") self._open() if self.ignore_version is False: self.logger.debug(\"ignore_version is False, fetching device version\") version_response = self.get_version() self._validate_and_set_version(version_response=version_response) if self.on_prepare is not None: self.logger.debug(\"on_prepare provided, executing now\") self.on_prepare(self) self._prepared = True def cleanup(self) -> None: \"\"\" Cleanup after scrapli-cfg operations Generally this can be skipped, however it will be executed if using a context manager. The purpose of this method is to close the underlying scrapli connection (if in \"dedicated_connection\" mode), and to reset the internally used `_version_string`, attribute. All this is done so that this cfg connection, if re-used later (as in later in that script using the same object) starts with a fresh slate. Args: N/A Returns: None Raises: N/A \"\"\" self._close() # reset the version string/prepare flag so we know we need to re-fetch/re-run if user # re-opens connection self._version_string = \"\" self._prepared = False # this has *probably* been reset already, but reset it just in case user re-opens connection # we can have a clean slate to work with try: self._reset_config_session() # type: ignore except AttributeError: pass @abstractmethod def get_version(self) -> ScrapliCfgResponse: \"\"\" Get device version string Args: N/A Returns: ScrapliCfgResponse: response object where result is the string of the primary version (as in the \"main\" os version) of the device Raises: N/A \"\"\" @abstractmethod def get_config(self, source: str = \"running\") -> ScrapliCfgResponse: \"\"\" Get device configuration Args: source: name of the config source, generally running|startup Returns: ScrapliCfgResponse: response object containing string of the target config source as the `result` attribute Raises: N/A \"\"\" @abstractmethod def load_config(self, config: str, replace: bool = False, **kwargs: Any) -> ScrapliCfgResponse: \"\"\" Load configuration to a device Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see your specific platform for details Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" @abstractmethod def abort_config(self) -> ScrapliCfgResponse: \"\"\" Abort a configuration -- discards any loaded config Args: N/A Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" @abstractmethod def commit_config(self, source: str = \"running\") -> ScrapliCfgResponse: \"\"\" Commit a loaded configuration Args: source: name of the config source to commit against, generally running|startup Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" @abstractmethod def diff_config(self, source: str = \"running\") -> ScrapliCfgDiffResponse: \"\"\" Diff a loaded configuration against the source config store Args: source: name of the config source to diff against, generally running|startup -- device diffs will generally not care about this argument, but the built in scrapli differ will Returns: ScrapliCfgDiffResponse: scrapli cfg diff object Raises: N/A \"\"\" def render_substituted_config( self, config_template: str, substitutes: List[Tuple[str, Pattern[str]]], source: str = \"running\", ) -> str: \"\"\" Render a substituted configuration file Renders a configuration based on a user template, substitutes, and a target config from the device. Args: config_template: config file to use as the base for substitutions -- should contain jinja2-like variables that will be replaced with data fetched from the source config by the substitutes patterns substitutes: tuple of name, pattern -- where name matches the jinja2-like variable in the config_template file, and pattern is a compiled regular expression pattern to be used to fetch that section from the source config source: config source to use for the substitution efforts, typically running|startup Returns: str: substituted/rendered config Raises: N/A \"\"\" self.logger.info(\"fetching configuration and replacing with provided substitutes\") source_config = self.get_config(source=source) return self._render_substituted_config( config_template=config_template, substitutes=substitutes, source_config=source_config.result, )","title":"ScrapliCfgPlatform"},{"location":"api_docs/platform/base/sync_platform/#ancestors-in-mro","text":"abc.ABC scrapli_cfg.platform.base.base_platform.ScrapliCfgBase","title":"Ancestors (in MRO)"},{"location":"api_docs/platform/base/sync_platform/#descendants","text":"scrapli_cfg.platform.core.arista_eos.sync_platform.ScrapliCfgEOS scrapli_cfg.platform.core.cisco_iosxe.sync_platform.ScrapliCfgIOSXE scrapli_cfg.platform.core.cisco_iosxr.sync_platform.ScrapliCfgIOSXR scrapli_cfg.platform.core.cisco_nxos.sync_platform.ScrapliCfgNXOS scrapli_cfg.platform.core.juniper_junos.sync_platform.ScrapliCfgJunos","title":"Descendants"},{"location":"api_docs/platform/base/sync_platform/#class-variables","text":"conn: Union[scrapli.driver.network.sync_driver.NetworkDriver, scrapli.driver.network.async_driver.AsyncNetworkDriver]","title":"Class variables"},{"location":"api_docs/platform/base/sync_platform/#methods","text":"","title":"Methods"},{"location":"api_docs/platform/base/sync_platform/#abort_config","text":"abort_config(self) \u2011> scrapli_cfg.response.ScrapliCfgResponse 1 2 3 4 5 6 7 8 9 10 Abort a configuration -- discards any loaded config Args: N/A Returns: ScrapliCfgResponse: response object Raises: N/A","title":"abort_config"},{"location":"api_docs/platform/base/sync_platform/#cleanup","text":"cleanup(self) \u2011> None 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 Cleanup after scrapli-cfg operations Generally this can be skipped, however it will be executed if using a context manager. The purpose of this method is to close the underlying scrapli connection (if in \"dedicated_connection\" mode), and to reset the internally used `_version_string`, attribute. All this is done so that this cfg connection, if re-used later (as in later in that script using the same object) starts with a fresh slate. Args: N/A Returns: None Raises: N/A","title":"cleanup"},{"location":"api_docs/platform/base/sync_platform/#commit_config","text":"commit_config(self, source: str = 'running') \u2011> scrapli_cfg.response.ScrapliCfgResponse 1 2 3 4 5 6 7 8 9 10 Commit a loaded configuration Args: source: name of the config source to commit against, generally running|startup Returns: ScrapliCfgResponse: response object Raises: N/A","title":"commit_config"},{"location":"api_docs/platform/base/sync_platform/#diff_config","text":"diff_config(self, source: str = 'running') \u2011> scrapli_cfg.diff.ScrapliCfgDiffResponse 1 2 3 4 5 6 7 8 9 10 11 12 Diff a loaded configuration against the source config store Args: source: name of the config source to diff against, generally running|startup -- device diffs will generally not care about this argument, but the built in scrapli differ will Returns: ScrapliCfgDiffResponse: scrapli cfg diff object Raises: N/A","title":"diff_config"},{"location":"api_docs/platform/base/sync_platform/#get_config","text":"get_config(self, source: str = 'running') \u2011> scrapli_cfg.response.ScrapliCfgResponse 1 2 3 4 5 6 7 8 9 10 11 Get device configuration Args: source: name of the config source, generally running|startup Returns: ScrapliCfgResponse: response object containing string of the target config source as the `result` attribute Raises: N/A","title":"get_config"},{"location":"api_docs/platform/base/sync_platform/#get_version","text":"get_version(self) \u2011> scrapli_cfg.response.ScrapliCfgResponse 1 2 3 4 5 6 7 8 9 10 11 Get device version string Args: N/A Returns: ScrapliCfgResponse: response object where result is the string of the primary version (as in the \"main\" os version) of the device Raises: N/A","title":"get_version"},{"location":"api_docs/platform/base/sync_platform/#load_config","text":"load_config(self, config: str, replace: bool = False, **kwargs: Any) \u2011> scrapli_cfg.response.ScrapliCfgResponse 1 2 3 4 5 6 7 8 9 10 11 12 13 14 Load configuration to a device Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see your specific platform for details Returns: ScrapliCfgResponse: response object Raises: N/A","title":"load_config"},{"location":"api_docs/platform/base/sync_platform/#prepare","text":"prepare(self) \u2011> None 1 2 3 4 5 6 7 8 9 10 Prepare connection for scrapli_cfg operations Args: N/A Returns: None Raises: N/A","title":"prepare"},{"location":"api_docs/platform/base/sync_platform/#render_substituted_config","text":"render_substituted_config(self, config_template: str, substitutes: List[Tuple[str, Pattern[str]]], source: str = 'running') \u2011> str 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 Render a substituted configuration file Renders a configuration based on a user template, substitutes, and a target config from the device. Args: config_template: config file to use as the base for substitutions -- should contain jinja2-like variables that will be replaced with data fetched from the source config by the substitutes patterns substitutes: tuple of name, pattern -- where name matches the jinja2-like variable in the config_template file, and pattern is a compiled regular expression pattern to be used to fetch that section from the source config source: config source to use for the substitution efforts, typically running|startup Returns: str: substituted/rendered config Raises: N/A","title":"render_substituted_config"},{"location":"api_docs/platform/core/arista_eos/async_platform/","text":"window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting()) Module scrapli_cfg.platform.core.arista_eos.async_platform \u00b6 scrapli_cfg.platform.core.arista_eos.async_platform Expand source code \"\"\"scrapli_cfg.platform.core.arista_eos.async_platform\"\"\" from typing import Any, Callable, List, Optional from scrapli.driver.core import AsyncEOSDriver from scrapli.response import MultiResponse, Response from scrapli_cfg.diff import ScrapliCfgDiffResponse from scrapli_cfg.exceptions import DiffConfigError, LoadConfigError, ScrapliCfgException from scrapli_cfg.platform.base.async_platform import AsyncScrapliCfgPlatform from scrapli_cfg.platform.core.arista_eos.base_platform import CONFIG_SOURCES, ScrapliCfgEOSBase from scrapli_cfg.response import ScrapliCfgResponse class AsyncScrapliCfgEOS(AsyncScrapliCfgPlatform, ScrapliCfgEOSBase): def __init__( self, conn: AsyncEOSDriver, *, config_sources: Optional[List[str]] = None, on_prepare: Optional[Callable[..., Any]] = None, dedicated_connection: bool = False, ignore_version: bool = False, ) -> None: if config_sources is None: config_sources = CONFIG_SOURCES super().__init__( conn=conn, config_sources=config_sources, on_prepare=on_prepare, dedicated_connection=dedicated_connection, ignore_version=ignore_version, ) self.conn: AsyncEOSDriver self.config_session_name = \"\" async def _clear_config_session(self, session_name: str) -> Response: \"\"\" Clear a configuration session Args: session_name: name of session to clear Returns: Response: scrapli response from clearing the session Raises: N/A \"\"\" # Note, early versions of eos supporting config sessions cant be aborted like this, but # i dont want to register a config session for each session we want to delete so we'll just # roll w/ this for now return await self.conn.send_command(command=f\"configure session {session_name} abort\") async def clear_config_sessions( self, session_name: str = \"\", session_prefix: str = \"\" ) -> ScrapliCfgResponse: \"\"\" Clear a specific config session or all sessions with a prefix (ex: scrapli_cfg_) Args: session_name: name of specific config session to clear session_prefix: prefix of session(s) to clear -- ignored if session_name is provided Returns: ScrapliCfgResponse: response object containing string of the target config source as the `result` attribute Raises: N/A \"\"\" scrapli_responses = [] response = self._pre_clear_config_sessions() try: get_config_sessions_result = await self.conn.send_command( command=\"show config sessions | json\" ) scrapli_responses.append(get_config_sessions_result) if get_config_sessions_result.failed: msg = \"failed to show current config sessions\" self.logger.critical(msg) raise ScrapliCfgException(msg) config_session_names = self._parse_config_sessions( device_output=get_config_sessions_result.result ) for config_session in config_session_names: if session_name: if config_session == session_name: clear_config_session_result = await self._clear_config_session( session_name=session_name ) scrapli_responses.append(clear_config_session_result) else: if config_session.startswith(session_prefix): clear_config_session_result = await self._clear_config_session( session_name=session_name ) scrapli_responses.append(clear_config_session_result) except ScrapliCfgException: pass return self._post_clear_config_sessions( response=response, scrapli_responses=scrapli_responses ) async def get_version(self) -> ScrapliCfgResponse: response = self._pre_get_version() version_result = await self.conn.send_command( command=\"show version | i Software image version\" ) return self._post_get_version( response=response, scrapli_responses=[version_result], result=self._parse_version(device_output=version_result.result), ) async def get_config(self, source: str = \"running\") -> ScrapliCfgResponse: response = self._pre_get_config(source=source) config_result = await self.conn.send_command( command=self._get_config_command(source=source) ) return self._post_get_config( response=response, source=source, scrapli_responses=[config_result], result=config_result.result, ) async def load_config( self, config: str, replace: bool = False, **kwargs: Any ) -> ScrapliCfgResponse: \"\"\" Load configuration to a device Supported kwargs: N/A Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for eos supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" scrapli_responses = [] response = self._pre_load_config(config=config) ( config, eager_config, register_config_session, ) = self._prepare_load_config_session_and_payload(config=config) if register_config_session: # only need to register a session if we havent -- we will reset session to an empty # string after any commits/aborts so we know if we are doing \"new\" operations self.conn.register_configuration_session(session_name=self.config_session_name) try: if replace: # default the config session - we only need to do this if we are doing a REPLACE rollback_clean_config_result = await self.conn.send_config( config=\"rollback clean-config\", privilege_level=self.config_session_name ) if rollback_clean_config_result.failed: msg = \"failed to load clean config in configuration session\" self.logger.critical(msg) raise LoadConfigError(msg) config_result = await self.conn.send_config( config=config, privilege_level=self.config_session_name ) scrapli_responses.append(config_result) if config_result.failed: msg = \"failed to load the candidate config into the config session\" self.logger.critical(msg) raise LoadConfigError(msg) # eager cuz banners and such; perhaps if no banner/macro we can disable eager though.... if eager_config: eager_config_result = await self.conn.send_config( config=eager_config, privilege_level=self.config_session_name, eager=True ) scrapli_responses.append(eager_config_result) if eager_config_result.failed: msg = \"failed to load the candidate config into the config session\" self.logger.critical(msg) raise LoadConfigError(msg) except LoadConfigError: # we catch our own exception so we dont need to do any if failed checks along the way # as soon as we hit this (or when we are done w/ the try block) we are done loading the # config and can build and return a response object pass return self._post_load_config( response=response, scrapli_responses=scrapli_responses, ) async def abort_config(self) -> ScrapliCfgResponse: response = self._pre_abort_config(session_or_config_file=bool(self.config_session_name)) await self.conn.acquire_priv(desired_priv=self.config_session_name) await self.conn._abort_config() # pylint: disable=W0212 self._reset_config_session() return self._post_abort_config( response=response, scrapli_responses=[], ) async def commit_config(self, source: str = \"running\") -> ScrapliCfgResponse: response = self._pre_commit_config( source=source, session_or_config_file=bool(self.config_session_name) ) commit_results = await self.conn.send_commands( commands=[ f\"configure session {self.config_session_name} commit\", \"copy running-config startup-config\", ] ) self._reset_config_session() return self._post_commit_config(response=response, scrapli_responses=[commit_results]) async def diff_config(self, source: str = \"running\") -> ScrapliCfgDiffResponse: scrapli_responses = [] device_diff = \"\" source_config = \"\" diff_response = self._pre_diff_config( source=source, session_or_config_file=bool(self.config_session_name) ) try: diff_result = await self.conn.send_config( config=\"show session-config diffs\", privilege_level=self.config_session_name ) scrapli_responses.append(diff_result) if diff_result.failed: msg = \"failed generating diff for config session\" self.logger.critical(msg) raise DiffConfigError(msg) device_diff = diff_result.result source_config_result = await self.get_config(source=source) source_config = source_config_result.result if isinstance(source_config_result.scrapli_responses, MultiResponse): # in this case this will always be a multiresponse or nothing (failure) but mypy # doesnt know that, hence the isinstance check scrapli_responses.extend(source_config_result.scrapli_responses) if source_config_result.failed: msg = \"failed fetching source config for diff comparison\" self.logger.critical(msg) raise DiffConfigError(msg) except DiffConfigError: pass return self._post_diff_config( diff_response=diff_response, scrapli_responses=scrapli_responses, source_config=self.clean_config(source_config), candidate_config=self.clean_config(self.candidate_config), device_diff=device_diff, ) Classes \u00b6 AsyncScrapliCfgEOS \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 Helper class that provides a standard way to create an ABC using inheritance. Scrapli Config async base class Args: conn: scrapli connection to use config_sources: list of config sources on_prepare: optional callable to run at connection `prepare` dedicated_connection: if `False` (default value) scrapli cfg will not open or close the underlying scrapli connection and will raise an exception if the scrapli connection is not open. If `True` will automatically open and close the scrapli connection when using with a context manager, `prepare` will open the scrapli connection (if not already open), and `close` will close the scrapli connection. ignore_version: ignore checking device version support; currently this just means that scrapli-cfg will not fetch the device version during the prepare phase, however this will (hopefully) be used in the future to limit what methods can be used against a target device. For example, for EOS devices we need > 4.14 to load configs; so if a device is encountered at 4.13 the version check would raise an exception rather than just failing in a potentially awkward fashion. Returns: None Raises: N/A Expand source code class AsyncScrapliCfgEOS(AsyncScrapliCfgPlatform, ScrapliCfgEOSBase): def __init__( self, conn: AsyncEOSDriver, *, config_sources: Optional[List[str]] = None, on_prepare: Optional[Callable[..., Any]] = None, dedicated_connection: bool = False, ignore_version: bool = False, ) -> None: if config_sources is None: config_sources = CONFIG_SOURCES super().__init__( conn=conn, config_sources=config_sources, on_prepare=on_prepare, dedicated_connection=dedicated_connection, ignore_version=ignore_version, ) self.conn: AsyncEOSDriver self.config_session_name = \"\" async def _clear_config_session(self, session_name: str) -> Response: \"\"\" Clear a configuration session Args: session_name: name of session to clear Returns: Response: scrapli response from clearing the session Raises: N/A \"\"\" # Note, early versions of eos supporting config sessions cant be aborted like this, but # i dont want to register a config session for each session we want to delete so we'll just # roll w/ this for now return await self.conn.send_command(command=f\"configure session {session_name} abort\") async def clear_config_sessions( self, session_name: str = \"\", session_prefix: str = \"\" ) -> ScrapliCfgResponse: \"\"\" Clear a specific config session or all sessions with a prefix (ex: scrapli_cfg_) Args: session_name: name of specific config session to clear session_prefix: prefix of session(s) to clear -- ignored if session_name is provided Returns: ScrapliCfgResponse: response object containing string of the target config source as the `result` attribute Raises: N/A \"\"\" scrapli_responses = [] response = self._pre_clear_config_sessions() try: get_config_sessions_result = await self.conn.send_command( command=\"show config sessions | json\" ) scrapli_responses.append(get_config_sessions_result) if get_config_sessions_result.failed: msg = \"failed to show current config sessions\" self.logger.critical(msg) raise ScrapliCfgException(msg) config_session_names = self._parse_config_sessions( device_output=get_config_sessions_result.result ) for config_session in config_session_names: if session_name: if config_session == session_name: clear_config_session_result = await self._clear_config_session( session_name=session_name ) scrapli_responses.append(clear_config_session_result) else: if config_session.startswith(session_prefix): clear_config_session_result = await self._clear_config_session( session_name=session_name ) scrapli_responses.append(clear_config_session_result) except ScrapliCfgException: pass return self._post_clear_config_sessions( response=response, scrapli_responses=scrapli_responses ) async def get_version(self) -> ScrapliCfgResponse: response = self._pre_get_version() version_result = await self.conn.send_command( command=\"show version | i Software image version\" ) return self._post_get_version( response=response, scrapli_responses=[version_result], result=self._parse_version(device_output=version_result.result), ) async def get_config(self, source: str = \"running\") -> ScrapliCfgResponse: response = self._pre_get_config(source=source) config_result = await self.conn.send_command( command=self._get_config_command(source=source) ) return self._post_get_config( response=response, source=source, scrapli_responses=[config_result], result=config_result.result, ) async def load_config( self, config: str, replace: bool = False, **kwargs: Any ) -> ScrapliCfgResponse: \"\"\" Load configuration to a device Supported kwargs: N/A Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for eos supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" scrapli_responses = [] response = self._pre_load_config(config=config) ( config, eager_config, register_config_session, ) = self._prepare_load_config_session_and_payload(config=config) if register_config_session: # only need to register a session if we havent -- we will reset session to an empty # string after any commits/aborts so we know if we are doing \"new\" operations self.conn.register_configuration_session(session_name=self.config_session_name) try: if replace: # default the config session - we only need to do this if we are doing a REPLACE rollback_clean_config_result = await self.conn.send_config( config=\"rollback clean-config\", privilege_level=self.config_session_name ) if rollback_clean_config_result.failed: msg = \"failed to load clean config in configuration session\" self.logger.critical(msg) raise LoadConfigError(msg) config_result = await self.conn.send_config( config=config, privilege_level=self.config_session_name ) scrapli_responses.append(config_result) if config_result.failed: msg = \"failed to load the candidate config into the config session\" self.logger.critical(msg) raise LoadConfigError(msg) # eager cuz banners and such; perhaps if no banner/macro we can disable eager though.... if eager_config: eager_config_result = await self.conn.send_config( config=eager_config, privilege_level=self.config_session_name, eager=True ) scrapli_responses.append(eager_config_result) if eager_config_result.failed: msg = \"failed to load the candidate config into the config session\" self.logger.critical(msg) raise LoadConfigError(msg) except LoadConfigError: # we catch our own exception so we dont need to do any if failed checks along the way # as soon as we hit this (or when we are done w/ the try block) we are done loading the # config and can build and return a response object pass return self._post_load_config( response=response, scrapli_responses=scrapli_responses, ) async def abort_config(self) -> ScrapliCfgResponse: response = self._pre_abort_config(session_or_config_file=bool(self.config_session_name)) await self.conn.acquire_priv(desired_priv=self.config_session_name) await self.conn._abort_config() # pylint: disable=W0212 self._reset_config_session() return self._post_abort_config( response=response, scrapli_responses=[], ) async def commit_config(self, source: str = \"running\") -> ScrapliCfgResponse: response = self._pre_commit_config( source=source, session_or_config_file=bool(self.config_session_name) ) commit_results = await self.conn.send_commands( commands=[ f\"configure session {self.config_session_name} commit\", \"copy running-config startup-config\", ] ) self._reset_config_session() return self._post_commit_config(response=response, scrapli_responses=[commit_results]) async def diff_config(self, source: str = \"running\") -> ScrapliCfgDiffResponse: scrapli_responses = [] device_diff = \"\" source_config = \"\" diff_response = self._pre_diff_config( source=source, session_or_config_file=bool(self.config_session_name) ) try: diff_result = await self.conn.send_config( config=\"show session-config diffs\", privilege_level=self.config_session_name ) scrapli_responses.append(diff_result) if diff_result.failed: msg = \"failed generating diff for config session\" self.logger.critical(msg) raise DiffConfigError(msg) device_diff = diff_result.result source_config_result = await self.get_config(source=source) source_config = source_config_result.result if isinstance(source_config_result.scrapli_responses, MultiResponse): # in this case this will always be a multiresponse or nothing (failure) but mypy # doesnt know that, hence the isinstance check scrapli_responses.extend(source_config_result.scrapli_responses) if source_config_result.failed: msg = \"failed fetching source config for diff comparison\" self.logger.critical(msg) raise DiffConfigError(msg) except DiffConfigError: pass return self._post_diff_config( diff_response=diff_response, scrapli_responses=scrapli_responses, source_config=self.clean_config(source_config), candidate_config=self.clean_config(self.candidate_config), device_diff=device_diff, ) Ancestors (in MRO) \u00b6 scrapli_cfg.platform.base.async_platform.AsyncScrapliCfgPlatform abc.ABC scrapli_cfg.platform.base.base_platform.ScrapliCfgBase scrapli_cfg.platform.core.arista_eos.base_platform.ScrapliCfgEOSBase Class variables \u00b6 conn: Union[scrapli.driver.network.sync_driver.NetworkDriver, scrapli.driver.network.async_driver.AsyncNetworkDriver] Methods \u00b6 clear_config_sessions \u00b6 clear_config_sessions(self, session_name: str = '', session_prefix: str = '') \u2011> scrapli_cfg.response.ScrapliCfgResponse 1 2 3 4 5 6 7 8 9 10 11 12 Clear a specific config session or all sessions with a prefix (ex: scrapli_cfg_) Args: session_name: name of specific config session to clear session_prefix: prefix of session(s) to clear -- ignored if session_name is provided Returns: ScrapliCfgResponse: response object containing string of the target config source as the `result` attribute Raises: N/A load_config \u00b6 load_config(self, config: str, replace: bool = False, **kwargs: Any) \u2011> scrapli_cfg.response.ScrapliCfgResponse 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 Load configuration to a device Supported kwargs: N/A Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for eos supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A","title":"Async Platform"},{"location":"api_docs/platform/core/arista_eos/async_platform/#module-scrapli_cfgplatformcorearista_eosasync_platform","text":"scrapli_cfg.platform.core.arista_eos.async_platform Expand source code \"\"\"scrapli_cfg.platform.core.arista_eos.async_platform\"\"\" from typing import Any, Callable, List, Optional from scrapli.driver.core import AsyncEOSDriver from scrapli.response import MultiResponse, Response from scrapli_cfg.diff import ScrapliCfgDiffResponse from scrapli_cfg.exceptions import DiffConfigError, LoadConfigError, ScrapliCfgException from scrapli_cfg.platform.base.async_platform import AsyncScrapliCfgPlatform from scrapli_cfg.platform.core.arista_eos.base_platform import CONFIG_SOURCES, ScrapliCfgEOSBase from scrapli_cfg.response import ScrapliCfgResponse class AsyncScrapliCfgEOS(AsyncScrapliCfgPlatform, ScrapliCfgEOSBase): def __init__( self, conn: AsyncEOSDriver, *, config_sources: Optional[List[str]] = None, on_prepare: Optional[Callable[..., Any]] = None, dedicated_connection: bool = False, ignore_version: bool = False, ) -> None: if config_sources is None: config_sources = CONFIG_SOURCES super().__init__( conn=conn, config_sources=config_sources, on_prepare=on_prepare, dedicated_connection=dedicated_connection, ignore_version=ignore_version, ) self.conn: AsyncEOSDriver self.config_session_name = \"\" async def _clear_config_session(self, session_name: str) -> Response: \"\"\" Clear a configuration session Args: session_name: name of session to clear Returns: Response: scrapli response from clearing the session Raises: N/A \"\"\" # Note, early versions of eos supporting config sessions cant be aborted like this, but # i dont want to register a config session for each session we want to delete so we'll just # roll w/ this for now return await self.conn.send_command(command=f\"configure session {session_name} abort\") async def clear_config_sessions( self, session_name: str = \"\", session_prefix: str = \"\" ) -> ScrapliCfgResponse: \"\"\" Clear a specific config session or all sessions with a prefix (ex: scrapli_cfg_) Args: session_name: name of specific config session to clear session_prefix: prefix of session(s) to clear -- ignored if session_name is provided Returns: ScrapliCfgResponse: response object containing string of the target config source as the `result` attribute Raises: N/A \"\"\" scrapli_responses = [] response = self._pre_clear_config_sessions() try: get_config_sessions_result = await self.conn.send_command( command=\"show config sessions | json\" ) scrapli_responses.append(get_config_sessions_result) if get_config_sessions_result.failed: msg = \"failed to show current config sessions\" self.logger.critical(msg) raise ScrapliCfgException(msg) config_session_names = self._parse_config_sessions( device_output=get_config_sessions_result.result ) for config_session in config_session_names: if session_name: if config_session == session_name: clear_config_session_result = await self._clear_config_session( session_name=session_name ) scrapli_responses.append(clear_config_session_result) else: if config_session.startswith(session_prefix): clear_config_session_result = await self._clear_config_session( session_name=session_name ) scrapli_responses.append(clear_config_session_result) except ScrapliCfgException: pass return self._post_clear_config_sessions( response=response, scrapli_responses=scrapli_responses ) async def get_version(self) -> ScrapliCfgResponse: response = self._pre_get_version() version_result = await self.conn.send_command( command=\"show version | i Software image version\" ) return self._post_get_version( response=response, scrapli_responses=[version_result], result=self._parse_version(device_output=version_result.result), ) async def get_config(self, source: str = \"running\") -> ScrapliCfgResponse: response = self._pre_get_config(source=source) config_result = await self.conn.send_command( command=self._get_config_command(source=source) ) return self._post_get_config( response=response, source=source, scrapli_responses=[config_result], result=config_result.result, ) async def load_config( self, config: str, replace: bool = False, **kwargs: Any ) -> ScrapliCfgResponse: \"\"\" Load configuration to a device Supported kwargs: N/A Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for eos supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" scrapli_responses = [] response = self._pre_load_config(config=config) ( config, eager_config, register_config_session, ) = self._prepare_load_config_session_and_payload(config=config) if register_config_session: # only need to register a session if we havent -- we will reset session to an empty # string after any commits/aborts so we know if we are doing \"new\" operations self.conn.register_configuration_session(session_name=self.config_session_name) try: if replace: # default the config session - we only need to do this if we are doing a REPLACE rollback_clean_config_result = await self.conn.send_config( config=\"rollback clean-config\", privilege_level=self.config_session_name ) if rollback_clean_config_result.failed: msg = \"failed to load clean config in configuration session\" self.logger.critical(msg) raise LoadConfigError(msg) config_result = await self.conn.send_config( config=config, privilege_level=self.config_session_name ) scrapli_responses.append(config_result) if config_result.failed: msg = \"failed to load the candidate config into the config session\" self.logger.critical(msg) raise LoadConfigError(msg) # eager cuz banners and such; perhaps if no banner/macro we can disable eager though.... if eager_config: eager_config_result = await self.conn.send_config( config=eager_config, privilege_level=self.config_session_name, eager=True ) scrapli_responses.append(eager_config_result) if eager_config_result.failed: msg = \"failed to load the candidate config into the config session\" self.logger.critical(msg) raise LoadConfigError(msg) except LoadConfigError: # we catch our own exception so we dont need to do any if failed checks along the way # as soon as we hit this (or when we are done w/ the try block) we are done loading the # config and can build and return a response object pass return self._post_load_config( response=response, scrapli_responses=scrapli_responses, ) async def abort_config(self) -> ScrapliCfgResponse: response = self._pre_abort_config(session_or_config_file=bool(self.config_session_name)) await self.conn.acquire_priv(desired_priv=self.config_session_name) await self.conn._abort_config() # pylint: disable=W0212 self._reset_config_session() return self._post_abort_config( response=response, scrapli_responses=[], ) async def commit_config(self, source: str = \"running\") -> ScrapliCfgResponse: response = self._pre_commit_config( source=source, session_or_config_file=bool(self.config_session_name) ) commit_results = await self.conn.send_commands( commands=[ f\"configure session {self.config_session_name} commit\", \"copy running-config startup-config\", ] ) self._reset_config_session() return self._post_commit_config(response=response, scrapli_responses=[commit_results]) async def diff_config(self, source: str = \"running\") -> ScrapliCfgDiffResponse: scrapli_responses = [] device_diff = \"\" source_config = \"\" diff_response = self._pre_diff_config( source=source, session_or_config_file=bool(self.config_session_name) ) try: diff_result = await self.conn.send_config( config=\"show session-config diffs\", privilege_level=self.config_session_name ) scrapli_responses.append(diff_result) if diff_result.failed: msg = \"failed generating diff for config session\" self.logger.critical(msg) raise DiffConfigError(msg) device_diff = diff_result.result source_config_result = await self.get_config(source=source) source_config = source_config_result.result if isinstance(source_config_result.scrapli_responses, MultiResponse): # in this case this will always be a multiresponse or nothing (failure) but mypy # doesnt know that, hence the isinstance check scrapli_responses.extend(source_config_result.scrapli_responses) if source_config_result.failed: msg = \"failed fetching source config for diff comparison\" self.logger.critical(msg) raise DiffConfigError(msg) except DiffConfigError: pass return self._post_diff_config( diff_response=diff_response, scrapli_responses=scrapli_responses, source_config=self.clean_config(source_config), candidate_config=self.clean_config(self.candidate_config), device_diff=device_diff, )","title":"Module scrapli_cfg.platform.core.arista_eos.async_platform"},{"location":"api_docs/platform/core/arista_eos/async_platform/#classes","text":"","title":"Classes"},{"location":"api_docs/platform/core/arista_eos/async_platform/#asyncscraplicfgeos","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 Helper class that provides a standard way to create an ABC using inheritance. Scrapli Config async base class Args: conn: scrapli connection to use config_sources: list of config sources on_prepare: optional callable to run at connection `prepare` dedicated_connection: if `False` (default value) scrapli cfg will not open or close the underlying scrapli connection and will raise an exception if the scrapli connection is not open. If `True` will automatically open and close the scrapli connection when using with a context manager, `prepare` will open the scrapli connection (if not already open), and `close` will close the scrapli connection. ignore_version: ignore checking device version support; currently this just means that scrapli-cfg will not fetch the device version during the prepare phase, however this will (hopefully) be used in the future to limit what methods can be used against a target device. For example, for EOS devices we need > 4.14 to load configs; so if a device is encountered at 4.13 the version check would raise an exception rather than just failing in a potentially awkward fashion. Returns: None Raises: N/A Expand source code class AsyncScrapliCfgEOS(AsyncScrapliCfgPlatform, ScrapliCfgEOSBase): def __init__( self, conn: AsyncEOSDriver, *, config_sources: Optional[List[str]] = None, on_prepare: Optional[Callable[..., Any]] = None, dedicated_connection: bool = False, ignore_version: bool = False, ) -> None: if config_sources is None: config_sources = CONFIG_SOURCES super().__init__( conn=conn, config_sources=config_sources, on_prepare=on_prepare, dedicated_connection=dedicated_connection, ignore_version=ignore_version, ) self.conn: AsyncEOSDriver self.config_session_name = \"\" async def _clear_config_session(self, session_name: str) -> Response: \"\"\" Clear a configuration session Args: session_name: name of session to clear Returns: Response: scrapli response from clearing the session Raises: N/A \"\"\" # Note, early versions of eos supporting config sessions cant be aborted like this, but # i dont want to register a config session for each session we want to delete so we'll just # roll w/ this for now return await self.conn.send_command(command=f\"configure session {session_name} abort\") async def clear_config_sessions( self, session_name: str = \"\", session_prefix: str = \"\" ) -> ScrapliCfgResponse: \"\"\" Clear a specific config session or all sessions with a prefix (ex: scrapli_cfg_) Args: session_name: name of specific config session to clear session_prefix: prefix of session(s) to clear -- ignored if session_name is provided Returns: ScrapliCfgResponse: response object containing string of the target config source as the `result` attribute Raises: N/A \"\"\" scrapli_responses = [] response = self._pre_clear_config_sessions() try: get_config_sessions_result = await self.conn.send_command( command=\"show config sessions | json\" ) scrapli_responses.append(get_config_sessions_result) if get_config_sessions_result.failed: msg = \"failed to show current config sessions\" self.logger.critical(msg) raise ScrapliCfgException(msg) config_session_names = self._parse_config_sessions( device_output=get_config_sessions_result.result ) for config_session in config_session_names: if session_name: if config_session == session_name: clear_config_session_result = await self._clear_config_session( session_name=session_name ) scrapli_responses.append(clear_config_session_result) else: if config_session.startswith(session_prefix): clear_config_session_result = await self._clear_config_session( session_name=session_name ) scrapli_responses.append(clear_config_session_result) except ScrapliCfgException: pass return self._post_clear_config_sessions( response=response, scrapli_responses=scrapli_responses ) async def get_version(self) -> ScrapliCfgResponse: response = self._pre_get_version() version_result = await self.conn.send_command( command=\"show version | i Software image version\" ) return self._post_get_version( response=response, scrapli_responses=[version_result], result=self._parse_version(device_output=version_result.result), ) async def get_config(self, source: str = \"running\") -> ScrapliCfgResponse: response = self._pre_get_config(source=source) config_result = await self.conn.send_command( command=self._get_config_command(source=source) ) return self._post_get_config( response=response, source=source, scrapli_responses=[config_result], result=config_result.result, ) async def load_config( self, config: str, replace: bool = False, **kwargs: Any ) -> ScrapliCfgResponse: \"\"\" Load configuration to a device Supported kwargs: N/A Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for eos supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" scrapli_responses = [] response = self._pre_load_config(config=config) ( config, eager_config, register_config_session, ) = self._prepare_load_config_session_and_payload(config=config) if register_config_session: # only need to register a session if we havent -- we will reset session to an empty # string after any commits/aborts so we know if we are doing \"new\" operations self.conn.register_configuration_session(session_name=self.config_session_name) try: if replace: # default the config session - we only need to do this if we are doing a REPLACE rollback_clean_config_result = await self.conn.send_config( config=\"rollback clean-config\", privilege_level=self.config_session_name ) if rollback_clean_config_result.failed: msg = \"failed to load clean config in configuration session\" self.logger.critical(msg) raise LoadConfigError(msg) config_result = await self.conn.send_config( config=config, privilege_level=self.config_session_name ) scrapli_responses.append(config_result) if config_result.failed: msg = \"failed to load the candidate config into the config session\" self.logger.critical(msg) raise LoadConfigError(msg) # eager cuz banners and such; perhaps if no banner/macro we can disable eager though.... if eager_config: eager_config_result = await self.conn.send_config( config=eager_config, privilege_level=self.config_session_name, eager=True ) scrapli_responses.append(eager_config_result) if eager_config_result.failed: msg = \"failed to load the candidate config into the config session\" self.logger.critical(msg) raise LoadConfigError(msg) except LoadConfigError: # we catch our own exception so we dont need to do any if failed checks along the way # as soon as we hit this (or when we are done w/ the try block) we are done loading the # config and can build and return a response object pass return self._post_load_config( response=response, scrapli_responses=scrapli_responses, ) async def abort_config(self) -> ScrapliCfgResponse: response = self._pre_abort_config(session_or_config_file=bool(self.config_session_name)) await self.conn.acquire_priv(desired_priv=self.config_session_name) await self.conn._abort_config() # pylint: disable=W0212 self._reset_config_session() return self._post_abort_config( response=response, scrapli_responses=[], ) async def commit_config(self, source: str = \"running\") -> ScrapliCfgResponse: response = self._pre_commit_config( source=source, session_or_config_file=bool(self.config_session_name) ) commit_results = await self.conn.send_commands( commands=[ f\"configure session {self.config_session_name} commit\", \"copy running-config startup-config\", ] ) self._reset_config_session() return self._post_commit_config(response=response, scrapli_responses=[commit_results]) async def diff_config(self, source: str = \"running\") -> ScrapliCfgDiffResponse: scrapli_responses = [] device_diff = \"\" source_config = \"\" diff_response = self._pre_diff_config( source=source, session_or_config_file=bool(self.config_session_name) ) try: diff_result = await self.conn.send_config( config=\"show session-config diffs\", privilege_level=self.config_session_name ) scrapli_responses.append(diff_result) if diff_result.failed: msg = \"failed generating diff for config session\" self.logger.critical(msg) raise DiffConfigError(msg) device_diff = diff_result.result source_config_result = await self.get_config(source=source) source_config = source_config_result.result if isinstance(source_config_result.scrapli_responses, MultiResponse): # in this case this will always be a multiresponse or nothing (failure) but mypy # doesnt know that, hence the isinstance check scrapli_responses.extend(source_config_result.scrapli_responses) if source_config_result.failed: msg = \"failed fetching source config for diff comparison\" self.logger.critical(msg) raise DiffConfigError(msg) except DiffConfigError: pass return self._post_diff_config( diff_response=diff_response, scrapli_responses=scrapli_responses, source_config=self.clean_config(source_config), candidate_config=self.clean_config(self.candidate_config), device_diff=device_diff, )","title":"AsyncScrapliCfgEOS"},{"location":"api_docs/platform/core/arista_eos/async_platform/#ancestors-in-mro","text":"scrapli_cfg.platform.base.async_platform.AsyncScrapliCfgPlatform abc.ABC scrapli_cfg.platform.base.base_platform.ScrapliCfgBase scrapli_cfg.platform.core.arista_eos.base_platform.ScrapliCfgEOSBase","title":"Ancestors (in MRO)"},{"location":"api_docs/platform/core/arista_eos/async_platform/#class-variables","text":"conn: Union[scrapli.driver.network.sync_driver.NetworkDriver, scrapli.driver.network.async_driver.AsyncNetworkDriver]","title":"Class variables"},{"location":"api_docs/platform/core/arista_eos/async_platform/#methods","text":"","title":"Methods"},{"location":"api_docs/platform/core/arista_eos/async_platform/#clear_config_sessions","text":"clear_config_sessions(self, session_name: str = '', session_prefix: str = '') \u2011> scrapli_cfg.response.ScrapliCfgResponse 1 2 3 4 5 6 7 8 9 10 11 12 Clear a specific config session or all sessions with a prefix (ex: scrapli_cfg_) Args: session_name: name of specific config session to clear session_prefix: prefix of session(s) to clear -- ignored if session_name is provided Returns: ScrapliCfgResponse: response object containing string of the target config source as the `result` attribute Raises: N/A","title":"clear_config_sessions"},{"location":"api_docs/platform/core/arista_eos/async_platform/#load_config","text":"load_config(self, config: str, replace: bool = False, **kwargs: Any) \u2011> scrapli_cfg.response.ScrapliCfgResponse 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 Load configuration to a device Supported kwargs: N/A Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for eos supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A","title":"load_config"},{"location":"api_docs/platform/core/arista_eos/base_platform/","text":"window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting()) Module scrapli_cfg.platform.core.arista_eos.base_platform \u00b6 scrapli_cfg.platform.core.arista_eos.base Expand source code \"\"\"scrapli_cfg.platform.core.arista_eos.base\"\"\" import json import re from datetime import datetime from logging import Logger, LoggerAdapter from typing import TYPE_CHECKING, Iterable, List, Tuple, Union from scrapli.driver import AsyncNetworkDriver, NetworkDriver from scrapli.response import Response from scrapli_cfg.exceptions import ScrapliCfgException from scrapli_cfg.helper import strip_blank_lines from scrapli_cfg.platform.core.arista_eos.patterns import ( BANNER_PATTERN, END_PATTERN, GLOBAL_COMMENT_LINE_PATTERN, VERSION_PATTERN, ) from scrapli_cfg.response import ScrapliCfgResponse if TYPE_CHECKING: LoggerAdapterT = LoggerAdapter[Logger] # pylint:disable=E1136 else: LoggerAdapterT = LoggerAdapter CONFIG_SOURCES = [ \"running\", \"startup\", ] class ScrapliCfgEOSBase: conn: Union[NetworkDriver, AsyncNetworkDriver] logger: LoggerAdapterT config_sources: List[str] config_session_name: str candidate_config: str @staticmethod def _parse_version(device_output: str) -> str: \"\"\" Parse version string out of device output Args: device_output: output from show version command Returns: str: device version string Raises: N/A \"\"\" version_string_search = re.search(pattern=VERSION_PATTERN, string=device_output) if not version_string_search: return \"\" version_string = version_string_search.group(0) or \"\" return version_string @staticmethod def _parse_config_sessions(device_output: str) -> List[str]: \"\"\" Parse config session names out of device output Args: device_output: output from show version command Returns: list[str]: config session names Raises: N/A \"\"\" try: config_session_dict = json.loads(device_output) except json.JSONDecodeError: return [] sessions = list(config_session_dict.get(\"sessions\", {})) return sessions @staticmethod def _get_config_command(source: str) -> str: \"\"\" Return command to use to get config based on the provided source Args: source: name of the config source, generally running|startup Returns: str: command to use to fetch the requested config Raises: N/A \"\"\" if source == \"running\": return \"show running-config\" return \"show startup-config\" @staticmethod def _prepare_config_payloads(config: str) -> Tuple[str, str]: \"\"\" Prepare a configuration so it can be nicely sent to the device via scrapli Args: config: configuration to prep Returns: tuple: tuple of \"normal\" config lines and \"eager\" config lines Raises: N/A \"\"\" # remove comment lines config = re.sub(pattern=GLOBAL_COMMENT_LINE_PATTERN, repl=\"!\", string=config) # remove \"end\" at the end of config if present - if its present it will drop scrapli out # of the config session which we do not want config = re.sub(pattern=END_PATTERN, repl=\"!\", string=config) # find all sections that need to be \"eagerly\" sent eager_config = re.findall(pattern=BANNER_PATTERN, string=config) for eager_section in eager_config: config = config.replace(eager_section, \"!\") joined_eager_config = \"\\n\".join(captured_section for captured_section in eager_config) return config, joined_eager_config def _prepare_load_config_session_and_payload(self, config: str) -> Tuple[str, str, bool]: \"\"\" Prepare the normal and eager payloads and decide if we need to register a config session Args: config: candidate config to load Returns: tuple: tuple containing \"normal\" config elements to send to the device and \"eager\" mode config elements to send to the device (things like banners/macro that require scrapli \"eager=True\"), and lastly a bool indicating if the config session needs to be registered on the device Raises: N/A \"\"\" config, eager_config = self._prepare_config_payloads(config=config) register_config_session = False if not self.config_session_name: self.config_session_name = f\"scrapli_cfg_{round(datetime.now().timestamp())}\" self.logger.debug(f\"configuration session name will be '{self.config_session_name}'\") register_config_session = True return config, eager_config, register_config_session def _reset_config_session(self) -> None: \"\"\" Reset config session info Resets the candidate config and config session name attributes -- when these are \"empty\" we know there is no current config session Args: N/A Returns: None Raises: N/A \"\"\" self.logger.debug(\"resetting candidate config and config session name\") self.candidate_config = \"\" self.config_session_name = \"\" def clean_config(self, config: str) -> str: \"\"\" Clean a configuration file of unwanted lines Args: config: configuration string to \"clean\"; remove all comment lines from both the source and candidate configs -- this is only done here pre-diff, so we dont modify the user provided candidate config which can totally have those comment lines - we only remove \"global\" (top level) comments though... user comments attached to interfaces and the stuff will remain Returns: str: cleaned configuration string Raises: N/A \"\"\" self.logger.debug(\"cleaning config file\") return strip_blank_lines( config=re.sub(pattern=GLOBAL_COMMENT_LINE_PATTERN, string=config, repl=\"\") ) def _pre_clear_config_sessions(self) -> ScrapliCfgResponse: \"\"\" Handle pre \"clear_config_sessions\" operations for parity between sync and async Args: N/A Returns: ScrapliCfgResponse: new response object to update w/ get results Raises: N/A \"\"\" self.logger.info(\"clear_config_sessions requested\") response = ScrapliCfgResponse( host=self.conn.host, raise_for_status_exception=ScrapliCfgException ) return response def _post_clear_config_sessions( self, response: ScrapliCfgResponse, scrapli_responses: Iterable[Response], ) -> ScrapliCfgResponse: \"\"\" Handle post \"clear_config_sessions\" operations for parity between sync and async Args: response: response object to update scrapli_responses: list of scrapli response objects from fetching the version Returns: ScrapliCfgResponse: response object containing string of the version as the `result` attribute Raises: N/A \"\"\" response.record_response(scrapli_responses=scrapli_responses) if response.failed: msg = \"failed to clear device configuration session(s)\" self.logger.critical(msg) response.result = msg else: response.result = \"configuration session(s) cleared\" return response Classes \u00b6 ScrapliCfgEOSBase \u00b6 Expand source code class ScrapliCfgEOSBase: conn: Union[NetworkDriver, AsyncNetworkDriver] logger: LoggerAdapterT config_sources: List[str] config_session_name: str candidate_config: str @staticmethod def _parse_version(device_output: str) -> str: \"\"\" Parse version string out of device output Args: device_output: output from show version command Returns: str: device version string Raises: N/A \"\"\" version_string_search = re.search(pattern=VERSION_PATTERN, string=device_output) if not version_string_search: return \"\" version_string = version_string_search.group(0) or \"\" return version_string @staticmethod def _parse_config_sessions(device_output: str) -> List[str]: \"\"\" Parse config session names out of device output Args: device_output: output from show version command Returns: list[str]: config session names Raises: N/A \"\"\" try: config_session_dict = json.loads(device_output) except json.JSONDecodeError: return [] sessions = list(config_session_dict.get(\"sessions\", {})) return sessions @staticmethod def _get_config_command(source: str) -> str: \"\"\" Return command to use to get config based on the provided source Args: source: name of the config source, generally running|startup Returns: str: command to use to fetch the requested config Raises: N/A \"\"\" if source == \"running\": return \"show running-config\" return \"show startup-config\" @staticmethod def _prepare_config_payloads(config: str) -> Tuple[str, str]: \"\"\" Prepare a configuration so it can be nicely sent to the device via scrapli Args: config: configuration to prep Returns: tuple: tuple of \"normal\" config lines and \"eager\" config lines Raises: N/A \"\"\" # remove comment lines config = re.sub(pattern=GLOBAL_COMMENT_LINE_PATTERN, repl=\"!\", string=config) # remove \"end\" at the end of config if present - if its present it will drop scrapli out # of the config session which we do not want config = re.sub(pattern=END_PATTERN, repl=\"!\", string=config) # find all sections that need to be \"eagerly\" sent eager_config = re.findall(pattern=BANNER_PATTERN, string=config) for eager_section in eager_config: config = config.replace(eager_section, \"!\") joined_eager_config = \"\\n\".join(captured_section for captured_section in eager_config) return config, joined_eager_config def _prepare_load_config_session_and_payload(self, config: str) -> Tuple[str, str, bool]: \"\"\" Prepare the normal and eager payloads and decide if we need to register a config session Args: config: candidate config to load Returns: tuple: tuple containing \"normal\" config elements to send to the device and \"eager\" mode config elements to send to the device (things like banners/macro that require scrapli \"eager=True\"), and lastly a bool indicating if the config session needs to be registered on the device Raises: N/A \"\"\" config, eager_config = self._prepare_config_payloads(config=config) register_config_session = False if not self.config_session_name: self.config_session_name = f\"scrapli_cfg_{round(datetime.now().timestamp())}\" self.logger.debug(f\"configuration session name will be '{self.config_session_name}'\") register_config_session = True return config, eager_config, register_config_session def _reset_config_session(self) -> None: \"\"\" Reset config session info Resets the candidate config and config session name attributes -- when these are \"empty\" we know there is no current config session Args: N/A Returns: None Raises: N/A \"\"\" self.logger.debug(\"resetting candidate config and config session name\") self.candidate_config = \"\" self.config_session_name = \"\" def clean_config(self, config: str) -> str: \"\"\" Clean a configuration file of unwanted lines Args: config: configuration string to \"clean\"; remove all comment lines from both the source and candidate configs -- this is only done here pre-diff, so we dont modify the user provided candidate config which can totally have those comment lines - we only remove \"global\" (top level) comments though... user comments attached to interfaces and the stuff will remain Returns: str: cleaned configuration string Raises: N/A \"\"\" self.logger.debug(\"cleaning config file\") return strip_blank_lines( config=re.sub(pattern=GLOBAL_COMMENT_LINE_PATTERN, string=config, repl=\"\") ) def _pre_clear_config_sessions(self) -> ScrapliCfgResponse: \"\"\" Handle pre \"clear_config_sessions\" operations for parity between sync and async Args: N/A Returns: ScrapliCfgResponse: new response object to update w/ get results Raises: N/A \"\"\" self.logger.info(\"clear_config_sessions requested\") response = ScrapliCfgResponse( host=self.conn.host, raise_for_status_exception=ScrapliCfgException ) return response def _post_clear_config_sessions( self, response: ScrapliCfgResponse, scrapli_responses: Iterable[Response], ) -> ScrapliCfgResponse: \"\"\" Handle post \"clear_config_sessions\" operations for parity between sync and async Args: response: response object to update scrapli_responses: list of scrapli response objects from fetching the version Returns: ScrapliCfgResponse: response object containing string of the version as the `result` attribute Raises: N/A \"\"\" response.record_response(scrapli_responses=scrapli_responses) if response.failed: msg = \"failed to clear device configuration session(s)\" self.logger.critical(msg) response.result = msg else: response.result = \"configuration session(s) cleared\" return response Descendants \u00b6 scrapli_cfg.platform.core.arista_eos.async_platform.AsyncScrapliCfgEOS scrapli_cfg.platform.core.arista_eos.sync_platform.ScrapliCfgEOS Class variables \u00b6 candidate_config: str config_session_name: str config_sources: List[str] conn: Union[scrapli.driver.network.sync_driver.NetworkDriver, scrapli.driver.network.async_driver.AsyncNetworkDriver] logger: logging.LoggerAdapter Methods \u00b6 clean_config \u00b6 clean_config(self, config: str) \u2011> str 1 2 3 4 5 6 7 8 9 10 11 12 13 14 Clean a configuration file of unwanted lines Args: config: configuration string to \"clean\"; remove all comment lines from both the source and candidate configs -- this is only done here pre-diff, so we dont modify the user provided candidate config which can totally have those comment lines - we only remove \"global\" (top level) comments though... user comments attached to interfaces and the stuff will remain Returns: str: cleaned configuration string Raises: N/A","title":"Base platform"},{"location":"api_docs/platform/core/arista_eos/base_platform/#module-scrapli_cfgplatformcorearista_eosbase_platform","text":"scrapli_cfg.platform.core.arista_eos.base Expand source code \"\"\"scrapli_cfg.platform.core.arista_eos.base\"\"\" import json import re from datetime import datetime from logging import Logger, LoggerAdapter from typing import TYPE_CHECKING, Iterable, List, Tuple, Union from scrapli.driver import AsyncNetworkDriver, NetworkDriver from scrapli.response import Response from scrapli_cfg.exceptions import ScrapliCfgException from scrapli_cfg.helper import strip_blank_lines from scrapli_cfg.platform.core.arista_eos.patterns import ( BANNER_PATTERN, END_PATTERN, GLOBAL_COMMENT_LINE_PATTERN, VERSION_PATTERN, ) from scrapli_cfg.response import ScrapliCfgResponse if TYPE_CHECKING: LoggerAdapterT = LoggerAdapter[Logger] # pylint:disable=E1136 else: LoggerAdapterT = LoggerAdapter CONFIG_SOURCES = [ \"running\", \"startup\", ] class ScrapliCfgEOSBase: conn: Union[NetworkDriver, AsyncNetworkDriver] logger: LoggerAdapterT config_sources: List[str] config_session_name: str candidate_config: str @staticmethod def _parse_version(device_output: str) -> str: \"\"\" Parse version string out of device output Args: device_output: output from show version command Returns: str: device version string Raises: N/A \"\"\" version_string_search = re.search(pattern=VERSION_PATTERN, string=device_output) if not version_string_search: return \"\" version_string = version_string_search.group(0) or \"\" return version_string @staticmethod def _parse_config_sessions(device_output: str) -> List[str]: \"\"\" Parse config session names out of device output Args: device_output: output from show version command Returns: list[str]: config session names Raises: N/A \"\"\" try: config_session_dict = json.loads(device_output) except json.JSONDecodeError: return [] sessions = list(config_session_dict.get(\"sessions\", {})) return sessions @staticmethod def _get_config_command(source: str) -> str: \"\"\" Return command to use to get config based on the provided source Args: source: name of the config source, generally running|startup Returns: str: command to use to fetch the requested config Raises: N/A \"\"\" if source == \"running\": return \"show running-config\" return \"show startup-config\" @staticmethod def _prepare_config_payloads(config: str) -> Tuple[str, str]: \"\"\" Prepare a configuration so it can be nicely sent to the device via scrapli Args: config: configuration to prep Returns: tuple: tuple of \"normal\" config lines and \"eager\" config lines Raises: N/A \"\"\" # remove comment lines config = re.sub(pattern=GLOBAL_COMMENT_LINE_PATTERN, repl=\"!\", string=config) # remove \"end\" at the end of config if present - if its present it will drop scrapli out # of the config session which we do not want config = re.sub(pattern=END_PATTERN, repl=\"!\", string=config) # find all sections that need to be \"eagerly\" sent eager_config = re.findall(pattern=BANNER_PATTERN, string=config) for eager_section in eager_config: config = config.replace(eager_section, \"!\") joined_eager_config = \"\\n\".join(captured_section for captured_section in eager_config) return config, joined_eager_config def _prepare_load_config_session_and_payload(self, config: str) -> Tuple[str, str, bool]: \"\"\" Prepare the normal and eager payloads and decide if we need to register a config session Args: config: candidate config to load Returns: tuple: tuple containing \"normal\" config elements to send to the device and \"eager\" mode config elements to send to the device (things like banners/macro that require scrapli \"eager=True\"), and lastly a bool indicating if the config session needs to be registered on the device Raises: N/A \"\"\" config, eager_config = self._prepare_config_payloads(config=config) register_config_session = False if not self.config_session_name: self.config_session_name = f\"scrapli_cfg_{round(datetime.now().timestamp())}\" self.logger.debug(f\"configuration session name will be '{self.config_session_name}'\") register_config_session = True return config, eager_config, register_config_session def _reset_config_session(self) -> None: \"\"\" Reset config session info Resets the candidate config and config session name attributes -- when these are \"empty\" we know there is no current config session Args: N/A Returns: None Raises: N/A \"\"\" self.logger.debug(\"resetting candidate config and config session name\") self.candidate_config = \"\" self.config_session_name = \"\" def clean_config(self, config: str) -> str: \"\"\" Clean a configuration file of unwanted lines Args: config: configuration string to \"clean\"; remove all comment lines from both the source and candidate configs -- this is only done here pre-diff, so we dont modify the user provided candidate config which can totally have those comment lines - we only remove \"global\" (top level) comments though... user comments attached to interfaces and the stuff will remain Returns: str: cleaned configuration string Raises: N/A \"\"\" self.logger.debug(\"cleaning config file\") return strip_blank_lines( config=re.sub(pattern=GLOBAL_COMMENT_LINE_PATTERN, string=config, repl=\"\") ) def _pre_clear_config_sessions(self) -> ScrapliCfgResponse: \"\"\" Handle pre \"clear_config_sessions\" operations for parity between sync and async Args: N/A Returns: ScrapliCfgResponse: new response object to update w/ get results Raises: N/A \"\"\" self.logger.info(\"clear_config_sessions requested\") response = ScrapliCfgResponse( host=self.conn.host, raise_for_status_exception=ScrapliCfgException ) return response def _post_clear_config_sessions( self, response: ScrapliCfgResponse, scrapli_responses: Iterable[Response], ) -> ScrapliCfgResponse: \"\"\" Handle post \"clear_config_sessions\" operations for parity between sync and async Args: response: response object to update scrapli_responses: list of scrapli response objects from fetching the version Returns: ScrapliCfgResponse: response object containing string of the version as the `result` attribute Raises: N/A \"\"\" response.record_response(scrapli_responses=scrapli_responses) if response.failed: msg = \"failed to clear device configuration session(s)\" self.logger.critical(msg) response.result = msg else: response.result = \"configuration session(s) cleared\" return response","title":"Module scrapli_cfg.platform.core.arista_eos.base_platform"},{"location":"api_docs/platform/core/arista_eos/base_platform/#classes","text":"","title":"Classes"},{"location":"api_docs/platform/core/arista_eos/base_platform/#scraplicfgeosbase","text":"Expand source code class ScrapliCfgEOSBase: conn: Union[NetworkDriver, AsyncNetworkDriver] logger: LoggerAdapterT config_sources: List[str] config_session_name: str candidate_config: str @staticmethod def _parse_version(device_output: str) -> str: \"\"\" Parse version string out of device output Args: device_output: output from show version command Returns: str: device version string Raises: N/A \"\"\" version_string_search = re.search(pattern=VERSION_PATTERN, string=device_output) if not version_string_search: return \"\" version_string = version_string_search.group(0) or \"\" return version_string @staticmethod def _parse_config_sessions(device_output: str) -> List[str]: \"\"\" Parse config session names out of device output Args: device_output: output from show version command Returns: list[str]: config session names Raises: N/A \"\"\" try: config_session_dict = json.loads(device_output) except json.JSONDecodeError: return [] sessions = list(config_session_dict.get(\"sessions\", {})) return sessions @staticmethod def _get_config_command(source: str) -> str: \"\"\" Return command to use to get config based on the provided source Args: source: name of the config source, generally running|startup Returns: str: command to use to fetch the requested config Raises: N/A \"\"\" if source == \"running\": return \"show running-config\" return \"show startup-config\" @staticmethod def _prepare_config_payloads(config: str) -> Tuple[str, str]: \"\"\" Prepare a configuration so it can be nicely sent to the device via scrapli Args: config: configuration to prep Returns: tuple: tuple of \"normal\" config lines and \"eager\" config lines Raises: N/A \"\"\" # remove comment lines config = re.sub(pattern=GLOBAL_COMMENT_LINE_PATTERN, repl=\"!\", string=config) # remove \"end\" at the end of config if present - if its present it will drop scrapli out # of the config session which we do not want config = re.sub(pattern=END_PATTERN, repl=\"!\", string=config) # find all sections that need to be \"eagerly\" sent eager_config = re.findall(pattern=BANNER_PATTERN, string=config) for eager_section in eager_config: config = config.replace(eager_section, \"!\") joined_eager_config = \"\\n\".join(captured_section for captured_section in eager_config) return config, joined_eager_config def _prepare_load_config_session_and_payload(self, config: str) -> Tuple[str, str, bool]: \"\"\" Prepare the normal and eager payloads and decide if we need to register a config session Args: config: candidate config to load Returns: tuple: tuple containing \"normal\" config elements to send to the device and \"eager\" mode config elements to send to the device (things like banners/macro that require scrapli \"eager=True\"), and lastly a bool indicating if the config session needs to be registered on the device Raises: N/A \"\"\" config, eager_config = self._prepare_config_payloads(config=config) register_config_session = False if not self.config_session_name: self.config_session_name = f\"scrapli_cfg_{round(datetime.now().timestamp())}\" self.logger.debug(f\"configuration session name will be '{self.config_session_name}'\") register_config_session = True return config, eager_config, register_config_session def _reset_config_session(self) -> None: \"\"\" Reset config session info Resets the candidate config and config session name attributes -- when these are \"empty\" we know there is no current config session Args: N/A Returns: None Raises: N/A \"\"\" self.logger.debug(\"resetting candidate config and config session name\") self.candidate_config = \"\" self.config_session_name = \"\" def clean_config(self, config: str) -> str: \"\"\" Clean a configuration file of unwanted lines Args: config: configuration string to \"clean\"; remove all comment lines from both the source and candidate configs -- this is only done here pre-diff, so we dont modify the user provided candidate config which can totally have those comment lines - we only remove \"global\" (top level) comments though... user comments attached to interfaces and the stuff will remain Returns: str: cleaned configuration string Raises: N/A \"\"\" self.logger.debug(\"cleaning config file\") return strip_blank_lines( config=re.sub(pattern=GLOBAL_COMMENT_LINE_PATTERN, string=config, repl=\"\") ) def _pre_clear_config_sessions(self) -> ScrapliCfgResponse: \"\"\" Handle pre \"clear_config_sessions\" operations for parity between sync and async Args: N/A Returns: ScrapliCfgResponse: new response object to update w/ get results Raises: N/A \"\"\" self.logger.info(\"clear_config_sessions requested\") response = ScrapliCfgResponse( host=self.conn.host, raise_for_status_exception=ScrapliCfgException ) return response def _post_clear_config_sessions( self, response: ScrapliCfgResponse, scrapli_responses: Iterable[Response], ) -> ScrapliCfgResponse: \"\"\" Handle post \"clear_config_sessions\" operations for parity between sync and async Args: response: response object to update scrapli_responses: list of scrapli response objects from fetching the version Returns: ScrapliCfgResponse: response object containing string of the version as the `result` attribute Raises: N/A \"\"\" response.record_response(scrapli_responses=scrapli_responses) if response.failed: msg = \"failed to clear device configuration session(s)\" self.logger.critical(msg) response.result = msg else: response.result = \"configuration session(s) cleared\" return response","title":"ScrapliCfgEOSBase"},{"location":"api_docs/platform/core/arista_eos/base_platform/#descendants","text":"scrapli_cfg.platform.core.arista_eos.async_platform.AsyncScrapliCfgEOS scrapli_cfg.platform.core.arista_eos.sync_platform.ScrapliCfgEOS","title":"Descendants"},{"location":"api_docs/platform/core/arista_eos/base_platform/#class-variables","text":"candidate_config: str config_session_name: str config_sources: List[str] conn: Union[scrapli.driver.network.sync_driver.NetworkDriver, scrapli.driver.network.async_driver.AsyncNetworkDriver] logger: logging.LoggerAdapter","title":"Class variables"},{"location":"api_docs/platform/core/arista_eos/base_platform/#methods","text":"","title":"Methods"},{"location":"api_docs/platform/core/arista_eos/base_platform/#clean_config","text":"clean_config(self, config: str) \u2011> str 1 2 3 4 5 6 7 8 9 10 11 12 13 14 Clean a configuration file of unwanted lines Args: config: configuration string to \"clean\"; remove all comment lines from both the source and candidate configs -- this is only done here pre-diff, so we dont modify the user provided candidate config which can totally have those comment lines - we only remove \"global\" (top level) comments though... user comments attached to interfaces and the stuff will remain Returns: str: cleaned configuration string Raises: N/A","title":"clean_config"},{"location":"api_docs/platform/core/arista_eos/patterns/","text":"window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting()) Module scrapli_cfg.platform.core.arista_eos.patterns \u00b6 scrapli_cfg.platform.core.arista_eos.patterns Expand source code \"\"\"scrapli_cfg.platform.core.arista_eos.patterns\"\"\" import re VERSION_PATTERN = re.compile(pattern=r\"\\d+\\.\\d+\\.[a-z0-9\\-]+(\\.\\d+[a-z]{0,1})?\", flags=re.I) GLOBAL_COMMENT_LINE_PATTERN = re.compile(pattern=r\"^\\! .*$\", flags=re.I | re.M) BANNER_PATTERN = re.compile(pattern=r\"^banner.*EOF$\", flags=re.I | re.M | re.S) END_PATTERN = re.compile(pattern=\"end$\") # pre-canned config section grabber patterns # match all ethernet interfaces w/ or w/out config items below them ETHERNET_INTERFACES = re.compile( pattern=r\"(^interface ethernet\\d+$(?:\\n^\\s{3}.*$)*\\n!\\n)+\", flags=re.I | re.M ) # match management1 interface and config items below it MANAGEMENT_ONE_INTERFACE = re.compile( pattern=r\"^interface management1$(?:\\n^\\s{3}.*$)*\\n!\", flags=re.I | re.M )","title":"Patterns"},{"location":"api_docs/platform/core/arista_eos/patterns/#module-scrapli_cfgplatformcorearista_eospatterns","text":"scrapli_cfg.platform.core.arista_eos.patterns Expand source code \"\"\"scrapli_cfg.platform.core.arista_eos.patterns\"\"\" import re VERSION_PATTERN = re.compile(pattern=r\"\\d+\\.\\d+\\.[a-z0-9\\-]+(\\.\\d+[a-z]{0,1})?\", flags=re.I) GLOBAL_COMMENT_LINE_PATTERN = re.compile(pattern=r\"^\\! .*$\", flags=re.I | re.M) BANNER_PATTERN = re.compile(pattern=r\"^banner.*EOF$\", flags=re.I | re.M | re.S) END_PATTERN = re.compile(pattern=\"end$\") # pre-canned config section grabber patterns # match all ethernet interfaces w/ or w/out config items below them ETHERNET_INTERFACES = re.compile( pattern=r\"(^interface ethernet\\d+$(?:\\n^\\s{3}.*$)*\\n!\\n)+\", flags=re.I | re.M ) # match management1 interface and config items below it MANAGEMENT_ONE_INTERFACE = re.compile( pattern=r\"^interface management1$(?:\\n^\\s{3}.*$)*\\n!\", flags=re.I | re.M )","title":"Module scrapli_cfg.platform.core.arista_eos.patterns"},{"location":"api_docs/platform/core/arista_eos/sync_platform/","text":"window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting()) Module scrapli_cfg.platform.core.arista_eos.sync_platform \u00b6 scrapli_cfg.platform.core.arista_eos.sync Expand source code \"\"\"scrapli_cfg.platform.core.arista_eos.sync\"\"\" from typing import Any, Callable, List, Optional from scrapli.driver.core import EOSDriver from scrapli.response import MultiResponse, Response from scrapli_cfg.diff import ScrapliCfgDiffResponse from scrapli_cfg.exceptions import DiffConfigError, LoadConfigError, ScrapliCfgException from scrapli_cfg.platform.base.sync_platform import ScrapliCfgPlatform from scrapli_cfg.platform.core.arista_eos.base_platform import CONFIG_SOURCES, ScrapliCfgEOSBase from scrapli_cfg.response import ScrapliCfgResponse class ScrapliCfgEOS(ScrapliCfgPlatform, ScrapliCfgEOSBase): def __init__( self, conn: EOSDriver, *, config_sources: Optional[List[str]] = None, on_prepare: Optional[Callable[..., Any]] = None, dedicated_connection: bool = False, ignore_version: bool = False, ) -> None: if config_sources is None: config_sources = CONFIG_SOURCES super().__init__( conn=conn, config_sources=config_sources, on_prepare=on_prepare, dedicated_connection=dedicated_connection, ignore_version=ignore_version, ) self.conn: EOSDriver self.config_session_name = \"\" def _clear_config_session(self, session_name: str) -> Response: \"\"\" Clear a configuration session Args: session_name: name of session to clear Returns: Response: scrapli response from clearing the session Raises: N/A \"\"\" # Note, early versions of eos supporting config sessions cant be aborted like this, but # i dont want to register a config session for each session we want to delete so we'll just # roll w/ this for now return self.conn.send_command(command=f\"configure session {session_name} abort\") def clear_config_sessions( self, session_name: str = \"\", session_prefix: str = \"\" ) -> ScrapliCfgResponse: \"\"\" Clear a specific config session or all sessions with a prefix (ex: scrapli_cfg_) Args: session_name: name of specific config session to clear session_prefix: prefix of session(s) to clear -- ignored if session_name is provided Returns: ScrapliCfgResponse: response object containing string of the target config source as the `result` attribute Raises: N/A \"\"\" scrapli_responses = [] response = self._pre_clear_config_sessions() try: get_config_sessions_result = self.conn.send_command( command=\"show config sessions | json\" ) scrapli_responses.append(get_config_sessions_result) if get_config_sessions_result.failed: msg = \"failed to show current config sessions\" self.logger.critical(msg) raise ScrapliCfgException(msg) config_session_names = self._parse_config_sessions( device_output=get_config_sessions_result.result ) for config_session in config_session_names: if session_name: if config_session == session_name: clear_config_session_result = self._clear_config_session( session_name=session_name ) scrapli_responses.append(clear_config_session_result) else: if config_session.startswith(session_prefix): clear_config_session_result = self._clear_config_session( session_name=session_name ) scrapli_responses.append(clear_config_session_result) except ScrapliCfgException: pass return self._post_clear_config_sessions( response=response, scrapli_responses=scrapli_responses ) def get_version(self) -> ScrapliCfgResponse: response = self._pre_get_version() version_result = self.conn.send_command(command=\"show version | i Software image version\") return self._post_get_version( response=response, scrapli_responses=[version_result], result=self._parse_version(device_output=version_result.result), ) def get_config(self, source: str = \"running\") -> ScrapliCfgResponse: response = self._pre_get_config(source=source) config_result = self.conn.send_command(command=self._get_config_command(source=source)) return self._post_get_config( response=response, source=source, scrapli_responses=[config_result], result=config_result.result, ) def load_config(self, config: str, replace: bool = False, **kwargs: Any) -> ScrapliCfgResponse: \"\"\" Load configuration to a device Supported kwargs: N/A Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for eos supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" scrapli_responses = [] response = self._pre_load_config(config=config) ( config, eager_config, register_config_session, ) = self._prepare_load_config_session_and_payload(config=config) if register_config_session is True: # only need to register a session if we havent -- we will reset session to an empty # string after any commits/aborts so we know if we are doing \"new\" operations self.conn.register_configuration_session(session_name=self.config_session_name) try: if replace: # default the config session - we only need to do this if we are doing a REPLACE rollback_clean_config_result = self.conn.send_config( config=\"rollback clean-config\", privilege_level=self.config_session_name ) scrapli_responses.append(rollback_clean_config_result) if rollback_clean_config_result.failed: msg = \"failed to load clean config in configuration session\" self.logger.critical(msg) raise LoadConfigError(msg) config_result = self.conn.send_config( config=config, privilege_level=self.config_session_name ) scrapli_responses.append(config_result) if config_result.failed: msg = \"failed to load the candidate config into the config session\" self.logger.critical(msg) raise LoadConfigError(msg) # eager cuz banners and such; perhaps if no banner/macro we can disable eager though.... if eager_config: eager_config_result = self.conn.send_config( config=eager_config, privilege_level=self.config_session_name, eager=True ) scrapli_responses.append(eager_config_result) if eager_config_result.failed: msg = \"failed to load the candidate config into the config session\" self.logger.critical(msg) raise LoadConfigError(msg) except LoadConfigError: # we catch our own exception so we dont need to do any if failed checks along the way # as soon as we hit this (or when we are done w/ the try block) we are done loading the # config and can build and return a response object pass return self._post_load_config( response=response, scrapli_responses=scrapli_responses, ) def abort_config(self) -> ScrapliCfgResponse: response = self._pre_abort_config(session_or_config_file=bool(self.config_session_name)) self.conn.acquire_priv(desired_priv=self.config_session_name) self.conn._abort_config() # pylint: disable=W0212 self._reset_config_session() return self._post_abort_config(response=response, scrapli_responses=[]) def commit_config(self, source: str = \"running\") -> ScrapliCfgResponse: response = self._pre_commit_config( source=source, session_or_config_file=bool(self.config_session_name) ) commit_results = self.conn.send_commands( commands=[ f\"configure session {self.config_session_name} commit\", \"copy running-config startup-config\", ] ) self._reset_config_session() return self._post_commit_config(response=response, scrapli_responses=[commit_results]) def diff_config(self, source: str = \"running\") -> ScrapliCfgDiffResponse: scrapli_responses = [] device_diff = \"\" source_config = \"\" diff_response = self._pre_diff_config( source=source, session_or_config_file=bool(self.config_session_name) ) try: diff_result = self.conn.send_config( config=\"show session-config diffs\", privilege_level=self.config_session_name ) scrapli_responses.append(diff_result) if diff_result.failed: msg = \"failed generating diff for config session\" self.logger.critical(msg) raise DiffConfigError(msg) device_diff = diff_result.result source_config_result = self.get_config(source=source) source_config = source_config_result.result if isinstance(source_config_result.scrapli_responses, MultiResponse): # in this case this will always be a multiresponse or nothing (failure) but mypy # doesnt know that, hence the isinstance check scrapli_responses.extend(source_config_result.scrapli_responses) if source_config_result.failed: msg = \"failed fetching source config for diff comparison\" self.logger.critical(msg) raise DiffConfigError(msg) except DiffConfigError: pass return self._post_diff_config( diff_response=diff_response, scrapli_responses=scrapli_responses, source_config=self.clean_config(source_config), candidate_config=self.clean_config(self.candidate_config), device_diff=device_diff, ) Classes \u00b6 ScrapliCfgEOS \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 Helper class that provides a standard way to create an ABC using inheritance. Scrapli Config base class Args: conn: scrapli connection to use config_sources: list of config sources on_prepare: optional callable to run at connection `prepare` dedicated_connection: if `False` (default value) scrapli cfg will not open or close the underlying scrapli connection and will raise an exception if the scrapli connection is not open. If `True` will automatically open and close the scrapli connection when using with a context manager, `prepare` will open the scrapli connection (if not already open), and `close` will close the scrapli connection. ignore_version: ignore checking device version support; currently this just means that scrapli-cfg will not fetch the device version during the prepare phase, however this will (hopefully) be used in the future to limit what methods can be used against a target device. For example, for EOS devices we need > 4.14 to load configs; so if a device is encountered at 4.13 the version check would raise an exception rather than just failing in a potentially awkward fashion. Returns: None Raises: N/A Expand source code class ScrapliCfgEOS(ScrapliCfgPlatform, ScrapliCfgEOSBase): def __init__( self, conn: EOSDriver, *, config_sources: Optional[List[str]] = None, on_prepare: Optional[Callable[..., Any]] = None, dedicated_connection: bool = False, ignore_version: bool = False, ) -> None: if config_sources is None: config_sources = CONFIG_SOURCES super().__init__( conn=conn, config_sources=config_sources, on_prepare=on_prepare, dedicated_connection=dedicated_connection, ignore_version=ignore_version, ) self.conn: EOSDriver self.config_session_name = \"\" def _clear_config_session(self, session_name: str) -> Response: \"\"\" Clear a configuration session Args: session_name: name of session to clear Returns: Response: scrapli response from clearing the session Raises: N/A \"\"\" # Note, early versions of eos supporting config sessions cant be aborted like this, but # i dont want to register a config session for each session we want to delete so we'll just # roll w/ this for now return self.conn.send_command(command=f\"configure session {session_name} abort\") def clear_config_sessions( self, session_name: str = \"\", session_prefix: str = \"\" ) -> ScrapliCfgResponse: \"\"\" Clear a specific config session or all sessions with a prefix (ex: scrapli_cfg_) Args: session_name: name of specific config session to clear session_prefix: prefix of session(s) to clear -- ignored if session_name is provided Returns: ScrapliCfgResponse: response object containing string of the target config source as the `result` attribute Raises: N/A \"\"\" scrapli_responses = [] response = self._pre_clear_config_sessions() try: get_config_sessions_result = self.conn.send_command( command=\"show config sessions | json\" ) scrapli_responses.append(get_config_sessions_result) if get_config_sessions_result.failed: msg = \"failed to show current config sessions\" self.logger.critical(msg) raise ScrapliCfgException(msg) config_session_names = self._parse_config_sessions( device_output=get_config_sessions_result.result ) for config_session in config_session_names: if session_name: if config_session == session_name: clear_config_session_result = self._clear_config_session( session_name=session_name ) scrapli_responses.append(clear_config_session_result) else: if config_session.startswith(session_prefix): clear_config_session_result = self._clear_config_session( session_name=session_name ) scrapli_responses.append(clear_config_session_result) except ScrapliCfgException: pass return self._post_clear_config_sessions( response=response, scrapli_responses=scrapli_responses ) def get_version(self) -> ScrapliCfgResponse: response = self._pre_get_version() version_result = self.conn.send_command(command=\"show version | i Software image version\") return self._post_get_version( response=response, scrapli_responses=[version_result], result=self._parse_version(device_output=version_result.result), ) def get_config(self, source: str = \"running\") -> ScrapliCfgResponse: response = self._pre_get_config(source=source) config_result = self.conn.send_command(command=self._get_config_command(source=source)) return self._post_get_config( response=response, source=source, scrapli_responses=[config_result], result=config_result.result, ) def load_config(self, config: str, replace: bool = False, **kwargs: Any) -> ScrapliCfgResponse: \"\"\" Load configuration to a device Supported kwargs: N/A Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for eos supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" scrapli_responses = [] response = self._pre_load_config(config=config) ( config, eager_config, register_config_session, ) = self._prepare_load_config_session_and_payload(config=config) if register_config_session is True: # only need to register a session if we havent -- we will reset session to an empty # string after any commits/aborts so we know if we are doing \"new\" operations self.conn.register_configuration_session(session_name=self.config_session_name) try: if replace: # default the config session - we only need to do this if we are doing a REPLACE rollback_clean_config_result = self.conn.send_config( config=\"rollback clean-config\", privilege_level=self.config_session_name ) scrapli_responses.append(rollback_clean_config_result) if rollback_clean_config_result.failed: msg = \"failed to load clean config in configuration session\" self.logger.critical(msg) raise LoadConfigError(msg) config_result = self.conn.send_config( config=config, privilege_level=self.config_session_name ) scrapli_responses.append(config_result) if config_result.failed: msg = \"failed to load the candidate config into the config session\" self.logger.critical(msg) raise LoadConfigError(msg) # eager cuz banners and such; perhaps if no banner/macro we can disable eager though.... if eager_config: eager_config_result = self.conn.send_config( config=eager_config, privilege_level=self.config_session_name, eager=True ) scrapli_responses.append(eager_config_result) if eager_config_result.failed: msg = \"failed to load the candidate config into the config session\" self.logger.critical(msg) raise LoadConfigError(msg) except LoadConfigError: # we catch our own exception so we dont need to do any if failed checks along the way # as soon as we hit this (or when we are done w/ the try block) we are done loading the # config and can build and return a response object pass return self._post_load_config( response=response, scrapli_responses=scrapli_responses, ) def abort_config(self) -> ScrapliCfgResponse: response = self._pre_abort_config(session_or_config_file=bool(self.config_session_name)) self.conn.acquire_priv(desired_priv=self.config_session_name) self.conn._abort_config() # pylint: disable=W0212 self._reset_config_session() return self._post_abort_config(response=response, scrapli_responses=[]) def commit_config(self, source: str = \"running\") -> ScrapliCfgResponse: response = self._pre_commit_config( source=source, session_or_config_file=bool(self.config_session_name) ) commit_results = self.conn.send_commands( commands=[ f\"configure session {self.config_session_name} commit\", \"copy running-config startup-config\", ] ) self._reset_config_session() return self._post_commit_config(response=response, scrapli_responses=[commit_results]) def diff_config(self, source: str = \"running\") -> ScrapliCfgDiffResponse: scrapli_responses = [] device_diff = \"\" source_config = \"\" diff_response = self._pre_diff_config( source=source, session_or_config_file=bool(self.config_session_name) ) try: diff_result = self.conn.send_config( config=\"show session-config diffs\", privilege_level=self.config_session_name ) scrapli_responses.append(diff_result) if diff_result.failed: msg = \"failed generating diff for config session\" self.logger.critical(msg) raise DiffConfigError(msg) device_diff = diff_result.result source_config_result = self.get_config(source=source) source_config = source_config_result.result if isinstance(source_config_result.scrapli_responses, MultiResponse): # in this case this will always be a multiresponse or nothing (failure) but mypy # doesnt know that, hence the isinstance check scrapli_responses.extend(source_config_result.scrapli_responses) if source_config_result.failed: msg = \"failed fetching source config for diff comparison\" self.logger.critical(msg) raise DiffConfigError(msg) except DiffConfigError: pass return self._post_diff_config( diff_response=diff_response, scrapli_responses=scrapli_responses, source_config=self.clean_config(source_config), candidate_config=self.clean_config(self.candidate_config), device_diff=device_diff, ) Ancestors (in MRO) \u00b6 scrapli_cfg.platform.base.sync_platform.ScrapliCfgPlatform abc.ABC scrapli_cfg.platform.base.base_platform.ScrapliCfgBase scrapli_cfg.platform.core.arista_eos.base_platform.ScrapliCfgEOSBase Class variables \u00b6 conn: Union[scrapli.driver.network.sync_driver.NetworkDriver, scrapli.driver.network.async_driver.AsyncNetworkDriver] Methods \u00b6 clear_config_sessions \u00b6 clear_config_sessions(self, session_name: str = '', session_prefix: str = '') \u2011> scrapli_cfg.response.ScrapliCfgResponse 1 2 3 4 5 6 7 8 9 10 11 12 Clear a specific config session or all sessions with a prefix (ex: scrapli_cfg_) Args: session_name: name of specific config session to clear session_prefix: prefix of session(s) to clear -- ignored if session_name is provided Returns: ScrapliCfgResponse: response object containing string of the target config source as the `result` attribute Raises: N/A load_config \u00b6 load_config(self, config: str, replace: bool = False, **kwargs: Any) \u2011> scrapli_cfg.response.ScrapliCfgResponse 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 Load configuration to a device Supported kwargs: N/A Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for eos supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A","title":"Sync Platform"},{"location":"api_docs/platform/core/arista_eos/sync_platform/#module-scrapli_cfgplatformcorearista_eossync_platform","text":"scrapli_cfg.platform.core.arista_eos.sync Expand source code \"\"\"scrapli_cfg.platform.core.arista_eos.sync\"\"\" from typing import Any, Callable, List, Optional from scrapli.driver.core import EOSDriver from scrapli.response import MultiResponse, Response from scrapli_cfg.diff import ScrapliCfgDiffResponse from scrapli_cfg.exceptions import DiffConfigError, LoadConfigError, ScrapliCfgException from scrapli_cfg.platform.base.sync_platform import ScrapliCfgPlatform from scrapli_cfg.platform.core.arista_eos.base_platform import CONFIG_SOURCES, ScrapliCfgEOSBase from scrapli_cfg.response import ScrapliCfgResponse class ScrapliCfgEOS(ScrapliCfgPlatform, ScrapliCfgEOSBase): def __init__( self, conn: EOSDriver, *, config_sources: Optional[List[str]] = None, on_prepare: Optional[Callable[..., Any]] = None, dedicated_connection: bool = False, ignore_version: bool = False, ) -> None: if config_sources is None: config_sources = CONFIG_SOURCES super().__init__( conn=conn, config_sources=config_sources, on_prepare=on_prepare, dedicated_connection=dedicated_connection, ignore_version=ignore_version, ) self.conn: EOSDriver self.config_session_name = \"\" def _clear_config_session(self, session_name: str) -> Response: \"\"\" Clear a configuration session Args: session_name: name of session to clear Returns: Response: scrapli response from clearing the session Raises: N/A \"\"\" # Note, early versions of eos supporting config sessions cant be aborted like this, but # i dont want to register a config session for each session we want to delete so we'll just # roll w/ this for now return self.conn.send_command(command=f\"configure session {session_name} abort\") def clear_config_sessions( self, session_name: str = \"\", session_prefix: str = \"\" ) -> ScrapliCfgResponse: \"\"\" Clear a specific config session or all sessions with a prefix (ex: scrapli_cfg_) Args: session_name: name of specific config session to clear session_prefix: prefix of session(s) to clear -- ignored if session_name is provided Returns: ScrapliCfgResponse: response object containing string of the target config source as the `result` attribute Raises: N/A \"\"\" scrapli_responses = [] response = self._pre_clear_config_sessions() try: get_config_sessions_result = self.conn.send_command( command=\"show config sessions | json\" ) scrapli_responses.append(get_config_sessions_result) if get_config_sessions_result.failed: msg = \"failed to show current config sessions\" self.logger.critical(msg) raise ScrapliCfgException(msg) config_session_names = self._parse_config_sessions( device_output=get_config_sessions_result.result ) for config_session in config_session_names: if session_name: if config_session == session_name: clear_config_session_result = self._clear_config_session( session_name=session_name ) scrapli_responses.append(clear_config_session_result) else: if config_session.startswith(session_prefix): clear_config_session_result = self._clear_config_session( session_name=session_name ) scrapli_responses.append(clear_config_session_result) except ScrapliCfgException: pass return self._post_clear_config_sessions( response=response, scrapli_responses=scrapli_responses ) def get_version(self) -> ScrapliCfgResponse: response = self._pre_get_version() version_result = self.conn.send_command(command=\"show version | i Software image version\") return self._post_get_version( response=response, scrapli_responses=[version_result], result=self._parse_version(device_output=version_result.result), ) def get_config(self, source: str = \"running\") -> ScrapliCfgResponse: response = self._pre_get_config(source=source) config_result = self.conn.send_command(command=self._get_config_command(source=source)) return self._post_get_config( response=response, source=source, scrapli_responses=[config_result], result=config_result.result, ) def load_config(self, config: str, replace: bool = False, **kwargs: Any) -> ScrapliCfgResponse: \"\"\" Load configuration to a device Supported kwargs: N/A Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for eos supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" scrapli_responses = [] response = self._pre_load_config(config=config) ( config, eager_config, register_config_session, ) = self._prepare_load_config_session_and_payload(config=config) if register_config_session is True: # only need to register a session if we havent -- we will reset session to an empty # string after any commits/aborts so we know if we are doing \"new\" operations self.conn.register_configuration_session(session_name=self.config_session_name) try: if replace: # default the config session - we only need to do this if we are doing a REPLACE rollback_clean_config_result = self.conn.send_config( config=\"rollback clean-config\", privilege_level=self.config_session_name ) scrapli_responses.append(rollback_clean_config_result) if rollback_clean_config_result.failed: msg = \"failed to load clean config in configuration session\" self.logger.critical(msg) raise LoadConfigError(msg) config_result = self.conn.send_config( config=config, privilege_level=self.config_session_name ) scrapli_responses.append(config_result) if config_result.failed: msg = \"failed to load the candidate config into the config session\" self.logger.critical(msg) raise LoadConfigError(msg) # eager cuz banners and such; perhaps if no banner/macro we can disable eager though.... if eager_config: eager_config_result = self.conn.send_config( config=eager_config, privilege_level=self.config_session_name, eager=True ) scrapli_responses.append(eager_config_result) if eager_config_result.failed: msg = \"failed to load the candidate config into the config session\" self.logger.critical(msg) raise LoadConfigError(msg) except LoadConfigError: # we catch our own exception so we dont need to do any if failed checks along the way # as soon as we hit this (or when we are done w/ the try block) we are done loading the # config and can build and return a response object pass return self._post_load_config( response=response, scrapli_responses=scrapli_responses, ) def abort_config(self) -> ScrapliCfgResponse: response = self._pre_abort_config(session_or_config_file=bool(self.config_session_name)) self.conn.acquire_priv(desired_priv=self.config_session_name) self.conn._abort_config() # pylint: disable=W0212 self._reset_config_session() return self._post_abort_config(response=response, scrapli_responses=[]) def commit_config(self, source: str = \"running\") -> ScrapliCfgResponse: response = self._pre_commit_config( source=source, session_or_config_file=bool(self.config_session_name) ) commit_results = self.conn.send_commands( commands=[ f\"configure session {self.config_session_name} commit\", \"copy running-config startup-config\", ] ) self._reset_config_session() return self._post_commit_config(response=response, scrapli_responses=[commit_results]) def diff_config(self, source: str = \"running\") -> ScrapliCfgDiffResponse: scrapli_responses = [] device_diff = \"\" source_config = \"\" diff_response = self._pre_diff_config( source=source, session_or_config_file=bool(self.config_session_name) ) try: diff_result = self.conn.send_config( config=\"show session-config diffs\", privilege_level=self.config_session_name ) scrapli_responses.append(diff_result) if diff_result.failed: msg = \"failed generating diff for config session\" self.logger.critical(msg) raise DiffConfigError(msg) device_diff = diff_result.result source_config_result = self.get_config(source=source) source_config = source_config_result.result if isinstance(source_config_result.scrapli_responses, MultiResponse): # in this case this will always be a multiresponse or nothing (failure) but mypy # doesnt know that, hence the isinstance check scrapli_responses.extend(source_config_result.scrapli_responses) if source_config_result.failed: msg = \"failed fetching source config for diff comparison\" self.logger.critical(msg) raise DiffConfigError(msg) except DiffConfigError: pass return self._post_diff_config( diff_response=diff_response, scrapli_responses=scrapli_responses, source_config=self.clean_config(source_config), candidate_config=self.clean_config(self.candidate_config), device_diff=device_diff, )","title":"Module scrapli_cfg.platform.core.arista_eos.sync_platform"},{"location":"api_docs/platform/core/arista_eos/sync_platform/#classes","text":"","title":"Classes"},{"location":"api_docs/platform/core/arista_eos/sync_platform/#scraplicfgeos","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 Helper class that provides a standard way to create an ABC using inheritance. Scrapli Config base class Args: conn: scrapli connection to use config_sources: list of config sources on_prepare: optional callable to run at connection `prepare` dedicated_connection: if `False` (default value) scrapli cfg will not open or close the underlying scrapli connection and will raise an exception if the scrapli connection is not open. If `True` will automatically open and close the scrapli connection when using with a context manager, `prepare` will open the scrapli connection (if not already open), and `close` will close the scrapli connection. ignore_version: ignore checking device version support; currently this just means that scrapli-cfg will not fetch the device version during the prepare phase, however this will (hopefully) be used in the future to limit what methods can be used against a target device. For example, for EOS devices we need > 4.14 to load configs; so if a device is encountered at 4.13 the version check would raise an exception rather than just failing in a potentially awkward fashion. Returns: None Raises: N/A Expand source code class ScrapliCfgEOS(ScrapliCfgPlatform, ScrapliCfgEOSBase): def __init__( self, conn: EOSDriver, *, config_sources: Optional[List[str]] = None, on_prepare: Optional[Callable[..., Any]] = None, dedicated_connection: bool = False, ignore_version: bool = False, ) -> None: if config_sources is None: config_sources = CONFIG_SOURCES super().__init__( conn=conn, config_sources=config_sources, on_prepare=on_prepare, dedicated_connection=dedicated_connection, ignore_version=ignore_version, ) self.conn: EOSDriver self.config_session_name = \"\" def _clear_config_session(self, session_name: str) -> Response: \"\"\" Clear a configuration session Args: session_name: name of session to clear Returns: Response: scrapli response from clearing the session Raises: N/A \"\"\" # Note, early versions of eos supporting config sessions cant be aborted like this, but # i dont want to register a config session for each session we want to delete so we'll just # roll w/ this for now return self.conn.send_command(command=f\"configure session {session_name} abort\") def clear_config_sessions( self, session_name: str = \"\", session_prefix: str = \"\" ) -> ScrapliCfgResponse: \"\"\" Clear a specific config session or all sessions with a prefix (ex: scrapli_cfg_) Args: session_name: name of specific config session to clear session_prefix: prefix of session(s) to clear -- ignored if session_name is provided Returns: ScrapliCfgResponse: response object containing string of the target config source as the `result` attribute Raises: N/A \"\"\" scrapli_responses = [] response = self._pre_clear_config_sessions() try: get_config_sessions_result = self.conn.send_command( command=\"show config sessions | json\" ) scrapli_responses.append(get_config_sessions_result) if get_config_sessions_result.failed: msg = \"failed to show current config sessions\" self.logger.critical(msg) raise ScrapliCfgException(msg) config_session_names = self._parse_config_sessions( device_output=get_config_sessions_result.result ) for config_session in config_session_names: if session_name: if config_session == session_name: clear_config_session_result = self._clear_config_session( session_name=session_name ) scrapli_responses.append(clear_config_session_result) else: if config_session.startswith(session_prefix): clear_config_session_result = self._clear_config_session( session_name=session_name ) scrapli_responses.append(clear_config_session_result) except ScrapliCfgException: pass return self._post_clear_config_sessions( response=response, scrapli_responses=scrapli_responses ) def get_version(self) -> ScrapliCfgResponse: response = self._pre_get_version() version_result = self.conn.send_command(command=\"show version | i Software image version\") return self._post_get_version( response=response, scrapli_responses=[version_result], result=self._parse_version(device_output=version_result.result), ) def get_config(self, source: str = \"running\") -> ScrapliCfgResponse: response = self._pre_get_config(source=source) config_result = self.conn.send_command(command=self._get_config_command(source=source)) return self._post_get_config( response=response, source=source, scrapli_responses=[config_result], result=config_result.result, ) def load_config(self, config: str, replace: bool = False, **kwargs: Any) -> ScrapliCfgResponse: \"\"\" Load configuration to a device Supported kwargs: N/A Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for eos supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" scrapli_responses = [] response = self._pre_load_config(config=config) ( config, eager_config, register_config_session, ) = self._prepare_load_config_session_and_payload(config=config) if register_config_session is True: # only need to register a session if we havent -- we will reset session to an empty # string after any commits/aborts so we know if we are doing \"new\" operations self.conn.register_configuration_session(session_name=self.config_session_name) try: if replace: # default the config session - we only need to do this if we are doing a REPLACE rollback_clean_config_result = self.conn.send_config( config=\"rollback clean-config\", privilege_level=self.config_session_name ) scrapli_responses.append(rollback_clean_config_result) if rollback_clean_config_result.failed: msg = \"failed to load clean config in configuration session\" self.logger.critical(msg) raise LoadConfigError(msg) config_result = self.conn.send_config( config=config, privilege_level=self.config_session_name ) scrapli_responses.append(config_result) if config_result.failed: msg = \"failed to load the candidate config into the config session\" self.logger.critical(msg) raise LoadConfigError(msg) # eager cuz banners and such; perhaps if no banner/macro we can disable eager though.... if eager_config: eager_config_result = self.conn.send_config( config=eager_config, privilege_level=self.config_session_name, eager=True ) scrapli_responses.append(eager_config_result) if eager_config_result.failed: msg = \"failed to load the candidate config into the config session\" self.logger.critical(msg) raise LoadConfigError(msg) except LoadConfigError: # we catch our own exception so we dont need to do any if failed checks along the way # as soon as we hit this (or when we are done w/ the try block) we are done loading the # config and can build and return a response object pass return self._post_load_config( response=response, scrapli_responses=scrapli_responses, ) def abort_config(self) -> ScrapliCfgResponse: response = self._pre_abort_config(session_or_config_file=bool(self.config_session_name)) self.conn.acquire_priv(desired_priv=self.config_session_name) self.conn._abort_config() # pylint: disable=W0212 self._reset_config_session() return self._post_abort_config(response=response, scrapli_responses=[]) def commit_config(self, source: str = \"running\") -> ScrapliCfgResponse: response = self._pre_commit_config( source=source, session_or_config_file=bool(self.config_session_name) ) commit_results = self.conn.send_commands( commands=[ f\"configure session {self.config_session_name} commit\", \"copy running-config startup-config\", ] ) self._reset_config_session() return self._post_commit_config(response=response, scrapli_responses=[commit_results]) def diff_config(self, source: str = \"running\") -> ScrapliCfgDiffResponse: scrapli_responses = [] device_diff = \"\" source_config = \"\" diff_response = self._pre_diff_config( source=source, session_or_config_file=bool(self.config_session_name) ) try: diff_result = self.conn.send_config( config=\"show session-config diffs\", privilege_level=self.config_session_name ) scrapli_responses.append(diff_result) if diff_result.failed: msg = \"failed generating diff for config session\" self.logger.critical(msg) raise DiffConfigError(msg) device_diff = diff_result.result source_config_result = self.get_config(source=source) source_config = source_config_result.result if isinstance(source_config_result.scrapli_responses, MultiResponse): # in this case this will always be a multiresponse or nothing (failure) but mypy # doesnt know that, hence the isinstance check scrapli_responses.extend(source_config_result.scrapli_responses) if source_config_result.failed: msg = \"failed fetching source config for diff comparison\" self.logger.critical(msg) raise DiffConfigError(msg) except DiffConfigError: pass return self._post_diff_config( diff_response=diff_response, scrapli_responses=scrapli_responses, source_config=self.clean_config(source_config), candidate_config=self.clean_config(self.candidate_config), device_diff=device_diff, )","title":"ScrapliCfgEOS"},{"location":"api_docs/platform/core/arista_eos/sync_platform/#ancestors-in-mro","text":"scrapli_cfg.platform.base.sync_platform.ScrapliCfgPlatform abc.ABC scrapli_cfg.platform.base.base_platform.ScrapliCfgBase scrapli_cfg.platform.core.arista_eos.base_platform.ScrapliCfgEOSBase","title":"Ancestors (in MRO)"},{"location":"api_docs/platform/core/arista_eos/sync_platform/#class-variables","text":"conn: Union[scrapli.driver.network.sync_driver.NetworkDriver, scrapli.driver.network.async_driver.AsyncNetworkDriver]","title":"Class variables"},{"location":"api_docs/platform/core/arista_eos/sync_platform/#methods","text":"","title":"Methods"},{"location":"api_docs/platform/core/arista_eos/sync_platform/#clear_config_sessions","text":"clear_config_sessions(self, session_name: str = '', session_prefix: str = '') \u2011> scrapli_cfg.response.ScrapliCfgResponse 1 2 3 4 5 6 7 8 9 10 11 12 Clear a specific config session or all sessions with a prefix (ex: scrapli_cfg_) Args: session_name: name of specific config session to clear session_prefix: prefix of session(s) to clear -- ignored if session_name is provided Returns: ScrapliCfgResponse: response object containing string of the target config source as the `result` attribute Raises: N/A","title":"clear_config_sessions"},{"location":"api_docs/platform/core/arista_eos/sync_platform/#load_config","text":"load_config(self, config: str, replace: bool = False, **kwargs: Any) \u2011> scrapli_cfg.response.ScrapliCfgResponse 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 Load configuration to a device Supported kwargs: N/A Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for eos supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A","title":"load_config"},{"location":"api_docs/platform/core/cisco_iosxe/async_platform/","text":"window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting()) Module scrapli_cfg.platform.core.cisco_iosxe.async_platform \u00b6 scrapli_cfg.platform.core.cisco_iosxe.async_platform Expand source code \"\"\"scrapli_cfg.platform.core.cisco_iosxe.async_platform\"\"\" from typing import Any, Callable, List, Optional from scrapli.driver import AsyncNetworkDriver from scrapli.response import Response from scrapli_cfg.diff import ScrapliCfgDiffResponse from scrapli_cfg.exceptions import DiffConfigError, FailedToDetermineDeviceState from scrapli_cfg.platform.base.async_platform import AsyncScrapliCfgPlatform from scrapli_cfg.platform.core.cisco_iosxe.base_platform import ( CONFIG_SOURCES, FilePromptMode, ScrapliCfgIOSXEBase, ) from scrapli_cfg.response import ScrapliCfgResponse class AsyncScrapliCfgIOSXE(AsyncScrapliCfgPlatform, ScrapliCfgIOSXEBase): def __init__( self, conn: AsyncNetworkDriver, *, config_sources: Optional[List[str]] = None, on_prepare: Optional[Callable[..., Any]] = None, filesystem: str = \"flash:\", cleanup_post_commit: bool = True, dedicated_connection: bool = False, ignore_version: bool = False, ) -> None: if config_sources is None: config_sources = CONFIG_SOURCES super().__init__( conn=conn, config_sources=config_sources, on_prepare=on_prepare, dedicated_connection=dedicated_connection, ignore_version=ignore_version, ) self.filesystem = filesystem self._filesystem_space_available_buffer_perc = 10 self._replace = False self.candidate_config_filename = \"\" self.cleanup_post_commit = cleanup_post_commit async def _get_filesystem_space_available(self) -> int: \"\"\" Abort a configuration -- discards any loaded config Args: N/A Returns: None Raises: FailedToDetermineDeviceState: if unable to fetch file filesystem bytes available \"\"\" filesystem_size_result = await self.conn.send_command( command=f\"dir {self.filesystem} | i bytes\" ) if filesystem_size_result.failed: raise FailedToDetermineDeviceState(\"failed to determine space available on filesystem\") return self._post_get_filesystem_space_available(output=filesystem_size_result.result) async def _determine_file_prompt_mode(self) -> FilePromptMode: \"\"\" Determine the device file prompt mode Args: N/A Returns: FilePromptMode: enum representing file prompt mode Raises: FailedToDetermineDeviceState: if unable to fetch file prompt mode \"\"\" file_prompt_mode_result = await self.conn.send_command(command=\"show run | i file prompt\") if file_prompt_mode_result.failed: raise FailedToDetermineDeviceState(\"failed to determine file prompt mode\") return self._post_determine_file_prompt_mode(output=file_prompt_mode_result.result) async def _delete_candidate_config(self) -> Response: \"\"\" Delete candidate config from the filesystem Args: N/A Returns: Response: response from deleting the candidate config Raises: N/A \"\"\" # have to check again because the candidate config may have changed this! file_prompt_mode = await self._determine_file_prompt_mode() if file_prompt_mode in (FilePromptMode.ALERT, FilePromptMode.NOISY): delete_events = [ ( f\"delete {self.filesystem}{self.candidate_config_filename}\", \"Delete filename\", ), ( \"\", \"[confirm]\", ), (\"\", \"\"), ] else: delete_events = [ (f\"delete {self.filesystem}{self.candidate_config_filename}\", \"[confirm]\"), (\"\", \"\"), ] delete_result = await self.conn.send_interactive(interact_events=delete_events) return delete_result async def get_version(self) -> ScrapliCfgResponse: response = self._pre_get_version() version_result = await self.conn.send_command(command=\"show version | i Version\") return self._post_get_version( response=response, scrapli_responses=[version_result], result=self._parse_version(device_output=version_result.result), ) async def get_config(self, source: str = \"running\") -> ScrapliCfgResponse: response = self._pre_get_config(source=source) config_result = await self.conn.send_command( command=self._get_config_command(source=source) ) return self._post_get_config( response=response, source=source, scrapli_responses=[config_result], result=config_result.result, ) async def load_config( self, config: str, replace: bool = False, **kwargs: Any ) -> ScrapliCfgResponse: \"\"\" Load configuration to a device Supported kwargs: N/A Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for iosxe supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" response = self._pre_load_config(config=config) config = self._prepare_load_config(config=config, replace=replace) filesystem_bytes_available = await self._get_filesystem_space_available() self._space_available(filesystem_bytes_available=filesystem_bytes_available) # when in tcl command mode or whatever it is, tcl wants \\r for return char, so stash the # original return char and sub in \\r for a bit original_return_char = self.conn.comms_return_char tcl_comms_return_char = \"\\r\" # pop into tclsh before swapping the return char just to be safe -- \\r or \\n should both be # fine for up to here but who knows... :) await self.conn.acquire_priv(desired_priv=\"tclsh\") self.conn.comms_return_char = tcl_comms_return_char config_result = await self.conn.send_config(config=config, privilege_level=\"tclsh\") # reset the return char to the \"normal\" one and drop into whatever is the \"default\" priv await self.conn.acquire_priv(desired_priv=self.conn.default_desired_privilege_level) self.conn.comms_return_char = original_return_char return self._post_load_config( response=response, scrapli_responses=[config_result], ) async def abort_config(self) -> ScrapliCfgResponse: response = self._pre_abort_config( session_or_config_file=bool(self.candidate_config_filename) ) abort_result = await self._delete_candidate_config() self._reset_config_session() return self._post_abort_config(response=response, scrapli_responses=[abort_result]) async def save_config(self) -> Response: \"\"\" Save the config -- \"copy run start\"! Args: N/A Returns: Response: scrapli response object Raises: N/A \"\"\" # we always re-check file prompt mode because it could have changed! file_prompt_mode = await self._determine_file_prompt_mode() if file_prompt_mode == FilePromptMode.ALERT: save_events = [ ( \"copy running-config startup-config\", \"Destination filename\", ), (\"\", \"\"), ] elif file_prompt_mode == FilePromptMode.NOISY: save_events = [ ( \"copy running-config startup-config\", \"Source filename\", ), ( \"\", \"Destination filename\", ), (\"\", \"\"), ] else: save_events = [(\"copy running-config startup-config\", \"\")] save_result = await self.conn.send_interactive(interact_events=save_events) return save_result async def _commit_config_merge( self, file_prompt_mode: Optional[FilePromptMode] = None ) -> Response: \"\"\" Commit the configuration in merge mode Args: file_prompt_mode: optionally provide the file prompt mode, if its None we will fetch it to decide if we need to use interactive mode or not Returns: Response: scrapli response object Raises: N/A \"\"\" if file_prompt_mode is None: file_prompt_mode = await self._determine_file_prompt_mode() if file_prompt_mode == FilePromptMode.ALERT: merge_events = [ ( f\"copy {self.filesystem}{self.candidate_config_filename} running-config\", \"Destination filename\", ), (\"\", \"\"), ] elif file_prompt_mode == FilePromptMode.NOISY: merge_events = [ ( f\"copy {self.filesystem}{self.candidate_config_filename} running-config\", \"Source filename\", ), ( \"\", \"Destination filename\", ), (\"\", \"\"), ] else: merge_events = [ (f\"copy {self.filesystem}{self.candidate_config_filename} running-config\", \"\") ] commit_result = await self.conn.send_interactive(interact_events=merge_events) return commit_result async def commit_config(self, source: str = \"running\") -> ScrapliCfgResponse: scrapli_responses = [] response = self._pre_commit_config( source=source, session_or_config_file=bool(self.candidate_config_filename) ) file_prompt_mode = await self._determine_file_prompt_mode() if self._replace is True: replace_command = ( f\"configure replace {self.filesystem}{self.candidate_config_filename} force\" ) commit_result = await self.conn.send_command(command=replace_command) else: commit_result = await self._commit_config_merge(file_prompt_mode=file_prompt_mode) scrapli_responses.append(commit_result) save_config_result = await self.save_config() scrapli_responses.append(save_config_result) if self.cleanup_post_commit: cleanup_result = await self._delete_candidate_config() scrapli_responses.append(cleanup_result) self._reset_config_session() return self._post_load_config( response=response, scrapli_responses=scrapli_responses, ) async def diff_config(self, source: str = \"running\") -> ScrapliCfgDiffResponse: scrapli_responses = [] device_diff = \"\" source_config = \"\" diff_response = self._pre_diff_config( source=source, session_or_config_file=bool(self.candidate_config_filename) ) try: diff_result = await self.conn.send_command( command=self._get_diff_command(source=source) ) scrapli_responses.append(diff_result) if diff_result.failed: msg = \"failed generating diff for config session\" self.logger.critical(msg) raise DiffConfigError(msg) device_diff = diff_result.result source_config_result = await self.get_config(source=source) source_config = source_config_result.result if isinstance(source_config_result.scrapli_responses, list): scrapli_responses.extend(source_config_result.scrapli_responses) if source_config_result.failed: msg = \"failed fetching source config for diff comparison\" self.logger.critical(msg) raise DiffConfigError(msg) except DiffConfigError: pass return self._post_diff_config( diff_response=diff_response, scrapli_responses=scrapli_responses, source_config=self.clean_config(source_config), candidate_config=self.clean_config(self.candidate_config), device_diff=device_diff, ) Classes \u00b6 AsyncScrapliCfgIOSXE \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 Helper class that provides a standard way to create an ABC using inheritance. Scrapli Config async base class Args: conn: scrapli connection to use config_sources: list of config sources on_prepare: optional callable to run at connection `prepare` dedicated_connection: if `False` (default value) scrapli cfg will not open or close the underlying scrapli connection and will raise an exception if the scrapli connection is not open. If `True` will automatically open and close the scrapli connection when using with a context manager, `prepare` will open the scrapli connection (if not already open), and `close` will close the scrapli connection. ignore_version: ignore checking device version support; currently this just means that scrapli-cfg will not fetch the device version during the prepare phase, however this will (hopefully) be used in the future to limit what methods can be used against a target device. For example, for EOS devices we need > 4.14 to load configs; so if a device is encountered at 4.13 the version check would raise an exception rather than just failing in a potentially awkward fashion. Returns: None Raises: N/A Expand source code class AsyncScrapliCfgIOSXE(AsyncScrapliCfgPlatform, ScrapliCfgIOSXEBase): def __init__( self, conn: AsyncNetworkDriver, *, config_sources: Optional[List[str]] = None, on_prepare: Optional[Callable[..., Any]] = None, filesystem: str = \"flash:\", cleanup_post_commit: bool = True, dedicated_connection: bool = False, ignore_version: bool = False, ) -> None: if config_sources is None: config_sources = CONFIG_SOURCES super().__init__( conn=conn, config_sources=config_sources, on_prepare=on_prepare, dedicated_connection=dedicated_connection, ignore_version=ignore_version, ) self.filesystem = filesystem self._filesystem_space_available_buffer_perc = 10 self._replace = False self.candidate_config_filename = \"\" self.cleanup_post_commit = cleanup_post_commit async def _get_filesystem_space_available(self) -> int: \"\"\" Abort a configuration -- discards any loaded config Args: N/A Returns: None Raises: FailedToDetermineDeviceState: if unable to fetch file filesystem bytes available \"\"\" filesystem_size_result = await self.conn.send_command( command=f\"dir {self.filesystem} | i bytes\" ) if filesystem_size_result.failed: raise FailedToDetermineDeviceState(\"failed to determine space available on filesystem\") return self._post_get_filesystem_space_available(output=filesystem_size_result.result) async def _determine_file_prompt_mode(self) -> FilePromptMode: \"\"\" Determine the device file prompt mode Args: N/A Returns: FilePromptMode: enum representing file prompt mode Raises: FailedToDetermineDeviceState: if unable to fetch file prompt mode \"\"\" file_prompt_mode_result = await self.conn.send_command(command=\"show run | i file prompt\") if file_prompt_mode_result.failed: raise FailedToDetermineDeviceState(\"failed to determine file prompt mode\") return self._post_determine_file_prompt_mode(output=file_prompt_mode_result.result) async def _delete_candidate_config(self) -> Response: \"\"\" Delete candidate config from the filesystem Args: N/A Returns: Response: response from deleting the candidate config Raises: N/A \"\"\" # have to check again because the candidate config may have changed this! file_prompt_mode = await self._determine_file_prompt_mode() if file_prompt_mode in (FilePromptMode.ALERT, FilePromptMode.NOISY): delete_events = [ ( f\"delete {self.filesystem}{self.candidate_config_filename}\", \"Delete filename\", ), ( \"\", \"[confirm]\", ), (\"\", \"\"), ] else: delete_events = [ (f\"delete {self.filesystem}{self.candidate_config_filename}\", \"[confirm]\"), (\"\", \"\"), ] delete_result = await self.conn.send_interactive(interact_events=delete_events) return delete_result async def get_version(self) -> ScrapliCfgResponse: response = self._pre_get_version() version_result = await self.conn.send_command(command=\"show version | i Version\") return self._post_get_version( response=response, scrapli_responses=[version_result], result=self._parse_version(device_output=version_result.result), ) async def get_config(self, source: str = \"running\") -> ScrapliCfgResponse: response = self._pre_get_config(source=source) config_result = await self.conn.send_command( command=self._get_config_command(source=source) ) return self._post_get_config( response=response, source=source, scrapli_responses=[config_result], result=config_result.result, ) async def load_config( self, config: str, replace: bool = False, **kwargs: Any ) -> ScrapliCfgResponse: \"\"\" Load configuration to a device Supported kwargs: N/A Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for iosxe supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" response = self._pre_load_config(config=config) config = self._prepare_load_config(config=config, replace=replace) filesystem_bytes_available = await self._get_filesystem_space_available() self._space_available(filesystem_bytes_available=filesystem_bytes_available) # when in tcl command mode or whatever it is, tcl wants \\r for return char, so stash the # original return char and sub in \\r for a bit original_return_char = self.conn.comms_return_char tcl_comms_return_char = \"\\r\" # pop into tclsh before swapping the return char just to be safe -- \\r or \\n should both be # fine for up to here but who knows... :) await self.conn.acquire_priv(desired_priv=\"tclsh\") self.conn.comms_return_char = tcl_comms_return_char config_result = await self.conn.send_config(config=config, privilege_level=\"tclsh\") # reset the return char to the \"normal\" one and drop into whatever is the \"default\" priv await self.conn.acquire_priv(desired_priv=self.conn.default_desired_privilege_level) self.conn.comms_return_char = original_return_char return self._post_load_config( response=response, scrapli_responses=[config_result], ) async def abort_config(self) -> ScrapliCfgResponse: response = self._pre_abort_config( session_or_config_file=bool(self.candidate_config_filename) ) abort_result = await self._delete_candidate_config() self._reset_config_session() return self._post_abort_config(response=response, scrapli_responses=[abort_result]) async def save_config(self) -> Response: \"\"\" Save the config -- \"copy run start\"! Args: N/A Returns: Response: scrapli response object Raises: N/A \"\"\" # we always re-check file prompt mode because it could have changed! file_prompt_mode = await self._determine_file_prompt_mode() if file_prompt_mode == FilePromptMode.ALERT: save_events = [ ( \"copy running-config startup-config\", \"Destination filename\", ), (\"\", \"\"), ] elif file_prompt_mode == FilePromptMode.NOISY: save_events = [ ( \"copy running-config startup-config\", \"Source filename\", ), ( \"\", \"Destination filename\", ), (\"\", \"\"), ] else: save_events = [(\"copy running-config startup-config\", \"\")] save_result = await self.conn.send_interactive(interact_events=save_events) return save_result async def _commit_config_merge( self, file_prompt_mode: Optional[FilePromptMode] = None ) -> Response: \"\"\" Commit the configuration in merge mode Args: file_prompt_mode: optionally provide the file prompt mode, if its None we will fetch it to decide if we need to use interactive mode or not Returns: Response: scrapli response object Raises: N/A \"\"\" if file_prompt_mode is None: file_prompt_mode = await self._determine_file_prompt_mode() if file_prompt_mode == FilePromptMode.ALERT: merge_events = [ ( f\"copy {self.filesystem}{self.candidate_config_filename} running-config\", \"Destination filename\", ), (\"\", \"\"), ] elif file_prompt_mode == FilePromptMode.NOISY: merge_events = [ ( f\"copy {self.filesystem}{self.candidate_config_filename} running-config\", \"Source filename\", ), ( \"\", \"Destination filename\", ), (\"\", \"\"), ] else: merge_events = [ (f\"copy {self.filesystem}{self.candidate_config_filename} running-config\", \"\") ] commit_result = await self.conn.send_interactive(interact_events=merge_events) return commit_result async def commit_config(self, source: str = \"running\") -> ScrapliCfgResponse: scrapli_responses = [] response = self._pre_commit_config( source=source, session_or_config_file=bool(self.candidate_config_filename) ) file_prompt_mode = await self._determine_file_prompt_mode() if self._replace is True: replace_command = ( f\"configure replace {self.filesystem}{self.candidate_config_filename} force\" ) commit_result = await self.conn.send_command(command=replace_command) else: commit_result = await self._commit_config_merge(file_prompt_mode=file_prompt_mode) scrapli_responses.append(commit_result) save_config_result = await self.save_config() scrapli_responses.append(save_config_result) if self.cleanup_post_commit: cleanup_result = await self._delete_candidate_config() scrapli_responses.append(cleanup_result) self._reset_config_session() return self._post_load_config( response=response, scrapli_responses=scrapli_responses, ) async def diff_config(self, source: str = \"running\") -> ScrapliCfgDiffResponse: scrapli_responses = [] device_diff = \"\" source_config = \"\" diff_response = self._pre_diff_config( source=source, session_or_config_file=bool(self.candidate_config_filename) ) try: diff_result = await self.conn.send_command( command=self._get_diff_command(source=source) ) scrapli_responses.append(diff_result) if diff_result.failed: msg = \"failed generating diff for config session\" self.logger.critical(msg) raise DiffConfigError(msg) device_diff = diff_result.result source_config_result = await self.get_config(source=source) source_config = source_config_result.result if isinstance(source_config_result.scrapli_responses, list): scrapli_responses.extend(source_config_result.scrapli_responses) if source_config_result.failed: msg = \"failed fetching source config for diff comparison\" self.logger.critical(msg) raise DiffConfigError(msg) except DiffConfigError: pass return self._post_diff_config( diff_response=diff_response, scrapli_responses=scrapli_responses, source_config=self.clean_config(source_config), candidate_config=self.clean_config(self.candidate_config), device_diff=device_diff, ) Ancestors (in MRO) \u00b6 scrapli_cfg.platform.base.async_platform.AsyncScrapliCfgPlatform abc.ABC scrapli_cfg.platform.base.base_platform.ScrapliCfgBase scrapli_cfg.platform.core.cisco_iosxe.base_platform.ScrapliCfgIOSXEBase Class variables \u00b6 conn: Union[scrapli.driver.network.sync_driver.NetworkDriver, scrapli.driver.network.async_driver.AsyncNetworkDriver] Methods \u00b6 load_config \u00b6 load_config(self, config: str, replace: bool = False, **kwargs: Any) \u2011> scrapli_cfg.response.ScrapliCfgResponse 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 Load configuration to a device Supported kwargs: N/A Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for iosxe supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A save_config \u00b6 save_config(self) \u2011> scrapli.response.Response 1 2 3 4 5 6 7 8 9 10 Save the config -- \"copy run start\"! Args: N/A Returns: Response: scrapli response object Raises: N/A","title":"Async Platform"},{"location":"api_docs/platform/core/cisco_iosxe/async_platform/#module-scrapli_cfgplatformcorecisco_iosxeasync_platform","text":"scrapli_cfg.platform.core.cisco_iosxe.async_platform Expand source code \"\"\"scrapli_cfg.platform.core.cisco_iosxe.async_platform\"\"\" from typing import Any, Callable, List, Optional from scrapli.driver import AsyncNetworkDriver from scrapli.response import Response from scrapli_cfg.diff import ScrapliCfgDiffResponse from scrapli_cfg.exceptions import DiffConfigError, FailedToDetermineDeviceState from scrapli_cfg.platform.base.async_platform import AsyncScrapliCfgPlatform from scrapli_cfg.platform.core.cisco_iosxe.base_platform import ( CONFIG_SOURCES, FilePromptMode, ScrapliCfgIOSXEBase, ) from scrapli_cfg.response import ScrapliCfgResponse class AsyncScrapliCfgIOSXE(AsyncScrapliCfgPlatform, ScrapliCfgIOSXEBase): def __init__( self, conn: AsyncNetworkDriver, *, config_sources: Optional[List[str]] = None, on_prepare: Optional[Callable[..., Any]] = None, filesystem: str = \"flash:\", cleanup_post_commit: bool = True, dedicated_connection: bool = False, ignore_version: bool = False, ) -> None: if config_sources is None: config_sources = CONFIG_SOURCES super().__init__( conn=conn, config_sources=config_sources, on_prepare=on_prepare, dedicated_connection=dedicated_connection, ignore_version=ignore_version, ) self.filesystem = filesystem self._filesystem_space_available_buffer_perc = 10 self._replace = False self.candidate_config_filename = \"\" self.cleanup_post_commit = cleanup_post_commit async def _get_filesystem_space_available(self) -> int: \"\"\" Abort a configuration -- discards any loaded config Args: N/A Returns: None Raises: FailedToDetermineDeviceState: if unable to fetch file filesystem bytes available \"\"\" filesystem_size_result = await self.conn.send_command( command=f\"dir {self.filesystem} | i bytes\" ) if filesystem_size_result.failed: raise FailedToDetermineDeviceState(\"failed to determine space available on filesystem\") return self._post_get_filesystem_space_available(output=filesystem_size_result.result) async def _determine_file_prompt_mode(self) -> FilePromptMode: \"\"\" Determine the device file prompt mode Args: N/A Returns: FilePromptMode: enum representing file prompt mode Raises: FailedToDetermineDeviceState: if unable to fetch file prompt mode \"\"\" file_prompt_mode_result = await self.conn.send_command(command=\"show run | i file prompt\") if file_prompt_mode_result.failed: raise FailedToDetermineDeviceState(\"failed to determine file prompt mode\") return self._post_determine_file_prompt_mode(output=file_prompt_mode_result.result) async def _delete_candidate_config(self) -> Response: \"\"\" Delete candidate config from the filesystem Args: N/A Returns: Response: response from deleting the candidate config Raises: N/A \"\"\" # have to check again because the candidate config may have changed this! file_prompt_mode = await self._determine_file_prompt_mode() if file_prompt_mode in (FilePromptMode.ALERT, FilePromptMode.NOISY): delete_events = [ ( f\"delete {self.filesystem}{self.candidate_config_filename}\", \"Delete filename\", ), ( \"\", \"[confirm]\", ), (\"\", \"\"), ] else: delete_events = [ (f\"delete {self.filesystem}{self.candidate_config_filename}\", \"[confirm]\"), (\"\", \"\"), ] delete_result = await self.conn.send_interactive(interact_events=delete_events) return delete_result async def get_version(self) -> ScrapliCfgResponse: response = self._pre_get_version() version_result = await self.conn.send_command(command=\"show version | i Version\") return self._post_get_version( response=response, scrapli_responses=[version_result], result=self._parse_version(device_output=version_result.result), ) async def get_config(self, source: str = \"running\") -> ScrapliCfgResponse: response = self._pre_get_config(source=source) config_result = await self.conn.send_command( command=self._get_config_command(source=source) ) return self._post_get_config( response=response, source=source, scrapli_responses=[config_result], result=config_result.result, ) async def load_config( self, config: str, replace: bool = False, **kwargs: Any ) -> ScrapliCfgResponse: \"\"\" Load configuration to a device Supported kwargs: N/A Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for iosxe supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" response = self._pre_load_config(config=config) config = self._prepare_load_config(config=config, replace=replace) filesystem_bytes_available = await self._get_filesystem_space_available() self._space_available(filesystem_bytes_available=filesystem_bytes_available) # when in tcl command mode or whatever it is, tcl wants \\r for return char, so stash the # original return char and sub in \\r for a bit original_return_char = self.conn.comms_return_char tcl_comms_return_char = \"\\r\" # pop into tclsh before swapping the return char just to be safe -- \\r or \\n should both be # fine for up to here but who knows... :) await self.conn.acquire_priv(desired_priv=\"tclsh\") self.conn.comms_return_char = tcl_comms_return_char config_result = await self.conn.send_config(config=config, privilege_level=\"tclsh\") # reset the return char to the \"normal\" one and drop into whatever is the \"default\" priv await self.conn.acquire_priv(desired_priv=self.conn.default_desired_privilege_level) self.conn.comms_return_char = original_return_char return self._post_load_config( response=response, scrapli_responses=[config_result], ) async def abort_config(self) -> ScrapliCfgResponse: response = self._pre_abort_config( session_or_config_file=bool(self.candidate_config_filename) ) abort_result = await self._delete_candidate_config() self._reset_config_session() return self._post_abort_config(response=response, scrapli_responses=[abort_result]) async def save_config(self) -> Response: \"\"\" Save the config -- \"copy run start\"! Args: N/A Returns: Response: scrapli response object Raises: N/A \"\"\" # we always re-check file prompt mode because it could have changed! file_prompt_mode = await self._determine_file_prompt_mode() if file_prompt_mode == FilePromptMode.ALERT: save_events = [ ( \"copy running-config startup-config\", \"Destination filename\", ), (\"\", \"\"), ] elif file_prompt_mode == FilePromptMode.NOISY: save_events = [ ( \"copy running-config startup-config\", \"Source filename\", ), ( \"\", \"Destination filename\", ), (\"\", \"\"), ] else: save_events = [(\"copy running-config startup-config\", \"\")] save_result = await self.conn.send_interactive(interact_events=save_events) return save_result async def _commit_config_merge( self, file_prompt_mode: Optional[FilePromptMode] = None ) -> Response: \"\"\" Commit the configuration in merge mode Args: file_prompt_mode: optionally provide the file prompt mode, if its None we will fetch it to decide if we need to use interactive mode or not Returns: Response: scrapli response object Raises: N/A \"\"\" if file_prompt_mode is None: file_prompt_mode = await self._determine_file_prompt_mode() if file_prompt_mode == FilePromptMode.ALERT: merge_events = [ ( f\"copy {self.filesystem}{self.candidate_config_filename} running-config\", \"Destination filename\", ), (\"\", \"\"), ] elif file_prompt_mode == FilePromptMode.NOISY: merge_events = [ ( f\"copy {self.filesystem}{self.candidate_config_filename} running-config\", \"Source filename\", ), ( \"\", \"Destination filename\", ), (\"\", \"\"), ] else: merge_events = [ (f\"copy {self.filesystem}{self.candidate_config_filename} running-config\", \"\") ] commit_result = await self.conn.send_interactive(interact_events=merge_events) return commit_result async def commit_config(self, source: str = \"running\") -> ScrapliCfgResponse: scrapli_responses = [] response = self._pre_commit_config( source=source, session_or_config_file=bool(self.candidate_config_filename) ) file_prompt_mode = await self._determine_file_prompt_mode() if self._replace is True: replace_command = ( f\"configure replace {self.filesystem}{self.candidate_config_filename} force\" ) commit_result = await self.conn.send_command(command=replace_command) else: commit_result = await self._commit_config_merge(file_prompt_mode=file_prompt_mode) scrapli_responses.append(commit_result) save_config_result = await self.save_config() scrapli_responses.append(save_config_result) if self.cleanup_post_commit: cleanup_result = await self._delete_candidate_config() scrapli_responses.append(cleanup_result) self._reset_config_session() return self._post_load_config( response=response, scrapli_responses=scrapli_responses, ) async def diff_config(self, source: str = \"running\") -> ScrapliCfgDiffResponse: scrapli_responses = [] device_diff = \"\" source_config = \"\" diff_response = self._pre_diff_config( source=source, session_or_config_file=bool(self.candidate_config_filename) ) try: diff_result = await self.conn.send_command( command=self._get_diff_command(source=source) ) scrapli_responses.append(diff_result) if diff_result.failed: msg = \"failed generating diff for config session\" self.logger.critical(msg) raise DiffConfigError(msg) device_diff = diff_result.result source_config_result = await self.get_config(source=source) source_config = source_config_result.result if isinstance(source_config_result.scrapli_responses, list): scrapli_responses.extend(source_config_result.scrapli_responses) if source_config_result.failed: msg = \"failed fetching source config for diff comparison\" self.logger.critical(msg) raise DiffConfigError(msg) except DiffConfigError: pass return self._post_diff_config( diff_response=diff_response, scrapli_responses=scrapli_responses, source_config=self.clean_config(source_config), candidate_config=self.clean_config(self.candidate_config), device_diff=device_diff, )","title":"Module scrapli_cfg.platform.core.cisco_iosxe.async_platform"},{"location":"api_docs/platform/core/cisco_iosxe/async_platform/#classes","text":"","title":"Classes"},{"location":"api_docs/platform/core/cisco_iosxe/async_platform/#asyncscraplicfgiosxe","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 Helper class that provides a standard way to create an ABC using inheritance. Scrapli Config async base class Args: conn: scrapli connection to use config_sources: list of config sources on_prepare: optional callable to run at connection `prepare` dedicated_connection: if `False` (default value) scrapli cfg will not open or close the underlying scrapli connection and will raise an exception if the scrapli connection is not open. If `True` will automatically open and close the scrapli connection when using with a context manager, `prepare` will open the scrapli connection (if not already open), and `close` will close the scrapli connection. ignore_version: ignore checking device version support; currently this just means that scrapli-cfg will not fetch the device version during the prepare phase, however this will (hopefully) be used in the future to limit what methods can be used against a target device. For example, for EOS devices we need > 4.14 to load configs; so if a device is encountered at 4.13 the version check would raise an exception rather than just failing in a potentially awkward fashion. Returns: None Raises: N/A Expand source code class AsyncScrapliCfgIOSXE(AsyncScrapliCfgPlatform, ScrapliCfgIOSXEBase): def __init__( self, conn: AsyncNetworkDriver, *, config_sources: Optional[List[str]] = None, on_prepare: Optional[Callable[..., Any]] = None, filesystem: str = \"flash:\", cleanup_post_commit: bool = True, dedicated_connection: bool = False, ignore_version: bool = False, ) -> None: if config_sources is None: config_sources = CONFIG_SOURCES super().__init__( conn=conn, config_sources=config_sources, on_prepare=on_prepare, dedicated_connection=dedicated_connection, ignore_version=ignore_version, ) self.filesystem = filesystem self._filesystem_space_available_buffer_perc = 10 self._replace = False self.candidate_config_filename = \"\" self.cleanup_post_commit = cleanup_post_commit async def _get_filesystem_space_available(self) -> int: \"\"\" Abort a configuration -- discards any loaded config Args: N/A Returns: None Raises: FailedToDetermineDeviceState: if unable to fetch file filesystem bytes available \"\"\" filesystem_size_result = await self.conn.send_command( command=f\"dir {self.filesystem} | i bytes\" ) if filesystem_size_result.failed: raise FailedToDetermineDeviceState(\"failed to determine space available on filesystem\") return self._post_get_filesystem_space_available(output=filesystem_size_result.result) async def _determine_file_prompt_mode(self) -> FilePromptMode: \"\"\" Determine the device file prompt mode Args: N/A Returns: FilePromptMode: enum representing file prompt mode Raises: FailedToDetermineDeviceState: if unable to fetch file prompt mode \"\"\" file_prompt_mode_result = await self.conn.send_command(command=\"show run | i file prompt\") if file_prompt_mode_result.failed: raise FailedToDetermineDeviceState(\"failed to determine file prompt mode\") return self._post_determine_file_prompt_mode(output=file_prompt_mode_result.result) async def _delete_candidate_config(self) -> Response: \"\"\" Delete candidate config from the filesystem Args: N/A Returns: Response: response from deleting the candidate config Raises: N/A \"\"\" # have to check again because the candidate config may have changed this! file_prompt_mode = await self._determine_file_prompt_mode() if file_prompt_mode in (FilePromptMode.ALERT, FilePromptMode.NOISY): delete_events = [ ( f\"delete {self.filesystem}{self.candidate_config_filename}\", \"Delete filename\", ), ( \"\", \"[confirm]\", ), (\"\", \"\"), ] else: delete_events = [ (f\"delete {self.filesystem}{self.candidate_config_filename}\", \"[confirm]\"), (\"\", \"\"), ] delete_result = await self.conn.send_interactive(interact_events=delete_events) return delete_result async def get_version(self) -> ScrapliCfgResponse: response = self._pre_get_version() version_result = await self.conn.send_command(command=\"show version | i Version\") return self._post_get_version( response=response, scrapli_responses=[version_result], result=self._parse_version(device_output=version_result.result), ) async def get_config(self, source: str = \"running\") -> ScrapliCfgResponse: response = self._pre_get_config(source=source) config_result = await self.conn.send_command( command=self._get_config_command(source=source) ) return self._post_get_config( response=response, source=source, scrapli_responses=[config_result], result=config_result.result, ) async def load_config( self, config: str, replace: bool = False, **kwargs: Any ) -> ScrapliCfgResponse: \"\"\" Load configuration to a device Supported kwargs: N/A Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for iosxe supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" response = self._pre_load_config(config=config) config = self._prepare_load_config(config=config, replace=replace) filesystem_bytes_available = await self._get_filesystem_space_available() self._space_available(filesystem_bytes_available=filesystem_bytes_available) # when in tcl command mode or whatever it is, tcl wants \\r for return char, so stash the # original return char and sub in \\r for a bit original_return_char = self.conn.comms_return_char tcl_comms_return_char = \"\\r\" # pop into tclsh before swapping the return char just to be safe -- \\r or \\n should both be # fine for up to here but who knows... :) await self.conn.acquire_priv(desired_priv=\"tclsh\") self.conn.comms_return_char = tcl_comms_return_char config_result = await self.conn.send_config(config=config, privilege_level=\"tclsh\") # reset the return char to the \"normal\" one and drop into whatever is the \"default\" priv await self.conn.acquire_priv(desired_priv=self.conn.default_desired_privilege_level) self.conn.comms_return_char = original_return_char return self._post_load_config( response=response, scrapli_responses=[config_result], ) async def abort_config(self) -> ScrapliCfgResponse: response = self._pre_abort_config( session_or_config_file=bool(self.candidate_config_filename) ) abort_result = await self._delete_candidate_config() self._reset_config_session() return self._post_abort_config(response=response, scrapli_responses=[abort_result]) async def save_config(self) -> Response: \"\"\" Save the config -- \"copy run start\"! Args: N/A Returns: Response: scrapli response object Raises: N/A \"\"\" # we always re-check file prompt mode because it could have changed! file_prompt_mode = await self._determine_file_prompt_mode() if file_prompt_mode == FilePromptMode.ALERT: save_events = [ ( \"copy running-config startup-config\", \"Destination filename\", ), (\"\", \"\"), ] elif file_prompt_mode == FilePromptMode.NOISY: save_events = [ ( \"copy running-config startup-config\", \"Source filename\", ), ( \"\", \"Destination filename\", ), (\"\", \"\"), ] else: save_events = [(\"copy running-config startup-config\", \"\")] save_result = await self.conn.send_interactive(interact_events=save_events) return save_result async def _commit_config_merge( self, file_prompt_mode: Optional[FilePromptMode] = None ) -> Response: \"\"\" Commit the configuration in merge mode Args: file_prompt_mode: optionally provide the file prompt mode, if its None we will fetch it to decide if we need to use interactive mode or not Returns: Response: scrapli response object Raises: N/A \"\"\" if file_prompt_mode is None: file_prompt_mode = await self._determine_file_prompt_mode() if file_prompt_mode == FilePromptMode.ALERT: merge_events = [ ( f\"copy {self.filesystem}{self.candidate_config_filename} running-config\", \"Destination filename\", ), (\"\", \"\"), ] elif file_prompt_mode == FilePromptMode.NOISY: merge_events = [ ( f\"copy {self.filesystem}{self.candidate_config_filename} running-config\", \"Source filename\", ), ( \"\", \"Destination filename\", ), (\"\", \"\"), ] else: merge_events = [ (f\"copy {self.filesystem}{self.candidate_config_filename} running-config\", \"\") ] commit_result = await self.conn.send_interactive(interact_events=merge_events) return commit_result async def commit_config(self, source: str = \"running\") -> ScrapliCfgResponse: scrapli_responses = [] response = self._pre_commit_config( source=source, session_or_config_file=bool(self.candidate_config_filename) ) file_prompt_mode = await self._determine_file_prompt_mode() if self._replace is True: replace_command = ( f\"configure replace {self.filesystem}{self.candidate_config_filename} force\" ) commit_result = await self.conn.send_command(command=replace_command) else: commit_result = await self._commit_config_merge(file_prompt_mode=file_prompt_mode) scrapli_responses.append(commit_result) save_config_result = await self.save_config() scrapli_responses.append(save_config_result) if self.cleanup_post_commit: cleanup_result = await self._delete_candidate_config() scrapli_responses.append(cleanup_result) self._reset_config_session() return self._post_load_config( response=response, scrapli_responses=scrapli_responses, ) async def diff_config(self, source: str = \"running\") -> ScrapliCfgDiffResponse: scrapli_responses = [] device_diff = \"\" source_config = \"\" diff_response = self._pre_diff_config( source=source, session_or_config_file=bool(self.candidate_config_filename) ) try: diff_result = await self.conn.send_command( command=self._get_diff_command(source=source) ) scrapli_responses.append(diff_result) if diff_result.failed: msg = \"failed generating diff for config session\" self.logger.critical(msg) raise DiffConfigError(msg) device_diff = diff_result.result source_config_result = await self.get_config(source=source) source_config = source_config_result.result if isinstance(source_config_result.scrapli_responses, list): scrapli_responses.extend(source_config_result.scrapli_responses) if source_config_result.failed: msg = \"failed fetching source config for diff comparison\" self.logger.critical(msg) raise DiffConfigError(msg) except DiffConfigError: pass return self._post_diff_config( diff_response=diff_response, scrapli_responses=scrapli_responses, source_config=self.clean_config(source_config), candidate_config=self.clean_config(self.candidate_config), device_diff=device_diff, )","title":"AsyncScrapliCfgIOSXE"},{"location":"api_docs/platform/core/cisco_iosxe/async_platform/#ancestors-in-mro","text":"scrapli_cfg.platform.base.async_platform.AsyncScrapliCfgPlatform abc.ABC scrapli_cfg.platform.base.base_platform.ScrapliCfgBase scrapli_cfg.platform.core.cisco_iosxe.base_platform.ScrapliCfgIOSXEBase","title":"Ancestors (in MRO)"},{"location":"api_docs/platform/core/cisco_iosxe/async_platform/#class-variables","text":"conn: Union[scrapli.driver.network.sync_driver.NetworkDriver, scrapli.driver.network.async_driver.AsyncNetworkDriver]","title":"Class variables"},{"location":"api_docs/platform/core/cisco_iosxe/async_platform/#methods","text":"","title":"Methods"},{"location":"api_docs/platform/core/cisco_iosxe/async_platform/#load_config","text":"load_config(self, config: str, replace: bool = False, **kwargs: Any) \u2011> scrapli_cfg.response.ScrapliCfgResponse 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 Load configuration to a device Supported kwargs: N/A Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for iosxe supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A","title":"load_config"},{"location":"api_docs/platform/core/cisco_iosxe/async_platform/#save_config","text":"save_config(self) \u2011> scrapli.response.Response 1 2 3 4 5 6 7 8 9 10 Save the config -- \"copy run start\"! Args: N/A Returns: Response: scrapli response object Raises: N/A","title":"save_config"},{"location":"api_docs/platform/core/cisco_iosxe/base_platform/","text":"window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting()) Module scrapli_cfg.platform.core.cisco_iosxe.base_platform \u00b6 scrapli_cfg.platform.core.cisco_iosxe.base Expand source code \"\"\"scrapli_cfg.platform.core.cisco_iosxe.base\"\"\" import re from datetime import datetime from enum import Enum from logging import Logger, LoggerAdapter from typing import TYPE_CHECKING, Tuple from scrapli_cfg.exceptions import FailedToFetchSpaceAvailable, InsufficientSpaceAvailable from scrapli_cfg.helper import strip_blank_lines from scrapli_cfg.platform.core.cisco_iosxe.patterns import ( BYTES_FREE, FILE_PROMPT_MODE, OUTPUT_HEADER_PATTERN, VERSION_PATTERN, ) if TYPE_CHECKING: LoggerAdapterT = LoggerAdapter[Logger] # pylint:disable=E1136 else: LoggerAdapterT = LoggerAdapter CONFIG_SOURCES = [ \"running\", \"startup\", ] class FilePromptMode(Enum): \"\"\"Enum representing file prompt modes\"\"\" NOISY = \"noisy\" ALERT = \"alert\" QUIET = \"quiet\" class ScrapliCfgIOSXEBase: logger: LoggerAdapterT candidate_config: str candidate_config_filename: str _replace: bool filesystem: str _filesystem_space_available_buffer_perc: int def _post_get_filesystem_space_available(self, output: str) -> int: \"\"\" Handle post \"get_filesystem_space_available\" operations for parity between sync and async Args: output: output that was fetched from the device Returns: int: bytes of space available on filesystem Raises: FailedToFetchSpaceAvailable: if could not determine space available... duh :) \"\"\" self.logger.info(\"determining space available from device output\") bytes_available_match = re.search(pattern=BYTES_FREE, string=output) if not bytes_available_match: msg = \"could not determine space available on filesystem\" self.logger.critical(msg) raise FailedToFetchSpaceAvailable(msg) return int(bytes_available_match.groupdict()[\"bytes_available\"]) def _space_available(self, filesystem_bytes_available: int) -> None: \"\"\" Space available operations for parity between sync and async It seems that on iosxe the length of the config is near enough 1:1 to the size it takes up on the disk... so roll w/ that plus a bit of buffer based on the available buffer perc Args: filesystem_bytes_available: bytes available on filesystem Returns: None Raises: InsufficientSpaceAvailable: if... insufficient space available.... \"\"\" if filesystem_bytes_available < ( len(self.candidate_config) / (self._filesystem_space_available_buffer_perc / 100) ) + len(self.candidate_config): # filesystem has less than candidate config file size + 10% (by default) space, bail out msg = ( f\"insufficient space available for candidate config + \" f\"{self._filesystem_space_available_buffer_perc}% (buffer)\" ) self.logger.critical(msg) raise InsufficientSpaceAvailable(msg) def _post_determine_file_prompt_mode(self, output: str) -> FilePromptMode: \"\"\" Handle post \"determine_file_prompt_mode\" operations for parity between sync and async Args: output: output that was fetched from the device Returns: FilePromptMode: enum representing file prompt mode Raises: N/A \"\"\" self.logger.debug(\"determining file prompt mode from device output\") file_prompt_match = re.search(pattern=FILE_PROMPT_MODE, string=output) if not file_prompt_match: return FilePromptMode.ALERT prompt_mode = file_prompt_match.groupdict()[\"prompt_mode\"] if prompt_mode == \"noisy\": return FilePromptMode.NOISY return FilePromptMode.QUIET @staticmethod def _parse_version(device_output: str) -> str: \"\"\" Parse version string out of device output Args: device_output: output from show version command Returns: str: device version string Raises: N/A \"\"\" version_string_search = re.search(pattern=VERSION_PATTERN, string=device_output) if not version_string_search: return \"\" version_string = version_string_search.group(0) or \"\" return version_string def clean_config(self, config: str) -> str: \"\"\" Clean a configuration file of unwanted lines Args: config: configuration string to \"clean\"; cleaning removes lines that would prevent using the provided configuration as a \"load_config\" source from working -- i.e. removes the leading \"Building Configuration\" line Returns: str: cleaned configuration string Raises: N/A \"\"\" self.logger.debug(\"cleaning config file\") return strip_blank_lines( config=re.sub(pattern=OUTPUT_HEADER_PATTERN, string=config, repl=\"\", count=1) ) def _reset_config_session(self) -> None: \"\"\" Reset config session info Resets the candidate config and config session name attributes -- when these are \"empty\" we know there is no current config session Args: N/A Returns: None Raises: N/A \"\"\" self.logger.debug(\"resetting candidate config and candidate config file name\") self.candidate_config = \"\" self.candidate_config_filename = \"\" @staticmethod def _get_config_command(source: str) -> str: \"\"\" Return command to use to get config based on the provided source Args: source: name of the config source, generally running|startup Returns: str: command to use to fetch the requested config Raises: N/A \"\"\" if source == \"running\": return \"show running-config\" return \"show startup-config\" def _get_diff_command(self, source: str) -> str: \"\"\" Return command to use to get config diff based on the provided source Args: source: name of the config source, generally running|startup Returns: str: command to use to fetch the requested config Raises: N/A \"\"\" if self._replace: return ( f\"show archive config differences system:{source}-config {self.filesystem}\" f\"{self.candidate_config_filename}\" ) return ( f\"show archive config incremental-diffs {self.filesystem}\" f\"{self.candidate_config_filename} ignorecase\" ) def _prepare_config_payloads(self, config: str) -> str: \"\"\" Prepare a configuration so it can be nicely sent to the device via scrapli Args: config: configuration to prep Returns: str: string of config lines to write to candidate config file Raises: N/A \"\"\" tclsh_start_file = f'puts [open \"{self.filesystem}{self.candidate_config_filename}\" w+] {{' tclsh_end_file = \"}\" final_config = \"\\n\".join((tclsh_start_file, config, tclsh_end_file)) return final_config def _prepare_load_config(self, config: str, replace: bool) -> str: \"\"\" Handle pre \"load_config\" operations for parity between sync and async Args: config: candidate config to load replace: True/False replace the configuration; passed here so it can be set at the class level as we need to stay in config mode and we need to know if we are doing a merge or a replace when we go to diff things Returns: str: string of config to write to candidate config file Raises: N/A \"\"\" self.candidate_config = config if not self.candidate_config_filename: self.candidate_config_filename = f\"scrapli_cfg_{round(datetime.now().timestamp())}\" self.logger.debug( f\"candidate config file name will be '{self.candidate_config_filename}'\" ) config = self._prepare_config_payloads(config=config) self._replace = replace return config def _normalize_source_candidate_configs(self, source_config: str) -> Tuple[str, str]: \"\"\" Normalize candidate config and source config so that we can easily diff them Args: source_config: current config of the source config store Returns: ScrapliCfgDiff: scrapli cfg diff object Raises: N/A \"\"\" self.logger.debug(\"normalizing source and candidate configs for diff object\") # remove any of the leading timestamp/building config/config size/last change lines in # both the source and candidate configs so they dont need to be compared source_config = self.clean_config(config=source_config) candidate_config = self.clean_config(config=self.candidate_config) return source_config, candidate_config Classes \u00b6 FilePromptMode \u00b6 1 Enum representing file prompt modes Expand source code class FilePromptMode(Enum): \"\"\"Enum representing file prompt modes\"\"\" NOISY = \"noisy\" ALERT = \"alert\" QUIET = \"quiet\" Ancestors (in MRO) \u00b6 enum.Enum Class variables \u00b6 ALERT NOISY QUIET ScrapliCfgIOSXEBase \u00b6 Expand source code class ScrapliCfgIOSXEBase: logger: LoggerAdapterT candidate_config: str candidate_config_filename: str _replace: bool filesystem: str _filesystem_space_available_buffer_perc: int def _post_get_filesystem_space_available(self, output: str) -> int: \"\"\" Handle post \"get_filesystem_space_available\" operations for parity between sync and async Args: output: output that was fetched from the device Returns: int: bytes of space available on filesystem Raises: FailedToFetchSpaceAvailable: if could not determine space available... duh :) \"\"\" self.logger.info(\"determining space available from device output\") bytes_available_match = re.search(pattern=BYTES_FREE, string=output) if not bytes_available_match: msg = \"could not determine space available on filesystem\" self.logger.critical(msg) raise FailedToFetchSpaceAvailable(msg) return int(bytes_available_match.groupdict()[\"bytes_available\"]) def _space_available(self, filesystem_bytes_available: int) -> None: \"\"\" Space available operations for parity between sync and async It seems that on iosxe the length of the config is near enough 1:1 to the size it takes up on the disk... so roll w/ that plus a bit of buffer based on the available buffer perc Args: filesystem_bytes_available: bytes available on filesystem Returns: None Raises: InsufficientSpaceAvailable: if... insufficient space available.... \"\"\" if filesystem_bytes_available < ( len(self.candidate_config) / (self._filesystem_space_available_buffer_perc / 100) ) + len(self.candidate_config): # filesystem has less than candidate config file size + 10% (by default) space, bail out msg = ( f\"insufficient space available for candidate config + \" f\"{self._filesystem_space_available_buffer_perc}% (buffer)\" ) self.logger.critical(msg) raise InsufficientSpaceAvailable(msg) def _post_determine_file_prompt_mode(self, output: str) -> FilePromptMode: \"\"\" Handle post \"determine_file_prompt_mode\" operations for parity between sync and async Args: output: output that was fetched from the device Returns: FilePromptMode: enum representing file prompt mode Raises: N/A \"\"\" self.logger.debug(\"determining file prompt mode from device output\") file_prompt_match = re.search(pattern=FILE_PROMPT_MODE, string=output) if not file_prompt_match: return FilePromptMode.ALERT prompt_mode = file_prompt_match.groupdict()[\"prompt_mode\"] if prompt_mode == \"noisy\": return FilePromptMode.NOISY return FilePromptMode.QUIET @staticmethod def _parse_version(device_output: str) -> str: \"\"\" Parse version string out of device output Args: device_output: output from show version command Returns: str: device version string Raises: N/A \"\"\" version_string_search = re.search(pattern=VERSION_PATTERN, string=device_output) if not version_string_search: return \"\" version_string = version_string_search.group(0) or \"\" return version_string def clean_config(self, config: str) -> str: \"\"\" Clean a configuration file of unwanted lines Args: config: configuration string to \"clean\"; cleaning removes lines that would prevent using the provided configuration as a \"load_config\" source from working -- i.e. removes the leading \"Building Configuration\" line Returns: str: cleaned configuration string Raises: N/A \"\"\" self.logger.debug(\"cleaning config file\") return strip_blank_lines( config=re.sub(pattern=OUTPUT_HEADER_PATTERN, string=config, repl=\"\", count=1) ) def _reset_config_session(self) -> None: \"\"\" Reset config session info Resets the candidate config and config session name attributes -- when these are \"empty\" we know there is no current config session Args: N/A Returns: None Raises: N/A \"\"\" self.logger.debug(\"resetting candidate config and candidate config file name\") self.candidate_config = \"\" self.candidate_config_filename = \"\" @staticmethod def _get_config_command(source: str) -> str: \"\"\" Return command to use to get config based on the provided source Args: source: name of the config source, generally running|startup Returns: str: command to use to fetch the requested config Raises: N/A \"\"\" if source == \"running\": return \"show running-config\" return \"show startup-config\" def _get_diff_command(self, source: str) -> str: \"\"\" Return command to use to get config diff based on the provided source Args: source: name of the config source, generally running|startup Returns: str: command to use to fetch the requested config Raises: N/A \"\"\" if self._replace: return ( f\"show archive config differences system:{source}-config {self.filesystem}\" f\"{self.candidate_config_filename}\" ) return ( f\"show archive config incremental-diffs {self.filesystem}\" f\"{self.candidate_config_filename} ignorecase\" ) def _prepare_config_payloads(self, config: str) -> str: \"\"\" Prepare a configuration so it can be nicely sent to the device via scrapli Args: config: configuration to prep Returns: str: string of config lines to write to candidate config file Raises: N/A \"\"\" tclsh_start_file = f'puts [open \"{self.filesystem}{self.candidate_config_filename}\" w+] {{' tclsh_end_file = \"}\" final_config = \"\\n\".join((tclsh_start_file, config, tclsh_end_file)) return final_config def _prepare_load_config(self, config: str, replace: bool) -> str: \"\"\" Handle pre \"load_config\" operations for parity between sync and async Args: config: candidate config to load replace: True/False replace the configuration; passed here so it can be set at the class level as we need to stay in config mode and we need to know if we are doing a merge or a replace when we go to diff things Returns: str: string of config to write to candidate config file Raises: N/A \"\"\" self.candidate_config = config if not self.candidate_config_filename: self.candidate_config_filename = f\"scrapli_cfg_{round(datetime.now().timestamp())}\" self.logger.debug( f\"candidate config file name will be '{self.candidate_config_filename}'\" ) config = self._prepare_config_payloads(config=config) self._replace = replace return config def _normalize_source_candidate_configs(self, source_config: str) -> Tuple[str, str]: \"\"\" Normalize candidate config and source config so that we can easily diff them Args: source_config: current config of the source config store Returns: ScrapliCfgDiff: scrapli cfg diff object Raises: N/A \"\"\" self.logger.debug(\"normalizing source and candidate configs for diff object\") # remove any of the leading timestamp/building config/config size/last change lines in # both the source and candidate configs so they dont need to be compared source_config = self.clean_config(config=source_config) candidate_config = self.clean_config(config=self.candidate_config) return source_config, candidate_config Descendants \u00b6 scrapli_cfg.platform.core.cisco_iosxe.async_platform.AsyncScrapliCfgIOSXE scrapli_cfg.platform.core.cisco_iosxe.sync_platform.ScrapliCfgIOSXE Class variables \u00b6 candidate_config: str candidate_config_filename: str filesystem: str logger: logging.LoggerAdapter Methods \u00b6 clean_config \u00b6 clean_config(self, config: str) \u2011> str 1 2 3 4 5 6 7 8 9 10 11 12 Clean a configuration file of unwanted lines Args: config: configuration string to \"clean\"; cleaning removes lines that would prevent using the provided configuration as a \"load_config\" source from working -- i.e. removes the leading \"Building Configuration\" line Returns: str: cleaned configuration string Raises: N/A","title":"Base platform"},{"location":"api_docs/platform/core/cisco_iosxe/base_platform/#module-scrapli_cfgplatformcorecisco_iosxebase_platform","text":"scrapli_cfg.platform.core.cisco_iosxe.base Expand source code \"\"\"scrapli_cfg.platform.core.cisco_iosxe.base\"\"\" import re from datetime import datetime from enum import Enum from logging import Logger, LoggerAdapter from typing import TYPE_CHECKING, Tuple from scrapli_cfg.exceptions import FailedToFetchSpaceAvailable, InsufficientSpaceAvailable from scrapli_cfg.helper import strip_blank_lines from scrapli_cfg.platform.core.cisco_iosxe.patterns import ( BYTES_FREE, FILE_PROMPT_MODE, OUTPUT_HEADER_PATTERN, VERSION_PATTERN, ) if TYPE_CHECKING: LoggerAdapterT = LoggerAdapter[Logger] # pylint:disable=E1136 else: LoggerAdapterT = LoggerAdapter CONFIG_SOURCES = [ \"running\", \"startup\", ] class FilePromptMode(Enum): \"\"\"Enum representing file prompt modes\"\"\" NOISY = \"noisy\" ALERT = \"alert\" QUIET = \"quiet\" class ScrapliCfgIOSXEBase: logger: LoggerAdapterT candidate_config: str candidate_config_filename: str _replace: bool filesystem: str _filesystem_space_available_buffer_perc: int def _post_get_filesystem_space_available(self, output: str) -> int: \"\"\" Handle post \"get_filesystem_space_available\" operations for parity between sync and async Args: output: output that was fetched from the device Returns: int: bytes of space available on filesystem Raises: FailedToFetchSpaceAvailable: if could not determine space available... duh :) \"\"\" self.logger.info(\"determining space available from device output\") bytes_available_match = re.search(pattern=BYTES_FREE, string=output) if not bytes_available_match: msg = \"could not determine space available on filesystem\" self.logger.critical(msg) raise FailedToFetchSpaceAvailable(msg) return int(bytes_available_match.groupdict()[\"bytes_available\"]) def _space_available(self, filesystem_bytes_available: int) -> None: \"\"\" Space available operations for parity between sync and async It seems that on iosxe the length of the config is near enough 1:1 to the size it takes up on the disk... so roll w/ that plus a bit of buffer based on the available buffer perc Args: filesystem_bytes_available: bytes available on filesystem Returns: None Raises: InsufficientSpaceAvailable: if... insufficient space available.... \"\"\" if filesystem_bytes_available < ( len(self.candidate_config) / (self._filesystem_space_available_buffer_perc / 100) ) + len(self.candidate_config): # filesystem has less than candidate config file size + 10% (by default) space, bail out msg = ( f\"insufficient space available for candidate config + \" f\"{self._filesystem_space_available_buffer_perc}% (buffer)\" ) self.logger.critical(msg) raise InsufficientSpaceAvailable(msg) def _post_determine_file_prompt_mode(self, output: str) -> FilePromptMode: \"\"\" Handle post \"determine_file_prompt_mode\" operations for parity between sync and async Args: output: output that was fetched from the device Returns: FilePromptMode: enum representing file prompt mode Raises: N/A \"\"\" self.logger.debug(\"determining file prompt mode from device output\") file_prompt_match = re.search(pattern=FILE_PROMPT_MODE, string=output) if not file_prompt_match: return FilePromptMode.ALERT prompt_mode = file_prompt_match.groupdict()[\"prompt_mode\"] if prompt_mode == \"noisy\": return FilePromptMode.NOISY return FilePromptMode.QUIET @staticmethod def _parse_version(device_output: str) -> str: \"\"\" Parse version string out of device output Args: device_output: output from show version command Returns: str: device version string Raises: N/A \"\"\" version_string_search = re.search(pattern=VERSION_PATTERN, string=device_output) if not version_string_search: return \"\" version_string = version_string_search.group(0) or \"\" return version_string def clean_config(self, config: str) -> str: \"\"\" Clean a configuration file of unwanted lines Args: config: configuration string to \"clean\"; cleaning removes lines that would prevent using the provided configuration as a \"load_config\" source from working -- i.e. removes the leading \"Building Configuration\" line Returns: str: cleaned configuration string Raises: N/A \"\"\" self.logger.debug(\"cleaning config file\") return strip_blank_lines( config=re.sub(pattern=OUTPUT_HEADER_PATTERN, string=config, repl=\"\", count=1) ) def _reset_config_session(self) -> None: \"\"\" Reset config session info Resets the candidate config and config session name attributes -- when these are \"empty\" we know there is no current config session Args: N/A Returns: None Raises: N/A \"\"\" self.logger.debug(\"resetting candidate config and candidate config file name\") self.candidate_config = \"\" self.candidate_config_filename = \"\" @staticmethod def _get_config_command(source: str) -> str: \"\"\" Return command to use to get config based on the provided source Args: source: name of the config source, generally running|startup Returns: str: command to use to fetch the requested config Raises: N/A \"\"\" if source == \"running\": return \"show running-config\" return \"show startup-config\" def _get_diff_command(self, source: str) -> str: \"\"\" Return command to use to get config diff based on the provided source Args: source: name of the config source, generally running|startup Returns: str: command to use to fetch the requested config Raises: N/A \"\"\" if self._replace: return ( f\"show archive config differences system:{source}-config {self.filesystem}\" f\"{self.candidate_config_filename}\" ) return ( f\"show archive config incremental-diffs {self.filesystem}\" f\"{self.candidate_config_filename} ignorecase\" ) def _prepare_config_payloads(self, config: str) -> str: \"\"\" Prepare a configuration so it can be nicely sent to the device via scrapli Args: config: configuration to prep Returns: str: string of config lines to write to candidate config file Raises: N/A \"\"\" tclsh_start_file = f'puts [open \"{self.filesystem}{self.candidate_config_filename}\" w+] {{' tclsh_end_file = \"}\" final_config = \"\\n\".join((tclsh_start_file, config, tclsh_end_file)) return final_config def _prepare_load_config(self, config: str, replace: bool) -> str: \"\"\" Handle pre \"load_config\" operations for parity between sync and async Args: config: candidate config to load replace: True/False replace the configuration; passed here so it can be set at the class level as we need to stay in config mode and we need to know if we are doing a merge or a replace when we go to diff things Returns: str: string of config to write to candidate config file Raises: N/A \"\"\" self.candidate_config = config if not self.candidate_config_filename: self.candidate_config_filename = f\"scrapli_cfg_{round(datetime.now().timestamp())}\" self.logger.debug( f\"candidate config file name will be '{self.candidate_config_filename}'\" ) config = self._prepare_config_payloads(config=config) self._replace = replace return config def _normalize_source_candidate_configs(self, source_config: str) -> Tuple[str, str]: \"\"\" Normalize candidate config and source config so that we can easily diff them Args: source_config: current config of the source config store Returns: ScrapliCfgDiff: scrapli cfg diff object Raises: N/A \"\"\" self.logger.debug(\"normalizing source and candidate configs for diff object\") # remove any of the leading timestamp/building config/config size/last change lines in # both the source and candidate configs so they dont need to be compared source_config = self.clean_config(config=source_config) candidate_config = self.clean_config(config=self.candidate_config) return source_config, candidate_config","title":"Module scrapli_cfg.platform.core.cisco_iosxe.base_platform"},{"location":"api_docs/platform/core/cisco_iosxe/base_platform/#classes","text":"","title":"Classes"},{"location":"api_docs/platform/core/cisco_iosxe/base_platform/#filepromptmode","text":"1 Enum representing file prompt modes Expand source code class FilePromptMode(Enum): \"\"\"Enum representing file prompt modes\"\"\" NOISY = \"noisy\" ALERT = \"alert\" QUIET = \"quiet\"","title":"FilePromptMode"},{"location":"api_docs/platform/core/cisco_iosxe/base_platform/#ancestors-in-mro","text":"enum.Enum","title":"Ancestors (in MRO)"},{"location":"api_docs/platform/core/cisco_iosxe/base_platform/#class-variables","text":"ALERT NOISY QUIET","title":"Class variables"},{"location":"api_docs/platform/core/cisco_iosxe/base_platform/#scraplicfgiosxebase","text":"Expand source code class ScrapliCfgIOSXEBase: logger: LoggerAdapterT candidate_config: str candidate_config_filename: str _replace: bool filesystem: str _filesystem_space_available_buffer_perc: int def _post_get_filesystem_space_available(self, output: str) -> int: \"\"\" Handle post \"get_filesystem_space_available\" operations for parity between sync and async Args: output: output that was fetched from the device Returns: int: bytes of space available on filesystem Raises: FailedToFetchSpaceAvailable: if could not determine space available... duh :) \"\"\" self.logger.info(\"determining space available from device output\") bytes_available_match = re.search(pattern=BYTES_FREE, string=output) if not bytes_available_match: msg = \"could not determine space available on filesystem\" self.logger.critical(msg) raise FailedToFetchSpaceAvailable(msg) return int(bytes_available_match.groupdict()[\"bytes_available\"]) def _space_available(self, filesystem_bytes_available: int) -> None: \"\"\" Space available operations for parity between sync and async It seems that on iosxe the length of the config is near enough 1:1 to the size it takes up on the disk... so roll w/ that plus a bit of buffer based on the available buffer perc Args: filesystem_bytes_available: bytes available on filesystem Returns: None Raises: InsufficientSpaceAvailable: if... insufficient space available.... \"\"\" if filesystem_bytes_available < ( len(self.candidate_config) / (self._filesystem_space_available_buffer_perc / 100) ) + len(self.candidate_config): # filesystem has less than candidate config file size + 10% (by default) space, bail out msg = ( f\"insufficient space available for candidate config + \" f\"{self._filesystem_space_available_buffer_perc}% (buffer)\" ) self.logger.critical(msg) raise InsufficientSpaceAvailable(msg) def _post_determine_file_prompt_mode(self, output: str) -> FilePromptMode: \"\"\" Handle post \"determine_file_prompt_mode\" operations for parity between sync and async Args: output: output that was fetched from the device Returns: FilePromptMode: enum representing file prompt mode Raises: N/A \"\"\" self.logger.debug(\"determining file prompt mode from device output\") file_prompt_match = re.search(pattern=FILE_PROMPT_MODE, string=output) if not file_prompt_match: return FilePromptMode.ALERT prompt_mode = file_prompt_match.groupdict()[\"prompt_mode\"] if prompt_mode == \"noisy\": return FilePromptMode.NOISY return FilePromptMode.QUIET @staticmethod def _parse_version(device_output: str) -> str: \"\"\" Parse version string out of device output Args: device_output: output from show version command Returns: str: device version string Raises: N/A \"\"\" version_string_search = re.search(pattern=VERSION_PATTERN, string=device_output) if not version_string_search: return \"\" version_string = version_string_search.group(0) or \"\" return version_string def clean_config(self, config: str) -> str: \"\"\" Clean a configuration file of unwanted lines Args: config: configuration string to \"clean\"; cleaning removes lines that would prevent using the provided configuration as a \"load_config\" source from working -- i.e. removes the leading \"Building Configuration\" line Returns: str: cleaned configuration string Raises: N/A \"\"\" self.logger.debug(\"cleaning config file\") return strip_blank_lines( config=re.sub(pattern=OUTPUT_HEADER_PATTERN, string=config, repl=\"\", count=1) ) def _reset_config_session(self) -> None: \"\"\" Reset config session info Resets the candidate config and config session name attributes -- when these are \"empty\" we know there is no current config session Args: N/A Returns: None Raises: N/A \"\"\" self.logger.debug(\"resetting candidate config and candidate config file name\") self.candidate_config = \"\" self.candidate_config_filename = \"\" @staticmethod def _get_config_command(source: str) -> str: \"\"\" Return command to use to get config based on the provided source Args: source: name of the config source, generally running|startup Returns: str: command to use to fetch the requested config Raises: N/A \"\"\" if source == \"running\": return \"show running-config\" return \"show startup-config\" def _get_diff_command(self, source: str) -> str: \"\"\" Return command to use to get config diff based on the provided source Args: source: name of the config source, generally running|startup Returns: str: command to use to fetch the requested config Raises: N/A \"\"\" if self._replace: return ( f\"show archive config differences system:{source}-config {self.filesystem}\" f\"{self.candidate_config_filename}\" ) return ( f\"show archive config incremental-diffs {self.filesystem}\" f\"{self.candidate_config_filename} ignorecase\" ) def _prepare_config_payloads(self, config: str) -> str: \"\"\" Prepare a configuration so it can be nicely sent to the device via scrapli Args: config: configuration to prep Returns: str: string of config lines to write to candidate config file Raises: N/A \"\"\" tclsh_start_file = f'puts [open \"{self.filesystem}{self.candidate_config_filename}\" w+] {{' tclsh_end_file = \"}\" final_config = \"\\n\".join((tclsh_start_file, config, tclsh_end_file)) return final_config def _prepare_load_config(self, config: str, replace: bool) -> str: \"\"\" Handle pre \"load_config\" operations for parity between sync and async Args: config: candidate config to load replace: True/False replace the configuration; passed here so it can be set at the class level as we need to stay in config mode and we need to know if we are doing a merge or a replace when we go to diff things Returns: str: string of config to write to candidate config file Raises: N/A \"\"\" self.candidate_config = config if not self.candidate_config_filename: self.candidate_config_filename = f\"scrapli_cfg_{round(datetime.now().timestamp())}\" self.logger.debug( f\"candidate config file name will be '{self.candidate_config_filename}'\" ) config = self._prepare_config_payloads(config=config) self._replace = replace return config def _normalize_source_candidate_configs(self, source_config: str) -> Tuple[str, str]: \"\"\" Normalize candidate config and source config so that we can easily diff them Args: source_config: current config of the source config store Returns: ScrapliCfgDiff: scrapli cfg diff object Raises: N/A \"\"\" self.logger.debug(\"normalizing source and candidate configs for diff object\") # remove any of the leading timestamp/building config/config size/last change lines in # both the source and candidate configs so they dont need to be compared source_config = self.clean_config(config=source_config) candidate_config = self.clean_config(config=self.candidate_config) return source_config, candidate_config","title":"ScrapliCfgIOSXEBase"},{"location":"api_docs/platform/core/cisco_iosxe/base_platform/#descendants","text":"scrapli_cfg.platform.core.cisco_iosxe.async_platform.AsyncScrapliCfgIOSXE scrapli_cfg.platform.core.cisco_iosxe.sync_platform.ScrapliCfgIOSXE","title":"Descendants"},{"location":"api_docs/platform/core/cisco_iosxe/base_platform/#class-variables_1","text":"candidate_config: str candidate_config_filename: str filesystem: str logger: logging.LoggerAdapter","title":"Class variables"},{"location":"api_docs/platform/core/cisco_iosxe/base_platform/#methods","text":"","title":"Methods"},{"location":"api_docs/platform/core/cisco_iosxe/base_platform/#clean_config","text":"clean_config(self, config: str) \u2011> str 1 2 3 4 5 6 7 8 9 10 11 12 Clean a configuration file of unwanted lines Args: config: configuration string to \"clean\"; cleaning removes lines that would prevent using the provided configuration as a \"load_config\" source from working -- i.e. removes the leading \"Building Configuration\" line Returns: str: cleaned configuration string Raises: N/A","title":"clean_config"},{"location":"api_docs/platform/core/cisco_iosxe/patterns/","text":"window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting()) Module scrapli_cfg.platform.core.cisco_iosxe.patterns \u00b6 scrapli_cfg.platform.core.cisco_iosxe.patterns Expand source code \"\"\"scrapli_cfg.platform.core.cisco_iosxe.patterns\"\"\" import re VERSION_PATTERN = re.compile(pattern=r\"\\d+\\.[a-z0-9\\(\\)\\.]+\", flags=re.I) BYTES_FREE = re.compile(pattern=r\"(?P \\d+)(?: bytes free)\", flags=re.I) FILE_PROMPT_MODE = re.compile(pattern=r\"(?:file prompt )(?P \\w+)\", flags=re.I) OUTPUT_HEADER_PATTERN = re.compile( pattern=r\".*(?=(version \\d+\\.\\d+))\", flags=re.I | re.S, )","title":"Patterns"},{"location":"api_docs/platform/core/cisco_iosxe/patterns/#module-scrapli_cfgplatformcorecisco_iosxepatterns","text":"scrapli_cfg.platform.core.cisco_iosxe.patterns Expand source code \"\"\"scrapli_cfg.platform.core.cisco_iosxe.patterns\"\"\" import re VERSION_PATTERN = re.compile(pattern=r\"\\d+\\.[a-z0-9\\(\\)\\.]+\", flags=re.I) BYTES_FREE = re.compile(pattern=r\"(?P \\d+)(?: bytes free)\", flags=re.I) FILE_PROMPT_MODE = re.compile(pattern=r\"(?:file prompt )(?P \\w+)\", flags=re.I) OUTPUT_HEADER_PATTERN = re.compile( pattern=r\".*(?=(version \\d+\\.\\d+))\", flags=re.I | re.S, )","title":"Module scrapli_cfg.platform.core.cisco_iosxe.patterns"},{"location":"api_docs/platform/core/cisco_iosxe/sync_platform/","text":"window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting()) Module scrapli_cfg.platform.core.cisco_iosxe.sync_platform \u00b6 scrapli_cfg.platform.core.cisco_iosxe.sync_platform Expand source code \"\"\"scrapli_cfg.platform.core.cisco_iosxe.sync_platform\"\"\" from typing import Any, Callable, List, Optional from scrapli.driver import NetworkDriver from scrapli.response import MultiResponse, Response from scrapli_cfg.diff import ScrapliCfgDiffResponse from scrapli_cfg.exceptions import DiffConfigError, FailedToDetermineDeviceState from scrapli_cfg.platform.base.sync_platform import ScrapliCfgPlatform from scrapli_cfg.platform.core.cisco_iosxe.base_platform import ( CONFIG_SOURCES, FilePromptMode, ScrapliCfgIOSXEBase, ) from scrapli_cfg.response import ScrapliCfgResponse class ScrapliCfgIOSXE(ScrapliCfgPlatform, ScrapliCfgIOSXEBase): def __init__( self, conn: NetworkDriver, *, config_sources: Optional[List[str]] = None, on_prepare: Optional[Callable[..., Any]] = None, filesystem: str = \"flash:\", cleanup_post_commit: bool = True, dedicated_connection: bool = False, ignore_version: bool = False, ) -> None: if config_sources is None: config_sources = CONFIG_SOURCES super().__init__( conn=conn, config_sources=config_sources, on_prepare=on_prepare, dedicated_connection=dedicated_connection, ignore_version=ignore_version, ) self.filesystem = filesystem self._filesystem_space_available_buffer_perc = 10 self._replace = False self.candidate_config_filename = \"\" self.cleanup_post_commit = cleanup_post_commit def _get_filesystem_space_available(self) -> int: \"\"\" Abort a configuration -- discards any loaded config Args: N/A Returns: None Raises: FailedToDetermineDeviceState: if unable to fetch file filesystem bytes available \"\"\" filesystem_size_result = self.conn.send_command(command=f\"dir {self.filesystem} | i bytes\") if filesystem_size_result.failed: raise FailedToDetermineDeviceState(\"failed to determine space available on filesystem\") return self._post_get_filesystem_space_available(output=filesystem_size_result.result) def _determine_file_prompt_mode(self) -> FilePromptMode: \"\"\" Determine the device file prompt mode Args: N/A Returns: FilePromptMode: enum representing file prompt mode Raises: FailedToDetermineDeviceState: if unable to fetch file prompt mode \"\"\" file_prompt_mode_result = self.conn.send_command(command=\"show run | i file prompt\") if file_prompt_mode_result.failed: raise FailedToDetermineDeviceState(\"failed to determine file prompt mode\") return self._post_determine_file_prompt_mode(output=file_prompt_mode_result.result) def _delete_candidate_config(self) -> Response: \"\"\" Delete candidate config from the filesystem Args: N/A Returns: Response: response from deleting the candidate config Raises: N/A \"\"\" # have to check again because the candidate config may have changed this! file_prompt_mode = self._determine_file_prompt_mode() if file_prompt_mode in (FilePromptMode.ALERT, FilePromptMode.NOISY): delete_events = [ ( f\"delete {self.filesystem}{self.candidate_config_filename}\", \"Delete filename\", ), ( \"\", \"[confirm]\", ), (\"\", \"\"), ] else: delete_events = [ (f\"delete {self.filesystem}{self.candidate_config_filename}\", \"[confirm]\"), (\"\", \"\"), ] delete_result = self.conn.send_interactive(interact_events=delete_events) return delete_result def get_version(self) -> ScrapliCfgResponse: response = self._pre_get_version() version_result = self.conn.send_command(command=\"show version | i Version\") return self._post_get_version( response=response, scrapli_responses=[version_result], result=self._parse_version(device_output=version_result.result), ) def get_config(self, source: str = \"running\") -> ScrapliCfgResponse: response = self._pre_get_config(source=source) config_result = self.conn.send_command(command=self._get_config_command(source=source)) return self._post_get_config( response=response, source=source, scrapli_responses=[config_result], result=config_result.result, ) def load_config(self, config: str, replace: bool = False, **kwargs: Any) -> ScrapliCfgResponse: \"\"\" Load configuration to a device Supported kwargs: auto_clean: automatically \"clean\" any data that would be in a configuration from a \"get_config\" operation that would prevent loading a config -- for example, things like the \"Building Configuration\" lines in IOSXE output, etc.. Defaults to `True` Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for iosxe supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" if kwargs.get(\"auto_clean\", True) is True: config = self.clean_config(config=config) response = self._pre_load_config(config=config) config = self._prepare_load_config(config=config, replace=replace) filesystem_bytes_available = self._get_filesystem_space_available() self._space_available(filesystem_bytes_available=filesystem_bytes_available) # when in tcl command mode or whatever it is, tcl wants \\r for return char, so stash the # original return char and sub in \\r for a bit original_return_char = self.conn.comms_return_char tcl_comms_return_char = \"\\r\" # pop into tclsh before swapping the return char just to be safe -- \\r or \\n should both be # fine for up to here but who knows... :) self.conn.acquire_priv(desired_priv=\"tclsh\") self.conn.comms_return_char = tcl_comms_return_char config_result = self.conn.send_config(config=config, privilege_level=\"tclsh\") # reset the return char to the \"normal\" one and drop into whatever is the \"default\" priv self.conn.acquire_priv(desired_priv=self.conn.default_desired_privilege_level) self.conn.comms_return_char = original_return_char return self._post_load_config( response=response, scrapli_responses=[config_result], ) def abort_config(self) -> ScrapliCfgResponse: response = self._pre_abort_config( session_or_config_file=bool(self.candidate_config_filename) ) abort_result = self._delete_candidate_config() self._reset_config_session() return self._post_abort_config(response=response, scrapli_responses=[abort_result]) def save_config(self) -> Response: \"\"\" Save the config -- \"copy run start\"! Args: N/A Returns: Response: scrapli response object Raises: N/A \"\"\" # we always re-check file prompt mode because it could have changed! file_prompt_mode = self._determine_file_prompt_mode() if file_prompt_mode == FilePromptMode.ALERT: save_events = [ ( \"copy running-config startup-config\", \"Destination filename\", ), (\"\", \"\"), ] elif file_prompt_mode == FilePromptMode.NOISY: save_events = [ ( \"copy running-config startup-config\", \"Source filename\", ), ( \"\", \"Destination filename\", ), (\"\", \"\"), ] else: save_events = [(\"copy running-config startup-config\", \"\")] save_result = self.conn.send_interactive(interact_events=save_events) return save_result def _commit_config_merge(self, file_prompt_mode: Optional[FilePromptMode] = None) -> Response: \"\"\" Commit the configuration in merge mode Args: file_prompt_mode: optionally provide the file prompt mode, if its None we will fetch it to decide if we need to use interactive mode or not Returns: Response: scrapli response object Raises: N/A \"\"\" if file_prompt_mode is None: file_prompt_mode = self._determine_file_prompt_mode() if file_prompt_mode == FilePromptMode.ALERT: merge_events = [ ( f\"copy {self.filesystem}{self.candidate_config_filename} running-config\", \"Destination filename\", ), (\"\", \"\"), ] elif file_prompt_mode == FilePromptMode.NOISY: merge_events = [ ( f\"copy {self.filesystem}{self.candidate_config_filename} running-config\", \"Source filename\", ), ( \"\", \"Destination filename\", ), (\"\", \"\"), ] else: merge_events = [ (f\"copy {self.filesystem}{self.candidate_config_filename} running-config\", \"\") ] commit_result = self.conn.send_interactive(interact_events=merge_events) return commit_result def commit_config(self, source: str = \"running\") -> ScrapliCfgResponse: scrapli_responses = [] response = self._pre_commit_config( source=source, session_or_config_file=bool(self.candidate_config_filename) ) file_prompt_mode = self._determine_file_prompt_mode() if self._replace is True: replace_command = ( f\"configure replace {self.filesystem}{self.candidate_config_filename} force\" ) commit_result = self.conn.send_command(command=replace_command) else: commit_result = self._commit_config_merge(file_prompt_mode=file_prompt_mode) scrapli_responses.append(commit_result) save_config_result = self.save_config() scrapli_responses.append(save_config_result) if self.cleanup_post_commit: cleanup_result = self._delete_candidate_config() scrapli_responses.append(cleanup_result) self._reset_config_session() return self._post_load_config( response=response, scrapli_responses=scrapli_responses, ) def diff_config(self, source: str = \"running\") -> ScrapliCfgDiffResponse: scrapli_responses = [] device_diff = \"\" source_config = \"\" diff_response = self._pre_diff_config( source=source, session_or_config_file=bool(self.candidate_config_filename) ) try: diff_result = self.conn.send_command(command=self._get_diff_command(source=source)) scrapli_responses.append(diff_result) if diff_result.failed: msg = \"failed generating diff for config session\" self.logger.critical(msg) raise DiffConfigError(msg) device_diff = diff_result.result source_config_result = self.get_config(source=source) source_config = source_config_result.result if isinstance(source_config_result.scrapli_responses, MultiResponse): # in this case this will always be a multiresponse or nothing (failure) but mypy # doesnt know that, hence the isinstance check scrapli_responses.extend(source_config_result.scrapli_responses) if source_config_result.failed: msg = \"failed fetching source config for diff comparison\" self.logger.critical(msg) raise DiffConfigError(msg) except DiffConfigError: pass return self._post_diff_config( diff_response=diff_response, scrapli_responses=scrapli_responses, source_config=self.clean_config(source_config), candidate_config=self.clean_config(self.candidate_config), device_diff=device_diff, ) Classes \u00b6 ScrapliCfgIOSXE \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 Helper class that provides a standard way to create an ABC using inheritance. Scrapli Config base class Args: conn: scrapli connection to use config_sources: list of config sources on_prepare: optional callable to run at connection `prepare` dedicated_connection: if `False` (default value) scrapli cfg will not open or close the underlying scrapli connection and will raise an exception if the scrapli connection is not open. If `True` will automatically open and close the scrapli connection when using with a context manager, `prepare` will open the scrapli connection (if not already open), and `close` will close the scrapli connection. ignore_version: ignore checking device version support; currently this just means that scrapli-cfg will not fetch the device version during the prepare phase, however this will (hopefully) be used in the future to limit what methods can be used against a target device. For example, for EOS devices we need > 4.14 to load configs; so if a device is encountered at 4.13 the version check would raise an exception rather than just failing in a potentially awkward fashion. Returns: None Raises: N/A Expand source code class ScrapliCfgIOSXE(ScrapliCfgPlatform, ScrapliCfgIOSXEBase): def __init__( self, conn: NetworkDriver, *, config_sources: Optional[List[str]] = None, on_prepare: Optional[Callable[..., Any]] = None, filesystem: str = \"flash:\", cleanup_post_commit: bool = True, dedicated_connection: bool = False, ignore_version: bool = False, ) -> None: if config_sources is None: config_sources = CONFIG_SOURCES super().__init__( conn=conn, config_sources=config_sources, on_prepare=on_prepare, dedicated_connection=dedicated_connection, ignore_version=ignore_version, ) self.filesystem = filesystem self._filesystem_space_available_buffer_perc = 10 self._replace = False self.candidate_config_filename = \"\" self.cleanup_post_commit = cleanup_post_commit def _get_filesystem_space_available(self) -> int: \"\"\" Abort a configuration -- discards any loaded config Args: N/A Returns: None Raises: FailedToDetermineDeviceState: if unable to fetch file filesystem bytes available \"\"\" filesystem_size_result = self.conn.send_command(command=f\"dir {self.filesystem} | i bytes\") if filesystem_size_result.failed: raise FailedToDetermineDeviceState(\"failed to determine space available on filesystem\") return self._post_get_filesystem_space_available(output=filesystem_size_result.result) def _determine_file_prompt_mode(self) -> FilePromptMode: \"\"\" Determine the device file prompt mode Args: N/A Returns: FilePromptMode: enum representing file prompt mode Raises: FailedToDetermineDeviceState: if unable to fetch file prompt mode \"\"\" file_prompt_mode_result = self.conn.send_command(command=\"show run | i file prompt\") if file_prompt_mode_result.failed: raise FailedToDetermineDeviceState(\"failed to determine file prompt mode\") return self._post_determine_file_prompt_mode(output=file_prompt_mode_result.result) def _delete_candidate_config(self) -> Response: \"\"\" Delete candidate config from the filesystem Args: N/A Returns: Response: response from deleting the candidate config Raises: N/A \"\"\" # have to check again because the candidate config may have changed this! file_prompt_mode = self._determine_file_prompt_mode() if file_prompt_mode in (FilePromptMode.ALERT, FilePromptMode.NOISY): delete_events = [ ( f\"delete {self.filesystem}{self.candidate_config_filename}\", \"Delete filename\", ), ( \"\", \"[confirm]\", ), (\"\", \"\"), ] else: delete_events = [ (f\"delete {self.filesystem}{self.candidate_config_filename}\", \"[confirm]\"), (\"\", \"\"), ] delete_result = self.conn.send_interactive(interact_events=delete_events) return delete_result def get_version(self) -> ScrapliCfgResponse: response = self._pre_get_version() version_result = self.conn.send_command(command=\"show version | i Version\") return self._post_get_version( response=response, scrapli_responses=[version_result], result=self._parse_version(device_output=version_result.result), ) def get_config(self, source: str = \"running\") -> ScrapliCfgResponse: response = self._pre_get_config(source=source) config_result = self.conn.send_command(command=self._get_config_command(source=source)) return self._post_get_config( response=response, source=source, scrapli_responses=[config_result], result=config_result.result, ) def load_config(self, config: str, replace: bool = False, **kwargs: Any) -> ScrapliCfgResponse: \"\"\" Load configuration to a device Supported kwargs: auto_clean: automatically \"clean\" any data that would be in a configuration from a \"get_config\" operation that would prevent loading a config -- for example, things like the \"Building Configuration\" lines in IOSXE output, etc.. Defaults to `True` Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for iosxe supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" if kwargs.get(\"auto_clean\", True) is True: config = self.clean_config(config=config) response = self._pre_load_config(config=config) config = self._prepare_load_config(config=config, replace=replace) filesystem_bytes_available = self._get_filesystem_space_available() self._space_available(filesystem_bytes_available=filesystem_bytes_available) # when in tcl command mode or whatever it is, tcl wants \\r for return char, so stash the # original return char and sub in \\r for a bit original_return_char = self.conn.comms_return_char tcl_comms_return_char = \"\\r\" # pop into tclsh before swapping the return char just to be safe -- \\r or \\n should both be # fine for up to here but who knows... :) self.conn.acquire_priv(desired_priv=\"tclsh\") self.conn.comms_return_char = tcl_comms_return_char config_result = self.conn.send_config(config=config, privilege_level=\"tclsh\") # reset the return char to the \"normal\" one and drop into whatever is the \"default\" priv self.conn.acquire_priv(desired_priv=self.conn.default_desired_privilege_level) self.conn.comms_return_char = original_return_char return self._post_load_config( response=response, scrapli_responses=[config_result], ) def abort_config(self) -> ScrapliCfgResponse: response = self._pre_abort_config( session_or_config_file=bool(self.candidate_config_filename) ) abort_result = self._delete_candidate_config() self._reset_config_session() return self._post_abort_config(response=response, scrapli_responses=[abort_result]) def save_config(self) -> Response: \"\"\" Save the config -- \"copy run start\"! Args: N/A Returns: Response: scrapli response object Raises: N/A \"\"\" # we always re-check file prompt mode because it could have changed! file_prompt_mode = self._determine_file_prompt_mode() if file_prompt_mode == FilePromptMode.ALERT: save_events = [ ( \"copy running-config startup-config\", \"Destination filename\", ), (\"\", \"\"), ] elif file_prompt_mode == FilePromptMode.NOISY: save_events = [ ( \"copy running-config startup-config\", \"Source filename\", ), ( \"\", \"Destination filename\", ), (\"\", \"\"), ] else: save_events = [(\"copy running-config startup-config\", \"\")] save_result = self.conn.send_interactive(interact_events=save_events) return save_result def _commit_config_merge(self, file_prompt_mode: Optional[FilePromptMode] = None) -> Response: \"\"\" Commit the configuration in merge mode Args: file_prompt_mode: optionally provide the file prompt mode, if its None we will fetch it to decide if we need to use interactive mode or not Returns: Response: scrapli response object Raises: N/A \"\"\" if file_prompt_mode is None: file_prompt_mode = self._determine_file_prompt_mode() if file_prompt_mode == FilePromptMode.ALERT: merge_events = [ ( f\"copy {self.filesystem}{self.candidate_config_filename} running-config\", \"Destination filename\", ), (\"\", \"\"), ] elif file_prompt_mode == FilePromptMode.NOISY: merge_events = [ ( f\"copy {self.filesystem}{self.candidate_config_filename} running-config\", \"Source filename\", ), ( \"\", \"Destination filename\", ), (\"\", \"\"), ] else: merge_events = [ (f\"copy {self.filesystem}{self.candidate_config_filename} running-config\", \"\") ] commit_result = self.conn.send_interactive(interact_events=merge_events) return commit_result def commit_config(self, source: str = \"running\") -> ScrapliCfgResponse: scrapli_responses = [] response = self._pre_commit_config( source=source, session_or_config_file=bool(self.candidate_config_filename) ) file_prompt_mode = self._determine_file_prompt_mode() if self._replace is True: replace_command = ( f\"configure replace {self.filesystem}{self.candidate_config_filename} force\" ) commit_result = self.conn.send_command(command=replace_command) else: commit_result = self._commit_config_merge(file_prompt_mode=file_prompt_mode) scrapli_responses.append(commit_result) save_config_result = self.save_config() scrapli_responses.append(save_config_result) if self.cleanup_post_commit: cleanup_result = self._delete_candidate_config() scrapli_responses.append(cleanup_result) self._reset_config_session() return self._post_load_config( response=response, scrapli_responses=scrapli_responses, ) def diff_config(self, source: str = \"running\") -> ScrapliCfgDiffResponse: scrapli_responses = [] device_diff = \"\" source_config = \"\" diff_response = self._pre_diff_config( source=source, session_or_config_file=bool(self.candidate_config_filename) ) try: diff_result = self.conn.send_command(command=self._get_diff_command(source=source)) scrapli_responses.append(diff_result) if diff_result.failed: msg = \"failed generating diff for config session\" self.logger.critical(msg) raise DiffConfigError(msg) device_diff = diff_result.result source_config_result = self.get_config(source=source) source_config = source_config_result.result if isinstance(source_config_result.scrapli_responses, MultiResponse): # in this case this will always be a multiresponse or nothing (failure) but mypy # doesnt know that, hence the isinstance check scrapli_responses.extend(source_config_result.scrapli_responses) if source_config_result.failed: msg = \"failed fetching source config for diff comparison\" self.logger.critical(msg) raise DiffConfigError(msg) except DiffConfigError: pass return self._post_diff_config( diff_response=diff_response, scrapli_responses=scrapli_responses, source_config=self.clean_config(source_config), candidate_config=self.clean_config(self.candidate_config), device_diff=device_diff, ) Ancestors (in MRO) \u00b6 scrapli_cfg.platform.base.sync_platform.ScrapliCfgPlatform abc.ABC scrapli_cfg.platform.base.base_platform.ScrapliCfgBase scrapli_cfg.platform.core.cisco_iosxe.base_platform.ScrapliCfgIOSXEBase Class variables \u00b6 conn: Union[scrapli.driver.network.sync_driver.NetworkDriver, scrapli.driver.network.async_driver.AsyncNetworkDriver] Methods \u00b6 load_config \u00b6 load_config(self, config: str, replace: bool = False, **kwargs: Any) \u2011> scrapli_cfg.response.ScrapliCfgResponse 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 Load configuration to a device Supported kwargs: auto_clean: automatically \"clean\" any data that would be in a configuration from a \"get_config\" operation that would prevent loading a config -- for example, things like the \"Building Configuration\" lines in IOSXE output, etc.. Defaults to `True` Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for iosxe supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A save_config \u00b6 save_config(self) \u2011> scrapli.response.Response 1 2 3 4 5 6 7 8 9 10 Save the config -- \"copy run start\"! Args: N/A Returns: Response: scrapli response object Raises: N/A","title":"Sync Platform"},{"location":"api_docs/platform/core/cisco_iosxe/sync_platform/#module-scrapli_cfgplatformcorecisco_iosxesync_platform","text":"scrapli_cfg.platform.core.cisco_iosxe.sync_platform Expand source code \"\"\"scrapli_cfg.platform.core.cisco_iosxe.sync_platform\"\"\" from typing import Any, Callable, List, Optional from scrapli.driver import NetworkDriver from scrapli.response import MultiResponse, Response from scrapli_cfg.diff import ScrapliCfgDiffResponse from scrapli_cfg.exceptions import DiffConfigError, FailedToDetermineDeviceState from scrapli_cfg.platform.base.sync_platform import ScrapliCfgPlatform from scrapli_cfg.platform.core.cisco_iosxe.base_platform import ( CONFIG_SOURCES, FilePromptMode, ScrapliCfgIOSXEBase, ) from scrapli_cfg.response import ScrapliCfgResponse class ScrapliCfgIOSXE(ScrapliCfgPlatform, ScrapliCfgIOSXEBase): def __init__( self, conn: NetworkDriver, *, config_sources: Optional[List[str]] = None, on_prepare: Optional[Callable[..., Any]] = None, filesystem: str = \"flash:\", cleanup_post_commit: bool = True, dedicated_connection: bool = False, ignore_version: bool = False, ) -> None: if config_sources is None: config_sources = CONFIG_SOURCES super().__init__( conn=conn, config_sources=config_sources, on_prepare=on_prepare, dedicated_connection=dedicated_connection, ignore_version=ignore_version, ) self.filesystem = filesystem self._filesystem_space_available_buffer_perc = 10 self._replace = False self.candidate_config_filename = \"\" self.cleanup_post_commit = cleanup_post_commit def _get_filesystem_space_available(self) -> int: \"\"\" Abort a configuration -- discards any loaded config Args: N/A Returns: None Raises: FailedToDetermineDeviceState: if unable to fetch file filesystem bytes available \"\"\" filesystem_size_result = self.conn.send_command(command=f\"dir {self.filesystem} | i bytes\") if filesystem_size_result.failed: raise FailedToDetermineDeviceState(\"failed to determine space available on filesystem\") return self._post_get_filesystem_space_available(output=filesystem_size_result.result) def _determine_file_prompt_mode(self) -> FilePromptMode: \"\"\" Determine the device file prompt mode Args: N/A Returns: FilePromptMode: enum representing file prompt mode Raises: FailedToDetermineDeviceState: if unable to fetch file prompt mode \"\"\" file_prompt_mode_result = self.conn.send_command(command=\"show run | i file prompt\") if file_prompt_mode_result.failed: raise FailedToDetermineDeviceState(\"failed to determine file prompt mode\") return self._post_determine_file_prompt_mode(output=file_prompt_mode_result.result) def _delete_candidate_config(self) -> Response: \"\"\" Delete candidate config from the filesystem Args: N/A Returns: Response: response from deleting the candidate config Raises: N/A \"\"\" # have to check again because the candidate config may have changed this! file_prompt_mode = self._determine_file_prompt_mode() if file_prompt_mode in (FilePromptMode.ALERT, FilePromptMode.NOISY): delete_events = [ ( f\"delete {self.filesystem}{self.candidate_config_filename}\", \"Delete filename\", ), ( \"\", \"[confirm]\", ), (\"\", \"\"), ] else: delete_events = [ (f\"delete {self.filesystem}{self.candidate_config_filename}\", \"[confirm]\"), (\"\", \"\"), ] delete_result = self.conn.send_interactive(interact_events=delete_events) return delete_result def get_version(self) -> ScrapliCfgResponse: response = self._pre_get_version() version_result = self.conn.send_command(command=\"show version | i Version\") return self._post_get_version( response=response, scrapli_responses=[version_result], result=self._parse_version(device_output=version_result.result), ) def get_config(self, source: str = \"running\") -> ScrapliCfgResponse: response = self._pre_get_config(source=source) config_result = self.conn.send_command(command=self._get_config_command(source=source)) return self._post_get_config( response=response, source=source, scrapli_responses=[config_result], result=config_result.result, ) def load_config(self, config: str, replace: bool = False, **kwargs: Any) -> ScrapliCfgResponse: \"\"\" Load configuration to a device Supported kwargs: auto_clean: automatically \"clean\" any data that would be in a configuration from a \"get_config\" operation that would prevent loading a config -- for example, things like the \"Building Configuration\" lines in IOSXE output, etc.. Defaults to `True` Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for iosxe supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" if kwargs.get(\"auto_clean\", True) is True: config = self.clean_config(config=config) response = self._pre_load_config(config=config) config = self._prepare_load_config(config=config, replace=replace) filesystem_bytes_available = self._get_filesystem_space_available() self._space_available(filesystem_bytes_available=filesystem_bytes_available) # when in tcl command mode or whatever it is, tcl wants \\r for return char, so stash the # original return char and sub in \\r for a bit original_return_char = self.conn.comms_return_char tcl_comms_return_char = \"\\r\" # pop into tclsh before swapping the return char just to be safe -- \\r or \\n should both be # fine for up to here but who knows... :) self.conn.acquire_priv(desired_priv=\"tclsh\") self.conn.comms_return_char = tcl_comms_return_char config_result = self.conn.send_config(config=config, privilege_level=\"tclsh\") # reset the return char to the \"normal\" one and drop into whatever is the \"default\" priv self.conn.acquire_priv(desired_priv=self.conn.default_desired_privilege_level) self.conn.comms_return_char = original_return_char return self._post_load_config( response=response, scrapli_responses=[config_result], ) def abort_config(self) -> ScrapliCfgResponse: response = self._pre_abort_config( session_or_config_file=bool(self.candidate_config_filename) ) abort_result = self._delete_candidate_config() self._reset_config_session() return self._post_abort_config(response=response, scrapli_responses=[abort_result]) def save_config(self) -> Response: \"\"\" Save the config -- \"copy run start\"! Args: N/A Returns: Response: scrapli response object Raises: N/A \"\"\" # we always re-check file prompt mode because it could have changed! file_prompt_mode = self._determine_file_prompt_mode() if file_prompt_mode == FilePromptMode.ALERT: save_events = [ ( \"copy running-config startup-config\", \"Destination filename\", ), (\"\", \"\"), ] elif file_prompt_mode == FilePromptMode.NOISY: save_events = [ ( \"copy running-config startup-config\", \"Source filename\", ), ( \"\", \"Destination filename\", ), (\"\", \"\"), ] else: save_events = [(\"copy running-config startup-config\", \"\")] save_result = self.conn.send_interactive(interact_events=save_events) return save_result def _commit_config_merge(self, file_prompt_mode: Optional[FilePromptMode] = None) -> Response: \"\"\" Commit the configuration in merge mode Args: file_prompt_mode: optionally provide the file prompt mode, if its None we will fetch it to decide if we need to use interactive mode or not Returns: Response: scrapli response object Raises: N/A \"\"\" if file_prompt_mode is None: file_prompt_mode = self._determine_file_prompt_mode() if file_prompt_mode == FilePromptMode.ALERT: merge_events = [ ( f\"copy {self.filesystem}{self.candidate_config_filename} running-config\", \"Destination filename\", ), (\"\", \"\"), ] elif file_prompt_mode == FilePromptMode.NOISY: merge_events = [ ( f\"copy {self.filesystem}{self.candidate_config_filename} running-config\", \"Source filename\", ), ( \"\", \"Destination filename\", ), (\"\", \"\"), ] else: merge_events = [ (f\"copy {self.filesystem}{self.candidate_config_filename} running-config\", \"\") ] commit_result = self.conn.send_interactive(interact_events=merge_events) return commit_result def commit_config(self, source: str = \"running\") -> ScrapliCfgResponse: scrapli_responses = [] response = self._pre_commit_config( source=source, session_or_config_file=bool(self.candidate_config_filename) ) file_prompt_mode = self._determine_file_prompt_mode() if self._replace is True: replace_command = ( f\"configure replace {self.filesystem}{self.candidate_config_filename} force\" ) commit_result = self.conn.send_command(command=replace_command) else: commit_result = self._commit_config_merge(file_prompt_mode=file_prompt_mode) scrapli_responses.append(commit_result) save_config_result = self.save_config() scrapli_responses.append(save_config_result) if self.cleanup_post_commit: cleanup_result = self._delete_candidate_config() scrapli_responses.append(cleanup_result) self._reset_config_session() return self._post_load_config( response=response, scrapli_responses=scrapli_responses, ) def diff_config(self, source: str = \"running\") -> ScrapliCfgDiffResponse: scrapli_responses = [] device_diff = \"\" source_config = \"\" diff_response = self._pre_diff_config( source=source, session_or_config_file=bool(self.candidate_config_filename) ) try: diff_result = self.conn.send_command(command=self._get_diff_command(source=source)) scrapli_responses.append(diff_result) if diff_result.failed: msg = \"failed generating diff for config session\" self.logger.critical(msg) raise DiffConfigError(msg) device_diff = diff_result.result source_config_result = self.get_config(source=source) source_config = source_config_result.result if isinstance(source_config_result.scrapli_responses, MultiResponse): # in this case this will always be a multiresponse or nothing (failure) but mypy # doesnt know that, hence the isinstance check scrapli_responses.extend(source_config_result.scrapli_responses) if source_config_result.failed: msg = \"failed fetching source config for diff comparison\" self.logger.critical(msg) raise DiffConfigError(msg) except DiffConfigError: pass return self._post_diff_config( diff_response=diff_response, scrapli_responses=scrapli_responses, source_config=self.clean_config(source_config), candidate_config=self.clean_config(self.candidate_config), device_diff=device_diff, )","title":"Module scrapli_cfg.platform.core.cisco_iosxe.sync_platform"},{"location":"api_docs/platform/core/cisco_iosxe/sync_platform/#classes","text":"","title":"Classes"},{"location":"api_docs/platform/core/cisco_iosxe/sync_platform/#scraplicfgiosxe","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 Helper class that provides a standard way to create an ABC using inheritance. Scrapli Config base class Args: conn: scrapli connection to use config_sources: list of config sources on_prepare: optional callable to run at connection `prepare` dedicated_connection: if `False` (default value) scrapli cfg will not open or close the underlying scrapli connection and will raise an exception if the scrapli connection is not open. If `True` will automatically open and close the scrapli connection when using with a context manager, `prepare` will open the scrapli connection (if not already open), and `close` will close the scrapli connection. ignore_version: ignore checking device version support; currently this just means that scrapli-cfg will not fetch the device version during the prepare phase, however this will (hopefully) be used in the future to limit what methods can be used against a target device. For example, for EOS devices we need > 4.14 to load configs; so if a device is encountered at 4.13 the version check would raise an exception rather than just failing in a potentially awkward fashion. Returns: None Raises: N/A Expand source code class ScrapliCfgIOSXE(ScrapliCfgPlatform, ScrapliCfgIOSXEBase): def __init__( self, conn: NetworkDriver, *, config_sources: Optional[List[str]] = None, on_prepare: Optional[Callable[..., Any]] = None, filesystem: str = \"flash:\", cleanup_post_commit: bool = True, dedicated_connection: bool = False, ignore_version: bool = False, ) -> None: if config_sources is None: config_sources = CONFIG_SOURCES super().__init__( conn=conn, config_sources=config_sources, on_prepare=on_prepare, dedicated_connection=dedicated_connection, ignore_version=ignore_version, ) self.filesystem = filesystem self._filesystem_space_available_buffer_perc = 10 self._replace = False self.candidate_config_filename = \"\" self.cleanup_post_commit = cleanup_post_commit def _get_filesystem_space_available(self) -> int: \"\"\" Abort a configuration -- discards any loaded config Args: N/A Returns: None Raises: FailedToDetermineDeviceState: if unable to fetch file filesystem bytes available \"\"\" filesystem_size_result = self.conn.send_command(command=f\"dir {self.filesystem} | i bytes\") if filesystem_size_result.failed: raise FailedToDetermineDeviceState(\"failed to determine space available on filesystem\") return self._post_get_filesystem_space_available(output=filesystem_size_result.result) def _determine_file_prompt_mode(self) -> FilePromptMode: \"\"\" Determine the device file prompt mode Args: N/A Returns: FilePromptMode: enum representing file prompt mode Raises: FailedToDetermineDeviceState: if unable to fetch file prompt mode \"\"\" file_prompt_mode_result = self.conn.send_command(command=\"show run | i file prompt\") if file_prompt_mode_result.failed: raise FailedToDetermineDeviceState(\"failed to determine file prompt mode\") return self._post_determine_file_prompt_mode(output=file_prompt_mode_result.result) def _delete_candidate_config(self) -> Response: \"\"\" Delete candidate config from the filesystem Args: N/A Returns: Response: response from deleting the candidate config Raises: N/A \"\"\" # have to check again because the candidate config may have changed this! file_prompt_mode = self._determine_file_prompt_mode() if file_prompt_mode in (FilePromptMode.ALERT, FilePromptMode.NOISY): delete_events = [ ( f\"delete {self.filesystem}{self.candidate_config_filename}\", \"Delete filename\", ), ( \"\", \"[confirm]\", ), (\"\", \"\"), ] else: delete_events = [ (f\"delete {self.filesystem}{self.candidate_config_filename}\", \"[confirm]\"), (\"\", \"\"), ] delete_result = self.conn.send_interactive(interact_events=delete_events) return delete_result def get_version(self) -> ScrapliCfgResponse: response = self._pre_get_version() version_result = self.conn.send_command(command=\"show version | i Version\") return self._post_get_version( response=response, scrapli_responses=[version_result], result=self._parse_version(device_output=version_result.result), ) def get_config(self, source: str = \"running\") -> ScrapliCfgResponse: response = self._pre_get_config(source=source) config_result = self.conn.send_command(command=self._get_config_command(source=source)) return self._post_get_config( response=response, source=source, scrapli_responses=[config_result], result=config_result.result, ) def load_config(self, config: str, replace: bool = False, **kwargs: Any) -> ScrapliCfgResponse: \"\"\" Load configuration to a device Supported kwargs: auto_clean: automatically \"clean\" any data that would be in a configuration from a \"get_config\" operation that would prevent loading a config -- for example, things like the \"Building Configuration\" lines in IOSXE output, etc.. Defaults to `True` Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for iosxe supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" if kwargs.get(\"auto_clean\", True) is True: config = self.clean_config(config=config) response = self._pre_load_config(config=config) config = self._prepare_load_config(config=config, replace=replace) filesystem_bytes_available = self._get_filesystem_space_available() self._space_available(filesystem_bytes_available=filesystem_bytes_available) # when in tcl command mode or whatever it is, tcl wants \\r for return char, so stash the # original return char and sub in \\r for a bit original_return_char = self.conn.comms_return_char tcl_comms_return_char = \"\\r\" # pop into tclsh before swapping the return char just to be safe -- \\r or \\n should both be # fine for up to here but who knows... :) self.conn.acquire_priv(desired_priv=\"tclsh\") self.conn.comms_return_char = tcl_comms_return_char config_result = self.conn.send_config(config=config, privilege_level=\"tclsh\") # reset the return char to the \"normal\" one and drop into whatever is the \"default\" priv self.conn.acquire_priv(desired_priv=self.conn.default_desired_privilege_level) self.conn.comms_return_char = original_return_char return self._post_load_config( response=response, scrapli_responses=[config_result], ) def abort_config(self) -> ScrapliCfgResponse: response = self._pre_abort_config( session_or_config_file=bool(self.candidate_config_filename) ) abort_result = self._delete_candidate_config() self._reset_config_session() return self._post_abort_config(response=response, scrapli_responses=[abort_result]) def save_config(self) -> Response: \"\"\" Save the config -- \"copy run start\"! Args: N/A Returns: Response: scrapli response object Raises: N/A \"\"\" # we always re-check file prompt mode because it could have changed! file_prompt_mode = self._determine_file_prompt_mode() if file_prompt_mode == FilePromptMode.ALERT: save_events = [ ( \"copy running-config startup-config\", \"Destination filename\", ), (\"\", \"\"), ] elif file_prompt_mode == FilePromptMode.NOISY: save_events = [ ( \"copy running-config startup-config\", \"Source filename\", ), ( \"\", \"Destination filename\", ), (\"\", \"\"), ] else: save_events = [(\"copy running-config startup-config\", \"\")] save_result = self.conn.send_interactive(interact_events=save_events) return save_result def _commit_config_merge(self, file_prompt_mode: Optional[FilePromptMode] = None) -> Response: \"\"\" Commit the configuration in merge mode Args: file_prompt_mode: optionally provide the file prompt mode, if its None we will fetch it to decide if we need to use interactive mode or not Returns: Response: scrapli response object Raises: N/A \"\"\" if file_prompt_mode is None: file_prompt_mode = self._determine_file_prompt_mode() if file_prompt_mode == FilePromptMode.ALERT: merge_events = [ ( f\"copy {self.filesystem}{self.candidate_config_filename} running-config\", \"Destination filename\", ), (\"\", \"\"), ] elif file_prompt_mode == FilePromptMode.NOISY: merge_events = [ ( f\"copy {self.filesystem}{self.candidate_config_filename} running-config\", \"Source filename\", ), ( \"\", \"Destination filename\", ), (\"\", \"\"), ] else: merge_events = [ (f\"copy {self.filesystem}{self.candidate_config_filename} running-config\", \"\") ] commit_result = self.conn.send_interactive(interact_events=merge_events) return commit_result def commit_config(self, source: str = \"running\") -> ScrapliCfgResponse: scrapli_responses = [] response = self._pre_commit_config( source=source, session_or_config_file=bool(self.candidate_config_filename) ) file_prompt_mode = self._determine_file_prompt_mode() if self._replace is True: replace_command = ( f\"configure replace {self.filesystem}{self.candidate_config_filename} force\" ) commit_result = self.conn.send_command(command=replace_command) else: commit_result = self._commit_config_merge(file_prompt_mode=file_prompt_mode) scrapli_responses.append(commit_result) save_config_result = self.save_config() scrapli_responses.append(save_config_result) if self.cleanup_post_commit: cleanup_result = self._delete_candidate_config() scrapli_responses.append(cleanup_result) self._reset_config_session() return self._post_load_config( response=response, scrapli_responses=scrapli_responses, ) def diff_config(self, source: str = \"running\") -> ScrapliCfgDiffResponse: scrapli_responses = [] device_diff = \"\" source_config = \"\" diff_response = self._pre_diff_config( source=source, session_or_config_file=bool(self.candidate_config_filename) ) try: diff_result = self.conn.send_command(command=self._get_diff_command(source=source)) scrapli_responses.append(diff_result) if diff_result.failed: msg = \"failed generating diff for config session\" self.logger.critical(msg) raise DiffConfigError(msg) device_diff = diff_result.result source_config_result = self.get_config(source=source) source_config = source_config_result.result if isinstance(source_config_result.scrapli_responses, MultiResponse): # in this case this will always be a multiresponse or nothing (failure) but mypy # doesnt know that, hence the isinstance check scrapli_responses.extend(source_config_result.scrapli_responses) if source_config_result.failed: msg = \"failed fetching source config for diff comparison\" self.logger.critical(msg) raise DiffConfigError(msg) except DiffConfigError: pass return self._post_diff_config( diff_response=diff_response, scrapli_responses=scrapli_responses, source_config=self.clean_config(source_config), candidate_config=self.clean_config(self.candidate_config), device_diff=device_diff, )","title":"ScrapliCfgIOSXE"},{"location":"api_docs/platform/core/cisco_iosxe/sync_platform/#ancestors-in-mro","text":"scrapli_cfg.platform.base.sync_platform.ScrapliCfgPlatform abc.ABC scrapli_cfg.platform.base.base_platform.ScrapliCfgBase scrapli_cfg.platform.core.cisco_iosxe.base_platform.ScrapliCfgIOSXEBase","title":"Ancestors (in MRO)"},{"location":"api_docs/platform/core/cisco_iosxe/sync_platform/#class-variables","text":"conn: Union[scrapli.driver.network.sync_driver.NetworkDriver, scrapli.driver.network.async_driver.AsyncNetworkDriver]","title":"Class variables"},{"location":"api_docs/platform/core/cisco_iosxe/sync_platform/#methods","text":"","title":"Methods"},{"location":"api_docs/platform/core/cisco_iosxe/sync_platform/#load_config","text":"load_config(self, config: str, replace: bool = False, **kwargs: Any) \u2011> scrapli_cfg.response.ScrapliCfgResponse 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 Load configuration to a device Supported kwargs: auto_clean: automatically \"clean\" any data that would be in a configuration from a \"get_config\" operation that would prevent loading a config -- for example, things like the \"Building Configuration\" lines in IOSXE output, etc.. Defaults to `True` Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for iosxe supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A","title":"load_config"},{"location":"api_docs/platform/core/cisco_iosxe/sync_platform/#save_config","text":"save_config(self) \u2011> scrapli.response.Response 1 2 3 4 5 6 7 8 9 10 Save the config -- \"copy run start\"! Args: N/A Returns: Response: scrapli response object Raises: N/A","title":"save_config"},{"location":"api_docs/platform/core/cisco_iosxe/types/","text":"window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting()) Module scrapli_cfg.platform.core.cisco_iosxe.types \u00b6 scrapli_cfg.platform.core.cisco_iosxe.types Expand source code \"\"\"scrapli_cfg.platform.core.cisco_iosxe.types\"\"\" from enum import Enum class FilePromptMode(Enum): \"\"\"Enum representing file prompt modes\"\"\" NOISY = \"noisy\" ALERT = \"alert\" QUIET = \"quiet\" Classes \u00b6 FilePromptMode \u00b6 1 Enum representing file prompt modes Expand source code class FilePromptMode(Enum): \"\"\"Enum representing file prompt modes\"\"\" NOISY = \"noisy\" ALERT = \"alert\" QUIET = \"quiet\" Ancestors (in MRO) \u00b6 enum.Enum Class variables \u00b6 ALERT NOISY QUIET","title":"Types"},{"location":"api_docs/platform/core/cisco_iosxe/types/#module-scrapli_cfgplatformcorecisco_iosxetypes","text":"scrapli_cfg.platform.core.cisco_iosxe.types Expand source code \"\"\"scrapli_cfg.platform.core.cisco_iosxe.types\"\"\" from enum import Enum class FilePromptMode(Enum): \"\"\"Enum representing file prompt modes\"\"\" NOISY = \"noisy\" ALERT = \"alert\" QUIET = \"quiet\"","title":"Module scrapli_cfg.platform.core.cisco_iosxe.types"},{"location":"api_docs/platform/core/cisco_iosxe/types/#classes","text":"","title":"Classes"},{"location":"api_docs/platform/core/cisco_iosxe/types/#filepromptmode","text":"1 Enum representing file prompt modes Expand source code class FilePromptMode(Enum): \"\"\"Enum representing file prompt modes\"\"\" NOISY = \"noisy\" ALERT = \"alert\" QUIET = \"quiet\"","title":"FilePromptMode"},{"location":"api_docs/platform/core/cisco_iosxe/types/#ancestors-in-mro","text":"enum.Enum","title":"Ancestors (in MRO)"},{"location":"api_docs/platform/core/cisco_iosxe/types/#class-variables","text":"ALERT NOISY QUIET","title":"Class variables"},{"location":"api_docs/platform/core/cisco_iosxr/async_platform/","text":"window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting()) Module scrapli_cfg.platform.core.cisco_iosxr.async_platform \u00b6 scrapli_cfg.platform.core.cisco_iosxr.async_platform Expand source code \"\"\"scrapli_cfg.platform.core.cisco_iosxr.async_platform\"\"\" from typing import Any, Callable, List, Optional, Union from scrapli.driver import AsyncNetworkDriver from scrapli.response import MultiResponse, Response from scrapli_cfg.diff import ScrapliCfgDiffResponse from scrapli_cfg.exceptions import DiffConfigError, LoadConfigError from scrapli_cfg.platform.base.async_platform import AsyncScrapliCfgPlatform from scrapli_cfg.platform.core.cisco_iosxr.base_platform import CONFIG_SOURCES, ScrapliCfgIOSXRBase from scrapli_cfg.response import ScrapliCfgResponse class AsyncScrapliCfgIOSXR(AsyncScrapliCfgPlatform, ScrapliCfgIOSXRBase): def __init__( self, conn: AsyncNetworkDriver, *, config_sources: Optional[List[str]] = None, on_prepare: Optional[Callable[..., Any]] = None, dedicated_connection: bool = False, ignore_version: bool = False, ) -> None: if config_sources is None: config_sources = CONFIG_SOURCES super().__init__( conn=conn, config_sources=config_sources, on_prepare=on_prepare, dedicated_connection=dedicated_connection, ignore_version=ignore_version, ) self._replace = False self._in_configuration_session = False self._config_privilege_level = \"configuration\" async def get_version(self) -> ScrapliCfgResponse: response = self._pre_get_version() version_result = await self.conn.send_command(command=\"show version | i Version\") return self._post_get_version( response=response, scrapli_responses=[version_result], result=self._parse_version(device_output=version_result.result), ) async def get_config(self, source: str = \"running\") -> ScrapliCfgResponse: response = self._pre_get_config(source=source) if not self._in_configuration_session: config_result = await self.conn.send_command(command=\"show running-config\") else: config_result = await self.conn.send_config( config=\"show running-config\", privilege_level=self._config_privilege_level ) return self._post_get_config( response=response, source=source, scrapli_responses=[config_result], result=config_result.result, ) async def load_config( self, config: str, replace: bool = False, **kwargs: Any ) -> ScrapliCfgResponse: \"\"\" Load configuration to a device Supported kwargs: exclusive: True/False use `configure exclusive` mode Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for iosxr supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" scrapli_responses = [] response = self._pre_load_config(config=config) exclusive = kwargs.get(\"exclusive\", False) config, eager_config = self._prepare_load_config_session_and_payload( config=config, replace=replace, exclusive=exclusive ) try: config_result = await self.conn.send_config( config=config, privilege_level=self._config_privilege_level ) scrapli_responses.append(config_result) if config_result.failed: msg = \"failed to load the candidate config into the config session\" self.logger.critical(msg) raise LoadConfigError(msg) # eager cuz banners and such; perhaps if no banner/macro we can disable eager though.... if eager_config: eager_config_result = await self.conn.send_config( config=eager_config, privilege_level=self._config_privilege_level, eager=True ) scrapli_responses.append(eager_config_result) if eager_config_result.failed: msg = \"failed to load the candidate config into the config session\" self.logger.critical(msg) raise LoadConfigError(msg) except LoadConfigError: pass return self._post_load_config( response=response, scrapli_responses=scrapli_responses, ) async def abort_config(self) -> ScrapliCfgResponse: response = self._pre_abort_config(session_or_config_file=self._in_configuration_session) await self.conn._abort_config() # pylint: disable=W0212 self._reset_config_session() return self._post_abort_config(response=response, scrapli_responses=[]) async def commit_config(self, source: str = \"running\") -> ScrapliCfgResponse: scrapli_responses: List[Union[MultiResponse, Response]] = [] response = self._pre_commit_config( source=source, session_or_config_file=self._in_configuration_session ) if self._replace is True: commit_events = [(\"commit replace\", \"proceed?\"), (\"yes\", \"\")] commit_result = await self.conn.send_interactive( interact_events=commit_events, privilege_level=self._config_privilege_level ) else: commit_result = await self.conn.send_config(config=\"commit\") scrapli_responses.append(commit_result) self._reset_config_session() return self._post_commit_config(response=response, scrapli_responses=[commit_result]) async def diff_config(self, source: str = \"running\") -> ScrapliCfgDiffResponse: scrapli_responses = [] device_diff = \"\" source_config = \"\" diff_response = self._pre_diff_config( source=source, session_or_config_file=self._in_configuration_session ) try: diff_result = await self.conn.send_config( config=self._get_diff_command(), privilege_level=self._config_privilege_level ) scrapli_responses.append(diff_result) if diff_result.failed: msg = \"failed generating diff for config session\" self.logger.critical(msg) raise DiffConfigError(msg) device_diff = diff_result.result source_config_result = await self.get_config(source=source) source_config = source_config_result.result if isinstance(source_config_result.scrapli_responses, MultiResponse): # in this case this will always be a multiresponse or nothing (failure) but mypy # doesnt know that, hence the isinstance check scrapli_responses.extend(source_config_result.scrapli_responses) if source_config_result.failed: msg = \"failed fetching source config for diff comparison\" self.logger.critical(msg) raise DiffConfigError(msg) except DiffConfigError: pass return self._post_diff_config( diff_response=diff_response, scrapli_responses=scrapli_responses, source_config=self.clean_config(source_config), candidate_config=self.clean_config(self.candidate_config), device_diff=device_diff, ) Classes \u00b6 AsyncScrapliCfgIOSXR \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 Helper class that provides a standard way to create an ABC using inheritance. Scrapli Config async base class Args: conn: scrapli connection to use config_sources: list of config sources on_prepare: optional callable to run at connection `prepare` dedicated_connection: if `False` (default value) scrapli cfg will not open or close the underlying scrapli connection and will raise an exception if the scrapli connection is not open. If `True` will automatically open and close the scrapli connection when using with a context manager, `prepare` will open the scrapli connection (if not already open), and `close` will close the scrapli connection. ignore_version: ignore checking device version support; currently this just means that scrapli-cfg will not fetch the device version during the prepare phase, however this will (hopefully) be used in the future to limit what methods can be used against a target device. For example, for EOS devices we need > 4.14 to load configs; so if a device is encountered at 4.13 the version check would raise an exception rather than just failing in a potentially awkward fashion. Returns: None Raises: N/A Expand source code class AsyncScrapliCfgIOSXR(AsyncScrapliCfgPlatform, ScrapliCfgIOSXRBase): def __init__( self, conn: AsyncNetworkDriver, *, config_sources: Optional[List[str]] = None, on_prepare: Optional[Callable[..., Any]] = None, dedicated_connection: bool = False, ignore_version: bool = False, ) -> None: if config_sources is None: config_sources = CONFIG_SOURCES super().__init__( conn=conn, config_sources=config_sources, on_prepare=on_prepare, dedicated_connection=dedicated_connection, ignore_version=ignore_version, ) self._replace = False self._in_configuration_session = False self._config_privilege_level = \"configuration\" async def get_version(self) -> ScrapliCfgResponse: response = self._pre_get_version() version_result = await self.conn.send_command(command=\"show version | i Version\") return self._post_get_version( response=response, scrapli_responses=[version_result], result=self._parse_version(device_output=version_result.result), ) async def get_config(self, source: str = \"running\") -> ScrapliCfgResponse: response = self._pre_get_config(source=source) if not self._in_configuration_session: config_result = await self.conn.send_command(command=\"show running-config\") else: config_result = await self.conn.send_config( config=\"show running-config\", privilege_level=self._config_privilege_level ) return self._post_get_config( response=response, source=source, scrapli_responses=[config_result], result=config_result.result, ) async def load_config( self, config: str, replace: bool = False, **kwargs: Any ) -> ScrapliCfgResponse: \"\"\" Load configuration to a device Supported kwargs: exclusive: True/False use `configure exclusive` mode Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for iosxr supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" scrapli_responses = [] response = self._pre_load_config(config=config) exclusive = kwargs.get(\"exclusive\", False) config, eager_config = self._prepare_load_config_session_and_payload( config=config, replace=replace, exclusive=exclusive ) try: config_result = await self.conn.send_config( config=config, privilege_level=self._config_privilege_level ) scrapli_responses.append(config_result) if config_result.failed: msg = \"failed to load the candidate config into the config session\" self.logger.critical(msg) raise LoadConfigError(msg) # eager cuz banners and such; perhaps if no banner/macro we can disable eager though.... if eager_config: eager_config_result = await self.conn.send_config( config=eager_config, privilege_level=self._config_privilege_level, eager=True ) scrapli_responses.append(eager_config_result) if eager_config_result.failed: msg = \"failed to load the candidate config into the config session\" self.logger.critical(msg) raise LoadConfigError(msg) except LoadConfigError: pass return self._post_load_config( response=response, scrapli_responses=scrapli_responses, ) async def abort_config(self) -> ScrapliCfgResponse: response = self._pre_abort_config(session_or_config_file=self._in_configuration_session) await self.conn._abort_config() # pylint: disable=W0212 self._reset_config_session() return self._post_abort_config(response=response, scrapli_responses=[]) async def commit_config(self, source: str = \"running\") -> ScrapliCfgResponse: scrapli_responses: List[Union[MultiResponse, Response]] = [] response = self._pre_commit_config( source=source, session_or_config_file=self._in_configuration_session ) if self._replace is True: commit_events = [(\"commit replace\", \"proceed?\"), (\"yes\", \"\")] commit_result = await self.conn.send_interactive( interact_events=commit_events, privilege_level=self._config_privilege_level ) else: commit_result = await self.conn.send_config(config=\"commit\") scrapli_responses.append(commit_result) self._reset_config_session() return self._post_commit_config(response=response, scrapli_responses=[commit_result]) async def diff_config(self, source: str = \"running\") -> ScrapliCfgDiffResponse: scrapli_responses = [] device_diff = \"\" source_config = \"\" diff_response = self._pre_diff_config( source=source, session_or_config_file=self._in_configuration_session ) try: diff_result = await self.conn.send_config( config=self._get_diff_command(), privilege_level=self._config_privilege_level ) scrapli_responses.append(diff_result) if diff_result.failed: msg = \"failed generating diff for config session\" self.logger.critical(msg) raise DiffConfigError(msg) device_diff = diff_result.result source_config_result = await self.get_config(source=source) source_config = source_config_result.result if isinstance(source_config_result.scrapli_responses, MultiResponse): # in this case this will always be a multiresponse or nothing (failure) but mypy # doesnt know that, hence the isinstance check scrapli_responses.extend(source_config_result.scrapli_responses) if source_config_result.failed: msg = \"failed fetching source config for diff comparison\" self.logger.critical(msg) raise DiffConfigError(msg) except DiffConfigError: pass return self._post_diff_config( diff_response=diff_response, scrapli_responses=scrapli_responses, source_config=self.clean_config(source_config), candidate_config=self.clean_config(self.candidate_config), device_diff=device_diff, ) Ancestors (in MRO) \u00b6 scrapli_cfg.platform.base.async_platform.AsyncScrapliCfgPlatform abc.ABC scrapli_cfg.platform.base.base_platform.ScrapliCfgBase scrapli_cfg.platform.core.cisco_iosxr.base_platform.ScrapliCfgIOSXRBase Class variables \u00b6 conn: Union[scrapli.driver.network.sync_driver.NetworkDriver, scrapli.driver.network.async_driver.AsyncNetworkDriver] Methods \u00b6 load_config \u00b6 load_config(self, config: str, replace: bool = False, **kwargs: Any) \u2011> scrapli_cfg.response.ScrapliCfgResponse 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 Load configuration to a device Supported kwargs: exclusive: True/False use `configure exclusive` mode Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for iosxr supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A","title":"Async Platform"},{"location":"api_docs/platform/core/cisco_iosxr/async_platform/#module-scrapli_cfgplatformcorecisco_iosxrasync_platform","text":"scrapli_cfg.platform.core.cisco_iosxr.async_platform Expand source code \"\"\"scrapli_cfg.platform.core.cisco_iosxr.async_platform\"\"\" from typing import Any, Callable, List, Optional, Union from scrapli.driver import AsyncNetworkDriver from scrapli.response import MultiResponse, Response from scrapli_cfg.diff import ScrapliCfgDiffResponse from scrapli_cfg.exceptions import DiffConfigError, LoadConfigError from scrapli_cfg.platform.base.async_platform import AsyncScrapliCfgPlatform from scrapli_cfg.platform.core.cisco_iosxr.base_platform import CONFIG_SOURCES, ScrapliCfgIOSXRBase from scrapli_cfg.response import ScrapliCfgResponse class AsyncScrapliCfgIOSXR(AsyncScrapliCfgPlatform, ScrapliCfgIOSXRBase): def __init__( self, conn: AsyncNetworkDriver, *, config_sources: Optional[List[str]] = None, on_prepare: Optional[Callable[..., Any]] = None, dedicated_connection: bool = False, ignore_version: bool = False, ) -> None: if config_sources is None: config_sources = CONFIG_SOURCES super().__init__( conn=conn, config_sources=config_sources, on_prepare=on_prepare, dedicated_connection=dedicated_connection, ignore_version=ignore_version, ) self._replace = False self._in_configuration_session = False self._config_privilege_level = \"configuration\" async def get_version(self) -> ScrapliCfgResponse: response = self._pre_get_version() version_result = await self.conn.send_command(command=\"show version | i Version\") return self._post_get_version( response=response, scrapli_responses=[version_result], result=self._parse_version(device_output=version_result.result), ) async def get_config(self, source: str = \"running\") -> ScrapliCfgResponse: response = self._pre_get_config(source=source) if not self._in_configuration_session: config_result = await self.conn.send_command(command=\"show running-config\") else: config_result = await self.conn.send_config( config=\"show running-config\", privilege_level=self._config_privilege_level ) return self._post_get_config( response=response, source=source, scrapli_responses=[config_result], result=config_result.result, ) async def load_config( self, config: str, replace: bool = False, **kwargs: Any ) -> ScrapliCfgResponse: \"\"\" Load configuration to a device Supported kwargs: exclusive: True/False use `configure exclusive` mode Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for iosxr supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" scrapli_responses = [] response = self._pre_load_config(config=config) exclusive = kwargs.get(\"exclusive\", False) config, eager_config = self._prepare_load_config_session_and_payload( config=config, replace=replace, exclusive=exclusive ) try: config_result = await self.conn.send_config( config=config, privilege_level=self._config_privilege_level ) scrapli_responses.append(config_result) if config_result.failed: msg = \"failed to load the candidate config into the config session\" self.logger.critical(msg) raise LoadConfigError(msg) # eager cuz banners and such; perhaps if no banner/macro we can disable eager though.... if eager_config: eager_config_result = await self.conn.send_config( config=eager_config, privilege_level=self._config_privilege_level, eager=True ) scrapli_responses.append(eager_config_result) if eager_config_result.failed: msg = \"failed to load the candidate config into the config session\" self.logger.critical(msg) raise LoadConfigError(msg) except LoadConfigError: pass return self._post_load_config( response=response, scrapli_responses=scrapli_responses, ) async def abort_config(self) -> ScrapliCfgResponse: response = self._pre_abort_config(session_or_config_file=self._in_configuration_session) await self.conn._abort_config() # pylint: disable=W0212 self._reset_config_session() return self._post_abort_config(response=response, scrapli_responses=[]) async def commit_config(self, source: str = \"running\") -> ScrapliCfgResponse: scrapli_responses: List[Union[MultiResponse, Response]] = [] response = self._pre_commit_config( source=source, session_or_config_file=self._in_configuration_session ) if self._replace is True: commit_events = [(\"commit replace\", \"proceed?\"), (\"yes\", \"\")] commit_result = await self.conn.send_interactive( interact_events=commit_events, privilege_level=self._config_privilege_level ) else: commit_result = await self.conn.send_config(config=\"commit\") scrapli_responses.append(commit_result) self._reset_config_session() return self._post_commit_config(response=response, scrapli_responses=[commit_result]) async def diff_config(self, source: str = \"running\") -> ScrapliCfgDiffResponse: scrapli_responses = [] device_diff = \"\" source_config = \"\" diff_response = self._pre_diff_config( source=source, session_or_config_file=self._in_configuration_session ) try: diff_result = await self.conn.send_config( config=self._get_diff_command(), privilege_level=self._config_privilege_level ) scrapli_responses.append(diff_result) if diff_result.failed: msg = \"failed generating diff for config session\" self.logger.critical(msg) raise DiffConfigError(msg) device_diff = diff_result.result source_config_result = await self.get_config(source=source) source_config = source_config_result.result if isinstance(source_config_result.scrapli_responses, MultiResponse): # in this case this will always be a multiresponse or nothing (failure) but mypy # doesnt know that, hence the isinstance check scrapli_responses.extend(source_config_result.scrapli_responses) if source_config_result.failed: msg = \"failed fetching source config for diff comparison\" self.logger.critical(msg) raise DiffConfigError(msg) except DiffConfigError: pass return self._post_diff_config( diff_response=diff_response, scrapli_responses=scrapli_responses, source_config=self.clean_config(source_config), candidate_config=self.clean_config(self.candidate_config), device_diff=device_diff, )","title":"Module scrapli_cfg.platform.core.cisco_iosxr.async_platform"},{"location":"api_docs/platform/core/cisco_iosxr/async_platform/#classes","text":"","title":"Classes"},{"location":"api_docs/platform/core/cisco_iosxr/async_platform/#asyncscraplicfgiosxr","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 Helper class that provides a standard way to create an ABC using inheritance. Scrapli Config async base class Args: conn: scrapli connection to use config_sources: list of config sources on_prepare: optional callable to run at connection `prepare` dedicated_connection: if `False` (default value) scrapli cfg will not open or close the underlying scrapli connection and will raise an exception if the scrapli connection is not open. If `True` will automatically open and close the scrapli connection when using with a context manager, `prepare` will open the scrapli connection (if not already open), and `close` will close the scrapli connection. ignore_version: ignore checking device version support; currently this just means that scrapli-cfg will not fetch the device version during the prepare phase, however this will (hopefully) be used in the future to limit what methods can be used against a target device. For example, for EOS devices we need > 4.14 to load configs; so if a device is encountered at 4.13 the version check would raise an exception rather than just failing in a potentially awkward fashion. Returns: None Raises: N/A Expand source code class AsyncScrapliCfgIOSXR(AsyncScrapliCfgPlatform, ScrapliCfgIOSXRBase): def __init__( self, conn: AsyncNetworkDriver, *, config_sources: Optional[List[str]] = None, on_prepare: Optional[Callable[..., Any]] = None, dedicated_connection: bool = False, ignore_version: bool = False, ) -> None: if config_sources is None: config_sources = CONFIG_SOURCES super().__init__( conn=conn, config_sources=config_sources, on_prepare=on_prepare, dedicated_connection=dedicated_connection, ignore_version=ignore_version, ) self._replace = False self._in_configuration_session = False self._config_privilege_level = \"configuration\" async def get_version(self) -> ScrapliCfgResponse: response = self._pre_get_version() version_result = await self.conn.send_command(command=\"show version | i Version\") return self._post_get_version( response=response, scrapli_responses=[version_result], result=self._parse_version(device_output=version_result.result), ) async def get_config(self, source: str = \"running\") -> ScrapliCfgResponse: response = self._pre_get_config(source=source) if not self._in_configuration_session: config_result = await self.conn.send_command(command=\"show running-config\") else: config_result = await self.conn.send_config( config=\"show running-config\", privilege_level=self._config_privilege_level ) return self._post_get_config( response=response, source=source, scrapli_responses=[config_result], result=config_result.result, ) async def load_config( self, config: str, replace: bool = False, **kwargs: Any ) -> ScrapliCfgResponse: \"\"\" Load configuration to a device Supported kwargs: exclusive: True/False use `configure exclusive` mode Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for iosxr supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" scrapli_responses = [] response = self._pre_load_config(config=config) exclusive = kwargs.get(\"exclusive\", False) config, eager_config = self._prepare_load_config_session_and_payload( config=config, replace=replace, exclusive=exclusive ) try: config_result = await self.conn.send_config( config=config, privilege_level=self._config_privilege_level ) scrapli_responses.append(config_result) if config_result.failed: msg = \"failed to load the candidate config into the config session\" self.logger.critical(msg) raise LoadConfigError(msg) # eager cuz banners and such; perhaps if no banner/macro we can disable eager though.... if eager_config: eager_config_result = await self.conn.send_config( config=eager_config, privilege_level=self._config_privilege_level, eager=True ) scrapli_responses.append(eager_config_result) if eager_config_result.failed: msg = \"failed to load the candidate config into the config session\" self.logger.critical(msg) raise LoadConfigError(msg) except LoadConfigError: pass return self._post_load_config( response=response, scrapli_responses=scrapli_responses, ) async def abort_config(self) -> ScrapliCfgResponse: response = self._pre_abort_config(session_or_config_file=self._in_configuration_session) await self.conn._abort_config() # pylint: disable=W0212 self._reset_config_session() return self._post_abort_config(response=response, scrapli_responses=[]) async def commit_config(self, source: str = \"running\") -> ScrapliCfgResponse: scrapli_responses: List[Union[MultiResponse, Response]] = [] response = self._pre_commit_config( source=source, session_or_config_file=self._in_configuration_session ) if self._replace is True: commit_events = [(\"commit replace\", \"proceed?\"), (\"yes\", \"\")] commit_result = await self.conn.send_interactive( interact_events=commit_events, privilege_level=self._config_privilege_level ) else: commit_result = await self.conn.send_config(config=\"commit\") scrapli_responses.append(commit_result) self._reset_config_session() return self._post_commit_config(response=response, scrapli_responses=[commit_result]) async def diff_config(self, source: str = \"running\") -> ScrapliCfgDiffResponse: scrapli_responses = [] device_diff = \"\" source_config = \"\" diff_response = self._pre_diff_config( source=source, session_or_config_file=self._in_configuration_session ) try: diff_result = await self.conn.send_config( config=self._get_diff_command(), privilege_level=self._config_privilege_level ) scrapli_responses.append(diff_result) if diff_result.failed: msg = \"failed generating diff for config session\" self.logger.critical(msg) raise DiffConfigError(msg) device_diff = diff_result.result source_config_result = await self.get_config(source=source) source_config = source_config_result.result if isinstance(source_config_result.scrapli_responses, MultiResponse): # in this case this will always be a multiresponse or nothing (failure) but mypy # doesnt know that, hence the isinstance check scrapli_responses.extend(source_config_result.scrapli_responses) if source_config_result.failed: msg = \"failed fetching source config for diff comparison\" self.logger.critical(msg) raise DiffConfigError(msg) except DiffConfigError: pass return self._post_diff_config( diff_response=diff_response, scrapli_responses=scrapli_responses, source_config=self.clean_config(source_config), candidate_config=self.clean_config(self.candidate_config), device_diff=device_diff, )","title":"AsyncScrapliCfgIOSXR"},{"location":"api_docs/platform/core/cisco_iosxr/async_platform/#ancestors-in-mro","text":"scrapli_cfg.platform.base.async_platform.AsyncScrapliCfgPlatform abc.ABC scrapli_cfg.platform.base.base_platform.ScrapliCfgBase scrapli_cfg.platform.core.cisco_iosxr.base_platform.ScrapliCfgIOSXRBase","title":"Ancestors (in MRO)"},{"location":"api_docs/platform/core/cisco_iosxr/async_platform/#class-variables","text":"conn: Union[scrapli.driver.network.sync_driver.NetworkDriver, scrapli.driver.network.async_driver.AsyncNetworkDriver]","title":"Class variables"},{"location":"api_docs/platform/core/cisco_iosxr/async_platform/#methods","text":"","title":"Methods"},{"location":"api_docs/platform/core/cisco_iosxr/async_platform/#load_config","text":"load_config(self, config: str, replace: bool = False, **kwargs: Any) \u2011> scrapli_cfg.response.ScrapliCfgResponse 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 Load configuration to a device Supported kwargs: exclusive: True/False use `configure exclusive` mode Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for iosxr supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A","title":"load_config"},{"location":"api_docs/platform/core/cisco_iosxr/base_platform/","text":"window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting()) Module scrapli_cfg.platform.core.cisco_iosxr.base_platform \u00b6 scrapli_cfg.platform.core.cisco_iosxr.base_platform Expand source code \"\"\"scrapli_cfg.platform.core.cisco_iosxr.base_platform\"\"\" import re from logging import Logger, LoggerAdapter from typing import TYPE_CHECKING, Tuple from scrapli_cfg.helper import strip_blank_lines from scrapli_cfg.platform.core.cisco_iosxr.patterns import ( BANNER_PATTERN, END_PATTERN, OUTPUT_HEADER_PATTERN, VERSION_PATTERN, ) if TYPE_CHECKING: LoggerAdapterT = LoggerAdapter[Logger] # pylint:disable=E1136 else: LoggerAdapterT = LoggerAdapter CONFIG_SOURCES = [ \"running\", ] class ScrapliCfgIOSXRBase: logger: LoggerAdapterT _in_configuration_session: bool _config_privilege_level: str _replace: bool candidate_config: str @staticmethod def _parse_version(device_output: str) -> str: \"\"\" Parse version string out of device output Args: device_output: output from show version command Returns: str: device version string Raises: N/A \"\"\" version_string_search = re.search(pattern=VERSION_PATTERN, string=device_output) if not version_string_search: return \"\" version_string = version_string_search.group(0) or \"\" return version_string @staticmethod def _prepare_config_payloads(config: str) -> Tuple[str, str]: \"\"\" Prepare a configuration so it can be nicely sent to the device via scrapli Args: config: configuration to prep Returns: tuple: tuple of \"normal\" config lines and \"eager\" config lines Raises: N/A \"\"\" # remove building config lines config = re.sub(pattern=OUTPUT_HEADER_PATTERN, repl=\"!\", string=config) # remove \"end\" at the end of config if present - if its present it will drop scrapli out # of the config session which we do not want config = re.sub(pattern=END_PATTERN, repl=\"!\", string=config) # find all sections that need to be \"eagerly\" sent eager_config = re.findall(pattern=BANNER_PATTERN, string=config) for eager_section in eager_config: # afaik cant backreference a non capturing group so we have an extra group per match # that we ignore here (element 1) config = config.replace(eager_section[0], \"!\") joined_eager_config = \"\\n\".join(captured_section[0] for captured_section in eager_config) return config, joined_eager_config def _prepare_load_config_session_and_payload( self, config: str, replace: bool, exclusive: bool ) -> Tuple[str, str]: \"\"\" Handle pre \"load_config\" operations for parity between sync and async Args: config: candidate config to load replace: True/False replace the configuration; passed here so it can be set at the class level as we need to stay in config mode and we need to know if we are doing a merge or a replace when we go to diff things exclusive: True/False use exclusive config mode Returns: tuple: tuple containing \"normal\" config elements to send to the device and \"eager\" mode config elements to send to the device (things like banners/macro that require scrapli \"eager=True\") Raises: N/A \"\"\" self.candidate_config = config config, eager_config = self._prepare_config_payloads(config=config) self._in_configuration_session = True self._config_privilege_level = \"configuration_exclusive\" if exclusive else \"configuration\" self._replace = replace return config, eager_config def _reset_config_session(self) -> None: \"\"\" Reset config session info Resets the candidate config and config session name attributes -- when these are \"empty\" we know there is no current config session Args: N/A Returns: None Raises: N/A \"\"\" self.logger.debug(\"resetting candidate config and config session name\") self.candidate_config = \"\" self._in_configuration_session = False self._config_privilege_level = \"configuration\" def _get_diff_command(self) -> str: \"\"\" Generate diff command based on source to diff and filesystem/candidate config name Args: N/A Returns: str: command to use to diff the configuration Raises: N/A \"\"\" if self._replace: return \"show configuration changes diff\" return \"show commit changes diff\" def clean_config(self, config: str) -> str: \"\"\" Clean a configuration file of unwanted lines Args: config: configuration string to \"clean\"; cleaning removes leading timestamp/building config/xr version/last change lines. Returns: str: cleaned configuration string Raises: N/A \"\"\" self.logger.debug(\"cleaning config file\") # remove any of the leading timestamp/building config/xr version/last change lines in # both the source and candidate configs so they dont need to be compared return strip_blank_lines( config=re.sub(pattern=OUTPUT_HEADER_PATTERN, string=config, repl=\"\") ) Classes \u00b6 ScrapliCfgIOSXRBase \u00b6 Expand source code class ScrapliCfgIOSXRBase: logger: LoggerAdapterT _in_configuration_session: bool _config_privilege_level: str _replace: bool candidate_config: str @staticmethod def _parse_version(device_output: str) -> str: \"\"\" Parse version string out of device output Args: device_output: output from show version command Returns: str: device version string Raises: N/A \"\"\" version_string_search = re.search(pattern=VERSION_PATTERN, string=device_output) if not version_string_search: return \"\" version_string = version_string_search.group(0) or \"\" return version_string @staticmethod def _prepare_config_payloads(config: str) -> Tuple[str, str]: \"\"\" Prepare a configuration so it can be nicely sent to the device via scrapli Args: config: configuration to prep Returns: tuple: tuple of \"normal\" config lines and \"eager\" config lines Raises: N/A \"\"\" # remove building config lines config = re.sub(pattern=OUTPUT_HEADER_PATTERN, repl=\"!\", string=config) # remove \"end\" at the end of config if present - if its present it will drop scrapli out # of the config session which we do not want config = re.sub(pattern=END_PATTERN, repl=\"!\", string=config) # find all sections that need to be \"eagerly\" sent eager_config = re.findall(pattern=BANNER_PATTERN, string=config) for eager_section in eager_config: # afaik cant backreference a non capturing group so we have an extra group per match # that we ignore here (element 1) config = config.replace(eager_section[0], \"!\") joined_eager_config = \"\\n\".join(captured_section[0] for captured_section in eager_config) return config, joined_eager_config def _prepare_load_config_session_and_payload( self, config: str, replace: bool, exclusive: bool ) -> Tuple[str, str]: \"\"\" Handle pre \"load_config\" operations for parity between sync and async Args: config: candidate config to load replace: True/False replace the configuration; passed here so it can be set at the class level as we need to stay in config mode and we need to know if we are doing a merge or a replace when we go to diff things exclusive: True/False use exclusive config mode Returns: tuple: tuple containing \"normal\" config elements to send to the device and \"eager\" mode config elements to send to the device (things like banners/macro that require scrapli \"eager=True\") Raises: N/A \"\"\" self.candidate_config = config config, eager_config = self._prepare_config_payloads(config=config) self._in_configuration_session = True self._config_privilege_level = \"configuration_exclusive\" if exclusive else \"configuration\" self._replace = replace return config, eager_config def _reset_config_session(self) -> None: \"\"\" Reset config session info Resets the candidate config and config session name attributes -- when these are \"empty\" we know there is no current config session Args: N/A Returns: None Raises: N/A \"\"\" self.logger.debug(\"resetting candidate config and config session name\") self.candidate_config = \"\" self._in_configuration_session = False self._config_privilege_level = \"configuration\" def _get_diff_command(self) -> str: \"\"\" Generate diff command based on source to diff and filesystem/candidate config name Args: N/A Returns: str: command to use to diff the configuration Raises: N/A \"\"\" if self._replace: return \"show configuration changes diff\" return \"show commit changes diff\" def clean_config(self, config: str) -> str: \"\"\" Clean a configuration file of unwanted lines Args: config: configuration string to \"clean\"; cleaning removes leading timestamp/building config/xr version/last change lines. Returns: str: cleaned configuration string Raises: N/A \"\"\" self.logger.debug(\"cleaning config file\") # remove any of the leading timestamp/building config/xr version/last change lines in # both the source and candidate configs so they dont need to be compared return strip_blank_lines( config=re.sub(pattern=OUTPUT_HEADER_PATTERN, string=config, repl=\"\") ) Descendants \u00b6 scrapli_cfg.platform.core.cisco_iosxr.async_platform.AsyncScrapliCfgIOSXR scrapli_cfg.platform.core.cisco_iosxr.sync_platform.ScrapliCfgIOSXR Class variables \u00b6 candidate_config: str logger: logging.LoggerAdapter Methods \u00b6 clean_config \u00b6 clean_config(self, config: str) \u2011> str 1 2 3 4 5 6 7 8 9 10 11 Clean a configuration file of unwanted lines Args: config: configuration string to \"clean\"; cleaning removes leading timestamp/building config/xr version/last change lines. Returns: str: cleaned configuration string Raises: N/A","title":"Base platform"},{"location":"api_docs/platform/core/cisco_iosxr/base_platform/#module-scrapli_cfgplatformcorecisco_iosxrbase_platform","text":"scrapli_cfg.platform.core.cisco_iosxr.base_platform Expand source code \"\"\"scrapli_cfg.platform.core.cisco_iosxr.base_platform\"\"\" import re from logging import Logger, LoggerAdapter from typing import TYPE_CHECKING, Tuple from scrapli_cfg.helper import strip_blank_lines from scrapli_cfg.platform.core.cisco_iosxr.patterns import ( BANNER_PATTERN, END_PATTERN, OUTPUT_HEADER_PATTERN, VERSION_PATTERN, ) if TYPE_CHECKING: LoggerAdapterT = LoggerAdapter[Logger] # pylint:disable=E1136 else: LoggerAdapterT = LoggerAdapter CONFIG_SOURCES = [ \"running\", ] class ScrapliCfgIOSXRBase: logger: LoggerAdapterT _in_configuration_session: bool _config_privilege_level: str _replace: bool candidate_config: str @staticmethod def _parse_version(device_output: str) -> str: \"\"\" Parse version string out of device output Args: device_output: output from show version command Returns: str: device version string Raises: N/A \"\"\" version_string_search = re.search(pattern=VERSION_PATTERN, string=device_output) if not version_string_search: return \"\" version_string = version_string_search.group(0) or \"\" return version_string @staticmethod def _prepare_config_payloads(config: str) -> Tuple[str, str]: \"\"\" Prepare a configuration so it can be nicely sent to the device via scrapli Args: config: configuration to prep Returns: tuple: tuple of \"normal\" config lines and \"eager\" config lines Raises: N/A \"\"\" # remove building config lines config = re.sub(pattern=OUTPUT_HEADER_PATTERN, repl=\"!\", string=config) # remove \"end\" at the end of config if present - if its present it will drop scrapli out # of the config session which we do not want config = re.sub(pattern=END_PATTERN, repl=\"!\", string=config) # find all sections that need to be \"eagerly\" sent eager_config = re.findall(pattern=BANNER_PATTERN, string=config) for eager_section in eager_config: # afaik cant backreference a non capturing group so we have an extra group per match # that we ignore here (element 1) config = config.replace(eager_section[0], \"!\") joined_eager_config = \"\\n\".join(captured_section[0] for captured_section in eager_config) return config, joined_eager_config def _prepare_load_config_session_and_payload( self, config: str, replace: bool, exclusive: bool ) -> Tuple[str, str]: \"\"\" Handle pre \"load_config\" operations for parity between sync and async Args: config: candidate config to load replace: True/False replace the configuration; passed here so it can be set at the class level as we need to stay in config mode and we need to know if we are doing a merge or a replace when we go to diff things exclusive: True/False use exclusive config mode Returns: tuple: tuple containing \"normal\" config elements to send to the device and \"eager\" mode config elements to send to the device (things like banners/macro that require scrapli \"eager=True\") Raises: N/A \"\"\" self.candidate_config = config config, eager_config = self._prepare_config_payloads(config=config) self._in_configuration_session = True self._config_privilege_level = \"configuration_exclusive\" if exclusive else \"configuration\" self._replace = replace return config, eager_config def _reset_config_session(self) -> None: \"\"\" Reset config session info Resets the candidate config and config session name attributes -- when these are \"empty\" we know there is no current config session Args: N/A Returns: None Raises: N/A \"\"\" self.logger.debug(\"resetting candidate config and config session name\") self.candidate_config = \"\" self._in_configuration_session = False self._config_privilege_level = \"configuration\" def _get_diff_command(self) -> str: \"\"\" Generate diff command based on source to diff and filesystem/candidate config name Args: N/A Returns: str: command to use to diff the configuration Raises: N/A \"\"\" if self._replace: return \"show configuration changes diff\" return \"show commit changes diff\" def clean_config(self, config: str) -> str: \"\"\" Clean a configuration file of unwanted lines Args: config: configuration string to \"clean\"; cleaning removes leading timestamp/building config/xr version/last change lines. Returns: str: cleaned configuration string Raises: N/A \"\"\" self.logger.debug(\"cleaning config file\") # remove any of the leading timestamp/building config/xr version/last change lines in # both the source and candidate configs so they dont need to be compared return strip_blank_lines( config=re.sub(pattern=OUTPUT_HEADER_PATTERN, string=config, repl=\"\") )","title":"Module scrapli_cfg.platform.core.cisco_iosxr.base_platform"},{"location":"api_docs/platform/core/cisco_iosxr/base_platform/#classes","text":"","title":"Classes"},{"location":"api_docs/platform/core/cisco_iosxr/base_platform/#scraplicfgiosxrbase","text":"Expand source code class ScrapliCfgIOSXRBase: logger: LoggerAdapterT _in_configuration_session: bool _config_privilege_level: str _replace: bool candidate_config: str @staticmethod def _parse_version(device_output: str) -> str: \"\"\" Parse version string out of device output Args: device_output: output from show version command Returns: str: device version string Raises: N/A \"\"\" version_string_search = re.search(pattern=VERSION_PATTERN, string=device_output) if not version_string_search: return \"\" version_string = version_string_search.group(0) or \"\" return version_string @staticmethod def _prepare_config_payloads(config: str) -> Tuple[str, str]: \"\"\" Prepare a configuration so it can be nicely sent to the device via scrapli Args: config: configuration to prep Returns: tuple: tuple of \"normal\" config lines and \"eager\" config lines Raises: N/A \"\"\" # remove building config lines config = re.sub(pattern=OUTPUT_HEADER_PATTERN, repl=\"!\", string=config) # remove \"end\" at the end of config if present - if its present it will drop scrapli out # of the config session which we do not want config = re.sub(pattern=END_PATTERN, repl=\"!\", string=config) # find all sections that need to be \"eagerly\" sent eager_config = re.findall(pattern=BANNER_PATTERN, string=config) for eager_section in eager_config: # afaik cant backreference a non capturing group so we have an extra group per match # that we ignore here (element 1) config = config.replace(eager_section[0], \"!\") joined_eager_config = \"\\n\".join(captured_section[0] for captured_section in eager_config) return config, joined_eager_config def _prepare_load_config_session_and_payload( self, config: str, replace: bool, exclusive: bool ) -> Tuple[str, str]: \"\"\" Handle pre \"load_config\" operations for parity between sync and async Args: config: candidate config to load replace: True/False replace the configuration; passed here so it can be set at the class level as we need to stay in config mode and we need to know if we are doing a merge or a replace when we go to diff things exclusive: True/False use exclusive config mode Returns: tuple: tuple containing \"normal\" config elements to send to the device and \"eager\" mode config elements to send to the device (things like banners/macro that require scrapli \"eager=True\") Raises: N/A \"\"\" self.candidate_config = config config, eager_config = self._prepare_config_payloads(config=config) self._in_configuration_session = True self._config_privilege_level = \"configuration_exclusive\" if exclusive else \"configuration\" self._replace = replace return config, eager_config def _reset_config_session(self) -> None: \"\"\" Reset config session info Resets the candidate config and config session name attributes -- when these are \"empty\" we know there is no current config session Args: N/A Returns: None Raises: N/A \"\"\" self.logger.debug(\"resetting candidate config and config session name\") self.candidate_config = \"\" self._in_configuration_session = False self._config_privilege_level = \"configuration\" def _get_diff_command(self) -> str: \"\"\" Generate diff command based on source to diff and filesystem/candidate config name Args: N/A Returns: str: command to use to diff the configuration Raises: N/A \"\"\" if self._replace: return \"show configuration changes diff\" return \"show commit changes diff\" def clean_config(self, config: str) -> str: \"\"\" Clean a configuration file of unwanted lines Args: config: configuration string to \"clean\"; cleaning removes leading timestamp/building config/xr version/last change lines. Returns: str: cleaned configuration string Raises: N/A \"\"\" self.logger.debug(\"cleaning config file\") # remove any of the leading timestamp/building config/xr version/last change lines in # both the source and candidate configs so they dont need to be compared return strip_blank_lines( config=re.sub(pattern=OUTPUT_HEADER_PATTERN, string=config, repl=\"\") )","title":"ScrapliCfgIOSXRBase"},{"location":"api_docs/platform/core/cisco_iosxr/base_platform/#descendants","text":"scrapli_cfg.platform.core.cisco_iosxr.async_platform.AsyncScrapliCfgIOSXR scrapli_cfg.platform.core.cisco_iosxr.sync_platform.ScrapliCfgIOSXR","title":"Descendants"},{"location":"api_docs/platform/core/cisco_iosxr/base_platform/#class-variables","text":"candidate_config: str logger: logging.LoggerAdapter","title":"Class variables"},{"location":"api_docs/platform/core/cisco_iosxr/base_platform/#methods","text":"","title":"Methods"},{"location":"api_docs/platform/core/cisco_iosxr/base_platform/#clean_config","text":"clean_config(self, config: str) \u2011> str 1 2 3 4 5 6 7 8 9 10 11 Clean a configuration file of unwanted lines Args: config: configuration string to \"clean\"; cleaning removes leading timestamp/building config/xr version/last change lines. Returns: str: cleaned configuration string Raises: N/A","title":"clean_config"},{"location":"api_docs/platform/core/cisco_iosxr/patterns/","text":"window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting()) Module scrapli_cfg.platform.core.cisco_iosxr.patterns \u00b6 scrapli_cfg.platform.core.cisco_iosxr.patterns Expand source code \"\"\"scrapli_cfg.platform.core.cisco_iosxr.patterns\"\"\" import re VERSION_PATTERN = re.compile(pattern=r\"\\d+\\.\\d+\\.\\d+\", flags=re.I) BANNER_PATTERN = re.compile( pattern=r\"(^banner\\s(?:exec|incoming|login|motd|prompt-timeout|slip-ppp)\\s\" r\"(?P .{1}).*(?P=delim)$)\", flags=re.I | re.M | re.S, ) TIMESTAMP_PATTERN = datetime_pattern = re.compile( r\"^(mon|tue|wed|thu|fri|sat|sun)\\s+\" r\"(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)\\s+\" r\"\\d+\\s+\\d+:\\d+:\\d+((\\.\\d+\\s\\w+)|\\s\\d+)$\", flags=re.M | re.I, ) BUILD_CONFIG_PATTERN = re.compile(r\"(^building configuration\\.\\.\\.$)\", flags=re.I | re.M) CONFIG_VERSION_PATTERN = re.compile(r\"(^!! ios xr.*$)\", flags=re.I | re.M) CONFIG_CHANGE_PATTERN = re.compile(r\"(^!! last config.*$)\", flags=re.I | re.M) OUTPUT_HEADER_PATTERN = re.compile( pattern=rf\"{TIMESTAMP_PATTERN.pattern}|\" rf\"{BUILD_CONFIG_PATTERN.pattern}|\" rf\"{CONFIG_VERSION_PATTERN.pattern}|\" rf\"{CONFIG_CHANGE_PATTERN.pattern}\", flags=re.I | re.M, ) END_PATTERN = re.compile(pattern=\"end$\") # pre-canned config section grabber patterns # match all ethernet interfaces w/ or w/out config items below them IOSXR_INTERFACES_PATTERN = r\"(?:Ethernet|GigabitEthernet|TenGigE|HundredGigE)\" ETHERNET_INTERFACES = re.compile( pattern=rf\"(^interface {IOSXR_INTERFACES_PATTERN}(?:\\d|\\/)+$(?:\\n^\\s{1}.*$)*\\n!\\n)+\", flags=re.I | re.M, ) # match mgmteth[numbers, letters, forward slashes] interface and config items below it MANAGEMENT_ONE_INTERFACE = re.compile( pattern=r\"^^interface mgmteth(?:[a-z0-9\\/]+)(?:\\n^\\s.*$)*\\n!\", flags=re.I | re.M )","title":"Patterns"},{"location":"api_docs/platform/core/cisco_iosxr/patterns/#module-scrapli_cfgplatformcorecisco_iosxrpatterns","text":"scrapli_cfg.platform.core.cisco_iosxr.patterns Expand source code \"\"\"scrapli_cfg.platform.core.cisco_iosxr.patterns\"\"\" import re VERSION_PATTERN = re.compile(pattern=r\"\\d+\\.\\d+\\.\\d+\", flags=re.I) BANNER_PATTERN = re.compile( pattern=r\"(^banner\\s(?:exec|incoming|login|motd|prompt-timeout|slip-ppp)\\s\" r\"(?P .{1}).*(?P=delim)$)\", flags=re.I | re.M | re.S, ) TIMESTAMP_PATTERN = datetime_pattern = re.compile( r\"^(mon|tue|wed|thu|fri|sat|sun)\\s+\" r\"(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)\\s+\" r\"\\d+\\s+\\d+:\\d+:\\d+((\\.\\d+\\s\\w+)|\\s\\d+)$\", flags=re.M | re.I, ) BUILD_CONFIG_PATTERN = re.compile(r\"(^building configuration\\.\\.\\.$)\", flags=re.I | re.M) CONFIG_VERSION_PATTERN = re.compile(r\"(^!! ios xr.*$)\", flags=re.I | re.M) CONFIG_CHANGE_PATTERN = re.compile(r\"(^!! last config.*$)\", flags=re.I | re.M) OUTPUT_HEADER_PATTERN = re.compile( pattern=rf\"{TIMESTAMP_PATTERN.pattern}|\" rf\"{BUILD_CONFIG_PATTERN.pattern}|\" rf\"{CONFIG_VERSION_PATTERN.pattern}|\" rf\"{CONFIG_CHANGE_PATTERN.pattern}\", flags=re.I | re.M, ) END_PATTERN = re.compile(pattern=\"end$\") # pre-canned config section grabber patterns # match all ethernet interfaces w/ or w/out config items below them IOSXR_INTERFACES_PATTERN = r\"(?:Ethernet|GigabitEthernet|TenGigE|HundredGigE)\" ETHERNET_INTERFACES = re.compile( pattern=rf\"(^interface {IOSXR_INTERFACES_PATTERN}(?:\\d|\\/)+$(?:\\n^\\s{1}.*$)*\\n!\\n)+\", flags=re.I | re.M, ) # match mgmteth[numbers, letters, forward slashes] interface and config items below it MANAGEMENT_ONE_INTERFACE = re.compile( pattern=r\"^^interface mgmteth(?:[a-z0-9\\/]+)(?:\\n^\\s.*$)*\\n!\", flags=re.I | re.M )","title":"Module scrapli_cfg.platform.core.cisco_iosxr.patterns"},{"location":"api_docs/platform/core/cisco_iosxr/sync_platform/","text":"window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting()) Module scrapli_cfg.platform.core.cisco_iosxr.sync_platform \u00b6 scrapli_cfg.platform.core.cisco_iosxr.sync_platform Expand source code \"\"\"scrapli_cfg.platform.core.cisco_iosxr.sync_platform\"\"\" from typing import Any, Callable, List, Optional, Union from scrapli.driver import NetworkDriver from scrapli.response import MultiResponse, Response from scrapli_cfg.diff import ScrapliCfgDiffResponse from scrapli_cfg.exceptions import DiffConfigError, LoadConfigError from scrapli_cfg.platform.base.sync_platform import ScrapliCfgPlatform from scrapli_cfg.platform.core.cisco_iosxr.base_platform import CONFIG_SOURCES, ScrapliCfgIOSXRBase from scrapli_cfg.response import ScrapliCfgResponse class ScrapliCfgIOSXR(ScrapliCfgPlatform, ScrapliCfgIOSXRBase): def __init__( self, conn: NetworkDriver, *, config_sources: Optional[List[str]] = None, on_prepare: Optional[Callable[..., Any]] = None, dedicated_connection: bool = False, ignore_version: bool = False, ) -> None: if config_sources is None: config_sources = CONFIG_SOURCES super().__init__( conn=conn, config_sources=config_sources, on_prepare=on_prepare, dedicated_connection=dedicated_connection, ignore_version=ignore_version, ) self._replace = False self._in_configuration_session = False self._config_privilege_level = \"configuration\" def get_version(self) -> ScrapliCfgResponse: response = self._pre_get_version() version_result = self.conn.send_command(command=\"show version | i Version\") return self._post_get_version( response=response, scrapli_responses=[version_result], result=self._parse_version(device_output=version_result.result), ) def get_config(self, source: str = \"running\") -> ScrapliCfgResponse: response = self._pre_get_config(source=source) if not self._in_configuration_session: config_result = self.conn.send_command(command=\"show running-config\") else: config_result = self.conn.send_config( config=\"show running-config\", privilege_level=self._config_privilege_level ) return self._post_get_config( response=response, source=source, scrapli_responses=[config_result], result=config_result.result, ) def load_config(self, config: str, replace: bool = False, **kwargs: Any) -> ScrapliCfgResponse: \"\"\" Load configuration to a device Supported kwargs: exclusive: True/False use `configure exclusive` mode Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for iosxr supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" scrapli_responses = [] response = self._pre_load_config(config=config) exclusive = kwargs.get(\"exclusive\", False) config, eager_config = self._prepare_load_config_session_and_payload( config=config, replace=replace, exclusive=exclusive ) try: config_result = self.conn.send_config( config=config, privilege_level=self._config_privilege_level ) scrapli_responses.append(config_result) if config_result.failed: msg = \"failed to load the candidate config into the config session\" self.logger.critical(msg) raise LoadConfigError(msg) # eager cuz banners and such; perhaps if no banner/macro we can disable eager though.... if eager_config: eager_config_result = self.conn.send_config( config=eager_config, privilege_level=self._config_privilege_level, eager=True ) scrapli_responses.append(eager_config_result) if eager_config_result.failed: msg = \"failed to load the candidate config into the config session\" self.logger.critical(msg) raise LoadConfigError(msg) except LoadConfigError: pass return self._post_load_config( response=response, scrapli_responses=scrapli_responses, ) def abort_config(self) -> ScrapliCfgResponse: response = self._pre_abort_config(session_or_config_file=self._in_configuration_session) self.conn._abort_config() # pylint: disable=W0212 self._reset_config_session() return self._post_abort_config(response=response, scrapli_responses=[]) def commit_config(self, source: str = \"running\") -> ScrapliCfgResponse: scrapli_responses: List[Union[MultiResponse, Response]] = [] response = self._pre_commit_config( source=source, session_or_config_file=self._in_configuration_session ) if self._replace is True: commit_events = [(\"commit replace\", \"proceed?\"), (\"yes\", \"\")] commit_result = self.conn.send_interactive( interact_events=commit_events, privilege_level=self._config_privilege_level ) else: commit_result = self.conn.send_config(config=\"commit\") scrapli_responses.append(commit_result) self._reset_config_session() return self._post_commit_config(response=response, scrapli_responses=scrapli_responses) def diff_config(self, source: str = \"running\") -> ScrapliCfgDiffResponse: scrapli_responses = [] device_diff = \"\" source_config = \"\" diff_response = self._pre_diff_config( source=source, session_or_config_file=self._in_configuration_session ) try: diff_result = self.conn.send_config( config=self._get_diff_command(), privilege_level=self._config_privilege_level ) scrapli_responses.append(diff_result) if diff_result.failed: msg = \"failed generating diff for config session\" self.logger.critical(msg) raise DiffConfigError(msg) device_diff = diff_result.result source_config_result = self.get_config(source=source) source_config = source_config_result.result if isinstance(source_config_result.scrapli_responses, MultiResponse): # in this case this will always be a multiresponse or nothing (failure) but mypy # doesnt know that, hence the isinstance check scrapli_responses.extend(source_config_result.scrapli_responses) if source_config_result.failed: msg = \"failed fetching source config for diff comparison\" self.logger.critical(msg) raise DiffConfigError(msg) except DiffConfigError: pass return self._post_diff_config( diff_response=diff_response, scrapli_responses=scrapli_responses, source_config=self.clean_config(source_config), candidate_config=self.clean_config(self.candidate_config), device_diff=device_diff, ) Classes \u00b6 ScrapliCfgIOSXR \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 Helper class that provides a standard way to create an ABC using inheritance. Scrapli Config base class Args: conn: scrapli connection to use config_sources: list of config sources on_prepare: optional callable to run at connection `prepare` dedicated_connection: if `False` (default value) scrapli cfg will not open or close the underlying scrapli connection and will raise an exception if the scrapli connection is not open. If `True` will automatically open and close the scrapli connection when using with a context manager, `prepare` will open the scrapli connection (if not already open), and `close` will close the scrapli connection. ignore_version: ignore checking device version support; currently this just means that scrapli-cfg will not fetch the device version during the prepare phase, however this will (hopefully) be used in the future to limit what methods can be used against a target device. For example, for EOS devices we need > 4.14 to load configs; so if a device is encountered at 4.13 the version check would raise an exception rather than just failing in a potentially awkward fashion. Returns: None Raises: N/A Expand source code class ScrapliCfgIOSXR(ScrapliCfgPlatform, ScrapliCfgIOSXRBase): def __init__( self, conn: NetworkDriver, *, config_sources: Optional[List[str]] = None, on_prepare: Optional[Callable[..., Any]] = None, dedicated_connection: bool = False, ignore_version: bool = False, ) -> None: if config_sources is None: config_sources = CONFIG_SOURCES super().__init__( conn=conn, config_sources=config_sources, on_prepare=on_prepare, dedicated_connection=dedicated_connection, ignore_version=ignore_version, ) self._replace = False self._in_configuration_session = False self._config_privilege_level = \"configuration\" def get_version(self) -> ScrapliCfgResponse: response = self._pre_get_version() version_result = self.conn.send_command(command=\"show version | i Version\") return self._post_get_version( response=response, scrapli_responses=[version_result], result=self._parse_version(device_output=version_result.result), ) def get_config(self, source: str = \"running\") -> ScrapliCfgResponse: response = self._pre_get_config(source=source) if not self._in_configuration_session: config_result = self.conn.send_command(command=\"show running-config\") else: config_result = self.conn.send_config( config=\"show running-config\", privilege_level=self._config_privilege_level ) return self._post_get_config( response=response, source=source, scrapli_responses=[config_result], result=config_result.result, ) def load_config(self, config: str, replace: bool = False, **kwargs: Any) -> ScrapliCfgResponse: \"\"\" Load configuration to a device Supported kwargs: exclusive: True/False use `configure exclusive` mode Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for iosxr supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" scrapli_responses = [] response = self._pre_load_config(config=config) exclusive = kwargs.get(\"exclusive\", False) config, eager_config = self._prepare_load_config_session_and_payload( config=config, replace=replace, exclusive=exclusive ) try: config_result = self.conn.send_config( config=config, privilege_level=self._config_privilege_level ) scrapli_responses.append(config_result) if config_result.failed: msg = \"failed to load the candidate config into the config session\" self.logger.critical(msg) raise LoadConfigError(msg) # eager cuz banners and such; perhaps if no banner/macro we can disable eager though.... if eager_config: eager_config_result = self.conn.send_config( config=eager_config, privilege_level=self._config_privilege_level, eager=True ) scrapli_responses.append(eager_config_result) if eager_config_result.failed: msg = \"failed to load the candidate config into the config session\" self.logger.critical(msg) raise LoadConfigError(msg) except LoadConfigError: pass return self._post_load_config( response=response, scrapli_responses=scrapli_responses, ) def abort_config(self) -> ScrapliCfgResponse: response = self._pre_abort_config(session_or_config_file=self._in_configuration_session) self.conn._abort_config() # pylint: disable=W0212 self._reset_config_session() return self._post_abort_config(response=response, scrapli_responses=[]) def commit_config(self, source: str = \"running\") -> ScrapliCfgResponse: scrapli_responses: List[Union[MultiResponse, Response]] = [] response = self._pre_commit_config( source=source, session_or_config_file=self._in_configuration_session ) if self._replace is True: commit_events = [(\"commit replace\", \"proceed?\"), (\"yes\", \"\")] commit_result = self.conn.send_interactive( interact_events=commit_events, privilege_level=self._config_privilege_level ) else: commit_result = self.conn.send_config(config=\"commit\") scrapli_responses.append(commit_result) self._reset_config_session() return self._post_commit_config(response=response, scrapli_responses=scrapli_responses) def diff_config(self, source: str = \"running\") -> ScrapliCfgDiffResponse: scrapli_responses = [] device_diff = \"\" source_config = \"\" diff_response = self._pre_diff_config( source=source, session_or_config_file=self._in_configuration_session ) try: diff_result = self.conn.send_config( config=self._get_diff_command(), privilege_level=self._config_privilege_level ) scrapli_responses.append(diff_result) if diff_result.failed: msg = \"failed generating diff for config session\" self.logger.critical(msg) raise DiffConfigError(msg) device_diff = diff_result.result source_config_result = self.get_config(source=source) source_config = source_config_result.result if isinstance(source_config_result.scrapli_responses, MultiResponse): # in this case this will always be a multiresponse or nothing (failure) but mypy # doesnt know that, hence the isinstance check scrapli_responses.extend(source_config_result.scrapli_responses) if source_config_result.failed: msg = \"failed fetching source config for diff comparison\" self.logger.critical(msg) raise DiffConfigError(msg) except DiffConfigError: pass return self._post_diff_config( diff_response=diff_response, scrapli_responses=scrapli_responses, source_config=self.clean_config(source_config), candidate_config=self.clean_config(self.candidate_config), device_diff=device_diff, ) Ancestors (in MRO) \u00b6 scrapli_cfg.platform.base.sync_platform.ScrapliCfgPlatform abc.ABC scrapli_cfg.platform.base.base_platform.ScrapliCfgBase scrapli_cfg.platform.core.cisco_iosxr.base_platform.ScrapliCfgIOSXRBase Class variables \u00b6 conn: Union[scrapli.driver.network.sync_driver.NetworkDriver, scrapli.driver.network.async_driver.AsyncNetworkDriver] Methods \u00b6 load_config \u00b6 load_config(self, config: str, replace: bool = False, **kwargs: Any) \u2011> scrapli_cfg.response.ScrapliCfgResponse 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 Load configuration to a device Supported kwargs: exclusive: True/False use `configure exclusive` mode Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for iosxr supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A","title":"Sync Platform"},{"location":"api_docs/platform/core/cisco_iosxr/sync_platform/#module-scrapli_cfgplatformcorecisco_iosxrsync_platform","text":"scrapli_cfg.platform.core.cisco_iosxr.sync_platform Expand source code \"\"\"scrapli_cfg.platform.core.cisco_iosxr.sync_platform\"\"\" from typing import Any, Callable, List, Optional, Union from scrapli.driver import NetworkDriver from scrapli.response import MultiResponse, Response from scrapli_cfg.diff import ScrapliCfgDiffResponse from scrapli_cfg.exceptions import DiffConfigError, LoadConfigError from scrapli_cfg.platform.base.sync_platform import ScrapliCfgPlatform from scrapli_cfg.platform.core.cisco_iosxr.base_platform import CONFIG_SOURCES, ScrapliCfgIOSXRBase from scrapli_cfg.response import ScrapliCfgResponse class ScrapliCfgIOSXR(ScrapliCfgPlatform, ScrapliCfgIOSXRBase): def __init__( self, conn: NetworkDriver, *, config_sources: Optional[List[str]] = None, on_prepare: Optional[Callable[..., Any]] = None, dedicated_connection: bool = False, ignore_version: bool = False, ) -> None: if config_sources is None: config_sources = CONFIG_SOURCES super().__init__( conn=conn, config_sources=config_sources, on_prepare=on_prepare, dedicated_connection=dedicated_connection, ignore_version=ignore_version, ) self._replace = False self._in_configuration_session = False self._config_privilege_level = \"configuration\" def get_version(self) -> ScrapliCfgResponse: response = self._pre_get_version() version_result = self.conn.send_command(command=\"show version | i Version\") return self._post_get_version( response=response, scrapli_responses=[version_result], result=self._parse_version(device_output=version_result.result), ) def get_config(self, source: str = \"running\") -> ScrapliCfgResponse: response = self._pre_get_config(source=source) if not self._in_configuration_session: config_result = self.conn.send_command(command=\"show running-config\") else: config_result = self.conn.send_config( config=\"show running-config\", privilege_level=self._config_privilege_level ) return self._post_get_config( response=response, source=source, scrapli_responses=[config_result], result=config_result.result, ) def load_config(self, config: str, replace: bool = False, **kwargs: Any) -> ScrapliCfgResponse: \"\"\" Load configuration to a device Supported kwargs: exclusive: True/False use `configure exclusive` mode Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for iosxr supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" scrapli_responses = [] response = self._pre_load_config(config=config) exclusive = kwargs.get(\"exclusive\", False) config, eager_config = self._prepare_load_config_session_and_payload( config=config, replace=replace, exclusive=exclusive ) try: config_result = self.conn.send_config( config=config, privilege_level=self._config_privilege_level ) scrapli_responses.append(config_result) if config_result.failed: msg = \"failed to load the candidate config into the config session\" self.logger.critical(msg) raise LoadConfigError(msg) # eager cuz banners and such; perhaps if no banner/macro we can disable eager though.... if eager_config: eager_config_result = self.conn.send_config( config=eager_config, privilege_level=self._config_privilege_level, eager=True ) scrapli_responses.append(eager_config_result) if eager_config_result.failed: msg = \"failed to load the candidate config into the config session\" self.logger.critical(msg) raise LoadConfigError(msg) except LoadConfigError: pass return self._post_load_config( response=response, scrapli_responses=scrapli_responses, ) def abort_config(self) -> ScrapliCfgResponse: response = self._pre_abort_config(session_or_config_file=self._in_configuration_session) self.conn._abort_config() # pylint: disable=W0212 self._reset_config_session() return self._post_abort_config(response=response, scrapli_responses=[]) def commit_config(self, source: str = \"running\") -> ScrapliCfgResponse: scrapli_responses: List[Union[MultiResponse, Response]] = [] response = self._pre_commit_config( source=source, session_or_config_file=self._in_configuration_session ) if self._replace is True: commit_events = [(\"commit replace\", \"proceed?\"), (\"yes\", \"\")] commit_result = self.conn.send_interactive( interact_events=commit_events, privilege_level=self._config_privilege_level ) else: commit_result = self.conn.send_config(config=\"commit\") scrapli_responses.append(commit_result) self._reset_config_session() return self._post_commit_config(response=response, scrapli_responses=scrapli_responses) def diff_config(self, source: str = \"running\") -> ScrapliCfgDiffResponse: scrapli_responses = [] device_diff = \"\" source_config = \"\" diff_response = self._pre_diff_config( source=source, session_or_config_file=self._in_configuration_session ) try: diff_result = self.conn.send_config( config=self._get_diff_command(), privilege_level=self._config_privilege_level ) scrapli_responses.append(diff_result) if diff_result.failed: msg = \"failed generating diff for config session\" self.logger.critical(msg) raise DiffConfigError(msg) device_diff = diff_result.result source_config_result = self.get_config(source=source) source_config = source_config_result.result if isinstance(source_config_result.scrapli_responses, MultiResponse): # in this case this will always be a multiresponse or nothing (failure) but mypy # doesnt know that, hence the isinstance check scrapli_responses.extend(source_config_result.scrapli_responses) if source_config_result.failed: msg = \"failed fetching source config for diff comparison\" self.logger.critical(msg) raise DiffConfigError(msg) except DiffConfigError: pass return self._post_diff_config( diff_response=diff_response, scrapli_responses=scrapli_responses, source_config=self.clean_config(source_config), candidate_config=self.clean_config(self.candidate_config), device_diff=device_diff, )","title":"Module scrapli_cfg.platform.core.cisco_iosxr.sync_platform"},{"location":"api_docs/platform/core/cisco_iosxr/sync_platform/#classes","text":"","title":"Classes"},{"location":"api_docs/platform/core/cisco_iosxr/sync_platform/#scraplicfgiosxr","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 Helper class that provides a standard way to create an ABC using inheritance. Scrapli Config base class Args: conn: scrapli connection to use config_sources: list of config sources on_prepare: optional callable to run at connection `prepare` dedicated_connection: if `False` (default value) scrapli cfg will not open or close the underlying scrapli connection and will raise an exception if the scrapli connection is not open. If `True` will automatically open and close the scrapli connection when using with a context manager, `prepare` will open the scrapli connection (if not already open), and `close` will close the scrapli connection. ignore_version: ignore checking device version support; currently this just means that scrapli-cfg will not fetch the device version during the prepare phase, however this will (hopefully) be used in the future to limit what methods can be used against a target device. For example, for EOS devices we need > 4.14 to load configs; so if a device is encountered at 4.13 the version check would raise an exception rather than just failing in a potentially awkward fashion. Returns: None Raises: N/A Expand source code class ScrapliCfgIOSXR(ScrapliCfgPlatform, ScrapliCfgIOSXRBase): def __init__( self, conn: NetworkDriver, *, config_sources: Optional[List[str]] = None, on_prepare: Optional[Callable[..., Any]] = None, dedicated_connection: bool = False, ignore_version: bool = False, ) -> None: if config_sources is None: config_sources = CONFIG_SOURCES super().__init__( conn=conn, config_sources=config_sources, on_prepare=on_prepare, dedicated_connection=dedicated_connection, ignore_version=ignore_version, ) self._replace = False self._in_configuration_session = False self._config_privilege_level = \"configuration\" def get_version(self) -> ScrapliCfgResponse: response = self._pre_get_version() version_result = self.conn.send_command(command=\"show version | i Version\") return self._post_get_version( response=response, scrapli_responses=[version_result], result=self._parse_version(device_output=version_result.result), ) def get_config(self, source: str = \"running\") -> ScrapliCfgResponse: response = self._pre_get_config(source=source) if not self._in_configuration_session: config_result = self.conn.send_command(command=\"show running-config\") else: config_result = self.conn.send_config( config=\"show running-config\", privilege_level=self._config_privilege_level ) return self._post_get_config( response=response, source=source, scrapli_responses=[config_result], result=config_result.result, ) def load_config(self, config: str, replace: bool = False, **kwargs: Any) -> ScrapliCfgResponse: \"\"\" Load configuration to a device Supported kwargs: exclusive: True/False use `configure exclusive` mode Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for iosxr supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" scrapli_responses = [] response = self._pre_load_config(config=config) exclusive = kwargs.get(\"exclusive\", False) config, eager_config = self._prepare_load_config_session_and_payload( config=config, replace=replace, exclusive=exclusive ) try: config_result = self.conn.send_config( config=config, privilege_level=self._config_privilege_level ) scrapli_responses.append(config_result) if config_result.failed: msg = \"failed to load the candidate config into the config session\" self.logger.critical(msg) raise LoadConfigError(msg) # eager cuz banners and such; perhaps if no banner/macro we can disable eager though.... if eager_config: eager_config_result = self.conn.send_config( config=eager_config, privilege_level=self._config_privilege_level, eager=True ) scrapli_responses.append(eager_config_result) if eager_config_result.failed: msg = \"failed to load the candidate config into the config session\" self.logger.critical(msg) raise LoadConfigError(msg) except LoadConfigError: pass return self._post_load_config( response=response, scrapli_responses=scrapli_responses, ) def abort_config(self) -> ScrapliCfgResponse: response = self._pre_abort_config(session_or_config_file=self._in_configuration_session) self.conn._abort_config() # pylint: disable=W0212 self._reset_config_session() return self._post_abort_config(response=response, scrapli_responses=[]) def commit_config(self, source: str = \"running\") -> ScrapliCfgResponse: scrapli_responses: List[Union[MultiResponse, Response]] = [] response = self._pre_commit_config( source=source, session_or_config_file=self._in_configuration_session ) if self._replace is True: commit_events = [(\"commit replace\", \"proceed?\"), (\"yes\", \"\")] commit_result = self.conn.send_interactive( interact_events=commit_events, privilege_level=self._config_privilege_level ) else: commit_result = self.conn.send_config(config=\"commit\") scrapli_responses.append(commit_result) self._reset_config_session() return self._post_commit_config(response=response, scrapli_responses=scrapli_responses) def diff_config(self, source: str = \"running\") -> ScrapliCfgDiffResponse: scrapli_responses = [] device_diff = \"\" source_config = \"\" diff_response = self._pre_diff_config( source=source, session_or_config_file=self._in_configuration_session ) try: diff_result = self.conn.send_config( config=self._get_diff_command(), privilege_level=self._config_privilege_level ) scrapli_responses.append(diff_result) if diff_result.failed: msg = \"failed generating diff for config session\" self.logger.critical(msg) raise DiffConfigError(msg) device_diff = diff_result.result source_config_result = self.get_config(source=source) source_config = source_config_result.result if isinstance(source_config_result.scrapli_responses, MultiResponse): # in this case this will always be a multiresponse or nothing (failure) but mypy # doesnt know that, hence the isinstance check scrapli_responses.extend(source_config_result.scrapli_responses) if source_config_result.failed: msg = \"failed fetching source config for diff comparison\" self.logger.critical(msg) raise DiffConfigError(msg) except DiffConfigError: pass return self._post_diff_config( diff_response=diff_response, scrapli_responses=scrapli_responses, source_config=self.clean_config(source_config), candidate_config=self.clean_config(self.candidate_config), device_diff=device_diff, )","title":"ScrapliCfgIOSXR"},{"location":"api_docs/platform/core/cisco_iosxr/sync_platform/#ancestors-in-mro","text":"scrapli_cfg.platform.base.sync_platform.ScrapliCfgPlatform abc.ABC scrapli_cfg.platform.base.base_platform.ScrapliCfgBase scrapli_cfg.platform.core.cisco_iosxr.base_platform.ScrapliCfgIOSXRBase","title":"Ancestors (in MRO)"},{"location":"api_docs/platform/core/cisco_iosxr/sync_platform/#class-variables","text":"conn: Union[scrapli.driver.network.sync_driver.NetworkDriver, scrapli.driver.network.async_driver.AsyncNetworkDriver]","title":"Class variables"},{"location":"api_docs/platform/core/cisco_iosxr/sync_platform/#methods","text":"","title":"Methods"},{"location":"api_docs/platform/core/cisco_iosxr/sync_platform/#load_config","text":"load_config(self, config: str, replace: bool = False, **kwargs: Any) \u2011> scrapli_cfg.response.ScrapliCfgResponse 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 Load configuration to a device Supported kwargs: exclusive: True/False use `configure exclusive` mode Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for iosxr supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A","title":"load_config"},{"location":"api_docs/platform/core/cisco_nxos/async_platform/","text":"window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting()) Module scrapli_cfg.platform.core.cisco_nxos.async_platform \u00b6 scrapli_cfg.platform.core.cisco_nxos.async_platform Expand source code \"\"\"scrapli_cfg.platform.core.cisco_nxos.async_platform\"\"\" from typing import Any, Callable, List, Optional, Union from scrapli.driver.core import AsyncNXOSDriver from scrapli.response import MultiResponse, Response from scrapli_cfg.diff import ScrapliCfgDiffResponse from scrapli_cfg.exceptions import DiffConfigError, FailedToDetermineDeviceState from scrapli_cfg.platform.base.async_platform import AsyncScrapliCfgPlatform from scrapli_cfg.platform.core.cisco_nxos.base_platform import CONFIG_SOURCES, ScrapliCfgNXOSBase from scrapli_cfg.response import ScrapliCfgResponse class AsyncScrapliCfgNXOS(AsyncScrapliCfgPlatform, ScrapliCfgNXOSBase): def __init__( self, conn: AsyncNXOSDriver, *, config_sources: Optional[List[str]] = None, on_prepare: Optional[Callable[..., Any]] = None, filesystem: str = \"bootflash:\", cleanup_post_commit: bool = True, dedicated_connection: bool = False, ignore_version: bool = False, ) -> None: if config_sources is None: config_sources = CONFIG_SOURCES super().__init__( conn=conn, config_sources=config_sources, on_prepare=on_prepare, dedicated_connection=dedicated_connection, ignore_version=ignore_version, ) self.filesystem = filesystem self._filesystem_space_available_buffer_perc = 10 self._replace = False self.candidate_config_filename = \"\" self.cleanup_post_commit = cleanup_post_commit async def _get_filesystem_space_available(self) -> int: \"\"\" Get available space on filesystem Args: N/A Returns: None Raises: FailedToDetermineDeviceState: if unable to fetch file filesystem bytes available \"\"\" filesystem_size_result = await self.conn.send_command( command=f\"dir {self.filesystem} | i 'bytes free'\" ) if filesystem_size_result.failed: raise FailedToDetermineDeviceState(\"failed to determine space available on filesystem\") return self._post_get_filesystem_space_available(output=filesystem_size_result.result) async def _delete_candidate_config(self) -> MultiResponse: \"\"\" Delete candidate config from the filesystem Args: N/A Returns: MultiResponse: response from deleting the candidate config Raises: N/A \"\"\" delete_commands = [ \"terminal dont-ask\", f\"delete {self.filesystem}{self.candidate_config_filename}\", ] delete_result = await self.conn.send_commands(commands=delete_commands) return delete_result async def get_checkpoint(self) -> ScrapliCfgResponse: \"\"\" Get device checkpoint file Args: N/A Returns: ScrapliCfgResponse: response object containing string of the target config source as the `result` attribute Raises: N/A \"\"\" response, checkpoint_commands = self._pre_get_checkpoint(conn=self.conn) checkpoint_results = await self.conn.send_commands(commands=checkpoint_commands) try: checkpoint: str = checkpoint_results[2].result except IndexError: checkpoint = \"\" return self._post_get_config( response=response, source=\"running\", scrapli_responses=[checkpoint_results], result=checkpoint, ) async def get_version(self) -> ScrapliCfgResponse: response = self._pre_get_version() version_result = await self.conn.send_command(command='show version | i \"NXOS: version\"') return self._post_get_version( response=response, scrapli_responses=[version_result], result=self._parse_version(device_output=version_result.result), ) async def get_config(self, source: str = \"running\") -> ScrapliCfgResponse: response = self._pre_get_config(source=source) config_result = await self.conn.send_command( command=self._get_config_command(source=source) ) return self._post_get_config( response=response, source=source, scrapli_responses=[config_result], result=config_result.result, ) async def load_config( self, config: str, replace: bool = False, **kwargs: Any ) -> ScrapliCfgResponse: \"\"\" Load configuration to a device Supported kwargs: N/A Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for nxos supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" response = self._pre_load_config(config=config) config = self._prepare_load_config(config=config, replace=replace) filesystem_bytes_available = await self._get_filesystem_space_available() self._space_available(filesystem_bytes_available=filesystem_bytes_available) await self.conn.acquire_priv(desired_priv=\"tclsh\") config_result = await self.conn.send_config(config=config, privilege_level=\"tclsh\") await self.conn.acquire_priv(desired_priv=self.conn.default_desired_privilege_level) return self._post_load_config( response=response, scrapli_responses=[config_result], ) async def abort_config(self) -> ScrapliCfgResponse: response = self._pre_abort_config( session_or_config_file=bool(self.candidate_config_filename) ) abort_result = await self._delete_candidate_config() self._reset_config_session() return self._post_abort_config(response=response, scrapli_responses=[abort_result]) async def commit_config(self, source: str = \"running\") -> ScrapliCfgResponse: scrapli_responses: List[Union[MultiResponse, Response]] = [] response = self._pre_commit_config( source=source, session_or_config_file=bool(self.candidate_config_filename) ) if self._replace is True: replace_command = ( f\"rollback running-config file {self.filesystem}{self.candidate_config_filename}\" ) commit_result = await self.conn.send_command(command=replace_command) else: merge_command = f\"copy {self.filesystem}{self.candidate_config_filename} running-config\" commit_result = await self.conn.send_command(command=merge_command) scrapli_responses.append(commit_result) save_config_result = await self.conn.send_command( command=\"copy running-config startup-config\" ) scrapli_responses.append(save_config_result) if self.cleanup_post_commit: cleanup_result = await self._delete_candidate_config() scrapli_responses.append(cleanup_result) self._reset_config_session() return self._post_commit_config( response=response, scrapli_responses=scrapli_responses, ) async def diff_config(self, source: str = \"running\") -> ScrapliCfgDiffResponse: scrapli_responses = [] device_diff = \"\" source_config = \"\" diff_response = self._pre_diff_config( source=source, session_or_config_file=bool(self.candidate_config_filename) ) try: diff_command = self._get_diff_command(source=source) if diff_command: diff_result = await self.conn.send_command(command=diff_command) scrapli_responses.append(diff_result) if diff_result.failed: msg = \"failed generating diff for config session\" self.logger.critical(msg) raise DiffConfigError(msg) device_diff = diff_result.result else: device_diff = \"\" source_config_result = await self.get_config(source=source) source_config = source_config_result.result if isinstance(source_config_result.scrapli_responses, MultiResponse): # in this case this will always be a multiresponse or nothing (failure) but mypy # doesnt know that, hence the isinstance check scrapli_responses.extend(source_config_result.scrapli_responses) if source_config_result.failed: msg = \"failed fetching source config for diff comparison\" self.logger.critical(msg) raise DiffConfigError(msg) except DiffConfigError: pass return self._post_diff_config( diff_response=diff_response, scrapli_responses=scrapli_responses, source_config=self.clean_config(source_config), candidate_config=self.clean_config(self.candidate_config), device_diff=device_diff, ) Classes \u00b6 AsyncScrapliCfgNXOS \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 Helper class that provides a standard way to create an ABC using inheritance. Scrapli Config async base class Args: conn: scrapli connection to use config_sources: list of config sources on_prepare: optional callable to run at connection `prepare` dedicated_connection: if `False` (default value) scrapli cfg will not open or close the underlying scrapli connection and will raise an exception if the scrapli connection is not open. If `True` will automatically open and close the scrapli connection when using with a context manager, `prepare` will open the scrapli connection (if not already open), and `close` will close the scrapli connection. ignore_version: ignore checking device version support; currently this just means that scrapli-cfg will not fetch the device version during the prepare phase, however this will (hopefully) be used in the future to limit what methods can be used against a target device. For example, for EOS devices we need > 4.14 to load configs; so if a device is encountered at 4.13 the version check would raise an exception rather than just failing in a potentially awkward fashion. Returns: None Raises: N/A Expand source code class AsyncScrapliCfgNXOS(AsyncScrapliCfgPlatform, ScrapliCfgNXOSBase): def __init__( self, conn: AsyncNXOSDriver, *, config_sources: Optional[List[str]] = None, on_prepare: Optional[Callable[..., Any]] = None, filesystem: str = \"bootflash:\", cleanup_post_commit: bool = True, dedicated_connection: bool = False, ignore_version: bool = False, ) -> None: if config_sources is None: config_sources = CONFIG_SOURCES super().__init__( conn=conn, config_sources=config_sources, on_prepare=on_prepare, dedicated_connection=dedicated_connection, ignore_version=ignore_version, ) self.filesystem = filesystem self._filesystem_space_available_buffer_perc = 10 self._replace = False self.candidate_config_filename = \"\" self.cleanup_post_commit = cleanup_post_commit async def _get_filesystem_space_available(self) -> int: \"\"\" Get available space on filesystem Args: N/A Returns: None Raises: FailedToDetermineDeviceState: if unable to fetch file filesystem bytes available \"\"\" filesystem_size_result = await self.conn.send_command( command=f\"dir {self.filesystem} | i 'bytes free'\" ) if filesystem_size_result.failed: raise FailedToDetermineDeviceState(\"failed to determine space available on filesystem\") return self._post_get_filesystem_space_available(output=filesystem_size_result.result) async def _delete_candidate_config(self) -> MultiResponse: \"\"\" Delete candidate config from the filesystem Args: N/A Returns: MultiResponse: response from deleting the candidate config Raises: N/A \"\"\" delete_commands = [ \"terminal dont-ask\", f\"delete {self.filesystem}{self.candidate_config_filename}\", ] delete_result = await self.conn.send_commands(commands=delete_commands) return delete_result async def get_checkpoint(self) -> ScrapliCfgResponse: \"\"\" Get device checkpoint file Args: N/A Returns: ScrapliCfgResponse: response object containing string of the target config source as the `result` attribute Raises: N/A \"\"\" response, checkpoint_commands = self._pre_get_checkpoint(conn=self.conn) checkpoint_results = await self.conn.send_commands(commands=checkpoint_commands) try: checkpoint: str = checkpoint_results[2].result except IndexError: checkpoint = \"\" return self._post_get_config( response=response, source=\"running\", scrapli_responses=[checkpoint_results], result=checkpoint, ) async def get_version(self) -> ScrapliCfgResponse: response = self._pre_get_version() version_result = await self.conn.send_command(command='show version | i \"NXOS: version\"') return self._post_get_version( response=response, scrapli_responses=[version_result], result=self._parse_version(device_output=version_result.result), ) async def get_config(self, source: str = \"running\") -> ScrapliCfgResponse: response = self._pre_get_config(source=source) config_result = await self.conn.send_command( command=self._get_config_command(source=source) ) return self._post_get_config( response=response, source=source, scrapli_responses=[config_result], result=config_result.result, ) async def load_config( self, config: str, replace: bool = False, **kwargs: Any ) -> ScrapliCfgResponse: \"\"\" Load configuration to a device Supported kwargs: N/A Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for nxos supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" response = self._pre_load_config(config=config) config = self._prepare_load_config(config=config, replace=replace) filesystem_bytes_available = await self._get_filesystem_space_available() self._space_available(filesystem_bytes_available=filesystem_bytes_available) await self.conn.acquire_priv(desired_priv=\"tclsh\") config_result = await self.conn.send_config(config=config, privilege_level=\"tclsh\") await self.conn.acquire_priv(desired_priv=self.conn.default_desired_privilege_level) return self._post_load_config( response=response, scrapli_responses=[config_result], ) async def abort_config(self) -> ScrapliCfgResponse: response = self._pre_abort_config( session_or_config_file=bool(self.candidate_config_filename) ) abort_result = await self._delete_candidate_config() self._reset_config_session() return self._post_abort_config(response=response, scrapli_responses=[abort_result]) async def commit_config(self, source: str = \"running\") -> ScrapliCfgResponse: scrapli_responses: List[Union[MultiResponse, Response]] = [] response = self._pre_commit_config( source=source, session_or_config_file=bool(self.candidate_config_filename) ) if self._replace is True: replace_command = ( f\"rollback running-config file {self.filesystem}{self.candidate_config_filename}\" ) commit_result = await self.conn.send_command(command=replace_command) else: merge_command = f\"copy {self.filesystem}{self.candidate_config_filename} running-config\" commit_result = await self.conn.send_command(command=merge_command) scrapli_responses.append(commit_result) save_config_result = await self.conn.send_command( command=\"copy running-config startup-config\" ) scrapli_responses.append(save_config_result) if self.cleanup_post_commit: cleanup_result = await self._delete_candidate_config() scrapli_responses.append(cleanup_result) self._reset_config_session() return self._post_commit_config( response=response, scrapli_responses=scrapli_responses, ) async def diff_config(self, source: str = \"running\") -> ScrapliCfgDiffResponse: scrapli_responses = [] device_diff = \"\" source_config = \"\" diff_response = self._pre_diff_config( source=source, session_or_config_file=bool(self.candidate_config_filename) ) try: diff_command = self._get_diff_command(source=source) if diff_command: diff_result = await self.conn.send_command(command=diff_command) scrapli_responses.append(diff_result) if diff_result.failed: msg = \"failed generating diff for config session\" self.logger.critical(msg) raise DiffConfigError(msg) device_diff = diff_result.result else: device_diff = \"\" source_config_result = await self.get_config(source=source) source_config = source_config_result.result if isinstance(source_config_result.scrapli_responses, MultiResponse): # in this case this will always be a multiresponse or nothing (failure) but mypy # doesnt know that, hence the isinstance check scrapli_responses.extend(source_config_result.scrapli_responses) if source_config_result.failed: msg = \"failed fetching source config for diff comparison\" self.logger.critical(msg) raise DiffConfigError(msg) except DiffConfigError: pass return self._post_diff_config( diff_response=diff_response, scrapli_responses=scrapli_responses, source_config=self.clean_config(source_config), candidate_config=self.clean_config(self.candidate_config), device_diff=device_diff, ) Ancestors (in MRO) \u00b6 scrapli_cfg.platform.base.async_platform.AsyncScrapliCfgPlatform abc.ABC scrapli_cfg.platform.base.base_platform.ScrapliCfgBase scrapli_cfg.platform.core.cisco_nxos.base_platform.ScrapliCfgNXOSBase Class variables \u00b6 conn: Union[scrapli.driver.network.sync_driver.NetworkDriver, scrapli.driver.network.async_driver.AsyncNetworkDriver] Methods \u00b6 get_checkpoint \u00b6 get_checkpoint(self) \u2011> scrapli_cfg.response.ScrapliCfgResponse 1 2 3 4 5 6 7 8 9 10 11 Get device checkpoint file Args: N/A Returns: ScrapliCfgResponse: response object containing string of the target config source as the `result` attribute Raises: N/A load_config \u00b6 load_config(self, config: str, replace: bool = False, **kwargs: Any) \u2011> scrapli_cfg.response.ScrapliCfgResponse 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 Load configuration to a device Supported kwargs: N/A Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for nxos supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A","title":"Async Platform"},{"location":"api_docs/platform/core/cisco_nxos/async_platform/#module-scrapli_cfgplatformcorecisco_nxosasync_platform","text":"scrapli_cfg.platform.core.cisco_nxos.async_platform Expand source code \"\"\"scrapli_cfg.platform.core.cisco_nxos.async_platform\"\"\" from typing import Any, Callable, List, Optional, Union from scrapli.driver.core import AsyncNXOSDriver from scrapli.response import MultiResponse, Response from scrapli_cfg.diff import ScrapliCfgDiffResponse from scrapli_cfg.exceptions import DiffConfigError, FailedToDetermineDeviceState from scrapli_cfg.platform.base.async_platform import AsyncScrapliCfgPlatform from scrapli_cfg.platform.core.cisco_nxos.base_platform import CONFIG_SOURCES, ScrapliCfgNXOSBase from scrapli_cfg.response import ScrapliCfgResponse class AsyncScrapliCfgNXOS(AsyncScrapliCfgPlatform, ScrapliCfgNXOSBase): def __init__( self, conn: AsyncNXOSDriver, *, config_sources: Optional[List[str]] = None, on_prepare: Optional[Callable[..., Any]] = None, filesystem: str = \"bootflash:\", cleanup_post_commit: bool = True, dedicated_connection: bool = False, ignore_version: bool = False, ) -> None: if config_sources is None: config_sources = CONFIG_SOURCES super().__init__( conn=conn, config_sources=config_sources, on_prepare=on_prepare, dedicated_connection=dedicated_connection, ignore_version=ignore_version, ) self.filesystem = filesystem self._filesystem_space_available_buffer_perc = 10 self._replace = False self.candidate_config_filename = \"\" self.cleanup_post_commit = cleanup_post_commit async def _get_filesystem_space_available(self) -> int: \"\"\" Get available space on filesystem Args: N/A Returns: None Raises: FailedToDetermineDeviceState: if unable to fetch file filesystem bytes available \"\"\" filesystem_size_result = await self.conn.send_command( command=f\"dir {self.filesystem} | i 'bytes free'\" ) if filesystem_size_result.failed: raise FailedToDetermineDeviceState(\"failed to determine space available on filesystem\") return self._post_get_filesystem_space_available(output=filesystem_size_result.result) async def _delete_candidate_config(self) -> MultiResponse: \"\"\" Delete candidate config from the filesystem Args: N/A Returns: MultiResponse: response from deleting the candidate config Raises: N/A \"\"\" delete_commands = [ \"terminal dont-ask\", f\"delete {self.filesystem}{self.candidate_config_filename}\", ] delete_result = await self.conn.send_commands(commands=delete_commands) return delete_result async def get_checkpoint(self) -> ScrapliCfgResponse: \"\"\" Get device checkpoint file Args: N/A Returns: ScrapliCfgResponse: response object containing string of the target config source as the `result` attribute Raises: N/A \"\"\" response, checkpoint_commands = self._pre_get_checkpoint(conn=self.conn) checkpoint_results = await self.conn.send_commands(commands=checkpoint_commands) try: checkpoint: str = checkpoint_results[2].result except IndexError: checkpoint = \"\" return self._post_get_config( response=response, source=\"running\", scrapli_responses=[checkpoint_results], result=checkpoint, ) async def get_version(self) -> ScrapliCfgResponse: response = self._pre_get_version() version_result = await self.conn.send_command(command='show version | i \"NXOS: version\"') return self._post_get_version( response=response, scrapli_responses=[version_result], result=self._parse_version(device_output=version_result.result), ) async def get_config(self, source: str = \"running\") -> ScrapliCfgResponse: response = self._pre_get_config(source=source) config_result = await self.conn.send_command( command=self._get_config_command(source=source) ) return self._post_get_config( response=response, source=source, scrapli_responses=[config_result], result=config_result.result, ) async def load_config( self, config: str, replace: bool = False, **kwargs: Any ) -> ScrapliCfgResponse: \"\"\" Load configuration to a device Supported kwargs: N/A Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for nxos supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" response = self._pre_load_config(config=config) config = self._prepare_load_config(config=config, replace=replace) filesystem_bytes_available = await self._get_filesystem_space_available() self._space_available(filesystem_bytes_available=filesystem_bytes_available) await self.conn.acquire_priv(desired_priv=\"tclsh\") config_result = await self.conn.send_config(config=config, privilege_level=\"tclsh\") await self.conn.acquire_priv(desired_priv=self.conn.default_desired_privilege_level) return self._post_load_config( response=response, scrapli_responses=[config_result], ) async def abort_config(self) -> ScrapliCfgResponse: response = self._pre_abort_config( session_or_config_file=bool(self.candidate_config_filename) ) abort_result = await self._delete_candidate_config() self._reset_config_session() return self._post_abort_config(response=response, scrapli_responses=[abort_result]) async def commit_config(self, source: str = \"running\") -> ScrapliCfgResponse: scrapli_responses: List[Union[MultiResponse, Response]] = [] response = self._pre_commit_config( source=source, session_or_config_file=bool(self.candidate_config_filename) ) if self._replace is True: replace_command = ( f\"rollback running-config file {self.filesystem}{self.candidate_config_filename}\" ) commit_result = await self.conn.send_command(command=replace_command) else: merge_command = f\"copy {self.filesystem}{self.candidate_config_filename} running-config\" commit_result = await self.conn.send_command(command=merge_command) scrapli_responses.append(commit_result) save_config_result = await self.conn.send_command( command=\"copy running-config startup-config\" ) scrapli_responses.append(save_config_result) if self.cleanup_post_commit: cleanup_result = await self._delete_candidate_config() scrapli_responses.append(cleanup_result) self._reset_config_session() return self._post_commit_config( response=response, scrapli_responses=scrapli_responses, ) async def diff_config(self, source: str = \"running\") -> ScrapliCfgDiffResponse: scrapli_responses = [] device_diff = \"\" source_config = \"\" diff_response = self._pre_diff_config( source=source, session_or_config_file=bool(self.candidate_config_filename) ) try: diff_command = self._get_diff_command(source=source) if diff_command: diff_result = await self.conn.send_command(command=diff_command) scrapli_responses.append(diff_result) if diff_result.failed: msg = \"failed generating diff for config session\" self.logger.critical(msg) raise DiffConfigError(msg) device_diff = diff_result.result else: device_diff = \"\" source_config_result = await self.get_config(source=source) source_config = source_config_result.result if isinstance(source_config_result.scrapli_responses, MultiResponse): # in this case this will always be a multiresponse or nothing (failure) but mypy # doesnt know that, hence the isinstance check scrapli_responses.extend(source_config_result.scrapli_responses) if source_config_result.failed: msg = \"failed fetching source config for diff comparison\" self.logger.critical(msg) raise DiffConfigError(msg) except DiffConfigError: pass return self._post_diff_config( diff_response=diff_response, scrapli_responses=scrapli_responses, source_config=self.clean_config(source_config), candidate_config=self.clean_config(self.candidate_config), device_diff=device_diff, )","title":"Module scrapli_cfg.platform.core.cisco_nxos.async_platform"},{"location":"api_docs/platform/core/cisco_nxos/async_platform/#classes","text":"","title":"Classes"},{"location":"api_docs/platform/core/cisco_nxos/async_platform/#asyncscraplicfgnxos","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 Helper class that provides a standard way to create an ABC using inheritance. Scrapli Config async base class Args: conn: scrapli connection to use config_sources: list of config sources on_prepare: optional callable to run at connection `prepare` dedicated_connection: if `False` (default value) scrapli cfg will not open or close the underlying scrapli connection and will raise an exception if the scrapli connection is not open. If `True` will automatically open and close the scrapli connection when using with a context manager, `prepare` will open the scrapli connection (if not already open), and `close` will close the scrapli connection. ignore_version: ignore checking device version support; currently this just means that scrapli-cfg will not fetch the device version during the prepare phase, however this will (hopefully) be used in the future to limit what methods can be used against a target device. For example, for EOS devices we need > 4.14 to load configs; so if a device is encountered at 4.13 the version check would raise an exception rather than just failing in a potentially awkward fashion. Returns: None Raises: N/A Expand source code class AsyncScrapliCfgNXOS(AsyncScrapliCfgPlatform, ScrapliCfgNXOSBase): def __init__( self, conn: AsyncNXOSDriver, *, config_sources: Optional[List[str]] = None, on_prepare: Optional[Callable[..., Any]] = None, filesystem: str = \"bootflash:\", cleanup_post_commit: bool = True, dedicated_connection: bool = False, ignore_version: bool = False, ) -> None: if config_sources is None: config_sources = CONFIG_SOURCES super().__init__( conn=conn, config_sources=config_sources, on_prepare=on_prepare, dedicated_connection=dedicated_connection, ignore_version=ignore_version, ) self.filesystem = filesystem self._filesystem_space_available_buffer_perc = 10 self._replace = False self.candidate_config_filename = \"\" self.cleanup_post_commit = cleanup_post_commit async def _get_filesystem_space_available(self) -> int: \"\"\" Get available space on filesystem Args: N/A Returns: None Raises: FailedToDetermineDeviceState: if unable to fetch file filesystem bytes available \"\"\" filesystem_size_result = await self.conn.send_command( command=f\"dir {self.filesystem} | i 'bytes free'\" ) if filesystem_size_result.failed: raise FailedToDetermineDeviceState(\"failed to determine space available on filesystem\") return self._post_get_filesystem_space_available(output=filesystem_size_result.result) async def _delete_candidate_config(self) -> MultiResponse: \"\"\" Delete candidate config from the filesystem Args: N/A Returns: MultiResponse: response from deleting the candidate config Raises: N/A \"\"\" delete_commands = [ \"terminal dont-ask\", f\"delete {self.filesystem}{self.candidate_config_filename}\", ] delete_result = await self.conn.send_commands(commands=delete_commands) return delete_result async def get_checkpoint(self) -> ScrapliCfgResponse: \"\"\" Get device checkpoint file Args: N/A Returns: ScrapliCfgResponse: response object containing string of the target config source as the `result` attribute Raises: N/A \"\"\" response, checkpoint_commands = self._pre_get_checkpoint(conn=self.conn) checkpoint_results = await self.conn.send_commands(commands=checkpoint_commands) try: checkpoint: str = checkpoint_results[2].result except IndexError: checkpoint = \"\" return self._post_get_config( response=response, source=\"running\", scrapli_responses=[checkpoint_results], result=checkpoint, ) async def get_version(self) -> ScrapliCfgResponse: response = self._pre_get_version() version_result = await self.conn.send_command(command='show version | i \"NXOS: version\"') return self._post_get_version( response=response, scrapli_responses=[version_result], result=self._parse_version(device_output=version_result.result), ) async def get_config(self, source: str = \"running\") -> ScrapliCfgResponse: response = self._pre_get_config(source=source) config_result = await self.conn.send_command( command=self._get_config_command(source=source) ) return self._post_get_config( response=response, source=source, scrapli_responses=[config_result], result=config_result.result, ) async def load_config( self, config: str, replace: bool = False, **kwargs: Any ) -> ScrapliCfgResponse: \"\"\" Load configuration to a device Supported kwargs: N/A Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for nxos supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" response = self._pre_load_config(config=config) config = self._prepare_load_config(config=config, replace=replace) filesystem_bytes_available = await self._get_filesystem_space_available() self._space_available(filesystem_bytes_available=filesystem_bytes_available) await self.conn.acquire_priv(desired_priv=\"tclsh\") config_result = await self.conn.send_config(config=config, privilege_level=\"tclsh\") await self.conn.acquire_priv(desired_priv=self.conn.default_desired_privilege_level) return self._post_load_config( response=response, scrapli_responses=[config_result], ) async def abort_config(self) -> ScrapliCfgResponse: response = self._pre_abort_config( session_or_config_file=bool(self.candidate_config_filename) ) abort_result = await self._delete_candidate_config() self._reset_config_session() return self._post_abort_config(response=response, scrapli_responses=[abort_result]) async def commit_config(self, source: str = \"running\") -> ScrapliCfgResponse: scrapli_responses: List[Union[MultiResponse, Response]] = [] response = self._pre_commit_config( source=source, session_or_config_file=bool(self.candidate_config_filename) ) if self._replace is True: replace_command = ( f\"rollback running-config file {self.filesystem}{self.candidate_config_filename}\" ) commit_result = await self.conn.send_command(command=replace_command) else: merge_command = f\"copy {self.filesystem}{self.candidate_config_filename} running-config\" commit_result = await self.conn.send_command(command=merge_command) scrapli_responses.append(commit_result) save_config_result = await self.conn.send_command( command=\"copy running-config startup-config\" ) scrapli_responses.append(save_config_result) if self.cleanup_post_commit: cleanup_result = await self._delete_candidate_config() scrapli_responses.append(cleanup_result) self._reset_config_session() return self._post_commit_config( response=response, scrapli_responses=scrapli_responses, ) async def diff_config(self, source: str = \"running\") -> ScrapliCfgDiffResponse: scrapli_responses = [] device_diff = \"\" source_config = \"\" diff_response = self._pre_diff_config( source=source, session_or_config_file=bool(self.candidate_config_filename) ) try: diff_command = self._get_diff_command(source=source) if diff_command: diff_result = await self.conn.send_command(command=diff_command) scrapli_responses.append(diff_result) if diff_result.failed: msg = \"failed generating diff for config session\" self.logger.critical(msg) raise DiffConfigError(msg) device_diff = diff_result.result else: device_diff = \"\" source_config_result = await self.get_config(source=source) source_config = source_config_result.result if isinstance(source_config_result.scrapli_responses, MultiResponse): # in this case this will always be a multiresponse or nothing (failure) but mypy # doesnt know that, hence the isinstance check scrapli_responses.extend(source_config_result.scrapli_responses) if source_config_result.failed: msg = \"failed fetching source config for diff comparison\" self.logger.critical(msg) raise DiffConfigError(msg) except DiffConfigError: pass return self._post_diff_config( diff_response=diff_response, scrapli_responses=scrapli_responses, source_config=self.clean_config(source_config), candidate_config=self.clean_config(self.candidate_config), device_diff=device_diff, )","title":"AsyncScrapliCfgNXOS"},{"location":"api_docs/platform/core/cisco_nxos/async_platform/#ancestors-in-mro","text":"scrapli_cfg.platform.base.async_platform.AsyncScrapliCfgPlatform abc.ABC scrapli_cfg.platform.base.base_platform.ScrapliCfgBase scrapli_cfg.platform.core.cisco_nxos.base_platform.ScrapliCfgNXOSBase","title":"Ancestors (in MRO)"},{"location":"api_docs/platform/core/cisco_nxos/async_platform/#class-variables","text":"conn: Union[scrapli.driver.network.sync_driver.NetworkDriver, scrapli.driver.network.async_driver.AsyncNetworkDriver]","title":"Class variables"},{"location":"api_docs/platform/core/cisco_nxos/async_platform/#methods","text":"","title":"Methods"},{"location":"api_docs/platform/core/cisco_nxos/async_platform/#get_checkpoint","text":"get_checkpoint(self) \u2011> scrapli_cfg.response.ScrapliCfgResponse 1 2 3 4 5 6 7 8 9 10 11 Get device checkpoint file Args: N/A Returns: ScrapliCfgResponse: response object containing string of the target config source as the `result` attribute Raises: N/A","title":"get_checkpoint"},{"location":"api_docs/platform/core/cisco_nxos/async_platform/#load_config","text":"load_config(self, config: str, replace: bool = False, **kwargs: Any) \u2011> scrapli_cfg.response.ScrapliCfgResponse 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 Load configuration to a device Supported kwargs: N/A Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for nxos supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A","title":"load_config"},{"location":"api_docs/platform/core/cisco_nxos/base_platform/","text":"window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting()) Module scrapli_cfg.platform.core.cisco_nxos.base_platform \u00b6 scrapli_cfg.platform.core.cisco_nxos.base_platform Expand source code \"\"\"scrapli_cfg.platform.core.cisco_nxos.base_platform\"\"\" import re from datetime import datetime from logging import Logger, LoggerAdapter from typing import TYPE_CHECKING, List, Tuple, Union from scrapli.driver.network import AsyncNetworkDriver, NetworkDriver from scrapli_cfg.exceptions import ( FailedToFetchSpaceAvailable, GetConfigError, InsufficientSpaceAvailable, ) from scrapli_cfg.helper import strip_blank_lines from scrapli_cfg.platform.core.cisco_nxos.patterns import ( BYTES_FREE, CHECKPOINT_LINE, OUTPUT_HEADER_PATTERN, VERSION_PATTERN, ) from scrapli_cfg.response import ScrapliCfgResponse if TYPE_CHECKING: LoggerAdapterT = LoggerAdapter[Logger] # pylint:disable=E1136 else: LoggerAdapterT = LoggerAdapter CONFIG_SOURCES = [ \"running\", \"startup\", ] class ScrapliCfgNXOSBase: logger: LoggerAdapterT candidate_config: str candidate_config_filename: str _replace: bool filesystem: str _filesystem_space_available_buffer_perc: int def _post_get_filesystem_space_available(self, output: str) -> int: \"\"\" Handle post \"get_filesystem_space_available\" operations for parity between sync and async Args: output: output that was fetched from the device Returns: int: bytes of space available on filesystem Raises: FailedToFetchSpaceAvailable: if could not determine space available... duh :) \"\"\" self.logger.info(\"determining space available from device output\") bytes_available_match = re.search(pattern=BYTES_FREE, string=output) if not bytes_available_match: msg = \"could not determine space available on filesystem\" self.logger.critical(msg) raise FailedToFetchSpaceAvailable(msg) return int(bytes_available_match.groupdict()[\"bytes_available\"]) def _space_available(self, filesystem_bytes_available: int) -> None: \"\"\" Space available operations for parity between sync and async It seems that the length of the config is near enough 1:1 to the size it takes up on the disk... so roll w/ that plus a bit of buffer based on the available buffer perc Args: filesystem_bytes_available: bytes available on filesystem Returns: None Raises: InsufficientSpaceAvailable: if... insufficient space available.... \"\"\" if filesystem_bytes_available < ( len(self.candidate_config) / (self._filesystem_space_available_buffer_perc / 100) ) + len(self.candidate_config): # filesystem has less than candidate config file size + 10% (by default) space, bail out msg = ( f\"insufficient space available for candidate config + \" f\"{self._filesystem_space_available_buffer_perc}% (buffer)\" ) self.logger.critical(msg) raise InsufficientSpaceAvailable(msg) @staticmethod def _parse_version(device_output: str) -> str: \"\"\" Parse version string out of device output Args: device_output: output from show version command Returns: str: device version string Raises: N/A \"\"\" version_string_search = re.search(pattern=VERSION_PATTERN, string=device_output) if not version_string_search: return \"\" version_string = version_string_search.group(0) or \"\" return version_string def _reset_config_session(self) -> None: \"\"\" Reset config session info Resets the candidate config and config session name attributes -- when these are \"empty\" we know there is no current config session Args: N/A Returns: None Raises: N/A \"\"\" self.logger.debug(\"resetting candidate config and config session name\") self.candidate_config = \"\" self.candidate_config_filename = \"\" @staticmethod def _get_config_command(source: str) -> str: \"\"\" Return command to use to get config based on the provided source Args: source: name of the config source, generally running|startup Returns: str: command to use to fetch the requested config Raises: N/A \"\"\" if source == \"running\": return \"show running-config\" return \"show startup-config\" def _get_diff_command(self, source: str) -> str: \"\"\" Generate diff command based on source to diff and filesystem/candidate config name Args: source: config source to gen diff for Returns: str: command to use to diff the configuration Raises: N/A \"\"\" if self._replace: return ( f\"show diff rollback-patch {source}-config file {self.filesystem}\" f\"{self.candidate_config_filename}\" ) return \"\" def _prepare_config_payloads(self, config: str) -> str: \"\"\" Prepare a configuration so it can be nicely sent to the device via scrapli Args: config: configuration to prep Returns: str: string of config lines to write to candidate config file Raises: N/A \"\"\" # with the \"normal\" method (the way iosxe does this) it seems to want to stop at 250ish # lines... so this works but its kinda wonky... the actual lines we want to put in the text # file are enclosed in curly braces for tcl-reasons i guess tclsh_filesystem = f\"/{self.filesystem.strip(':')}/\" tclsh_start_file = f'set fl [open \"{tclsh_filesystem}{self.candidate_config_filename}\" wb+]' tcl_config = \"\\n\".join( [f\"puts -nonewline $fl {{{line}\\r}}\" for line in config.splitlines()] ) tclsh_end_file = \"close $fl\" final_config = \"\\n\".join((tclsh_start_file, tcl_config, tclsh_end_file)) return final_config def _prepare_load_config(self, config: str, replace: bool) -> str: \"\"\" Handle pre \"load_config\" operations for parity between sync and async Args: config: candidate config to load replace: True/False replace the configuration; passed here so it can be set at the class level as we need to stay in config mode and we need to know if we are doing a merge or a replace when we go to diff things Returns: str: string of config to write to candidate config file Raises: N/A \"\"\" self.candidate_config = config if not self.candidate_config_filename: self.candidate_config_filename = f\"scrapli_cfg_{round(datetime.now().timestamp())}\" self.logger.debug( f\"candidate config file name will be '{self.candidate_config_filename}'\" ) config = self._prepare_config_payloads(config=config) self._replace = replace return config def clean_config(self, config: str) -> str: \"\"\" Clean a configuration file of unwanted lines Args: config: configuration string to \"clean\" Returns: str: cleaned configuration string Raises: N/A \"\"\" self.logger.debug(\"cleaning config file\") config = re.sub(pattern=CHECKPOINT_LINE, string=config, repl=\"\") config = re.sub(pattern=OUTPUT_HEADER_PATTERN, string=config, repl=\"\") return strip_blank_lines(config=config) def _pre_get_checkpoint( self, conn: Union[AsyncNetworkDriver, NetworkDriver] ) -> Tuple[ScrapliCfgResponse, List[str]]: \"\"\" Handle pre \"get_checkpoint\" operations for parity between sync and async Args: conn: connection from the sync or async platform; passed in explicitly to maintain typing sanity Returns: list: list of commands needed to generate checkpoint and show it Raises: N/A \"\"\" self.logger.info(\"get_checkpoint requested\") tmp_timestamp = round(datetime.now().timestamp()) checkpoint_commands = [ \"terminal dont-ask\", f\"checkpoint file {self.filesystem}scrapli_cfg_tmp_{tmp_timestamp}\", f\"show file {self.filesystem}scrapli_cfg_tmp_{tmp_timestamp}\", f\"delete {self.filesystem}scrapli_cfg_tmp_{tmp_timestamp}\", ] response = ScrapliCfgResponse(host=conn.host, raise_for_status_exception=GetConfigError) return response, checkpoint_commands Classes \u00b6 ScrapliCfgNXOSBase \u00b6 Expand source code class ScrapliCfgNXOSBase: logger: LoggerAdapterT candidate_config: str candidate_config_filename: str _replace: bool filesystem: str _filesystem_space_available_buffer_perc: int def _post_get_filesystem_space_available(self, output: str) -> int: \"\"\" Handle post \"get_filesystem_space_available\" operations for parity between sync and async Args: output: output that was fetched from the device Returns: int: bytes of space available on filesystem Raises: FailedToFetchSpaceAvailable: if could not determine space available... duh :) \"\"\" self.logger.info(\"determining space available from device output\") bytes_available_match = re.search(pattern=BYTES_FREE, string=output) if not bytes_available_match: msg = \"could not determine space available on filesystem\" self.logger.critical(msg) raise FailedToFetchSpaceAvailable(msg) return int(bytes_available_match.groupdict()[\"bytes_available\"]) def _space_available(self, filesystem_bytes_available: int) -> None: \"\"\" Space available operations for parity between sync and async It seems that the length of the config is near enough 1:1 to the size it takes up on the disk... so roll w/ that plus a bit of buffer based on the available buffer perc Args: filesystem_bytes_available: bytes available on filesystem Returns: None Raises: InsufficientSpaceAvailable: if... insufficient space available.... \"\"\" if filesystem_bytes_available < ( len(self.candidate_config) / (self._filesystem_space_available_buffer_perc / 100) ) + len(self.candidate_config): # filesystem has less than candidate config file size + 10% (by default) space, bail out msg = ( f\"insufficient space available for candidate config + \" f\"{self._filesystem_space_available_buffer_perc}% (buffer)\" ) self.logger.critical(msg) raise InsufficientSpaceAvailable(msg) @staticmethod def _parse_version(device_output: str) -> str: \"\"\" Parse version string out of device output Args: device_output: output from show version command Returns: str: device version string Raises: N/A \"\"\" version_string_search = re.search(pattern=VERSION_PATTERN, string=device_output) if not version_string_search: return \"\" version_string = version_string_search.group(0) or \"\" return version_string def _reset_config_session(self) -> None: \"\"\" Reset config session info Resets the candidate config and config session name attributes -- when these are \"empty\" we know there is no current config session Args: N/A Returns: None Raises: N/A \"\"\" self.logger.debug(\"resetting candidate config and config session name\") self.candidate_config = \"\" self.candidate_config_filename = \"\" @staticmethod def _get_config_command(source: str) -> str: \"\"\" Return command to use to get config based on the provided source Args: source: name of the config source, generally running|startup Returns: str: command to use to fetch the requested config Raises: N/A \"\"\" if source == \"running\": return \"show running-config\" return \"show startup-config\" def _get_diff_command(self, source: str) -> str: \"\"\" Generate diff command based on source to diff and filesystem/candidate config name Args: source: config source to gen diff for Returns: str: command to use to diff the configuration Raises: N/A \"\"\" if self._replace: return ( f\"show diff rollback-patch {source}-config file {self.filesystem}\" f\"{self.candidate_config_filename}\" ) return \"\" def _prepare_config_payloads(self, config: str) -> str: \"\"\" Prepare a configuration so it can be nicely sent to the device via scrapli Args: config: configuration to prep Returns: str: string of config lines to write to candidate config file Raises: N/A \"\"\" # with the \"normal\" method (the way iosxe does this) it seems to want to stop at 250ish # lines... so this works but its kinda wonky... the actual lines we want to put in the text # file are enclosed in curly braces for tcl-reasons i guess tclsh_filesystem = f\"/{self.filesystem.strip(':')}/\" tclsh_start_file = f'set fl [open \"{tclsh_filesystem}{self.candidate_config_filename}\" wb+]' tcl_config = \"\\n\".join( [f\"puts -nonewline $fl {{{line}\\r}}\" for line in config.splitlines()] ) tclsh_end_file = \"close $fl\" final_config = \"\\n\".join((tclsh_start_file, tcl_config, tclsh_end_file)) return final_config def _prepare_load_config(self, config: str, replace: bool) -> str: \"\"\" Handle pre \"load_config\" operations for parity between sync and async Args: config: candidate config to load replace: True/False replace the configuration; passed here so it can be set at the class level as we need to stay in config mode and we need to know if we are doing a merge or a replace when we go to diff things Returns: str: string of config to write to candidate config file Raises: N/A \"\"\" self.candidate_config = config if not self.candidate_config_filename: self.candidate_config_filename = f\"scrapli_cfg_{round(datetime.now().timestamp())}\" self.logger.debug( f\"candidate config file name will be '{self.candidate_config_filename}'\" ) config = self._prepare_config_payloads(config=config) self._replace = replace return config def clean_config(self, config: str) -> str: \"\"\" Clean a configuration file of unwanted lines Args: config: configuration string to \"clean\" Returns: str: cleaned configuration string Raises: N/A \"\"\" self.logger.debug(\"cleaning config file\") config = re.sub(pattern=CHECKPOINT_LINE, string=config, repl=\"\") config = re.sub(pattern=OUTPUT_HEADER_PATTERN, string=config, repl=\"\") return strip_blank_lines(config=config) def _pre_get_checkpoint( self, conn: Union[AsyncNetworkDriver, NetworkDriver] ) -> Tuple[ScrapliCfgResponse, List[str]]: \"\"\" Handle pre \"get_checkpoint\" operations for parity between sync and async Args: conn: connection from the sync or async platform; passed in explicitly to maintain typing sanity Returns: list: list of commands needed to generate checkpoint and show it Raises: N/A \"\"\" self.logger.info(\"get_checkpoint requested\") tmp_timestamp = round(datetime.now().timestamp()) checkpoint_commands = [ \"terminal dont-ask\", f\"checkpoint file {self.filesystem}scrapli_cfg_tmp_{tmp_timestamp}\", f\"show file {self.filesystem}scrapli_cfg_tmp_{tmp_timestamp}\", f\"delete {self.filesystem}scrapli_cfg_tmp_{tmp_timestamp}\", ] response = ScrapliCfgResponse(host=conn.host, raise_for_status_exception=GetConfigError) return response, checkpoint_commands Descendants \u00b6 scrapli_cfg.platform.core.cisco_nxos.async_platform.AsyncScrapliCfgNXOS scrapli_cfg.platform.core.cisco_nxos.sync_platform.ScrapliCfgNXOS Class variables \u00b6 candidate_config: str candidate_config_filename: str filesystem: str logger: logging.LoggerAdapter Methods \u00b6 clean_config \u00b6 clean_config(self, config: str) \u2011> str 1 2 3 4 5 6 7 8 9 10 Clean a configuration file of unwanted lines Args: config: configuration string to \"clean\" Returns: str: cleaned configuration string Raises: N/A","title":"Base platform"},{"location":"api_docs/platform/core/cisco_nxos/base_platform/#module-scrapli_cfgplatformcorecisco_nxosbase_platform","text":"scrapli_cfg.platform.core.cisco_nxos.base_platform Expand source code \"\"\"scrapli_cfg.platform.core.cisco_nxos.base_platform\"\"\" import re from datetime import datetime from logging import Logger, LoggerAdapter from typing import TYPE_CHECKING, List, Tuple, Union from scrapli.driver.network import AsyncNetworkDriver, NetworkDriver from scrapli_cfg.exceptions import ( FailedToFetchSpaceAvailable, GetConfigError, InsufficientSpaceAvailable, ) from scrapli_cfg.helper import strip_blank_lines from scrapli_cfg.platform.core.cisco_nxos.patterns import ( BYTES_FREE, CHECKPOINT_LINE, OUTPUT_HEADER_PATTERN, VERSION_PATTERN, ) from scrapli_cfg.response import ScrapliCfgResponse if TYPE_CHECKING: LoggerAdapterT = LoggerAdapter[Logger] # pylint:disable=E1136 else: LoggerAdapterT = LoggerAdapter CONFIG_SOURCES = [ \"running\", \"startup\", ] class ScrapliCfgNXOSBase: logger: LoggerAdapterT candidate_config: str candidate_config_filename: str _replace: bool filesystem: str _filesystem_space_available_buffer_perc: int def _post_get_filesystem_space_available(self, output: str) -> int: \"\"\" Handle post \"get_filesystem_space_available\" operations for parity between sync and async Args: output: output that was fetched from the device Returns: int: bytes of space available on filesystem Raises: FailedToFetchSpaceAvailable: if could not determine space available... duh :) \"\"\" self.logger.info(\"determining space available from device output\") bytes_available_match = re.search(pattern=BYTES_FREE, string=output) if not bytes_available_match: msg = \"could not determine space available on filesystem\" self.logger.critical(msg) raise FailedToFetchSpaceAvailable(msg) return int(bytes_available_match.groupdict()[\"bytes_available\"]) def _space_available(self, filesystem_bytes_available: int) -> None: \"\"\" Space available operations for parity between sync and async It seems that the length of the config is near enough 1:1 to the size it takes up on the disk... so roll w/ that plus a bit of buffer based on the available buffer perc Args: filesystem_bytes_available: bytes available on filesystem Returns: None Raises: InsufficientSpaceAvailable: if... insufficient space available.... \"\"\" if filesystem_bytes_available < ( len(self.candidate_config) / (self._filesystem_space_available_buffer_perc / 100) ) + len(self.candidate_config): # filesystem has less than candidate config file size + 10% (by default) space, bail out msg = ( f\"insufficient space available for candidate config + \" f\"{self._filesystem_space_available_buffer_perc}% (buffer)\" ) self.logger.critical(msg) raise InsufficientSpaceAvailable(msg) @staticmethod def _parse_version(device_output: str) -> str: \"\"\" Parse version string out of device output Args: device_output: output from show version command Returns: str: device version string Raises: N/A \"\"\" version_string_search = re.search(pattern=VERSION_PATTERN, string=device_output) if not version_string_search: return \"\" version_string = version_string_search.group(0) or \"\" return version_string def _reset_config_session(self) -> None: \"\"\" Reset config session info Resets the candidate config and config session name attributes -- when these are \"empty\" we know there is no current config session Args: N/A Returns: None Raises: N/A \"\"\" self.logger.debug(\"resetting candidate config and config session name\") self.candidate_config = \"\" self.candidate_config_filename = \"\" @staticmethod def _get_config_command(source: str) -> str: \"\"\" Return command to use to get config based on the provided source Args: source: name of the config source, generally running|startup Returns: str: command to use to fetch the requested config Raises: N/A \"\"\" if source == \"running\": return \"show running-config\" return \"show startup-config\" def _get_diff_command(self, source: str) -> str: \"\"\" Generate diff command based on source to diff and filesystem/candidate config name Args: source: config source to gen diff for Returns: str: command to use to diff the configuration Raises: N/A \"\"\" if self._replace: return ( f\"show diff rollback-patch {source}-config file {self.filesystem}\" f\"{self.candidate_config_filename}\" ) return \"\" def _prepare_config_payloads(self, config: str) -> str: \"\"\" Prepare a configuration so it can be nicely sent to the device via scrapli Args: config: configuration to prep Returns: str: string of config lines to write to candidate config file Raises: N/A \"\"\" # with the \"normal\" method (the way iosxe does this) it seems to want to stop at 250ish # lines... so this works but its kinda wonky... the actual lines we want to put in the text # file are enclosed in curly braces for tcl-reasons i guess tclsh_filesystem = f\"/{self.filesystem.strip(':')}/\" tclsh_start_file = f'set fl [open \"{tclsh_filesystem}{self.candidate_config_filename}\" wb+]' tcl_config = \"\\n\".join( [f\"puts -nonewline $fl {{{line}\\r}}\" for line in config.splitlines()] ) tclsh_end_file = \"close $fl\" final_config = \"\\n\".join((tclsh_start_file, tcl_config, tclsh_end_file)) return final_config def _prepare_load_config(self, config: str, replace: bool) -> str: \"\"\" Handle pre \"load_config\" operations for parity between sync and async Args: config: candidate config to load replace: True/False replace the configuration; passed here so it can be set at the class level as we need to stay in config mode and we need to know if we are doing a merge or a replace when we go to diff things Returns: str: string of config to write to candidate config file Raises: N/A \"\"\" self.candidate_config = config if not self.candidate_config_filename: self.candidate_config_filename = f\"scrapli_cfg_{round(datetime.now().timestamp())}\" self.logger.debug( f\"candidate config file name will be '{self.candidate_config_filename}'\" ) config = self._prepare_config_payloads(config=config) self._replace = replace return config def clean_config(self, config: str) -> str: \"\"\" Clean a configuration file of unwanted lines Args: config: configuration string to \"clean\" Returns: str: cleaned configuration string Raises: N/A \"\"\" self.logger.debug(\"cleaning config file\") config = re.sub(pattern=CHECKPOINT_LINE, string=config, repl=\"\") config = re.sub(pattern=OUTPUT_HEADER_PATTERN, string=config, repl=\"\") return strip_blank_lines(config=config) def _pre_get_checkpoint( self, conn: Union[AsyncNetworkDriver, NetworkDriver] ) -> Tuple[ScrapliCfgResponse, List[str]]: \"\"\" Handle pre \"get_checkpoint\" operations for parity between sync and async Args: conn: connection from the sync or async platform; passed in explicitly to maintain typing sanity Returns: list: list of commands needed to generate checkpoint and show it Raises: N/A \"\"\" self.logger.info(\"get_checkpoint requested\") tmp_timestamp = round(datetime.now().timestamp()) checkpoint_commands = [ \"terminal dont-ask\", f\"checkpoint file {self.filesystem}scrapli_cfg_tmp_{tmp_timestamp}\", f\"show file {self.filesystem}scrapli_cfg_tmp_{tmp_timestamp}\", f\"delete {self.filesystem}scrapli_cfg_tmp_{tmp_timestamp}\", ] response = ScrapliCfgResponse(host=conn.host, raise_for_status_exception=GetConfigError) return response, checkpoint_commands","title":"Module scrapli_cfg.platform.core.cisco_nxos.base_platform"},{"location":"api_docs/platform/core/cisco_nxos/base_platform/#classes","text":"","title":"Classes"},{"location":"api_docs/platform/core/cisco_nxos/base_platform/#scraplicfgnxosbase","text":"Expand source code class ScrapliCfgNXOSBase: logger: LoggerAdapterT candidate_config: str candidate_config_filename: str _replace: bool filesystem: str _filesystem_space_available_buffer_perc: int def _post_get_filesystem_space_available(self, output: str) -> int: \"\"\" Handle post \"get_filesystem_space_available\" operations for parity between sync and async Args: output: output that was fetched from the device Returns: int: bytes of space available on filesystem Raises: FailedToFetchSpaceAvailable: if could not determine space available... duh :) \"\"\" self.logger.info(\"determining space available from device output\") bytes_available_match = re.search(pattern=BYTES_FREE, string=output) if not bytes_available_match: msg = \"could not determine space available on filesystem\" self.logger.critical(msg) raise FailedToFetchSpaceAvailable(msg) return int(bytes_available_match.groupdict()[\"bytes_available\"]) def _space_available(self, filesystem_bytes_available: int) -> None: \"\"\" Space available operations for parity between sync and async It seems that the length of the config is near enough 1:1 to the size it takes up on the disk... so roll w/ that plus a bit of buffer based on the available buffer perc Args: filesystem_bytes_available: bytes available on filesystem Returns: None Raises: InsufficientSpaceAvailable: if... insufficient space available.... \"\"\" if filesystem_bytes_available < ( len(self.candidate_config) / (self._filesystem_space_available_buffer_perc / 100) ) + len(self.candidate_config): # filesystem has less than candidate config file size + 10% (by default) space, bail out msg = ( f\"insufficient space available for candidate config + \" f\"{self._filesystem_space_available_buffer_perc}% (buffer)\" ) self.logger.critical(msg) raise InsufficientSpaceAvailable(msg) @staticmethod def _parse_version(device_output: str) -> str: \"\"\" Parse version string out of device output Args: device_output: output from show version command Returns: str: device version string Raises: N/A \"\"\" version_string_search = re.search(pattern=VERSION_PATTERN, string=device_output) if not version_string_search: return \"\" version_string = version_string_search.group(0) or \"\" return version_string def _reset_config_session(self) -> None: \"\"\" Reset config session info Resets the candidate config and config session name attributes -- when these are \"empty\" we know there is no current config session Args: N/A Returns: None Raises: N/A \"\"\" self.logger.debug(\"resetting candidate config and config session name\") self.candidate_config = \"\" self.candidate_config_filename = \"\" @staticmethod def _get_config_command(source: str) -> str: \"\"\" Return command to use to get config based on the provided source Args: source: name of the config source, generally running|startup Returns: str: command to use to fetch the requested config Raises: N/A \"\"\" if source == \"running\": return \"show running-config\" return \"show startup-config\" def _get_diff_command(self, source: str) -> str: \"\"\" Generate diff command based on source to diff and filesystem/candidate config name Args: source: config source to gen diff for Returns: str: command to use to diff the configuration Raises: N/A \"\"\" if self._replace: return ( f\"show diff rollback-patch {source}-config file {self.filesystem}\" f\"{self.candidate_config_filename}\" ) return \"\" def _prepare_config_payloads(self, config: str) -> str: \"\"\" Prepare a configuration so it can be nicely sent to the device via scrapli Args: config: configuration to prep Returns: str: string of config lines to write to candidate config file Raises: N/A \"\"\" # with the \"normal\" method (the way iosxe does this) it seems to want to stop at 250ish # lines... so this works but its kinda wonky... the actual lines we want to put in the text # file are enclosed in curly braces for tcl-reasons i guess tclsh_filesystem = f\"/{self.filesystem.strip(':')}/\" tclsh_start_file = f'set fl [open \"{tclsh_filesystem}{self.candidate_config_filename}\" wb+]' tcl_config = \"\\n\".join( [f\"puts -nonewline $fl {{{line}\\r}}\" for line in config.splitlines()] ) tclsh_end_file = \"close $fl\" final_config = \"\\n\".join((tclsh_start_file, tcl_config, tclsh_end_file)) return final_config def _prepare_load_config(self, config: str, replace: bool) -> str: \"\"\" Handle pre \"load_config\" operations for parity between sync and async Args: config: candidate config to load replace: True/False replace the configuration; passed here so it can be set at the class level as we need to stay in config mode and we need to know if we are doing a merge or a replace when we go to diff things Returns: str: string of config to write to candidate config file Raises: N/A \"\"\" self.candidate_config = config if not self.candidate_config_filename: self.candidate_config_filename = f\"scrapli_cfg_{round(datetime.now().timestamp())}\" self.logger.debug( f\"candidate config file name will be '{self.candidate_config_filename}'\" ) config = self._prepare_config_payloads(config=config) self._replace = replace return config def clean_config(self, config: str) -> str: \"\"\" Clean a configuration file of unwanted lines Args: config: configuration string to \"clean\" Returns: str: cleaned configuration string Raises: N/A \"\"\" self.logger.debug(\"cleaning config file\") config = re.sub(pattern=CHECKPOINT_LINE, string=config, repl=\"\") config = re.sub(pattern=OUTPUT_HEADER_PATTERN, string=config, repl=\"\") return strip_blank_lines(config=config) def _pre_get_checkpoint( self, conn: Union[AsyncNetworkDriver, NetworkDriver] ) -> Tuple[ScrapliCfgResponse, List[str]]: \"\"\" Handle pre \"get_checkpoint\" operations for parity between sync and async Args: conn: connection from the sync or async platform; passed in explicitly to maintain typing sanity Returns: list: list of commands needed to generate checkpoint and show it Raises: N/A \"\"\" self.logger.info(\"get_checkpoint requested\") tmp_timestamp = round(datetime.now().timestamp()) checkpoint_commands = [ \"terminal dont-ask\", f\"checkpoint file {self.filesystem}scrapli_cfg_tmp_{tmp_timestamp}\", f\"show file {self.filesystem}scrapli_cfg_tmp_{tmp_timestamp}\", f\"delete {self.filesystem}scrapli_cfg_tmp_{tmp_timestamp}\", ] response = ScrapliCfgResponse(host=conn.host, raise_for_status_exception=GetConfigError) return response, checkpoint_commands","title":"ScrapliCfgNXOSBase"},{"location":"api_docs/platform/core/cisco_nxos/base_platform/#descendants","text":"scrapli_cfg.platform.core.cisco_nxos.async_platform.AsyncScrapliCfgNXOS scrapli_cfg.platform.core.cisco_nxos.sync_platform.ScrapliCfgNXOS","title":"Descendants"},{"location":"api_docs/platform/core/cisco_nxos/base_platform/#class-variables","text":"candidate_config: str candidate_config_filename: str filesystem: str logger: logging.LoggerAdapter","title":"Class variables"},{"location":"api_docs/platform/core/cisco_nxos/base_platform/#methods","text":"","title":"Methods"},{"location":"api_docs/platform/core/cisco_nxos/base_platform/#clean_config","text":"clean_config(self, config: str) \u2011> str 1 2 3 4 5 6 7 8 9 10 Clean a configuration file of unwanted lines Args: config: configuration string to \"clean\" Returns: str: cleaned configuration string Raises: N/A","title":"clean_config"},{"location":"api_docs/platform/core/cisco_nxos/patterns/","text":"window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting()) Module scrapli_cfg.platform.core.cisco_nxos.patterns \u00b6 scrapli_cfg.platforms.cisco_nxos.patterns Expand source code \"\"\"scrapli_cfg.platforms.cisco_nxos.patterns\"\"\" import re VERSION_PATTERN = re.compile(pattern=r\"\\d+\\.[a-z0-9\\(\\)\\.]+\", flags=re.I) BYTES_FREE = re.compile(pattern=r\"(?P \\d+)(?: bytes free)\", flags=re.I) BUILD_CONFIG_PATTERN = re.compile(r\"(^!command:.*$)\", flags=re.I | re.M) CONFIG_VERSION_PATTERN = re.compile(r\"(^!running configuration last done.*$)\", flags=re.I | re.M) CONFIG_CHANGE_PATTERN = re.compile(r\"(^!time.*$)\", flags=re.I | re.M) OUTPUT_HEADER_PATTERN = re.compile( pattern=rf\"{BUILD_CONFIG_PATTERN.pattern}|\" rf\"{CONFIG_VERSION_PATTERN.pattern}|\" rf\"{CONFIG_CHANGE_PATTERN.pattern}\", flags=re.I | re.M, ) CHECKPOINT_LINE = re.compile(pattern=r\"^\\s*!#.*$\", flags=re.M)","title":"Patterns"},{"location":"api_docs/platform/core/cisco_nxos/patterns/#module-scrapli_cfgplatformcorecisco_nxospatterns","text":"scrapli_cfg.platforms.cisco_nxos.patterns Expand source code \"\"\"scrapli_cfg.platforms.cisco_nxos.patterns\"\"\" import re VERSION_PATTERN = re.compile(pattern=r\"\\d+\\.[a-z0-9\\(\\)\\.]+\", flags=re.I) BYTES_FREE = re.compile(pattern=r\"(?P \\d+)(?: bytes free)\", flags=re.I) BUILD_CONFIG_PATTERN = re.compile(r\"(^!command:.*$)\", flags=re.I | re.M) CONFIG_VERSION_PATTERN = re.compile(r\"(^!running configuration last done.*$)\", flags=re.I | re.M) CONFIG_CHANGE_PATTERN = re.compile(r\"(^!time.*$)\", flags=re.I | re.M) OUTPUT_HEADER_PATTERN = re.compile( pattern=rf\"{BUILD_CONFIG_PATTERN.pattern}|\" rf\"{CONFIG_VERSION_PATTERN.pattern}|\" rf\"{CONFIG_CHANGE_PATTERN.pattern}\", flags=re.I | re.M, ) CHECKPOINT_LINE = re.compile(pattern=r\"^\\s*!#.*$\", flags=re.M)","title":"Module scrapli_cfg.platform.core.cisco_nxos.patterns"},{"location":"api_docs/platform/core/cisco_nxos/sync_platform/","text":"window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting()) Module scrapli_cfg.platform.core.cisco_nxos.sync_platform \u00b6 scrapli_cfg.platform.core.cisco_nxos.sync_platform Expand source code \"\"\"scrapli_cfg.platform.core.cisco_nxos.sync_platform\"\"\" from typing import Any, Callable, List, Optional, Union from scrapli.driver.core import NXOSDriver from scrapli.response import MultiResponse, Response from scrapli_cfg.diff import ScrapliCfgDiffResponse from scrapli_cfg.exceptions import DiffConfigError, FailedToDetermineDeviceState from scrapli_cfg.platform.base.sync_platform import ScrapliCfgPlatform from scrapli_cfg.platform.core.cisco_nxos.base_platform import CONFIG_SOURCES, ScrapliCfgNXOSBase from scrapli_cfg.response import ScrapliCfgResponse class ScrapliCfgNXOS(ScrapliCfgNXOSBase, ScrapliCfgPlatform): def __init__( self, conn: NXOSDriver, *, config_sources: Optional[List[str]] = None, on_prepare: Optional[Callable[..., Any]] = None, filesystem: str = \"bootflash:\", cleanup_post_commit: bool = True, dedicated_connection: bool = False, ignore_version: bool = False, ) -> None: if config_sources is None: config_sources = CONFIG_SOURCES super().__init__( conn=conn, config_sources=config_sources, on_prepare=on_prepare, dedicated_connection=dedicated_connection, ignore_version=ignore_version, ) self.filesystem = filesystem self._filesystem_space_available_buffer_perc = 10 self._replace = False self.candidate_config_filename = \"\" self.cleanup_post_commit = cleanup_post_commit def _get_filesystem_space_available(self) -> int: \"\"\" Get available space on filesystem Args: N/A Returns: None Raises: FailedToDetermineDeviceState: if unable to fetch file filesystem bytes available \"\"\" filesystem_size_result = self.conn.send_command( command=f\"dir {self.filesystem} | i 'bytes free'\" ) if filesystem_size_result.failed: raise FailedToDetermineDeviceState(\"failed to determine space available on filesystem\") return self._post_get_filesystem_space_available(output=filesystem_size_result.result) def _delete_candidate_config(self) -> MultiResponse: \"\"\" Delete candidate config from the filesystem Args: N/A Returns: MultiResponse: response from deleting the candidate config Raises: N/A \"\"\" delete_commands = [ \"terminal dont-ask\", f\"delete {self.filesystem}{self.candidate_config_filename}\", ] delete_result = self.conn.send_commands(commands=delete_commands) return delete_result def get_checkpoint(self) -> ScrapliCfgResponse: \"\"\" Get device checkpoint file Args: N/A Returns: ScrapliCfgResponse: response object containing string of the target config source as the `result` attribute Raises: N/A \"\"\" response, checkpoint_commands = self._pre_get_checkpoint(conn=self.conn) checkpoint_results = self.conn.send_commands(commands=checkpoint_commands) try: checkpoint: str = checkpoint_results[2].result except IndexError: checkpoint = \"\" return self._post_get_config( response=response, source=\"running\", scrapli_responses=[checkpoint_results], result=checkpoint, ) def get_version(self) -> ScrapliCfgResponse: response = self._pre_get_version() version_result = self.conn.send_command(command='show version | i \"NXOS: version\"') return self._post_get_version( response=response, scrapli_responses=[version_result], result=self._parse_version(device_output=version_result.result), ) def get_config(self, source: str = \"running\") -> ScrapliCfgResponse: response = self._pre_get_config(source=source) config_result = self.conn.send_command(command=self._get_config_command(source=source)) return self._post_get_config( response=response, source=source, scrapli_responses=[config_result], result=config_result.result, ) def load_config(self, config: str, replace: bool = False, **kwargs: Any) -> ScrapliCfgResponse: \"\"\" Load configuration to a device Supported kwargs: N/A Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for nxos supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" response = self._pre_load_config(config=config) config = self._prepare_load_config(config=config, replace=replace) filesystem_bytes_available = self._get_filesystem_space_available() self._space_available(filesystem_bytes_available=filesystem_bytes_available) self.conn.acquire_priv(desired_priv=\"tclsh\") config_result = self.conn.send_config(config=config, privilege_level=\"tclsh\") self.conn.acquire_priv(desired_priv=self.conn.default_desired_privilege_level) return self._post_load_config( response=response, scrapli_responses=[config_result], ) def abort_config(self) -> ScrapliCfgResponse: response = self._pre_abort_config( session_or_config_file=bool(self.candidate_config_filename) ) abort_result = self._delete_candidate_config() self._reset_config_session() return self._post_abort_config(response=response, scrapli_responses=[abort_result]) def commit_config(self, source: str = \"running\") -> ScrapliCfgResponse: scrapli_responses: List[Union[MultiResponse, Response]] = [] response = self._pre_commit_config( source=source, session_or_config_file=bool(self.candidate_config_filename) ) if self._replace is True: replace_command = ( f\"rollback running-config file {self.filesystem}{self.candidate_config_filename}\" ) commit_result = self.conn.send_command(command=replace_command) else: merge_command = f\"copy {self.filesystem}{self.candidate_config_filename} running-config\" commit_result = self.conn.send_command(command=merge_command) scrapli_responses.append(commit_result) save_config_result = self.conn.send_command(command=\"copy running-config startup-config\") scrapli_responses.append(save_config_result) if self.cleanup_post_commit: cleanup_result = self._delete_candidate_config() scrapli_responses.append(cleanup_result) self._reset_config_session() return self._post_commit_config( response=response, scrapli_responses=scrapli_responses, ) def diff_config(self, source: str = \"running\") -> ScrapliCfgDiffResponse: scrapli_responses = [] device_diff = \"\" source_config = \"\" diff_response = self._pre_diff_config( source=source, session_or_config_file=bool(self.candidate_config_filename) ) try: diff_command = self._get_diff_command(source=source) if diff_command: diff_result = self.conn.send_command(command=diff_command) scrapli_responses.append(diff_result) if diff_result.failed: msg = \"failed generating diff for config session\" self.logger.critical(msg) raise DiffConfigError(msg) device_diff = diff_result.result else: device_diff = \"\" source_config_result = self.get_config(source=source) source_config = source_config_result.result if isinstance(source_config_result.scrapli_responses, MultiResponse): # in this case this will always be a multiresponse or nothing (failure) but mypy # doesnt know that, hence the isinstance check scrapli_responses.extend(source_config_result.scrapli_responses) if source_config_result.failed: msg = \"failed fetching source config for diff comparison\" self.logger.critical(msg) raise DiffConfigError(msg) except DiffConfigError: pass return self._post_diff_config( diff_response=diff_response, scrapli_responses=scrapli_responses, source_config=self.clean_config(source_config), candidate_config=self.clean_config(self.candidate_config), device_diff=device_diff, ) Classes \u00b6 ScrapliCfgNXOS \u00b6 1 2 Helper class that provides a standard way to create an ABC using inheritance. Expand source code class ScrapliCfgNXOS(ScrapliCfgNXOSBase, ScrapliCfgPlatform): def __init__( self, conn: NXOSDriver, *, config_sources: Optional[List[str]] = None, on_prepare: Optional[Callable[..., Any]] = None, filesystem: str = \"bootflash:\", cleanup_post_commit: bool = True, dedicated_connection: bool = False, ignore_version: bool = False, ) -> None: if config_sources is None: config_sources = CONFIG_SOURCES super().__init__( conn=conn, config_sources=config_sources, on_prepare=on_prepare, dedicated_connection=dedicated_connection, ignore_version=ignore_version, ) self.filesystem = filesystem self._filesystem_space_available_buffer_perc = 10 self._replace = False self.candidate_config_filename = \"\" self.cleanup_post_commit = cleanup_post_commit def _get_filesystem_space_available(self) -> int: \"\"\" Get available space on filesystem Args: N/A Returns: None Raises: FailedToDetermineDeviceState: if unable to fetch file filesystem bytes available \"\"\" filesystem_size_result = self.conn.send_command( command=f\"dir {self.filesystem} | i 'bytes free'\" ) if filesystem_size_result.failed: raise FailedToDetermineDeviceState(\"failed to determine space available on filesystem\") return self._post_get_filesystem_space_available(output=filesystem_size_result.result) def _delete_candidate_config(self) -> MultiResponse: \"\"\" Delete candidate config from the filesystem Args: N/A Returns: MultiResponse: response from deleting the candidate config Raises: N/A \"\"\" delete_commands = [ \"terminal dont-ask\", f\"delete {self.filesystem}{self.candidate_config_filename}\", ] delete_result = self.conn.send_commands(commands=delete_commands) return delete_result def get_checkpoint(self) -> ScrapliCfgResponse: \"\"\" Get device checkpoint file Args: N/A Returns: ScrapliCfgResponse: response object containing string of the target config source as the `result` attribute Raises: N/A \"\"\" response, checkpoint_commands = self._pre_get_checkpoint(conn=self.conn) checkpoint_results = self.conn.send_commands(commands=checkpoint_commands) try: checkpoint: str = checkpoint_results[2].result except IndexError: checkpoint = \"\" return self._post_get_config( response=response, source=\"running\", scrapli_responses=[checkpoint_results], result=checkpoint, ) def get_version(self) -> ScrapliCfgResponse: response = self._pre_get_version() version_result = self.conn.send_command(command='show version | i \"NXOS: version\"') return self._post_get_version( response=response, scrapli_responses=[version_result], result=self._parse_version(device_output=version_result.result), ) def get_config(self, source: str = \"running\") -> ScrapliCfgResponse: response = self._pre_get_config(source=source) config_result = self.conn.send_command(command=self._get_config_command(source=source)) return self._post_get_config( response=response, source=source, scrapli_responses=[config_result], result=config_result.result, ) def load_config(self, config: str, replace: bool = False, **kwargs: Any) -> ScrapliCfgResponse: \"\"\" Load configuration to a device Supported kwargs: N/A Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for nxos supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" response = self._pre_load_config(config=config) config = self._prepare_load_config(config=config, replace=replace) filesystem_bytes_available = self._get_filesystem_space_available() self._space_available(filesystem_bytes_available=filesystem_bytes_available) self.conn.acquire_priv(desired_priv=\"tclsh\") config_result = self.conn.send_config(config=config, privilege_level=\"tclsh\") self.conn.acquire_priv(desired_priv=self.conn.default_desired_privilege_level) return self._post_load_config( response=response, scrapli_responses=[config_result], ) def abort_config(self) -> ScrapliCfgResponse: response = self._pre_abort_config( session_or_config_file=bool(self.candidate_config_filename) ) abort_result = self._delete_candidate_config() self._reset_config_session() return self._post_abort_config(response=response, scrapli_responses=[abort_result]) def commit_config(self, source: str = \"running\") -> ScrapliCfgResponse: scrapli_responses: List[Union[MultiResponse, Response]] = [] response = self._pre_commit_config( source=source, session_or_config_file=bool(self.candidate_config_filename) ) if self._replace is True: replace_command = ( f\"rollback running-config file {self.filesystem}{self.candidate_config_filename}\" ) commit_result = self.conn.send_command(command=replace_command) else: merge_command = f\"copy {self.filesystem}{self.candidate_config_filename} running-config\" commit_result = self.conn.send_command(command=merge_command) scrapli_responses.append(commit_result) save_config_result = self.conn.send_command(command=\"copy running-config startup-config\") scrapli_responses.append(save_config_result) if self.cleanup_post_commit: cleanup_result = self._delete_candidate_config() scrapli_responses.append(cleanup_result) self._reset_config_session() return self._post_commit_config( response=response, scrapli_responses=scrapli_responses, ) def diff_config(self, source: str = \"running\") -> ScrapliCfgDiffResponse: scrapli_responses = [] device_diff = \"\" source_config = \"\" diff_response = self._pre_diff_config( source=source, session_or_config_file=bool(self.candidate_config_filename) ) try: diff_command = self._get_diff_command(source=source) if diff_command: diff_result = self.conn.send_command(command=diff_command) scrapli_responses.append(diff_result) if diff_result.failed: msg = \"failed generating diff for config session\" self.logger.critical(msg) raise DiffConfigError(msg) device_diff = diff_result.result else: device_diff = \"\" source_config_result = self.get_config(source=source) source_config = source_config_result.result if isinstance(source_config_result.scrapli_responses, MultiResponse): # in this case this will always be a multiresponse or nothing (failure) but mypy # doesnt know that, hence the isinstance check scrapli_responses.extend(source_config_result.scrapli_responses) if source_config_result.failed: msg = \"failed fetching source config for diff comparison\" self.logger.critical(msg) raise DiffConfigError(msg) except DiffConfigError: pass return self._post_diff_config( diff_response=diff_response, scrapli_responses=scrapli_responses, source_config=self.clean_config(source_config), candidate_config=self.clean_config(self.candidate_config), device_diff=device_diff, ) Ancestors (in MRO) \u00b6 scrapli_cfg.platform.core.cisco_nxos.base_platform.ScrapliCfgNXOSBase scrapli_cfg.platform.base.sync_platform.ScrapliCfgPlatform abc.ABC scrapli_cfg.platform.base.base_platform.ScrapliCfgBase Class variables \u00b6 candidate_config: str candidate_config_filename: str filesystem: str logger: logging.LoggerAdapter Methods \u00b6 get_checkpoint \u00b6 get_checkpoint(self) \u2011> scrapli_cfg.response.ScrapliCfgResponse 1 2 3 4 5 6 7 8 9 10 11 Get device checkpoint file Args: N/A Returns: ScrapliCfgResponse: response object containing string of the target config source as the `result` attribute Raises: N/A load_config \u00b6 load_config(self, config: str, replace: bool = False, **kwargs: Any) \u2011> scrapli_cfg.response.ScrapliCfgResponse 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 Load configuration to a device Supported kwargs: N/A Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for nxos supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A","title":"Sync Platform"},{"location":"api_docs/platform/core/cisco_nxos/sync_platform/#module-scrapli_cfgplatformcorecisco_nxossync_platform","text":"scrapli_cfg.platform.core.cisco_nxos.sync_platform Expand source code \"\"\"scrapli_cfg.platform.core.cisco_nxos.sync_platform\"\"\" from typing import Any, Callable, List, Optional, Union from scrapli.driver.core import NXOSDriver from scrapli.response import MultiResponse, Response from scrapli_cfg.diff import ScrapliCfgDiffResponse from scrapli_cfg.exceptions import DiffConfigError, FailedToDetermineDeviceState from scrapli_cfg.platform.base.sync_platform import ScrapliCfgPlatform from scrapli_cfg.platform.core.cisco_nxos.base_platform import CONFIG_SOURCES, ScrapliCfgNXOSBase from scrapli_cfg.response import ScrapliCfgResponse class ScrapliCfgNXOS(ScrapliCfgNXOSBase, ScrapliCfgPlatform): def __init__( self, conn: NXOSDriver, *, config_sources: Optional[List[str]] = None, on_prepare: Optional[Callable[..., Any]] = None, filesystem: str = \"bootflash:\", cleanup_post_commit: bool = True, dedicated_connection: bool = False, ignore_version: bool = False, ) -> None: if config_sources is None: config_sources = CONFIG_SOURCES super().__init__( conn=conn, config_sources=config_sources, on_prepare=on_prepare, dedicated_connection=dedicated_connection, ignore_version=ignore_version, ) self.filesystem = filesystem self._filesystem_space_available_buffer_perc = 10 self._replace = False self.candidate_config_filename = \"\" self.cleanup_post_commit = cleanup_post_commit def _get_filesystem_space_available(self) -> int: \"\"\" Get available space on filesystem Args: N/A Returns: None Raises: FailedToDetermineDeviceState: if unable to fetch file filesystem bytes available \"\"\" filesystem_size_result = self.conn.send_command( command=f\"dir {self.filesystem} | i 'bytes free'\" ) if filesystem_size_result.failed: raise FailedToDetermineDeviceState(\"failed to determine space available on filesystem\") return self._post_get_filesystem_space_available(output=filesystem_size_result.result) def _delete_candidate_config(self) -> MultiResponse: \"\"\" Delete candidate config from the filesystem Args: N/A Returns: MultiResponse: response from deleting the candidate config Raises: N/A \"\"\" delete_commands = [ \"terminal dont-ask\", f\"delete {self.filesystem}{self.candidate_config_filename}\", ] delete_result = self.conn.send_commands(commands=delete_commands) return delete_result def get_checkpoint(self) -> ScrapliCfgResponse: \"\"\" Get device checkpoint file Args: N/A Returns: ScrapliCfgResponse: response object containing string of the target config source as the `result` attribute Raises: N/A \"\"\" response, checkpoint_commands = self._pre_get_checkpoint(conn=self.conn) checkpoint_results = self.conn.send_commands(commands=checkpoint_commands) try: checkpoint: str = checkpoint_results[2].result except IndexError: checkpoint = \"\" return self._post_get_config( response=response, source=\"running\", scrapli_responses=[checkpoint_results], result=checkpoint, ) def get_version(self) -> ScrapliCfgResponse: response = self._pre_get_version() version_result = self.conn.send_command(command='show version | i \"NXOS: version\"') return self._post_get_version( response=response, scrapli_responses=[version_result], result=self._parse_version(device_output=version_result.result), ) def get_config(self, source: str = \"running\") -> ScrapliCfgResponse: response = self._pre_get_config(source=source) config_result = self.conn.send_command(command=self._get_config_command(source=source)) return self._post_get_config( response=response, source=source, scrapli_responses=[config_result], result=config_result.result, ) def load_config(self, config: str, replace: bool = False, **kwargs: Any) -> ScrapliCfgResponse: \"\"\" Load configuration to a device Supported kwargs: N/A Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for nxos supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" response = self._pre_load_config(config=config) config = self._prepare_load_config(config=config, replace=replace) filesystem_bytes_available = self._get_filesystem_space_available() self._space_available(filesystem_bytes_available=filesystem_bytes_available) self.conn.acquire_priv(desired_priv=\"tclsh\") config_result = self.conn.send_config(config=config, privilege_level=\"tclsh\") self.conn.acquire_priv(desired_priv=self.conn.default_desired_privilege_level) return self._post_load_config( response=response, scrapli_responses=[config_result], ) def abort_config(self) -> ScrapliCfgResponse: response = self._pre_abort_config( session_or_config_file=bool(self.candidate_config_filename) ) abort_result = self._delete_candidate_config() self._reset_config_session() return self._post_abort_config(response=response, scrapli_responses=[abort_result]) def commit_config(self, source: str = \"running\") -> ScrapliCfgResponse: scrapli_responses: List[Union[MultiResponse, Response]] = [] response = self._pre_commit_config( source=source, session_or_config_file=bool(self.candidate_config_filename) ) if self._replace is True: replace_command = ( f\"rollback running-config file {self.filesystem}{self.candidate_config_filename}\" ) commit_result = self.conn.send_command(command=replace_command) else: merge_command = f\"copy {self.filesystem}{self.candidate_config_filename} running-config\" commit_result = self.conn.send_command(command=merge_command) scrapli_responses.append(commit_result) save_config_result = self.conn.send_command(command=\"copy running-config startup-config\") scrapli_responses.append(save_config_result) if self.cleanup_post_commit: cleanup_result = self._delete_candidate_config() scrapli_responses.append(cleanup_result) self._reset_config_session() return self._post_commit_config( response=response, scrapli_responses=scrapli_responses, ) def diff_config(self, source: str = \"running\") -> ScrapliCfgDiffResponse: scrapli_responses = [] device_diff = \"\" source_config = \"\" diff_response = self._pre_diff_config( source=source, session_or_config_file=bool(self.candidate_config_filename) ) try: diff_command = self._get_diff_command(source=source) if diff_command: diff_result = self.conn.send_command(command=diff_command) scrapli_responses.append(diff_result) if diff_result.failed: msg = \"failed generating diff for config session\" self.logger.critical(msg) raise DiffConfigError(msg) device_diff = diff_result.result else: device_diff = \"\" source_config_result = self.get_config(source=source) source_config = source_config_result.result if isinstance(source_config_result.scrapli_responses, MultiResponse): # in this case this will always be a multiresponse or nothing (failure) but mypy # doesnt know that, hence the isinstance check scrapli_responses.extend(source_config_result.scrapli_responses) if source_config_result.failed: msg = \"failed fetching source config for diff comparison\" self.logger.critical(msg) raise DiffConfigError(msg) except DiffConfigError: pass return self._post_diff_config( diff_response=diff_response, scrapli_responses=scrapli_responses, source_config=self.clean_config(source_config), candidate_config=self.clean_config(self.candidate_config), device_diff=device_diff, )","title":"Module scrapli_cfg.platform.core.cisco_nxos.sync_platform"},{"location":"api_docs/platform/core/cisco_nxos/sync_platform/#classes","text":"","title":"Classes"},{"location":"api_docs/platform/core/cisco_nxos/sync_platform/#scraplicfgnxos","text":"1 2 Helper class that provides a standard way to create an ABC using inheritance. Expand source code class ScrapliCfgNXOS(ScrapliCfgNXOSBase, ScrapliCfgPlatform): def __init__( self, conn: NXOSDriver, *, config_sources: Optional[List[str]] = None, on_prepare: Optional[Callable[..., Any]] = None, filesystem: str = \"bootflash:\", cleanup_post_commit: bool = True, dedicated_connection: bool = False, ignore_version: bool = False, ) -> None: if config_sources is None: config_sources = CONFIG_SOURCES super().__init__( conn=conn, config_sources=config_sources, on_prepare=on_prepare, dedicated_connection=dedicated_connection, ignore_version=ignore_version, ) self.filesystem = filesystem self._filesystem_space_available_buffer_perc = 10 self._replace = False self.candidate_config_filename = \"\" self.cleanup_post_commit = cleanup_post_commit def _get_filesystem_space_available(self) -> int: \"\"\" Get available space on filesystem Args: N/A Returns: None Raises: FailedToDetermineDeviceState: if unable to fetch file filesystem bytes available \"\"\" filesystem_size_result = self.conn.send_command( command=f\"dir {self.filesystem} | i 'bytes free'\" ) if filesystem_size_result.failed: raise FailedToDetermineDeviceState(\"failed to determine space available on filesystem\") return self._post_get_filesystem_space_available(output=filesystem_size_result.result) def _delete_candidate_config(self) -> MultiResponse: \"\"\" Delete candidate config from the filesystem Args: N/A Returns: MultiResponse: response from deleting the candidate config Raises: N/A \"\"\" delete_commands = [ \"terminal dont-ask\", f\"delete {self.filesystem}{self.candidate_config_filename}\", ] delete_result = self.conn.send_commands(commands=delete_commands) return delete_result def get_checkpoint(self) -> ScrapliCfgResponse: \"\"\" Get device checkpoint file Args: N/A Returns: ScrapliCfgResponse: response object containing string of the target config source as the `result` attribute Raises: N/A \"\"\" response, checkpoint_commands = self._pre_get_checkpoint(conn=self.conn) checkpoint_results = self.conn.send_commands(commands=checkpoint_commands) try: checkpoint: str = checkpoint_results[2].result except IndexError: checkpoint = \"\" return self._post_get_config( response=response, source=\"running\", scrapli_responses=[checkpoint_results], result=checkpoint, ) def get_version(self) -> ScrapliCfgResponse: response = self._pre_get_version() version_result = self.conn.send_command(command='show version | i \"NXOS: version\"') return self._post_get_version( response=response, scrapli_responses=[version_result], result=self._parse_version(device_output=version_result.result), ) def get_config(self, source: str = \"running\") -> ScrapliCfgResponse: response = self._pre_get_config(source=source) config_result = self.conn.send_command(command=self._get_config_command(source=source)) return self._post_get_config( response=response, source=source, scrapli_responses=[config_result], result=config_result.result, ) def load_config(self, config: str, replace: bool = False, **kwargs: Any) -> ScrapliCfgResponse: \"\"\" Load configuration to a device Supported kwargs: N/A Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for nxos supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" response = self._pre_load_config(config=config) config = self._prepare_load_config(config=config, replace=replace) filesystem_bytes_available = self._get_filesystem_space_available() self._space_available(filesystem_bytes_available=filesystem_bytes_available) self.conn.acquire_priv(desired_priv=\"tclsh\") config_result = self.conn.send_config(config=config, privilege_level=\"tclsh\") self.conn.acquire_priv(desired_priv=self.conn.default_desired_privilege_level) return self._post_load_config( response=response, scrapli_responses=[config_result], ) def abort_config(self) -> ScrapliCfgResponse: response = self._pre_abort_config( session_or_config_file=bool(self.candidate_config_filename) ) abort_result = self._delete_candidate_config() self._reset_config_session() return self._post_abort_config(response=response, scrapli_responses=[abort_result]) def commit_config(self, source: str = \"running\") -> ScrapliCfgResponse: scrapli_responses: List[Union[MultiResponse, Response]] = [] response = self._pre_commit_config( source=source, session_or_config_file=bool(self.candidate_config_filename) ) if self._replace is True: replace_command = ( f\"rollback running-config file {self.filesystem}{self.candidate_config_filename}\" ) commit_result = self.conn.send_command(command=replace_command) else: merge_command = f\"copy {self.filesystem}{self.candidate_config_filename} running-config\" commit_result = self.conn.send_command(command=merge_command) scrapli_responses.append(commit_result) save_config_result = self.conn.send_command(command=\"copy running-config startup-config\") scrapli_responses.append(save_config_result) if self.cleanup_post_commit: cleanup_result = self._delete_candidate_config() scrapli_responses.append(cleanup_result) self._reset_config_session() return self._post_commit_config( response=response, scrapli_responses=scrapli_responses, ) def diff_config(self, source: str = \"running\") -> ScrapliCfgDiffResponse: scrapli_responses = [] device_diff = \"\" source_config = \"\" diff_response = self._pre_diff_config( source=source, session_or_config_file=bool(self.candidate_config_filename) ) try: diff_command = self._get_diff_command(source=source) if diff_command: diff_result = self.conn.send_command(command=diff_command) scrapli_responses.append(diff_result) if diff_result.failed: msg = \"failed generating diff for config session\" self.logger.critical(msg) raise DiffConfigError(msg) device_diff = diff_result.result else: device_diff = \"\" source_config_result = self.get_config(source=source) source_config = source_config_result.result if isinstance(source_config_result.scrapli_responses, MultiResponse): # in this case this will always be a multiresponse or nothing (failure) but mypy # doesnt know that, hence the isinstance check scrapli_responses.extend(source_config_result.scrapli_responses) if source_config_result.failed: msg = \"failed fetching source config for diff comparison\" self.logger.critical(msg) raise DiffConfigError(msg) except DiffConfigError: pass return self._post_diff_config( diff_response=diff_response, scrapli_responses=scrapli_responses, source_config=self.clean_config(source_config), candidate_config=self.clean_config(self.candidate_config), device_diff=device_diff, )","title":"ScrapliCfgNXOS"},{"location":"api_docs/platform/core/cisco_nxos/sync_platform/#ancestors-in-mro","text":"scrapli_cfg.platform.core.cisco_nxos.base_platform.ScrapliCfgNXOSBase scrapli_cfg.platform.base.sync_platform.ScrapliCfgPlatform abc.ABC scrapli_cfg.platform.base.base_platform.ScrapliCfgBase","title":"Ancestors (in MRO)"},{"location":"api_docs/platform/core/cisco_nxos/sync_platform/#class-variables","text":"candidate_config: str candidate_config_filename: str filesystem: str logger: logging.LoggerAdapter","title":"Class variables"},{"location":"api_docs/platform/core/cisco_nxos/sync_platform/#methods","text":"","title":"Methods"},{"location":"api_docs/platform/core/cisco_nxos/sync_platform/#get_checkpoint","text":"get_checkpoint(self) \u2011> scrapli_cfg.response.ScrapliCfgResponse 1 2 3 4 5 6 7 8 9 10 11 Get device checkpoint file Args: N/A Returns: ScrapliCfgResponse: response object containing string of the target config source as the `result` attribute Raises: N/A","title":"get_checkpoint"},{"location":"api_docs/platform/core/cisco_nxos/sync_platform/#load_config","text":"load_config(self, config: str, replace: bool = False, **kwargs: Any) \u2011> scrapli_cfg.response.ScrapliCfgResponse 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 Load configuration to a device Supported kwargs: N/A Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for nxos supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A","title":"load_config"},{"location":"api_docs/platform/core/juniper_junos/async_platform/","text":"window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting()) Module scrapli_cfg.platform.core.juniper_junos.async_platform \u00b6 scrapli_cfg.platform.core.juniper_junos.async_platform Expand source code \"\"\"scrapli_cfg.platform.core.juniper_junos.async_platform\"\"\" from typing import Any, Callable, List, Optional from scrapli.driver import AsyncNetworkDriver from scrapli.response import MultiResponse, Response from scrapli_cfg.diff import ScrapliCfgDiffResponse from scrapli_cfg.exceptions import DiffConfigError from scrapli_cfg.platform.base.async_platform import AsyncScrapliCfgPlatform from scrapli_cfg.platform.core.juniper_junos.base_platform import ( CONFIG_SOURCES, ScrapliCfgJunosBase, ) from scrapli_cfg.response import ScrapliCfgResponse class AsyncScrapliCfgJunos(AsyncScrapliCfgPlatform, ScrapliCfgJunosBase): def __init__( self, conn: AsyncNetworkDriver, *, config_sources: Optional[List[str]] = None, on_prepare: Optional[Callable[..., Any]] = None, filesystem: str = \"/config/\", cleanup_post_commit: bool = True, dedicated_connection: bool = False, ignore_version: bool = False, ) -> None: if config_sources is None: config_sources = CONFIG_SOURCES super().__init__( conn=conn, config_sources=config_sources, on_prepare=on_prepare, dedicated_connection=dedicated_connection, ignore_version=ignore_version, ) self.filesystem = filesystem self._replace = False self._set = False self.candidate_config_filename = \"\" self._in_configuration_session = False self.cleanup_post_commit = cleanup_post_commit async def _delete_candidate_config(self) -> Response: \"\"\" Delete candidate config from the filesystem Args: N/A Returns: Response: response from deleting the candidate config Raises: N/A \"\"\" delete_result = await self.conn.send_config( config=f\"rm {self.filesystem}{self.candidate_config_filename}\", privilege_level=\"root_shell\", ) return delete_result async def get_version(self) -> ScrapliCfgResponse: response = self._pre_get_version() version_result = await self.conn.send_command(command=\"show version | grep junos:\") return self._post_get_version( response=response, scrapli_responses=[version_result], result=self._parse_version(device_output=version_result.result), ) async def get_config(self, source: str = \"running\") -> ScrapliCfgResponse: response = self._pre_get_config(source=source) if self._in_configuration_session is True: config_result = await self.conn.send_config(config=\"run show configuration\") else: config_result = await self.conn.send_command(command=\"show configuration\") return self._post_get_config( response=response, source=source, scrapli_responses=[config_result], result=config_result.result, ) async def load_config( self, config: str, replace: bool = False, **kwargs: Any ) -> ScrapliCfgResponse: \"\"\" Load configuration to a device Supported kwargs: set: bool indicating config is a \"set\" style config (ignored if replace is True) Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for junos supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" self._set = kwargs.get(\"set\", False) response = self._pre_load_config(config=config) config = self._prepare_load_config(config=config, replace=replace) config_result = await self.conn.send_config(config=config, privilege_level=\"root_shell\") if self._replace is True: load_config = f\"load override {self.filesystem}{self.candidate_config_filename}\" else: if self._set is True: load_config = f\"load set {self.filesystem}{self.candidate_config_filename}\" else: load_config = f\"load merge {self.filesystem}{self.candidate_config_filename}\" load_result = await self.conn.send_config(config=load_config) self._in_configuration_session = True return self._post_load_config( response=response, scrapli_responses=[config_result, load_result], ) async def abort_config(self) -> ScrapliCfgResponse: response = self._pre_abort_config( session_or_config_file=bool(self.candidate_config_filename) ) rollback_result = await self.conn.send_config(config=\"rollback 0\") abort_result = await self._delete_candidate_config() self._reset_config_session() return self._post_abort_config( response=response, scrapli_responses=[rollback_result, abort_result] ) async def commit_config(self, source: str = \"running\") -> ScrapliCfgResponse: scrapli_responses = [] response = self._pre_commit_config( source=source, session_or_config_file=bool(self.candidate_config_filename) ) commit_result = await self.conn.send_config(config=\"commit\") scrapli_responses.append(commit_result) if self.cleanup_post_commit: cleanup_result = await self._delete_candidate_config() scrapli_responses.append(cleanup_result) self._reset_config_session() return self._post_load_config( response=response, scrapli_responses=scrapli_responses, ) async def diff_config(self, source: str = \"running\") -> ScrapliCfgDiffResponse: scrapli_responses = [] device_diff = \"\" source_config = \"\" diff_response = self._pre_diff_config( source=source, session_or_config_file=bool(self.candidate_config_filename) ) try: diff_result = await self.conn.send_config(config=\"show | compare\") scrapli_responses.append(diff_result) if diff_result.failed: msg = \"failed generating diff for config session\" self.logger.critical(msg) raise DiffConfigError(msg) device_diff = diff_result.result source_config_result = await self.get_config(source=source) source_config = source_config_result.result if isinstance(source_config_result.scrapli_responses, MultiResponse): # in this case this will always be a multiresponse or nothing (failure) but mypy # doesnt know that, hence the isinstance check scrapli_responses.extend(source_config_result.scrapli_responses) if source_config_result.failed: msg = \"failed fetching source config for diff comparison\" self.logger.critical(msg) raise DiffConfigError(msg) except DiffConfigError: pass return self._post_diff_config( diff_response=diff_response, scrapli_responses=scrapli_responses, source_config=self.clean_config(source_config), candidate_config=self.clean_config(self.candidate_config), device_diff=device_diff, ) Classes \u00b6 AsyncScrapliCfgJunos \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 Helper class that provides a standard way to create an ABC using inheritance. Scrapli Config async base class Args: conn: scrapli connection to use config_sources: list of config sources on_prepare: optional callable to run at connection `prepare` dedicated_connection: if `False` (default value) scrapli cfg will not open or close the underlying scrapli connection and will raise an exception if the scrapli connection is not open. If `True` will automatically open and close the scrapli connection when using with a context manager, `prepare` will open the scrapli connection (if not already open), and `close` will close the scrapli connection. ignore_version: ignore checking device version support; currently this just means that scrapli-cfg will not fetch the device version during the prepare phase, however this will (hopefully) be used in the future to limit what methods can be used against a target device. For example, for EOS devices we need > 4.14 to load configs; so if a device is encountered at 4.13 the version check would raise an exception rather than just failing in a potentially awkward fashion. Returns: None Raises: N/A Expand source code class AsyncScrapliCfgJunos(AsyncScrapliCfgPlatform, ScrapliCfgJunosBase): def __init__( self, conn: AsyncNetworkDriver, *, config_sources: Optional[List[str]] = None, on_prepare: Optional[Callable[..., Any]] = None, filesystem: str = \"/config/\", cleanup_post_commit: bool = True, dedicated_connection: bool = False, ignore_version: bool = False, ) -> None: if config_sources is None: config_sources = CONFIG_SOURCES super().__init__( conn=conn, config_sources=config_sources, on_prepare=on_prepare, dedicated_connection=dedicated_connection, ignore_version=ignore_version, ) self.filesystem = filesystem self._replace = False self._set = False self.candidate_config_filename = \"\" self._in_configuration_session = False self.cleanup_post_commit = cleanup_post_commit async def _delete_candidate_config(self) -> Response: \"\"\" Delete candidate config from the filesystem Args: N/A Returns: Response: response from deleting the candidate config Raises: N/A \"\"\" delete_result = await self.conn.send_config( config=f\"rm {self.filesystem}{self.candidate_config_filename}\", privilege_level=\"root_shell\", ) return delete_result async def get_version(self) -> ScrapliCfgResponse: response = self._pre_get_version() version_result = await self.conn.send_command(command=\"show version | grep junos:\") return self._post_get_version( response=response, scrapli_responses=[version_result], result=self._parse_version(device_output=version_result.result), ) async def get_config(self, source: str = \"running\") -> ScrapliCfgResponse: response = self._pre_get_config(source=source) if self._in_configuration_session is True: config_result = await self.conn.send_config(config=\"run show configuration\") else: config_result = await self.conn.send_command(command=\"show configuration\") return self._post_get_config( response=response, source=source, scrapli_responses=[config_result], result=config_result.result, ) async def load_config( self, config: str, replace: bool = False, **kwargs: Any ) -> ScrapliCfgResponse: \"\"\" Load configuration to a device Supported kwargs: set: bool indicating config is a \"set\" style config (ignored if replace is True) Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for junos supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" self._set = kwargs.get(\"set\", False) response = self._pre_load_config(config=config) config = self._prepare_load_config(config=config, replace=replace) config_result = await self.conn.send_config(config=config, privilege_level=\"root_shell\") if self._replace is True: load_config = f\"load override {self.filesystem}{self.candidate_config_filename}\" else: if self._set is True: load_config = f\"load set {self.filesystem}{self.candidate_config_filename}\" else: load_config = f\"load merge {self.filesystem}{self.candidate_config_filename}\" load_result = await self.conn.send_config(config=load_config) self._in_configuration_session = True return self._post_load_config( response=response, scrapli_responses=[config_result, load_result], ) async def abort_config(self) -> ScrapliCfgResponse: response = self._pre_abort_config( session_or_config_file=bool(self.candidate_config_filename) ) rollback_result = await self.conn.send_config(config=\"rollback 0\") abort_result = await self._delete_candidate_config() self._reset_config_session() return self._post_abort_config( response=response, scrapli_responses=[rollback_result, abort_result] ) async def commit_config(self, source: str = \"running\") -> ScrapliCfgResponse: scrapli_responses = [] response = self._pre_commit_config( source=source, session_or_config_file=bool(self.candidate_config_filename) ) commit_result = await self.conn.send_config(config=\"commit\") scrapli_responses.append(commit_result) if self.cleanup_post_commit: cleanup_result = await self._delete_candidate_config() scrapli_responses.append(cleanup_result) self._reset_config_session() return self._post_load_config( response=response, scrapli_responses=scrapli_responses, ) async def diff_config(self, source: str = \"running\") -> ScrapliCfgDiffResponse: scrapli_responses = [] device_diff = \"\" source_config = \"\" diff_response = self._pre_diff_config( source=source, session_or_config_file=bool(self.candidate_config_filename) ) try: diff_result = await self.conn.send_config(config=\"show | compare\") scrapli_responses.append(diff_result) if diff_result.failed: msg = \"failed generating diff for config session\" self.logger.critical(msg) raise DiffConfigError(msg) device_diff = diff_result.result source_config_result = await self.get_config(source=source) source_config = source_config_result.result if isinstance(source_config_result.scrapli_responses, MultiResponse): # in this case this will always be a multiresponse or nothing (failure) but mypy # doesnt know that, hence the isinstance check scrapli_responses.extend(source_config_result.scrapli_responses) if source_config_result.failed: msg = \"failed fetching source config for diff comparison\" self.logger.critical(msg) raise DiffConfigError(msg) except DiffConfigError: pass return self._post_diff_config( diff_response=diff_response, scrapli_responses=scrapli_responses, source_config=self.clean_config(source_config), candidate_config=self.clean_config(self.candidate_config), device_diff=device_diff, ) Ancestors (in MRO) \u00b6 scrapli_cfg.platform.base.async_platform.AsyncScrapliCfgPlatform abc.ABC scrapli_cfg.platform.base.base_platform.ScrapliCfgBase scrapli_cfg.platform.core.juniper_junos.base_platform.ScrapliCfgJunosBase Class variables \u00b6 conn: Union[scrapli.driver.network.sync_driver.NetworkDriver, scrapli.driver.network.async_driver.AsyncNetworkDriver] Methods \u00b6 load_config \u00b6 load_config(self, config: str, replace: bool = False, **kwargs: Any) \u2011> scrapli_cfg.response.ScrapliCfgResponse 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 Load configuration to a device Supported kwargs: set: bool indicating config is a \"set\" style config (ignored if replace is True) Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for junos supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A","title":"Async Platform"},{"location":"api_docs/platform/core/juniper_junos/async_platform/#module-scrapli_cfgplatformcorejuniper_junosasync_platform","text":"scrapli_cfg.platform.core.juniper_junos.async_platform Expand source code \"\"\"scrapli_cfg.platform.core.juniper_junos.async_platform\"\"\" from typing import Any, Callable, List, Optional from scrapli.driver import AsyncNetworkDriver from scrapli.response import MultiResponse, Response from scrapli_cfg.diff import ScrapliCfgDiffResponse from scrapli_cfg.exceptions import DiffConfigError from scrapli_cfg.platform.base.async_platform import AsyncScrapliCfgPlatform from scrapli_cfg.platform.core.juniper_junos.base_platform import ( CONFIG_SOURCES, ScrapliCfgJunosBase, ) from scrapli_cfg.response import ScrapliCfgResponse class AsyncScrapliCfgJunos(AsyncScrapliCfgPlatform, ScrapliCfgJunosBase): def __init__( self, conn: AsyncNetworkDriver, *, config_sources: Optional[List[str]] = None, on_prepare: Optional[Callable[..., Any]] = None, filesystem: str = \"/config/\", cleanup_post_commit: bool = True, dedicated_connection: bool = False, ignore_version: bool = False, ) -> None: if config_sources is None: config_sources = CONFIG_SOURCES super().__init__( conn=conn, config_sources=config_sources, on_prepare=on_prepare, dedicated_connection=dedicated_connection, ignore_version=ignore_version, ) self.filesystem = filesystem self._replace = False self._set = False self.candidate_config_filename = \"\" self._in_configuration_session = False self.cleanup_post_commit = cleanup_post_commit async def _delete_candidate_config(self) -> Response: \"\"\" Delete candidate config from the filesystem Args: N/A Returns: Response: response from deleting the candidate config Raises: N/A \"\"\" delete_result = await self.conn.send_config( config=f\"rm {self.filesystem}{self.candidate_config_filename}\", privilege_level=\"root_shell\", ) return delete_result async def get_version(self) -> ScrapliCfgResponse: response = self._pre_get_version() version_result = await self.conn.send_command(command=\"show version | grep junos:\") return self._post_get_version( response=response, scrapli_responses=[version_result], result=self._parse_version(device_output=version_result.result), ) async def get_config(self, source: str = \"running\") -> ScrapliCfgResponse: response = self._pre_get_config(source=source) if self._in_configuration_session is True: config_result = await self.conn.send_config(config=\"run show configuration\") else: config_result = await self.conn.send_command(command=\"show configuration\") return self._post_get_config( response=response, source=source, scrapli_responses=[config_result], result=config_result.result, ) async def load_config( self, config: str, replace: bool = False, **kwargs: Any ) -> ScrapliCfgResponse: \"\"\" Load configuration to a device Supported kwargs: set: bool indicating config is a \"set\" style config (ignored if replace is True) Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for junos supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" self._set = kwargs.get(\"set\", False) response = self._pre_load_config(config=config) config = self._prepare_load_config(config=config, replace=replace) config_result = await self.conn.send_config(config=config, privilege_level=\"root_shell\") if self._replace is True: load_config = f\"load override {self.filesystem}{self.candidate_config_filename}\" else: if self._set is True: load_config = f\"load set {self.filesystem}{self.candidate_config_filename}\" else: load_config = f\"load merge {self.filesystem}{self.candidate_config_filename}\" load_result = await self.conn.send_config(config=load_config) self._in_configuration_session = True return self._post_load_config( response=response, scrapli_responses=[config_result, load_result], ) async def abort_config(self) -> ScrapliCfgResponse: response = self._pre_abort_config( session_or_config_file=bool(self.candidate_config_filename) ) rollback_result = await self.conn.send_config(config=\"rollback 0\") abort_result = await self._delete_candidate_config() self._reset_config_session() return self._post_abort_config( response=response, scrapli_responses=[rollback_result, abort_result] ) async def commit_config(self, source: str = \"running\") -> ScrapliCfgResponse: scrapli_responses = [] response = self._pre_commit_config( source=source, session_or_config_file=bool(self.candidate_config_filename) ) commit_result = await self.conn.send_config(config=\"commit\") scrapli_responses.append(commit_result) if self.cleanup_post_commit: cleanup_result = await self._delete_candidate_config() scrapli_responses.append(cleanup_result) self._reset_config_session() return self._post_load_config( response=response, scrapli_responses=scrapli_responses, ) async def diff_config(self, source: str = \"running\") -> ScrapliCfgDiffResponse: scrapli_responses = [] device_diff = \"\" source_config = \"\" diff_response = self._pre_diff_config( source=source, session_or_config_file=bool(self.candidate_config_filename) ) try: diff_result = await self.conn.send_config(config=\"show | compare\") scrapli_responses.append(diff_result) if diff_result.failed: msg = \"failed generating diff for config session\" self.logger.critical(msg) raise DiffConfigError(msg) device_diff = diff_result.result source_config_result = await self.get_config(source=source) source_config = source_config_result.result if isinstance(source_config_result.scrapli_responses, MultiResponse): # in this case this will always be a multiresponse or nothing (failure) but mypy # doesnt know that, hence the isinstance check scrapli_responses.extend(source_config_result.scrapli_responses) if source_config_result.failed: msg = \"failed fetching source config for diff comparison\" self.logger.critical(msg) raise DiffConfigError(msg) except DiffConfigError: pass return self._post_diff_config( diff_response=diff_response, scrapli_responses=scrapli_responses, source_config=self.clean_config(source_config), candidate_config=self.clean_config(self.candidate_config), device_diff=device_diff, )","title":"Module scrapli_cfg.platform.core.juniper_junos.async_platform"},{"location":"api_docs/platform/core/juniper_junos/async_platform/#classes","text":"","title":"Classes"},{"location":"api_docs/platform/core/juniper_junos/async_platform/#asyncscraplicfgjunos","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 Helper class that provides a standard way to create an ABC using inheritance. Scrapli Config async base class Args: conn: scrapli connection to use config_sources: list of config sources on_prepare: optional callable to run at connection `prepare` dedicated_connection: if `False` (default value) scrapli cfg will not open or close the underlying scrapli connection and will raise an exception if the scrapli connection is not open. If `True` will automatically open and close the scrapli connection when using with a context manager, `prepare` will open the scrapli connection (if not already open), and `close` will close the scrapli connection. ignore_version: ignore checking device version support; currently this just means that scrapli-cfg will not fetch the device version during the prepare phase, however this will (hopefully) be used in the future to limit what methods can be used against a target device. For example, for EOS devices we need > 4.14 to load configs; so if a device is encountered at 4.13 the version check would raise an exception rather than just failing in a potentially awkward fashion. Returns: None Raises: N/A Expand source code class AsyncScrapliCfgJunos(AsyncScrapliCfgPlatform, ScrapliCfgJunosBase): def __init__( self, conn: AsyncNetworkDriver, *, config_sources: Optional[List[str]] = None, on_prepare: Optional[Callable[..., Any]] = None, filesystem: str = \"/config/\", cleanup_post_commit: bool = True, dedicated_connection: bool = False, ignore_version: bool = False, ) -> None: if config_sources is None: config_sources = CONFIG_SOURCES super().__init__( conn=conn, config_sources=config_sources, on_prepare=on_prepare, dedicated_connection=dedicated_connection, ignore_version=ignore_version, ) self.filesystem = filesystem self._replace = False self._set = False self.candidate_config_filename = \"\" self._in_configuration_session = False self.cleanup_post_commit = cleanup_post_commit async def _delete_candidate_config(self) -> Response: \"\"\" Delete candidate config from the filesystem Args: N/A Returns: Response: response from deleting the candidate config Raises: N/A \"\"\" delete_result = await self.conn.send_config( config=f\"rm {self.filesystem}{self.candidate_config_filename}\", privilege_level=\"root_shell\", ) return delete_result async def get_version(self) -> ScrapliCfgResponse: response = self._pre_get_version() version_result = await self.conn.send_command(command=\"show version | grep junos:\") return self._post_get_version( response=response, scrapli_responses=[version_result], result=self._parse_version(device_output=version_result.result), ) async def get_config(self, source: str = \"running\") -> ScrapliCfgResponse: response = self._pre_get_config(source=source) if self._in_configuration_session is True: config_result = await self.conn.send_config(config=\"run show configuration\") else: config_result = await self.conn.send_command(command=\"show configuration\") return self._post_get_config( response=response, source=source, scrapli_responses=[config_result], result=config_result.result, ) async def load_config( self, config: str, replace: bool = False, **kwargs: Any ) -> ScrapliCfgResponse: \"\"\" Load configuration to a device Supported kwargs: set: bool indicating config is a \"set\" style config (ignored if replace is True) Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for junos supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" self._set = kwargs.get(\"set\", False) response = self._pre_load_config(config=config) config = self._prepare_load_config(config=config, replace=replace) config_result = await self.conn.send_config(config=config, privilege_level=\"root_shell\") if self._replace is True: load_config = f\"load override {self.filesystem}{self.candidate_config_filename}\" else: if self._set is True: load_config = f\"load set {self.filesystem}{self.candidate_config_filename}\" else: load_config = f\"load merge {self.filesystem}{self.candidate_config_filename}\" load_result = await self.conn.send_config(config=load_config) self._in_configuration_session = True return self._post_load_config( response=response, scrapli_responses=[config_result, load_result], ) async def abort_config(self) -> ScrapliCfgResponse: response = self._pre_abort_config( session_or_config_file=bool(self.candidate_config_filename) ) rollback_result = await self.conn.send_config(config=\"rollback 0\") abort_result = await self._delete_candidate_config() self._reset_config_session() return self._post_abort_config( response=response, scrapli_responses=[rollback_result, abort_result] ) async def commit_config(self, source: str = \"running\") -> ScrapliCfgResponse: scrapli_responses = [] response = self._pre_commit_config( source=source, session_or_config_file=bool(self.candidate_config_filename) ) commit_result = await self.conn.send_config(config=\"commit\") scrapli_responses.append(commit_result) if self.cleanup_post_commit: cleanup_result = await self._delete_candidate_config() scrapli_responses.append(cleanup_result) self._reset_config_session() return self._post_load_config( response=response, scrapli_responses=scrapli_responses, ) async def diff_config(self, source: str = \"running\") -> ScrapliCfgDiffResponse: scrapli_responses = [] device_diff = \"\" source_config = \"\" diff_response = self._pre_diff_config( source=source, session_or_config_file=bool(self.candidate_config_filename) ) try: diff_result = await self.conn.send_config(config=\"show | compare\") scrapli_responses.append(diff_result) if diff_result.failed: msg = \"failed generating diff for config session\" self.logger.critical(msg) raise DiffConfigError(msg) device_diff = diff_result.result source_config_result = await self.get_config(source=source) source_config = source_config_result.result if isinstance(source_config_result.scrapli_responses, MultiResponse): # in this case this will always be a multiresponse or nothing (failure) but mypy # doesnt know that, hence the isinstance check scrapli_responses.extend(source_config_result.scrapli_responses) if source_config_result.failed: msg = \"failed fetching source config for diff comparison\" self.logger.critical(msg) raise DiffConfigError(msg) except DiffConfigError: pass return self._post_diff_config( diff_response=diff_response, scrapli_responses=scrapli_responses, source_config=self.clean_config(source_config), candidate_config=self.clean_config(self.candidate_config), device_diff=device_diff, )","title":"AsyncScrapliCfgJunos"},{"location":"api_docs/platform/core/juniper_junos/async_platform/#ancestors-in-mro","text":"scrapli_cfg.platform.base.async_platform.AsyncScrapliCfgPlatform abc.ABC scrapli_cfg.platform.base.base_platform.ScrapliCfgBase scrapli_cfg.platform.core.juniper_junos.base_platform.ScrapliCfgJunosBase","title":"Ancestors (in MRO)"},{"location":"api_docs/platform/core/juniper_junos/async_platform/#class-variables","text":"conn: Union[scrapli.driver.network.sync_driver.NetworkDriver, scrapli.driver.network.async_driver.AsyncNetworkDriver]","title":"Class variables"},{"location":"api_docs/platform/core/juniper_junos/async_platform/#methods","text":"","title":"Methods"},{"location":"api_docs/platform/core/juniper_junos/async_platform/#load_config","text":"load_config(self, config: str, replace: bool = False, **kwargs: Any) \u2011> scrapli_cfg.response.ScrapliCfgResponse 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 Load configuration to a device Supported kwargs: set: bool indicating config is a \"set\" style config (ignored if replace is True) Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for junos supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A","title":"load_config"},{"location":"api_docs/platform/core/juniper_junos/base_platform/","text":"window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting()) Module scrapli_cfg.platform.core.juniper_junos.base_platform \u00b6 scrapli_cfg.platform.core.juniper_junos.base_platform Expand source code \"\"\"scrapli_cfg.platform.core.juniper_junos.base_platform\"\"\" import re from datetime import datetime from logging import Logger, LoggerAdapter from typing import TYPE_CHECKING from scrapli_cfg.helper import strip_blank_lines from scrapli_cfg.platform.core.juniper_junos.patterns import ( EDIT_PATTERN, OUTPUT_HEADER_PATTERN, VERSION_PATTERN, ) if TYPE_CHECKING: LoggerAdapterT = LoggerAdapter[Logger] # pylint:disable=E1136 else: LoggerAdapterT = LoggerAdapter CONFIG_SOURCES = [ \"running\", ] class ScrapliCfgJunosBase: logger: LoggerAdapterT candidate_config: str candidate_config_filename: str _in_configuration_session: bool _replace: bool _set: bool filesystem: str @staticmethod def _parse_version(device_output: str) -> str: \"\"\" Parse version string out of device output Args: device_output: output from show version command Returns: str: device version string Raises: N/A \"\"\" version_string_search = re.search(pattern=VERSION_PATTERN, string=device_output) if not version_string_search: return \"\" version_string = version_string_search.group(0) or \"\" return version_string def _reset_config_session(self) -> None: \"\"\" Reset config session info Resets the candidate config and config session name attributes -- when these are \"empty\" we know there is no current config session Args: N/A Returns: None Raises: N/A \"\"\" self.logger.debug(\"resetting candidate config and candidate config file name\") self.candidate_config = \"\" self.candidate_config_filename = \"\" self._in_configuration_session = False self._set = False def _prepare_config_payloads(self, config: str) -> str: \"\"\" Prepare a configuration so it can be nicely sent to the device via scrapli Args: config: configuration to prep Returns: str: string of config lines to write to candidate config file Raises: N/A \"\"\" final_config_list = [] for config_line in config.splitlines(): final_config_list.append( f\"echo >> {self.filesystem}{self.candidate_config_filename} '{config_line}'\" ) final_config = \"\\n\".join(final_config_list) return final_config def _prepare_load_config(self, config: str, replace: bool) -> str: \"\"\" Handle pre \"load_config\" operations for parity between sync and async Args: config: candidate config to load replace: True/False replace the configuration; passed here so it can be set at the class level as we need to stay in config mode and we need to know if we are doing a merge or a replace when we go to diff things Returns: str: string of config to write to candidate config file Raises: N/A \"\"\" self.candidate_config = config if not self.candidate_config_filename: self.candidate_config_filename = f\"scrapli_cfg_{round(datetime.now().timestamp())}\" self.logger.debug( f\"candidate config file name will be '{self.candidate_config_filename}'\" ) config = self._prepare_config_payloads(config=config) self._replace = replace return config def clean_config(self, config: str) -> str: \"\"\" Clean a configuration file of unwanted lines Args: config: configuration string to \"clean\" Returns: str: cleaned configuration string Raises: N/A \"\"\" self.logger.debug(\"cleaning config file\") config = re.sub(pattern=OUTPUT_HEADER_PATTERN, string=config, repl=\"\") config = re.sub(pattern=EDIT_PATTERN, string=config, repl=\"\") return strip_blank_lines(config=config) Classes \u00b6 ScrapliCfgJunosBase \u00b6 Expand source code class ScrapliCfgJunosBase: logger: LoggerAdapterT candidate_config: str candidate_config_filename: str _in_configuration_session: bool _replace: bool _set: bool filesystem: str @staticmethod def _parse_version(device_output: str) -> str: \"\"\" Parse version string out of device output Args: device_output: output from show version command Returns: str: device version string Raises: N/A \"\"\" version_string_search = re.search(pattern=VERSION_PATTERN, string=device_output) if not version_string_search: return \"\" version_string = version_string_search.group(0) or \"\" return version_string def _reset_config_session(self) -> None: \"\"\" Reset config session info Resets the candidate config and config session name attributes -- when these are \"empty\" we know there is no current config session Args: N/A Returns: None Raises: N/A \"\"\" self.logger.debug(\"resetting candidate config and candidate config file name\") self.candidate_config = \"\" self.candidate_config_filename = \"\" self._in_configuration_session = False self._set = False def _prepare_config_payloads(self, config: str) -> str: \"\"\" Prepare a configuration so it can be nicely sent to the device via scrapli Args: config: configuration to prep Returns: str: string of config lines to write to candidate config file Raises: N/A \"\"\" final_config_list = [] for config_line in config.splitlines(): final_config_list.append( f\"echo >> {self.filesystem}{self.candidate_config_filename} '{config_line}'\" ) final_config = \"\\n\".join(final_config_list) return final_config def _prepare_load_config(self, config: str, replace: bool) -> str: \"\"\" Handle pre \"load_config\" operations for parity between sync and async Args: config: candidate config to load replace: True/False replace the configuration; passed here so it can be set at the class level as we need to stay in config mode and we need to know if we are doing a merge or a replace when we go to diff things Returns: str: string of config to write to candidate config file Raises: N/A \"\"\" self.candidate_config = config if not self.candidate_config_filename: self.candidate_config_filename = f\"scrapli_cfg_{round(datetime.now().timestamp())}\" self.logger.debug( f\"candidate config file name will be '{self.candidate_config_filename}'\" ) config = self._prepare_config_payloads(config=config) self._replace = replace return config def clean_config(self, config: str) -> str: \"\"\" Clean a configuration file of unwanted lines Args: config: configuration string to \"clean\" Returns: str: cleaned configuration string Raises: N/A \"\"\" self.logger.debug(\"cleaning config file\") config = re.sub(pattern=OUTPUT_HEADER_PATTERN, string=config, repl=\"\") config = re.sub(pattern=EDIT_PATTERN, string=config, repl=\"\") return strip_blank_lines(config=config) Descendants \u00b6 scrapli_cfg.platform.core.juniper_junos.async_platform.AsyncScrapliCfgJunos scrapli_cfg.platform.core.juniper_junos.sync_platform.ScrapliCfgJunos Class variables \u00b6 candidate_config: str candidate_config_filename: str filesystem: str logger: logging.LoggerAdapter Methods \u00b6 clean_config \u00b6 clean_config(self, config: str) \u2011> str 1 2 3 4 5 6 7 8 9 10 Clean a configuration file of unwanted lines Args: config: configuration string to \"clean\" Returns: str: cleaned configuration string Raises: N/A","title":"Base platform"},{"location":"api_docs/platform/core/juniper_junos/base_platform/#module-scrapli_cfgplatformcorejuniper_junosbase_platform","text":"scrapli_cfg.platform.core.juniper_junos.base_platform Expand source code \"\"\"scrapli_cfg.platform.core.juniper_junos.base_platform\"\"\" import re from datetime import datetime from logging import Logger, LoggerAdapter from typing import TYPE_CHECKING from scrapli_cfg.helper import strip_blank_lines from scrapli_cfg.platform.core.juniper_junos.patterns import ( EDIT_PATTERN, OUTPUT_HEADER_PATTERN, VERSION_PATTERN, ) if TYPE_CHECKING: LoggerAdapterT = LoggerAdapter[Logger] # pylint:disable=E1136 else: LoggerAdapterT = LoggerAdapter CONFIG_SOURCES = [ \"running\", ] class ScrapliCfgJunosBase: logger: LoggerAdapterT candidate_config: str candidate_config_filename: str _in_configuration_session: bool _replace: bool _set: bool filesystem: str @staticmethod def _parse_version(device_output: str) -> str: \"\"\" Parse version string out of device output Args: device_output: output from show version command Returns: str: device version string Raises: N/A \"\"\" version_string_search = re.search(pattern=VERSION_PATTERN, string=device_output) if not version_string_search: return \"\" version_string = version_string_search.group(0) or \"\" return version_string def _reset_config_session(self) -> None: \"\"\" Reset config session info Resets the candidate config and config session name attributes -- when these are \"empty\" we know there is no current config session Args: N/A Returns: None Raises: N/A \"\"\" self.logger.debug(\"resetting candidate config and candidate config file name\") self.candidate_config = \"\" self.candidate_config_filename = \"\" self._in_configuration_session = False self._set = False def _prepare_config_payloads(self, config: str) -> str: \"\"\" Prepare a configuration so it can be nicely sent to the device via scrapli Args: config: configuration to prep Returns: str: string of config lines to write to candidate config file Raises: N/A \"\"\" final_config_list = [] for config_line in config.splitlines(): final_config_list.append( f\"echo >> {self.filesystem}{self.candidate_config_filename} '{config_line}'\" ) final_config = \"\\n\".join(final_config_list) return final_config def _prepare_load_config(self, config: str, replace: bool) -> str: \"\"\" Handle pre \"load_config\" operations for parity between sync and async Args: config: candidate config to load replace: True/False replace the configuration; passed here so it can be set at the class level as we need to stay in config mode and we need to know if we are doing a merge or a replace when we go to diff things Returns: str: string of config to write to candidate config file Raises: N/A \"\"\" self.candidate_config = config if not self.candidate_config_filename: self.candidate_config_filename = f\"scrapli_cfg_{round(datetime.now().timestamp())}\" self.logger.debug( f\"candidate config file name will be '{self.candidate_config_filename}'\" ) config = self._prepare_config_payloads(config=config) self._replace = replace return config def clean_config(self, config: str) -> str: \"\"\" Clean a configuration file of unwanted lines Args: config: configuration string to \"clean\" Returns: str: cleaned configuration string Raises: N/A \"\"\" self.logger.debug(\"cleaning config file\") config = re.sub(pattern=OUTPUT_HEADER_PATTERN, string=config, repl=\"\") config = re.sub(pattern=EDIT_PATTERN, string=config, repl=\"\") return strip_blank_lines(config=config)","title":"Module scrapli_cfg.platform.core.juniper_junos.base_platform"},{"location":"api_docs/platform/core/juniper_junos/base_platform/#classes","text":"","title":"Classes"},{"location":"api_docs/platform/core/juniper_junos/base_platform/#scraplicfgjunosbase","text":"Expand source code class ScrapliCfgJunosBase: logger: LoggerAdapterT candidate_config: str candidate_config_filename: str _in_configuration_session: bool _replace: bool _set: bool filesystem: str @staticmethod def _parse_version(device_output: str) -> str: \"\"\" Parse version string out of device output Args: device_output: output from show version command Returns: str: device version string Raises: N/A \"\"\" version_string_search = re.search(pattern=VERSION_PATTERN, string=device_output) if not version_string_search: return \"\" version_string = version_string_search.group(0) or \"\" return version_string def _reset_config_session(self) -> None: \"\"\" Reset config session info Resets the candidate config and config session name attributes -- when these are \"empty\" we know there is no current config session Args: N/A Returns: None Raises: N/A \"\"\" self.logger.debug(\"resetting candidate config and candidate config file name\") self.candidate_config = \"\" self.candidate_config_filename = \"\" self._in_configuration_session = False self._set = False def _prepare_config_payloads(self, config: str) -> str: \"\"\" Prepare a configuration so it can be nicely sent to the device via scrapli Args: config: configuration to prep Returns: str: string of config lines to write to candidate config file Raises: N/A \"\"\" final_config_list = [] for config_line in config.splitlines(): final_config_list.append( f\"echo >> {self.filesystem}{self.candidate_config_filename} '{config_line}'\" ) final_config = \"\\n\".join(final_config_list) return final_config def _prepare_load_config(self, config: str, replace: bool) -> str: \"\"\" Handle pre \"load_config\" operations for parity between sync and async Args: config: candidate config to load replace: True/False replace the configuration; passed here so it can be set at the class level as we need to stay in config mode and we need to know if we are doing a merge or a replace when we go to diff things Returns: str: string of config to write to candidate config file Raises: N/A \"\"\" self.candidate_config = config if not self.candidate_config_filename: self.candidate_config_filename = f\"scrapli_cfg_{round(datetime.now().timestamp())}\" self.logger.debug( f\"candidate config file name will be '{self.candidate_config_filename}'\" ) config = self._prepare_config_payloads(config=config) self._replace = replace return config def clean_config(self, config: str) -> str: \"\"\" Clean a configuration file of unwanted lines Args: config: configuration string to \"clean\" Returns: str: cleaned configuration string Raises: N/A \"\"\" self.logger.debug(\"cleaning config file\") config = re.sub(pattern=OUTPUT_HEADER_PATTERN, string=config, repl=\"\") config = re.sub(pattern=EDIT_PATTERN, string=config, repl=\"\") return strip_blank_lines(config=config)","title":"ScrapliCfgJunosBase"},{"location":"api_docs/platform/core/juniper_junos/base_platform/#descendants","text":"scrapli_cfg.platform.core.juniper_junos.async_platform.AsyncScrapliCfgJunos scrapli_cfg.platform.core.juniper_junos.sync_platform.ScrapliCfgJunos","title":"Descendants"},{"location":"api_docs/platform/core/juniper_junos/base_platform/#class-variables","text":"candidate_config: str candidate_config_filename: str filesystem: str logger: logging.LoggerAdapter","title":"Class variables"},{"location":"api_docs/platform/core/juniper_junos/base_platform/#methods","text":"","title":"Methods"},{"location":"api_docs/platform/core/juniper_junos/base_platform/#clean_config","text":"clean_config(self, config: str) \u2011> str 1 2 3 4 5 6 7 8 9 10 Clean a configuration file of unwanted lines Args: config: configuration string to \"clean\" Returns: str: cleaned configuration string Raises: N/A","title":"clean_config"},{"location":"api_docs/platform/core/juniper_junos/patterns/","text":"window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting()) Module scrapli_cfg.platform.core.juniper_junos.patterns \u00b6 scrapli_cfg.platform.core.juniper_junos.patterns Expand source code \"\"\"scrapli_cfg.platform.core.juniper_junos.patterns\"\"\" import re VERSION_PATTERN = re.compile( # should match at least versions looking like: # 17.3R2.10 # 18.1R3-S2.5 pattern=r\"\\d+\\.[\\w-]+\\.\\w+\", ) OUTPUT_HEADER_PATTERN = re.compile(pattern=r\"^## last commit.*$\\nversion.*$\", flags=re.M | re.I) EDIT_PATTERN = re.compile(pattern=r\"^\\[edit\\]$\", flags=re.M)","title":"Patterns"},{"location":"api_docs/platform/core/juniper_junos/patterns/#module-scrapli_cfgplatformcorejuniper_junospatterns","text":"scrapli_cfg.platform.core.juniper_junos.patterns Expand source code \"\"\"scrapli_cfg.platform.core.juniper_junos.patterns\"\"\" import re VERSION_PATTERN = re.compile( # should match at least versions looking like: # 17.3R2.10 # 18.1R3-S2.5 pattern=r\"\\d+\\.[\\w-]+\\.\\w+\", ) OUTPUT_HEADER_PATTERN = re.compile(pattern=r\"^## last commit.*$\\nversion.*$\", flags=re.M | re.I) EDIT_PATTERN = re.compile(pattern=r\"^\\[edit\\]$\", flags=re.M)","title":"Module scrapli_cfg.platform.core.juniper_junos.patterns"},{"location":"api_docs/platform/core/juniper_junos/sync_platform/","text":"window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting()) Module scrapli_cfg.platform.core.juniper_junos.sync_platform \u00b6 scrapli_cfg.platform.core.juniper_junos.sync_platform Expand source code \"\"\"scrapli_cfg.platform.core.juniper_junos.sync_platform\"\"\" from typing import Any, Callable, List, Optional from scrapli.driver import NetworkDriver from scrapli.response import MultiResponse, Response from scrapli_cfg.diff import ScrapliCfgDiffResponse from scrapli_cfg.exceptions import DiffConfigError from scrapli_cfg.platform.base.sync_platform import ScrapliCfgPlatform from scrapli_cfg.platform.core.juniper_junos.base_platform import ( CONFIG_SOURCES, ScrapliCfgJunosBase, ) from scrapli_cfg.response import ScrapliCfgResponse class ScrapliCfgJunos(ScrapliCfgPlatform, ScrapliCfgJunosBase): def __init__( self, conn: NetworkDriver, *, config_sources: Optional[List[str]] = None, on_prepare: Optional[Callable[..., Any]] = None, filesystem: str = \"/config/\", cleanup_post_commit: bool = True, dedicated_connection: bool = False, ignore_version: bool = False, ) -> None: if config_sources is None: config_sources = CONFIG_SOURCES super().__init__( conn=conn, config_sources=config_sources, on_prepare=on_prepare, dedicated_connection=dedicated_connection, ignore_version=ignore_version, ) self.filesystem = filesystem self._replace = False self._set = False self.candidate_config_filename = \"\" self._in_configuration_session = False self.cleanup_post_commit = cleanup_post_commit def _delete_candidate_config(self) -> Response: \"\"\" Delete candidate config from the filesystem Args: N/A Returns: Response: response from deleting the candidate config Raises: N/A \"\"\" delete_result = self.conn.send_config( config=f\"rm {self.filesystem}{self.candidate_config_filename}\", privilege_level=\"root_shell\", ) return delete_result def get_version(self) -> ScrapliCfgResponse: response = self._pre_get_version() version_result = self.conn.send_command(command=\"show version | grep junos:\") return self._post_get_version( response=response, scrapli_responses=[version_result], result=self._parse_version(device_output=version_result.result), ) def get_config(self, source: str = \"running\") -> ScrapliCfgResponse: response = self._pre_get_config(source=source) if self._in_configuration_session is True: config_result = self.conn.send_config(config=\"run show configuration\") else: config_result = self.conn.send_command(command=\"show configuration\") return self._post_get_config( response=response, source=source, scrapli_responses=[config_result], result=config_result.result, ) def load_config(self, config: str, replace: bool = False, **kwargs: Any) -> ScrapliCfgResponse: \"\"\" Load configuration to a device Supported kwargs: set: bool indicating config is a \"set\" style config (ignored if replace is True) Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for junos supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" self._set = kwargs.get(\"set\", False) response = self._pre_load_config(config=config) config = self._prepare_load_config(config=config, replace=replace) config_result = self.conn.send_config(config=config, privilege_level=\"root_shell\") if self._replace is True: load_config = f\"load override {self.filesystem}{self.candidate_config_filename}\" else: if self._set is True: load_config = f\"load set {self.filesystem}{self.candidate_config_filename}\" else: load_config = f\"load merge {self.filesystem}{self.candidate_config_filename}\" load_result = self.conn.send_config(config=load_config) self._in_configuration_session = True return self._post_load_config( response=response, scrapli_responses=[config_result, load_result], ) def abort_config(self) -> ScrapliCfgResponse: response = self._pre_abort_config( session_or_config_file=bool(self.candidate_config_filename) ) rollback_result = self.conn.send_config(config=\"rollback 0\") abort_result = self._delete_candidate_config() self._reset_config_session() return self._post_abort_config( response=response, scrapli_responses=[rollback_result, abort_result] ) def commit_config(self, source: str = \"running\") -> ScrapliCfgResponse: scrapli_responses = [] response = self._pre_commit_config( source=source, session_or_config_file=bool(self.candidate_config_filename) ) commit_result = self.conn.send_config(config=\"commit\") scrapli_responses.append(commit_result) if self.cleanup_post_commit: cleanup_result = self._delete_candidate_config() scrapli_responses.append(cleanup_result) self._reset_config_session() return self._post_load_config( response=response, scrapli_responses=scrapli_responses, ) def diff_config(self, source: str = \"running\") -> ScrapliCfgDiffResponse: scrapli_responses = [] device_diff = \"\" source_config = \"\" diff_response = self._pre_diff_config( source=source, session_or_config_file=bool(self.candidate_config_filename) ) try: diff_result = self.conn.send_config(config=\"show | compare\") scrapli_responses.append(diff_result) if diff_result.failed: msg = \"failed generating diff for config session\" self.logger.critical(msg) raise DiffConfigError(msg) device_diff = diff_result.result source_config_result = self.get_config(source=source) source_config = source_config_result.result if isinstance(source_config_result.scrapli_responses, MultiResponse): # in this case this will always be a multiresponse or nothing (failure) but mypy # doesnt know that, hence the isinstance check scrapli_responses.extend(source_config_result.scrapli_responses) if source_config_result.failed: msg = \"failed fetching source config for diff comparison\" self.logger.critical(msg) raise DiffConfigError(msg) except DiffConfigError: pass return self._post_diff_config( diff_response=diff_response, scrapli_responses=scrapli_responses, source_config=self.clean_config(source_config), candidate_config=self.clean_config(self.candidate_config), device_diff=device_diff, ) Classes \u00b6 ScrapliCfgJunos \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 Helper class that provides a standard way to create an ABC using inheritance. Scrapli Config base class Args: conn: scrapli connection to use config_sources: list of config sources on_prepare: optional callable to run at connection `prepare` dedicated_connection: if `False` (default value) scrapli cfg will not open or close the underlying scrapli connection and will raise an exception if the scrapli connection is not open. If `True` will automatically open and close the scrapli connection when using with a context manager, `prepare` will open the scrapli connection (if not already open), and `close` will close the scrapli connection. ignore_version: ignore checking device version support; currently this just means that scrapli-cfg will not fetch the device version during the prepare phase, however this will (hopefully) be used in the future to limit what methods can be used against a target device. For example, for EOS devices we need > 4.14 to load configs; so if a device is encountered at 4.13 the version check would raise an exception rather than just failing in a potentially awkward fashion. Returns: None Raises: N/A Expand source code class ScrapliCfgJunos(ScrapliCfgPlatform, ScrapliCfgJunosBase): def __init__( self, conn: NetworkDriver, *, config_sources: Optional[List[str]] = None, on_prepare: Optional[Callable[..., Any]] = None, filesystem: str = \"/config/\", cleanup_post_commit: bool = True, dedicated_connection: bool = False, ignore_version: bool = False, ) -> None: if config_sources is None: config_sources = CONFIG_SOURCES super().__init__( conn=conn, config_sources=config_sources, on_prepare=on_prepare, dedicated_connection=dedicated_connection, ignore_version=ignore_version, ) self.filesystem = filesystem self._replace = False self._set = False self.candidate_config_filename = \"\" self._in_configuration_session = False self.cleanup_post_commit = cleanup_post_commit def _delete_candidate_config(self) -> Response: \"\"\" Delete candidate config from the filesystem Args: N/A Returns: Response: response from deleting the candidate config Raises: N/A \"\"\" delete_result = self.conn.send_config( config=f\"rm {self.filesystem}{self.candidate_config_filename}\", privilege_level=\"root_shell\", ) return delete_result def get_version(self) -> ScrapliCfgResponse: response = self._pre_get_version() version_result = self.conn.send_command(command=\"show version | grep junos:\") return self._post_get_version( response=response, scrapli_responses=[version_result], result=self._parse_version(device_output=version_result.result), ) def get_config(self, source: str = \"running\") -> ScrapliCfgResponse: response = self._pre_get_config(source=source) if self._in_configuration_session is True: config_result = self.conn.send_config(config=\"run show configuration\") else: config_result = self.conn.send_command(command=\"show configuration\") return self._post_get_config( response=response, source=source, scrapli_responses=[config_result], result=config_result.result, ) def load_config(self, config: str, replace: bool = False, **kwargs: Any) -> ScrapliCfgResponse: \"\"\" Load configuration to a device Supported kwargs: set: bool indicating config is a \"set\" style config (ignored if replace is True) Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for junos supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" self._set = kwargs.get(\"set\", False) response = self._pre_load_config(config=config) config = self._prepare_load_config(config=config, replace=replace) config_result = self.conn.send_config(config=config, privilege_level=\"root_shell\") if self._replace is True: load_config = f\"load override {self.filesystem}{self.candidate_config_filename}\" else: if self._set is True: load_config = f\"load set {self.filesystem}{self.candidate_config_filename}\" else: load_config = f\"load merge {self.filesystem}{self.candidate_config_filename}\" load_result = self.conn.send_config(config=load_config) self._in_configuration_session = True return self._post_load_config( response=response, scrapli_responses=[config_result, load_result], ) def abort_config(self) -> ScrapliCfgResponse: response = self._pre_abort_config( session_or_config_file=bool(self.candidate_config_filename) ) rollback_result = self.conn.send_config(config=\"rollback 0\") abort_result = self._delete_candidate_config() self._reset_config_session() return self._post_abort_config( response=response, scrapli_responses=[rollback_result, abort_result] ) def commit_config(self, source: str = \"running\") -> ScrapliCfgResponse: scrapli_responses = [] response = self._pre_commit_config( source=source, session_or_config_file=bool(self.candidate_config_filename) ) commit_result = self.conn.send_config(config=\"commit\") scrapli_responses.append(commit_result) if self.cleanup_post_commit: cleanup_result = self._delete_candidate_config() scrapli_responses.append(cleanup_result) self._reset_config_session() return self._post_load_config( response=response, scrapli_responses=scrapli_responses, ) def diff_config(self, source: str = \"running\") -> ScrapliCfgDiffResponse: scrapli_responses = [] device_diff = \"\" source_config = \"\" diff_response = self._pre_diff_config( source=source, session_or_config_file=bool(self.candidate_config_filename) ) try: diff_result = self.conn.send_config(config=\"show | compare\") scrapli_responses.append(diff_result) if diff_result.failed: msg = \"failed generating diff for config session\" self.logger.critical(msg) raise DiffConfigError(msg) device_diff = diff_result.result source_config_result = self.get_config(source=source) source_config = source_config_result.result if isinstance(source_config_result.scrapli_responses, MultiResponse): # in this case this will always be a multiresponse or nothing (failure) but mypy # doesnt know that, hence the isinstance check scrapli_responses.extend(source_config_result.scrapli_responses) if source_config_result.failed: msg = \"failed fetching source config for diff comparison\" self.logger.critical(msg) raise DiffConfigError(msg) except DiffConfigError: pass return self._post_diff_config( diff_response=diff_response, scrapli_responses=scrapli_responses, source_config=self.clean_config(source_config), candidate_config=self.clean_config(self.candidate_config), device_diff=device_diff, ) Ancestors (in MRO) \u00b6 scrapli_cfg.platform.base.sync_platform.ScrapliCfgPlatform abc.ABC scrapli_cfg.platform.base.base_platform.ScrapliCfgBase scrapli_cfg.platform.core.juniper_junos.base_platform.ScrapliCfgJunosBase Class variables \u00b6 conn: Union[scrapli.driver.network.sync_driver.NetworkDriver, scrapli.driver.network.async_driver.AsyncNetworkDriver] Methods \u00b6 load_config \u00b6 load_config(self, config: str, replace: bool = False, **kwargs: Any) \u2011> scrapli_cfg.response.ScrapliCfgResponse 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 Load configuration to a device Supported kwargs: set: bool indicating config is a \"set\" style config (ignored if replace is True) Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for junos supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A","title":"Sync Platform"},{"location":"api_docs/platform/core/juniper_junos/sync_platform/#module-scrapli_cfgplatformcorejuniper_junossync_platform","text":"scrapli_cfg.platform.core.juniper_junos.sync_platform Expand source code \"\"\"scrapli_cfg.platform.core.juniper_junos.sync_platform\"\"\" from typing import Any, Callable, List, Optional from scrapli.driver import NetworkDriver from scrapli.response import MultiResponse, Response from scrapli_cfg.diff import ScrapliCfgDiffResponse from scrapli_cfg.exceptions import DiffConfigError from scrapli_cfg.platform.base.sync_platform import ScrapliCfgPlatform from scrapli_cfg.platform.core.juniper_junos.base_platform import ( CONFIG_SOURCES, ScrapliCfgJunosBase, ) from scrapli_cfg.response import ScrapliCfgResponse class ScrapliCfgJunos(ScrapliCfgPlatform, ScrapliCfgJunosBase): def __init__( self, conn: NetworkDriver, *, config_sources: Optional[List[str]] = None, on_prepare: Optional[Callable[..., Any]] = None, filesystem: str = \"/config/\", cleanup_post_commit: bool = True, dedicated_connection: bool = False, ignore_version: bool = False, ) -> None: if config_sources is None: config_sources = CONFIG_SOURCES super().__init__( conn=conn, config_sources=config_sources, on_prepare=on_prepare, dedicated_connection=dedicated_connection, ignore_version=ignore_version, ) self.filesystem = filesystem self._replace = False self._set = False self.candidate_config_filename = \"\" self._in_configuration_session = False self.cleanup_post_commit = cleanup_post_commit def _delete_candidate_config(self) -> Response: \"\"\" Delete candidate config from the filesystem Args: N/A Returns: Response: response from deleting the candidate config Raises: N/A \"\"\" delete_result = self.conn.send_config( config=f\"rm {self.filesystem}{self.candidate_config_filename}\", privilege_level=\"root_shell\", ) return delete_result def get_version(self) -> ScrapliCfgResponse: response = self._pre_get_version() version_result = self.conn.send_command(command=\"show version | grep junos:\") return self._post_get_version( response=response, scrapli_responses=[version_result], result=self._parse_version(device_output=version_result.result), ) def get_config(self, source: str = \"running\") -> ScrapliCfgResponse: response = self._pre_get_config(source=source) if self._in_configuration_session is True: config_result = self.conn.send_config(config=\"run show configuration\") else: config_result = self.conn.send_command(command=\"show configuration\") return self._post_get_config( response=response, source=source, scrapli_responses=[config_result], result=config_result.result, ) def load_config(self, config: str, replace: bool = False, **kwargs: Any) -> ScrapliCfgResponse: \"\"\" Load configuration to a device Supported kwargs: set: bool indicating config is a \"set\" style config (ignored if replace is True) Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for junos supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" self._set = kwargs.get(\"set\", False) response = self._pre_load_config(config=config) config = self._prepare_load_config(config=config, replace=replace) config_result = self.conn.send_config(config=config, privilege_level=\"root_shell\") if self._replace is True: load_config = f\"load override {self.filesystem}{self.candidate_config_filename}\" else: if self._set is True: load_config = f\"load set {self.filesystem}{self.candidate_config_filename}\" else: load_config = f\"load merge {self.filesystem}{self.candidate_config_filename}\" load_result = self.conn.send_config(config=load_config) self._in_configuration_session = True return self._post_load_config( response=response, scrapli_responses=[config_result, load_result], ) def abort_config(self) -> ScrapliCfgResponse: response = self._pre_abort_config( session_or_config_file=bool(self.candidate_config_filename) ) rollback_result = self.conn.send_config(config=\"rollback 0\") abort_result = self._delete_candidate_config() self._reset_config_session() return self._post_abort_config( response=response, scrapli_responses=[rollback_result, abort_result] ) def commit_config(self, source: str = \"running\") -> ScrapliCfgResponse: scrapli_responses = [] response = self._pre_commit_config( source=source, session_or_config_file=bool(self.candidate_config_filename) ) commit_result = self.conn.send_config(config=\"commit\") scrapli_responses.append(commit_result) if self.cleanup_post_commit: cleanup_result = self._delete_candidate_config() scrapli_responses.append(cleanup_result) self._reset_config_session() return self._post_load_config( response=response, scrapli_responses=scrapli_responses, ) def diff_config(self, source: str = \"running\") -> ScrapliCfgDiffResponse: scrapli_responses = [] device_diff = \"\" source_config = \"\" diff_response = self._pre_diff_config( source=source, session_or_config_file=bool(self.candidate_config_filename) ) try: diff_result = self.conn.send_config(config=\"show | compare\") scrapli_responses.append(diff_result) if diff_result.failed: msg = \"failed generating diff for config session\" self.logger.critical(msg) raise DiffConfigError(msg) device_diff = diff_result.result source_config_result = self.get_config(source=source) source_config = source_config_result.result if isinstance(source_config_result.scrapli_responses, MultiResponse): # in this case this will always be a multiresponse or nothing (failure) but mypy # doesnt know that, hence the isinstance check scrapli_responses.extend(source_config_result.scrapli_responses) if source_config_result.failed: msg = \"failed fetching source config for diff comparison\" self.logger.critical(msg) raise DiffConfigError(msg) except DiffConfigError: pass return self._post_diff_config( diff_response=diff_response, scrapli_responses=scrapli_responses, source_config=self.clean_config(source_config), candidate_config=self.clean_config(self.candidate_config), device_diff=device_diff, )","title":"Module scrapli_cfg.platform.core.juniper_junos.sync_platform"},{"location":"api_docs/platform/core/juniper_junos/sync_platform/#classes","text":"","title":"Classes"},{"location":"api_docs/platform/core/juniper_junos/sync_platform/#scraplicfgjunos","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 Helper class that provides a standard way to create an ABC using inheritance. Scrapli Config base class Args: conn: scrapli connection to use config_sources: list of config sources on_prepare: optional callable to run at connection `prepare` dedicated_connection: if `False` (default value) scrapli cfg will not open or close the underlying scrapli connection and will raise an exception if the scrapli connection is not open. If `True` will automatically open and close the scrapli connection when using with a context manager, `prepare` will open the scrapli connection (if not already open), and `close` will close the scrapli connection. ignore_version: ignore checking device version support; currently this just means that scrapli-cfg will not fetch the device version during the prepare phase, however this will (hopefully) be used in the future to limit what methods can be used against a target device. For example, for EOS devices we need > 4.14 to load configs; so if a device is encountered at 4.13 the version check would raise an exception rather than just failing in a potentially awkward fashion. Returns: None Raises: N/A Expand source code class ScrapliCfgJunos(ScrapliCfgPlatform, ScrapliCfgJunosBase): def __init__( self, conn: NetworkDriver, *, config_sources: Optional[List[str]] = None, on_prepare: Optional[Callable[..., Any]] = None, filesystem: str = \"/config/\", cleanup_post_commit: bool = True, dedicated_connection: bool = False, ignore_version: bool = False, ) -> None: if config_sources is None: config_sources = CONFIG_SOURCES super().__init__( conn=conn, config_sources=config_sources, on_prepare=on_prepare, dedicated_connection=dedicated_connection, ignore_version=ignore_version, ) self.filesystem = filesystem self._replace = False self._set = False self.candidate_config_filename = \"\" self._in_configuration_session = False self.cleanup_post_commit = cleanup_post_commit def _delete_candidate_config(self) -> Response: \"\"\" Delete candidate config from the filesystem Args: N/A Returns: Response: response from deleting the candidate config Raises: N/A \"\"\" delete_result = self.conn.send_config( config=f\"rm {self.filesystem}{self.candidate_config_filename}\", privilege_level=\"root_shell\", ) return delete_result def get_version(self) -> ScrapliCfgResponse: response = self._pre_get_version() version_result = self.conn.send_command(command=\"show version | grep junos:\") return self._post_get_version( response=response, scrapli_responses=[version_result], result=self._parse_version(device_output=version_result.result), ) def get_config(self, source: str = \"running\") -> ScrapliCfgResponse: response = self._pre_get_config(source=source) if self._in_configuration_session is True: config_result = self.conn.send_config(config=\"run show configuration\") else: config_result = self.conn.send_command(command=\"show configuration\") return self._post_get_config( response=response, source=source, scrapli_responses=[config_result], result=config_result.result, ) def load_config(self, config: str, replace: bool = False, **kwargs: Any) -> ScrapliCfgResponse: \"\"\" Load configuration to a device Supported kwargs: set: bool indicating config is a \"set\" style config (ignored if replace is True) Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for junos supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A \"\"\" self._set = kwargs.get(\"set\", False) response = self._pre_load_config(config=config) config = self._prepare_load_config(config=config, replace=replace) config_result = self.conn.send_config(config=config, privilege_level=\"root_shell\") if self._replace is True: load_config = f\"load override {self.filesystem}{self.candidate_config_filename}\" else: if self._set is True: load_config = f\"load set {self.filesystem}{self.candidate_config_filename}\" else: load_config = f\"load merge {self.filesystem}{self.candidate_config_filename}\" load_result = self.conn.send_config(config=load_config) self._in_configuration_session = True return self._post_load_config( response=response, scrapli_responses=[config_result, load_result], ) def abort_config(self) -> ScrapliCfgResponse: response = self._pre_abort_config( session_or_config_file=bool(self.candidate_config_filename) ) rollback_result = self.conn.send_config(config=\"rollback 0\") abort_result = self._delete_candidate_config() self._reset_config_session() return self._post_abort_config( response=response, scrapli_responses=[rollback_result, abort_result] ) def commit_config(self, source: str = \"running\") -> ScrapliCfgResponse: scrapli_responses = [] response = self._pre_commit_config( source=source, session_or_config_file=bool(self.candidate_config_filename) ) commit_result = self.conn.send_config(config=\"commit\") scrapli_responses.append(commit_result) if self.cleanup_post_commit: cleanup_result = self._delete_candidate_config() scrapli_responses.append(cleanup_result) self._reset_config_session() return self._post_load_config( response=response, scrapli_responses=scrapli_responses, ) def diff_config(self, source: str = \"running\") -> ScrapliCfgDiffResponse: scrapli_responses = [] device_diff = \"\" source_config = \"\" diff_response = self._pre_diff_config( source=source, session_or_config_file=bool(self.candidate_config_filename) ) try: diff_result = self.conn.send_config(config=\"show | compare\") scrapli_responses.append(diff_result) if diff_result.failed: msg = \"failed generating diff for config session\" self.logger.critical(msg) raise DiffConfigError(msg) device_diff = diff_result.result source_config_result = self.get_config(source=source) source_config = source_config_result.result if isinstance(source_config_result.scrapli_responses, MultiResponse): # in this case this will always be a multiresponse or nothing (failure) but mypy # doesnt know that, hence the isinstance check scrapli_responses.extend(source_config_result.scrapli_responses) if source_config_result.failed: msg = \"failed fetching source config for diff comparison\" self.logger.critical(msg) raise DiffConfigError(msg) except DiffConfigError: pass return self._post_diff_config( diff_response=diff_response, scrapli_responses=scrapli_responses, source_config=self.clean_config(source_config), candidate_config=self.clean_config(self.candidate_config), device_diff=device_diff, )","title":"ScrapliCfgJunos"},{"location":"api_docs/platform/core/juniper_junos/sync_platform/#ancestors-in-mro","text":"scrapli_cfg.platform.base.sync_platform.ScrapliCfgPlatform abc.ABC scrapli_cfg.platform.base.base_platform.ScrapliCfgBase scrapli_cfg.platform.core.juniper_junos.base_platform.ScrapliCfgJunosBase","title":"Ancestors (in MRO)"},{"location":"api_docs/platform/core/juniper_junos/sync_platform/#class-variables","text":"conn: Union[scrapli.driver.network.sync_driver.NetworkDriver, scrapli.driver.network.async_driver.AsyncNetworkDriver]","title":"Class variables"},{"location":"api_docs/platform/core/juniper_junos/sync_platform/#methods","text":"","title":"Methods"},{"location":"api_docs/platform/core/juniper_junos/sync_platform/#load_config","text":"load_config(self, config: str, replace: bool = False, **kwargs: Any) \u2011> scrapli_cfg.response.ScrapliCfgResponse 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 Load configuration to a device Supported kwargs: set: bool indicating config is a \"set\" style config (ignored if replace is True) Args: config: string of the configuration to load replace: replace the configuration or not, if false configuration will be loaded as a merge operation kwargs: additional kwargs that the implementing classes may need for their platform, see above for junos supported kwargs Returns: ScrapliCfgResponse: response object Raises: N/A","title":"load_config"},{"location":"more_scrapli/nornir_scrapli/","text":"Nornir scrapli \u00b6 If you want to use scrapli, but don't want to deal with handling concurrency yourself, there is great news! The nornir_scrapli plugin allows you to use scrapli (and scrapli netconf and scrapli cfg) within the Nornir framework!","title":"Nornir Scrapli"},{"location":"more_scrapli/nornir_scrapli/#nornir-scrapli","text":"If you want to use scrapli, but don't want to deal with handling concurrency yourself, there is great news! The nornir_scrapli plugin allows you to use scrapli (and scrapli netconf and scrapli cfg) within the Nornir framework!","title":"Nornir scrapli"},{"location":"more_scrapli/scrapli/","text":"Scrapli \u00b6 scrapli ( docs ) is the \"parent\" scrapli library. Check it out if you need to connect to devices with telnet or ssh!","title":"Scrapli"},{"location":"more_scrapli/scrapli/#scrapli","text":"scrapli ( docs ) is the \"parent\" scrapli library. Check it out if you need to connect to devices with telnet or ssh!","title":"Scrapli"},{"location":"more_scrapli/scrapli_community/","text":"Scrapli Community \u00b6 If you would like to use scrapli, but the platform(s) that you work with are not supported in the \"core\" scrapli platforms, you should check out scrapli_community ! This is the place for users to share \"non-core\" scrapli platforms.","title":"Scrapli Community"},{"location":"more_scrapli/scrapli_community/#scrapli-community","text":"If you would like to use scrapli, but the platform(s) that you work with are not supported in the \"core\" scrapli platforms, you should check out scrapli_community ! This is the place for users to share \"non-core\" scrapli platforms.","title":"Scrapli Community"},{"location":"more_scrapli/scrapli_netconf/","text":"Scrapli Netconf \u00b6 scrapli_netconf ( docs ) is a netconf driver built on top of scrapli. The purpose of scrapli_netconf is to provide a fast, flexible, thoroughly tested, well typed, well documented, simple API that supports both synchronous and asynchronous usage. Working together scrapli and scrapli_netconf aim to provide a consistent (as is practical) look and feel when automating devices over telnet, SSH, or netconf (over SSH).","title":"Scrapli Netconf"},{"location":"more_scrapli/scrapli_netconf/#scrapli-netconf","text":"scrapli_netconf ( docs ) is a netconf driver built on top of scrapli. The purpose of scrapli_netconf is to provide a fast, flexible, thoroughly tested, well typed, well documented, simple API that supports both synchronous and asynchronous usage. Working together scrapli and scrapli_netconf aim to provide a consistent (as is practical) look and feel when automating devices over telnet, SSH, or netconf (over SSH).","title":"Scrapli Netconf"},{"location":"more_scrapli/scrapli_replay/","text":"Scrapli Replay \u00b6 scrapli_replay ( docs ) is a set of tools used to help test scrapli programs. scrapli_replay includes a utility to capture command input/output from real life servers and replay them in a semi-interactive fashion, as well as a pytest plugin that patches and records and replays session data (like vcr.py ) for scrapli connections.","title":"Scrapli Replay"},{"location":"more_scrapli/scrapli_replay/#scrapli-replay","text":"scrapli_replay ( docs ) is a set of tools used to help test scrapli programs. scrapli_replay includes a utility to capture command input/output from real life servers and replay them in a semi-interactive fashion, as well as a pytest plugin that patches and records and replays session data (like vcr.py ) for scrapli connections.","title":"Scrapli Replay"},{"location":"user_guide/basic_usage/","text":"Basic Usage \u00b6 Picking the right Driver \u00b6 When using scrapli_cfg, you will need to ensure that you are building a scrapli_cfg object specific to the target device. You can create your connection object directly from the appropriate scrapli_cfg class, i.e., ScrapliCfgIOSXE , or you can use the \"factory\" function to appropriately dispatch the class type based on a provided conn object (scrapli connection object). A simple example of creating a scrapli_cfg object by both methods is below: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from scrapli import Scrapli from scrapli_cfg.platform.core.cisco_iosxe import ScrapliCfgIOSXE from scrapli_cfg import ScrapliCfg device = { \"host\" : \"172.18.0.11\" , \"auth_username\" : \"vrnetlab\" , \"auth_password\" : \"VR-netlab9\" , \"auth_strict_key\" : False , \"platform\" : \"cisco_iosxe\" } conn = Scrapli ( ** device ) cfg_conn_from_specific_platform_class = ScrapliCfgIOSXE ( conn = conn ) cfg_conn_from_factory = ScrapliCfg ( conn = conn ) The available platform names are: arista_eos cisco_iosxe cisco_iosxr cisco_nxos juniper_junos Driver Arguments \u00b6 scrapli_cfg doesn't have a ton of arguments/options that you need to worry about! The most important argument is the conn argument -- which is expecting a scrapli connection that is built from the NetworkDriver . This connection must be from one of the \"core\" scrapli platforms (EOS, IOSXE, IOSXR, NXOS, JunOS). The other remaining primary arguments are as follows: config_sources : Generally ignored/handled by the platform implementation for you. A list of strings representing the valid config sources, i.e. \"running\", \"candidate\", or \"startup\" on_prepare : A callable (sync or async depending on your code of course) that is executed during the prepare method; initially scrapli-cfg contained a default callable that would disable console logging (in most cases), however as this actually made changes to your device that were somewhat \"magic\" it was removed. Now, users can pass an on_prepare callable to disable console logging, or really anything else they want. This callable should accept cls as the first argument which is a reference to the scrapli-cfg object itself (and thus has access to the underlying scrapli connection). More on this in the on_prepare section . dedicated_connection : If False (default value) scrapli cfg will not open or close the underlying scrapli connection and will raise an exception if the scrapli connection is not open. If True it will automatically open and close the scrapli connection when using with a context manager, prepare will open the scrapli connection (if not already open), and close will close the scrapli connection. ignore_version : Ignore checking device version support; currently this just means that scrapli-cfg will not fetch the device version during the prepare phase, however this will (hopefully) be used in the future to limit what methods can be used against a target device. For example, for EOS devices we need > 4.14 to load configs; so if a device is encountered at 4.13 the version check would raise an exception rather than just failing in a potentially awkward fashion. There are no additional arguments for creating a scrapli_cfg object, though each platform may have other optional arguments as necessary -- check the docs/class for those. scrapli_cfg Methods \u00b6 scrapli_cfg methods are mostly intended at managing device configuration, though there are a few extra methods in there as well. The following sections provide a brief description and example of how to use the main public methods. Note that nearly all public methods in scrapli_cfg will return a ScrapliCfgResponse object that will contain a result attribute of the result of the given task, as well as the underlying scrapli Response object, and the usual scrapli attributes like start/finish/elapsed time, a failed attribute, and a raise_for_status method. Get Version \u00b6 The get_version method does exactly what you would expect it to -- it fetches the version string from the target device. scrapli_cfg very intentionally has no \"getters\" (in the NAPALM-sense) except for get_version and get_config -- this is because there is no desire to maintain support for getters across a huge variety of versions/platforms. That said, the get_version method was implemented in order to (obviously) fetch device versions to (in the future) be used to validate the target device version supports all features that scrapli_cfg needs in order to manage the configurations. A simple example of fetching and printing the device version: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from scrapli import Scrapli from scrapli_cfg import ScrapliCfg device = { \"host\" : \"172.18.0.11\" , \"auth_username\" : \"vrnetlab\" , \"auth_password\" : \"VR-netlab9\" , \"auth_strict_key\" : False , \"platform\" : \"cisco_iosxe\" } with Scrapli ( ** device ) as conn : cfg_conn = ScrapliCfg ( conn = conn ) cfg_conn . prepare () version_result = cfg_conn . get_version () print ( version_result . result ) Get Config \u00b6 The get_config method does exactly what you would think it does, it fetches the device configuration as a string. This method supports a source argument to which you can provide a string representing the source config you would like to get -- generally this will be either \"startup\" or \"running\". A simple example of fetching and printing the device startup configuration: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from scrapli import Scrapli from scrapli_cfg import ScrapliCfg device = { \"host\" : \"172.18.0.11\" , \"auth_username\" : \"vrnetlab\" , \"auth_password\" : \"VR-netlab9\" , \"auth_strict_key\" : False , \"platform\" : \"cisco_iosxe\" } with Scrapli ( ** device ) as conn : cfg_conn = ScrapliCfg ( conn = conn ) cfg_conn . prepare () cfg_result = cfg_conn . get_config ( source = \"startup\" ) print ( cfg_result . result ) Get Checkpoint (NXOS Only) \u00b6 NXOS can be a little... difficult with configuration replacement operations. It expects to be fed \"checkpoint\" files instead of \"normal\" configuration text. In order to make life a bit easier the NXOS platform supports a get_checkpoint method that fetches a checkpoint file from the device. This is basically the same overall behavior as get_config , just resulting in fetching a checkpoint file. Some details about checkpoints can be found here . A simple example of fetching and printing a checkpoint file from an NXOS device: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from scrapli import Scrapli from scrapli_cfg import ScrapliCfg device = { \"host\" : \"172.18.0.12\" , \"auth_username\" : \"vrnetlab\" , \"auth_password\" : \"VR-netlab9\" , \"auth_strict_key\" : False , \"platform\" : \"cisco_nxos\" } with Scrapli ( ** device ) as conn : cfg_conn = ScrapliCfg ( conn = conn ) cfg_conn . prepare () chkpoint_result = cfg_conn . get_checkpoint () print ( chkpoint_result . result ) Load Config \u00b6 Another, hopefully very obviously named method! load_config does what it sounds like. load_config accepts a configuration to load (as a string; note that if you are doing config replace with NXOS you should use a checkpoint file!), optionally a bool indicating if the operation is a \"replace\" operation (default is False it is a merge operation), and lastly some optional keyword arguments that vary from platform to platform. If replace is False (default) then the config will be loaded as a merge candidate, otherwise it will be loaded as a full replace candidate. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from scrapli import Scrapli from scrapli_cfg import ScrapliCfg with open ( \"config\" , \"r\" ) as f : my_config = f . read () device = { \"host\" : \"172.18.0.11\" , \"auth_username\" : \"vrnetlab\" , \"auth_password\" : \"VR-netlab9\" , \"auth_strict_key\" : False , \"platform\" : \"cisco_iosxe\" } with Scrapli ( ** device ) as conn : cfg_conn = ScrapliCfg ( conn = conn ) cfg_conn . prepare () load_result = cfg_conn . load_config ( config = my_config , replace = True ) print ( load_result ) Note that loading a configuration does not apply the configuration! This simply will create a configuration session or a file on the device (depending on the specific platform type) that can be used to merge/replace the config. Abort Config \u00b6 If you've loaded a configuration but don't want to commit it, you can call abort_config which will delete the candidate config/delete config sessions used to load the config. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 from scrapli import Scrapli from scrapli_cfg import ScrapliCfg with open ( \"config\" , \"r\" ) as f : my_config = f . read () device = { \"host\" : \"172.18.0.11\" , \"auth_username\" : \"vrnetlab\" , \"auth_password\" : \"VR-netlab9\" , \"auth_strict_key\" : False , \"platform\" : \"cisco_iosxe\" } with Scrapli ( ** device ) as conn : cfg_conn = ScrapliCfg ( conn = conn ) cfg_conn . prepare () load_result = cfg_conn . load_config ( config = my_config , replace = True ) print ( load_result ) abort_result = cfg_conn . abort_config () print ( abort_result ) Commit Config \u00b6 If you've loaded a config and want to save/commit it you can do so with the commit_config method: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 from scrapli import Scrapli from scrapli_cfg import ScrapliCfg with open ( \"config\" , \"r\" ) as f : my_config = f . read () device = { \"host\" : \"172.18.0.11\" , \"auth_username\" : \"vrnetlab\" , \"auth_password\" : \"VR-netlab9\" , \"auth_strict_key\" : False , \"platform\" : \"cisco_iosxe\" } with Scrapli ( ** device ) as conn : cfg_conn = ScrapliCfg ( conn = conn ) cfg_conn . prepare () load_result = cfg_conn . load_config ( config = my_config , replace = True ) print ( load_result ) commit_result = cfg_conn . commit_config () print ( commit_result ) Diff Config \u00b6 Perhaps the most interesting/handy method of all: diff_config ! Just like the other methods, this method does exactly what it sounds like it would. There is one important difference between this method and the others, however; the diff_config method returns a ScrapliCfgDiffResponse object instead of a ScrapliCfgResponse object. The ScrapliCfgDiffResponse object is mostly the same as a normal scrapli_cfg response, but it also contains some properties that contain the diff output. scrapli_cfg always tries to get a diff from the device itself -- from whatever means are available on box, but also builds some basic diffs of its own. The diffs that scrapli_cfg builds are fairly simple and will show the difference between the candidate config and the target config, but will have no context about merge vs replace operations, so the diff will always show the \"full\" configuration diff (with colorful output though!). You can see each of the diffs like so: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from scrapli import Scrapli from scrapli_cfg import ScrapliCfg with open ( \"config\" , \"r\" ) as f : my_config = f . read () device = { \"host\" : \"172.18.0.11\" , \"auth_username\" : \"vrnetlab\" , \"auth_password\" : \"VR-netlab9\" , \"auth_strict_key\" : False , \"platform\" : \"cisco_iosxe\" } with Scrapli ( ** device ) as conn : cfg_conn = ScrapliCfg ( conn = conn ) cfg_conn . prepare () load_result = cfg_conn . load_config ( config = my_config , replace = True ) print ( load_result ) diff_result = cfg_conn . diff_config () print ( diff_result . device_diff ) print ( diff_result . unified_diff ) print ( diff_result . side_by_side_diff ) Render Substituted Config \u00b6 The render_substituted_config method is used to (based on user provided regex) auto merge a candidate configuration with sections of the current device configuration. This is meant to allow users an easy-ish way to start doing config replace operations, without having to have a template that covers all aspects of the device configuration. For example, let's say you want to manage everything on a switch except the interfaces. Maybe you want to do this because managing loads of templates for all the different types of interfaces/platforms is a pain, or maybe a different team manages that part of the config... whatever the case you want to be able to do full config replaces, but leave that part of the config completely untouched. This is what the render_substitued_config method is designed to help you with. Here is an example of using this method: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 from scrapli import Scrapli from scrapli_cfg import ScrapliCfg from scrapli_cfg.platform.core.arista_eos.patterns import ETHERNET_INTERFACES with open ( \"config\" , \"r\" ) as f : my_config = f . read () device = { \"host\" : \"172.18.0.14\" , \"auth_username\" : \"vrnetlab\" , \"auth_password\" : \"VR-netlab9\" , \"auth_strict_key\" : False , \"platform\" : \"arista_eos\" } with Scrapli ( ** device ) as conn : cfg_conn = ScrapliCfg ( conn = conn ) cfg_conn . prepare () rendered_config = cfg_conn . render_substituted_config ( config_template = my_config , substitutes = [( \"ethernet_interfaces\" , ETHERNET_INTERFACES )] ) load_result = cfg_conn . load_config ( config = my_config , replace = True ) print ( load_result ) In the above example we have a fairly \"normal\" scrapli_cfg setup -- create a connection and open it. Once the connection is opened we call the render_substituted_config and we pass a config_template and a list of substitutes to it. The config template is what it sounds like -- a template (that looks like a jinja2 template). In this case, this template has a variable ethernet_interfaces in the file where the ethernet interfaces would go, so instead of something like this: 1 2 3 4 5 6 7 username vrnetlab role network-admin secret sha512 $6$8zrJ4ESW2fqG2QqH$9u768TvLXXDeUJmG2Std71EX1ip6q4MoJrMwDng1cmpuSYc9ECWytRjvXpMH7C3dzSdoEv0MxAUiAZeeTre3h. ! interface Ethernet 1 description tacocat ! << SNIP >> interface Management1 We have something like this: 1 2 3 4 username vrnetlab role network-admin secret sha512 $6$8zrJ4ESW2fqG2QqH$9u768TvLXXDeUJmG2Std71EX1ip6q4MoJrMwDng1cmpuSYc9ECWytRjvXpMH7C3dzSdoEv0MxAUiAZeeTre3h. ! {{ ethernet_interfaces }} interface Management1 The substitutes we passed into the render_substituted_config method is a list of tuples, where the first item in the tuple is the variable we want to replace ( ethernet_interfaces in this case) and the second value is a regular expression that matches the section of the real running config that we want to put into this variable. Ultimately, using this example, if we had a \"real\" running configuration containing the following interface section (just using one interface to keep things simple) that looked like this: 1 2 3 4 5 6 username vrnetlab role network-admin secret sha512 $6$8zrJ4ESW2fqG2QqH$9u768TvLXXDeUJmG2Std71EX1ip6q4MoJrMwDng1cmpuSYc9ECWytRjvXpMH7C3dzSdoEv0MxAUiAZeeTre3h. ! interface Ethernet 1 description tacocat ! interface Management1 Our rendered template would end up looking just like that. Again, the point of this method is to allow you to more easily do configuration replaces without having to fully template out device configs. The obvious downside to this method is that it may require fairly complicated regular expressions in order to properly slice and dice the real config. On Prepare \u00b6 The on_prepare argument of the scrapli-cfg objects gives users the opportunity to pass a callable that will be executed prior to any operations occurring (this happens during the aptly named \"prepare\" method which you should be calling prior to using scrapli_cfg operations -- note that if you use the context manager functionality this will already be called for you!). The purpose of this on_prepare callable is to... prepare a device for config operations. Initially scrapli_cfg platforms contained a sane default on_prepare function that basically just disabled console logging. The reasoning for disabling console logging is to ensure that any get_config operations don't have log messages garbling up the output. This \"sane default\" setting has since been removed as it was a bit too much \"magic\" -- meaning that it felt wrong for scrapli_cfg to be making any kind of persistent configuration changes to your devices potentially without users being aware that was happening. As such, it would be a good idea to provide an on_prepare callable to at the very least disable console logging.","title":"Basic Usage"},{"location":"user_guide/basic_usage/#basic-usage","text":"","title":"Basic Usage"},{"location":"user_guide/basic_usage/#picking-the-right-driver","text":"When using scrapli_cfg, you will need to ensure that you are building a scrapli_cfg object specific to the target device. You can create your connection object directly from the appropriate scrapli_cfg class, i.e., ScrapliCfgIOSXE , or you can use the \"factory\" function to appropriately dispatch the class type based on a provided conn object (scrapli connection object). A simple example of creating a scrapli_cfg object by both methods is below: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from scrapli import Scrapli from scrapli_cfg.platform.core.cisco_iosxe import ScrapliCfgIOSXE from scrapli_cfg import ScrapliCfg device = { \"host\" : \"172.18.0.11\" , \"auth_username\" : \"vrnetlab\" , \"auth_password\" : \"VR-netlab9\" , \"auth_strict_key\" : False , \"platform\" : \"cisco_iosxe\" } conn = Scrapli ( ** device ) cfg_conn_from_specific_platform_class = ScrapliCfgIOSXE ( conn = conn ) cfg_conn_from_factory = ScrapliCfg ( conn = conn ) The available platform names are: arista_eos cisco_iosxe cisco_iosxr cisco_nxos juniper_junos","title":"Picking the right Driver"},{"location":"user_guide/basic_usage/#driver-arguments","text":"scrapli_cfg doesn't have a ton of arguments/options that you need to worry about! The most important argument is the conn argument -- which is expecting a scrapli connection that is built from the NetworkDriver . This connection must be from one of the \"core\" scrapli platforms (EOS, IOSXE, IOSXR, NXOS, JunOS). The other remaining primary arguments are as follows: config_sources : Generally ignored/handled by the platform implementation for you. A list of strings representing the valid config sources, i.e. \"running\", \"candidate\", or \"startup\" on_prepare : A callable (sync or async depending on your code of course) that is executed during the prepare method; initially scrapli-cfg contained a default callable that would disable console logging (in most cases), however as this actually made changes to your device that were somewhat \"magic\" it was removed. Now, users can pass an on_prepare callable to disable console logging, or really anything else they want. This callable should accept cls as the first argument which is a reference to the scrapli-cfg object itself (and thus has access to the underlying scrapli connection). More on this in the on_prepare section . dedicated_connection : If False (default value) scrapli cfg will not open or close the underlying scrapli connection and will raise an exception if the scrapli connection is not open. If True it will automatically open and close the scrapli connection when using with a context manager, prepare will open the scrapli connection (if not already open), and close will close the scrapli connection. ignore_version : Ignore checking device version support; currently this just means that scrapli-cfg will not fetch the device version during the prepare phase, however this will (hopefully) be used in the future to limit what methods can be used against a target device. For example, for EOS devices we need > 4.14 to load configs; so if a device is encountered at 4.13 the version check would raise an exception rather than just failing in a potentially awkward fashion. There are no additional arguments for creating a scrapli_cfg object, though each platform may have other optional arguments as necessary -- check the docs/class for those.","title":"Driver Arguments"},{"location":"user_guide/basic_usage/#scrapli_cfg-methods","text":"scrapli_cfg methods are mostly intended at managing device configuration, though there are a few extra methods in there as well. The following sections provide a brief description and example of how to use the main public methods. Note that nearly all public methods in scrapli_cfg will return a ScrapliCfgResponse object that will contain a result attribute of the result of the given task, as well as the underlying scrapli Response object, and the usual scrapli attributes like start/finish/elapsed time, a failed attribute, and a raise_for_status method.","title":"scrapli_cfg Methods"},{"location":"user_guide/basic_usage/#get-version","text":"The get_version method does exactly what you would expect it to -- it fetches the version string from the target device. scrapli_cfg very intentionally has no \"getters\" (in the NAPALM-sense) except for get_version and get_config -- this is because there is no desire to maintain support for getters across a huge variety of versions/platforms. That said, the get_version method was implemented in order to (obviously) fetch device versions to (in the future) be used to validate the target device version supports all features that scrapli_cfg needs in order to manage the configurations. A simple example of fetching and printing the device version: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from scrapli import Scrapli from scrapli_cfg import ScrapliCfg device = { \"host\" : \"172.18.0.11\" , \"auth_username\" : \"vrnetlab\" , \"auth_password\" : \"VR-netlab9\" , \"auth_strict_key\" : False , \"platform\" : \"cisco_iosxe\" } with Scrapli ( ** device ) as conn : cfg_conn = ScrapliCfg ( conn = conn ) cfg_conn . prepare () version_result = cfg_conn . get_version () print ( version_result . result )","title":"Get Version"},{"location":"user_guide/basic_usage/#get-config","text":"The get_config method does exactly what you would think it does, it fetches the device configuration as a string. This method supports a source argument to which you can provide a string representing the source config you would like to get -- generally this will be either \"startup\" or \"running\". A simple example of fetching and printing the device startup configuration: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from scrapli import Scrapli from scrapli_cfg import ScrapliCfg device = { \"host\" : \"172.18.0.11\" , \"auth_username\" : \"vrnetlab\" , \"auth_password\" : \"VR-netlab9\" , \"auth_strict_key\" : False , \"platform\" : \"cisco_iosxe\" } with Scrapli ( ** device ) as conn : cfg_conn = ScrapliCfg ( conn = conn ) cfg_conn . prepare () cfg_result = cfg_conn . get_config ( source = \"startup\" ) print ( cfg_result . result )","title":"Get Config"},{"location":"user_guide/basic_usage/#get-checkpoint-nxos-only","text":"NXOS can be a little... difficult with configuration replacement operations. It expects to be fed \"checkpoint\" files instead of \"normal\" configuration text. In order to make life a bit easier the NXOS platform supports a get_checkpoint method that fetches a checkpoint file from the device. This is basically the same overall behavior as get_config , just resulting in fetching a checkpoint file. Some details about checkpoints can be found here . A simple example of fetching and printing a checkpoint file from an NXOS device: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from scrapli import Scrapli from scrapli_cfg import ScrapliCfg device = { \"host\" : \"172.18.0.12\" , \"auth_username\" : \"vrnetlab\" , \"auth_password\" : \"VR-netlab9\" , \"auth_strict_key\" : False , \"platform\" : \"cisco_nxos\" } with Scrapli ( ** device ) as conn : cfg_conn = ScrapliCfg ( conn = conn ) cfg_conn . prepare () chkpoint_result = cfg_conn . get_checkpoint () print ( chkpoint_result . result )","title":"Get Checkpoint (NXOS Only)"},{"location":"user_guide/basic_usage/#load-config","text":"Another, hopefully very obviously named method! load_config does what it sounds like. load_config accepts a configuration to load (as a string; note that if you are doing config replace with NXOS you should use a checkpoint file!), optionally a bool indicating if the operation is a \"replace\" operation (default is False it is a merge operation), and lastly some optional keyword arguments that vary from platform to platform. If replace is False (default) then the config will be loaded as a merge candidate, otherwise it will be loaded as a full replace candidate. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from scrapli import Scrapli from scrapli_cfg import ScrapliCfg with open ( \"config\" , \"r\" ) as f : my_config = f . read () device = { \"host\" : \"172.18.0.11\" , \"auth_username\" : \"vrnetlab\" , \"auth_password\" : \"VR-netlab9\" , \"auth_strict_key\" : False , \"platform\" : \"cisco_iosxe\" } with Scrapli ( ** device ) as conn : cfg_conn = ScrapliCfg ( conn = conn ) cfg_conn . prepare () load_result = cfg_conn . load_config ( config = my_config , replace = True ) print ( load_result ) Note that loading a configuration does not apply the configuration! This simply will create a configuration session or a file on the device (depending on the specific platform type) that can be used to merge/replace the config.","title":"Load Config"},{"location":"user_guide/basic_usage/#abort-config","text":"If you've loaded a configuration but don't want to commit it, you can call abort_config which will delete the candidate config/delete config sessions used to load the config. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 from scrapli import Scrapli from scrapli_cfg import ScrapliCfg with open ( \"config\" , \"r\" ) as f : my_config = f . read () device = { \"host\" : \"172.18.0.11\" , \"auth_username\" : \"vrnetlab\" , \"auth_password\" : \"VR-netlab9\" , \"auth_strict_key\" : False , \"platform\" : \"cisco_iosxe\" } with Scrapli ( ** device ) as conn : cfg_conn = ScrapliCfg ( conn = conn ) cfg_conn . prepare () load_result = cfg_conn . load_config ( config = my_config , replace = True ) print ( load_result ) abort_result = cfg_conn . abort_config () print ( abort_result )","title":"Abort Config"},{"location":"user_guide/basic_usage/#commit-config","text":"If you've loaded a config and want to save/commit it you can do so with the commit_config method: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 from scrapli import Scrapli from scrapli_cfg import ScrapliCfg with open ( \"config\" , \"r\" ) as f : my_config = f . read () device = { \"host\" : \"172.18.0.11\" , \"auth_username\" : \"vrnetlab\" , \"auth_password\" : \"VR-netlab9\" , \"auth_strict_key\" : False , \"platform\" : \"cisco_iosxe\" } with Scrapli ( ** device ) as conn : cfg_conn = ScrapliCfg ( conn = conn ) cfg_conn . prepare () load_result = cfg_conn . load_config ( config = my_config , replace = True ) print ( load_result ) commit_result = cfg_conn . commit_config () print ( commit_result )","title":"Commit Config"},{"location":"user_guide/basic_usage/#diff-config","text":"Perhaps the most interesting/handy method of all: diff_config ! Just like the other methods, this method does exactly what it sounds like it would. There is one important difference between this method and the others, however; the diff_config method returns a ScrapliCfgDiffResponse object instead of a ScrapliCfgResponse object. The ScrapliCfgDiffResponse object is mostly the same as a normal scrapli_cfg response, but it also contains some properties that contain the diff output. scrapli_cfg always tries to get a diff from the device itself -- from whatever means are available on box, but also builds some basic diffs of its own. The diffs that scrapli_cfg builds are fairly simple and will show the difference between the candidate config and the target config, but will have no context about merge vs replace operations, so the diff will always show the \"full\" configuration diff (with colorful output though!). You can see each of the diffs like so: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from scrapli import Scrapli from scrapli_cfg import ScrapliCfg with open ( \"config\" , \"r\" ) as f : my_config = f . read () device = { \"host\" : \"172.18.0.11\" , \"auth_username\" : \"vrnetlab\" , \"auth_password\" : \"VR-netlab9\" , \"auth_strict_key\" : False , \"platform\" : \"cisco_iosxe\" } with Scrapli ( ** device ) as conn : cfg_conn = ScrapliCfg ( conn = conn ) cfg_conn . prepare () load_result = cfg_conn . load_config ( config = my_config , replace = True ) print ( load_result ) diff_result = cfg_conn . diff_config () print ( diff_result . device_diff ) print ( diff_result . unified_diff ) print ( diff_result . side_by_side_diff )","title":"Diff Config"},{"location":"user_guide/basic_usage/#render-substituted-config","text":"The render_substituted_config method is used to (based on user provided regex) auto merge a candidate configuration with sections of the current device configuration. This is meant to allow users an easy-ish way to start doing config replace operations, without having to have a template that covers all aspects of the device configuration. For example, let's say you want to manage everything on a switch except the interfaces. Maybe you want to do this because managing loads of templates for all the different types of interfaces/platforms is a pain, or maybe a different team manages that part of the config... whatever the case you want to be able to do full config replaces, but leave that part of the config completely untouched. This is what the render_substitued_config method is designed to help you with. Here is an example of using this method: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 from scrapli import Scrapli from scrapli_cfg import ScrapliCfg from scrapli_cfg.platform.core.arista_eos.patterns import ETHERNET_INTERFACES with open ( \"config\" , \"r\" ) as f : my_config = f . read () device = { \"host\" : \"172.18.0.14\" , \"auth_username\" : \"vrnetlab\" , \"auth_password\" : \"VR-netlab9\" , \"auth_strict_key\" : False , \"platform\" : \"arista_eos\" } with Scrapli ( ** device ) as conn : cfg_conn = ScrapliCfg ( conn = conn ) cfg_conn . prepare () rendered_config = cfg_conn . render_substituted_config ( config_template = my_config , substitutes = [( \"ethernet_interfaces\" , ETHERNET_INTERFACES )] ) load_result = cfg_conn . load_config ( config = my_config , replace = True ) print ( load_result ) In the above example we have a fairly \"normal\" scrapli_cfg setup -- create a connection and open it. Once the connection is opened we call the render_substituted_config and we pass a config_template and a list of substitutes to it. The config template is what it sounds like -- a template (that looks like a jinja2 template). In this case, this template has a variable ethernet_interfaces in the file where the ethernet interfaces would go, so instead of something like this: 1 2 3 4 5 6 7 username vrnetlab role network-admin secret sha512 $6$8zrJ4ESW2fqG2QqH$9u768TvLXXDeUJmG2Std71EX1ip6q4MoJrMwDng1cmpuSYc9ECWytRjvXpMH7C3dzSdoEv0MxAUiAZeeTre3h. ! interface Ethernet 1 description tacocat ! << SNIP >> interface Management1 We have something like this: 1 2 3 4 username vrnetlab role network-admin secret sha512 $6$8zrJ4ESW2fqG2QqH$9u768TvLXXDeUJmG2Std71EX1ip6q4MoJrMwDng1cmpuSYc9ECWytRjvXpMH7C3dzSdoEv0MxAUiAZeeTre3h. ! {{ ethernet_interfaces }} interface Management1 The substitutes we passed into the render_substituted_config method is a list of tuples, where the first item in the tuple is the variable we want to replace ( ethernet_interfaces in this case) and the second value is a regular expression that matches the section of the real running config that we want to put into this variable. Ultimately, using this example, if we had a \"real\" running configuration containing the following interface section (just using one interface to keep things simple) that looked like this: 1 2 3 4 5 6 username vrnetlab role network-admin secret sha512 $6$8zrJ4ESW2fqG2QqH$9u768TvLXXDeUJmG2Std71EX1ip6q4MoJrMwDng1cmpuSYc9ECWytRjvXpMH7C3dzSdoEv0MxAUiAZeeTre3h. ! interface Ethernet 1 description tacocat ! interface Management1 Our rendered template would end up looking just like that. Again, the point of this method is to allow you to more easily do configuration replaces without having to fully template out device configs. The obvious downside to this method is that it may require fairly complicated regular expressions in order to properly slice and dice the real config.","title":"Render Substituted Config"},{"location":"user_guide/basic_usage/#on-prepare","text":"The on_prepare argument of the scrapli-cfg objects gives users the opportunity to pass a callable that will be executed prior to any operations occurring (this happens during the aptly named \"prepare\" method which you should be calling prior to using scrapli_cfg operations -- note that if you use the context manager functionality this will already be called for you!). The purpose of this on_prepare callable is to... prepare a device for config operations. Initially scrapli_cfg platforms contained a sane default on_prepare function that basically just disabled console logging. The reasoning for disabling console logging is to ensure that any get_config operations don't have log messages garbling up the output. This \"sane default\" setting has since been removed as it was a bit too much \"magic\" -- meaning that it felt wrong for scrapli_cfg to be making any kind of persistent configuration changes to your devices potentially without users being aware that was happening. As such, it would be a good idea to provide an on_prepare callable to at the very least disable console logging.","title":"On Prepare"},{"location":"user_guide/installation/","text":"Installation \u00b6 Standard Installation \u00b6 As outlined in the quick start, you should be able to pip install scrapli \"normally\": 1 pip install scrapli-cfg Installing current master branch \u00b6 To install from the source repositories master branch: 1 pip install git+https://github.com/scrapli/scrapli_cfg Installing current develop branch \u00b6 To install from the source repositories develop branch: 1 pip install -e git+https://github.com/scrapli/scrapli_cfg.git@develop#egg=scrapli_cfg Installation from Source \u00b6 To install from source: 1 2 3 git clone https://github.com/scrapli/scrapli_cfg cd scrapli_cfg python setup.py install Supported Platforms \u00b6 As for platforms to run scrapli on -- it has and will be tested on MacOS and Ubuntu regularly and should work on any POSIX system. Windows at one point was being tested very minimally via GitHub Actions builds, however this is no longer the case as it is just not worth the effort. While scrapli should work on Windows when using the paramiko or ssh2-python transport drivers, it is not \"officially\" supported. It is strongly recommended/preferred for folks to use WSL/Cygwin instead of Windows.","title":"Installation"},{"location":"user_guide/installation/#installation","text":"","title":"Installation"},{"location":"user_guide/installation/#standard-installation","text":"As outlined in the quick start, you should be able to pip install scrapli \"normally\": 1 pip install scrapli-cfg","title":"Standard Installation"},{"location":"user_guide/installation/#installing-current-master-branch","text":"To install from the source repositories master branch: 1 pip install git+https://github.com/scrapli/scrapli_cfg","title":"Installing current master branch"},{"location":"user_guide/installation/#installing-current-develop-branch","text":"To install from the source repositories develop branch: 1 pip install -e git+https://github.com/scrapli/scrapli_cfg.git@develop#egg=scrapli_cfg","title":"Installing current develop branch"},{"location":"user_guide/installation/#installation-from-source","text":"To install from source: 1 2 3 git clone https://github.com/scrapli/scrapli_cfg cd scrapli_cfg python setup.py install","title":"Installation from Source"},{"location":"user_guide/installation/#supported-platforms","text":"As for platforms to run scrapli on -- it has and will be tested on MacOS and Ubuntu regularly and should work on any POSIX system. Windows at one point was being tested very minimally via GitHub Actions builds, however this is no longer the case as it is just not worth the effort. While scrapli should work on Windows when using the paramiko or ssh2-python transport drivers, it is not \"officially\" supported. It is strongly recommended/preferred for folks to use WSL/Cygwin instead of Windows.","title":"Supported Platforms"},{"location":"user_guide/project_details/","text":"Project Details \u00b6 What is scrapli_cfg \u00b6 scrapli_cfg is a library that sits \"on top\" of scrapli \"core\" and makes merging or replacing device configurations over Telnet or SSH easy. Why over Telnet or SSH? Because you pretty much will always have one of these options available to you, whereas you may not have eAPI or NETCONF ready and enabled (think day zero provisioning, or crazy security requirements locking down ports). So its like NAPALM? \u00b6 If you are familiar with the configuration management abilities of the excellent NAPALM library then you are already generally familiar with what scrapli_cfg is capable of. The primary differences between scrapli_cfg and NAPALM are as follows: scrapli_cfg has, and never will (unless I change my mind), have \"getters\" outside the \"get_config\" and \"get_version\" getters. This means there will not be anything like \"get_interfaces\" in scrapli_cfg. scrapli_cfg has no dependency on any APIs being available -- configurations are all handled via Telnet or SSH. This may sound \"bad\" because the cli is so \"bad\", but it means that there are no requirements for additional ports to be opened or services to be enabled (i.e. eAPI or NETCONF), it even means (with a bit of work to handle initially logging into a terminal server and getting to the right port) you could use scrapli_cfg to fully manage device configuration over terminal server connections. scrapli_cfg has no Python dependencies other than scrapli -- this means there are no vendor libraries necessary, no eznc, no pyeapi, and no pyiosxr. Fewer dependencies isn't a huge deal, but it does mean that the scrapli community is fully \"in control\" of all requirements which is pretty nice! scrapli_cfg, just like \"normal\" scrapli provides supports both synchronous and asynchronous code with the same API scrapli_cfg, provides a render_substituted_config method that helps you easily merge templated configurations with real device configuration -- so you can do \"full config replace\" without having to template out every last line of config! Supported Platforms \u00b6 Just like scrapli \"core\", scrapli_cfg covers the \"core\" NAPALM platforms -- Cisco IOS-XE, IOS-XR, NX-OS, Arista EOS, and Juniper JunOS (eventually, no JunOS support just yet). Below are the core driver platforms and regularly tested version. Cisco IOS-XE (tested on: 16.12.03) Cisco NX-OS (tested on: 9.2.4) Juniper JunOS (tested on: 17.3R2.10) Cisco IOS-XR (tested on: 6.5.3) Arista EOS (tested on: 4.22.1F) Specific platform support requirements are listed below. Arista EOS \u00b6 scrapli_cfg uses configuration sessions in EOS, this feature was added somewhere around the 4.14 release. Early versions of EOS that support configuration sessions did not allow configuration sessions to be aborted from privilege exec, the clear_config_sessions will not work on these versions, however all other scrapli_cfg features should work. Cisco IOSXE \u00b6 IOSXE behavior is very similar to NAPALM, using the archive feature to help with config management and diffs, as such scrapli_cfg requires IOS versions > 12.4(20)T -- all IOSXE versions should be supported (please open an issue or find me on Slack/Twitter if this is incorrect!). Cisco IOSXR \u00b6 scrapli_cfg has worked on every IOSXR version that it has been tested on -- due to IOSXR natively supporting configuration merging/replacing this should work on most IOSXR devices. Cisco NXOS \u00b6 scrapli_cfg should work on most versions of NXOS, there is no requirement for NX-API, instead scrapli_cfg simply relies on the tclsh. Juniper JunOS \u00b6 scrapli_cfg should work on JunOS too -- though JunOS has likely received the least amount of testing at this point.","title":"Project Details"},{"location":"user_guide/project_details/#project-details","text":"","title":"Project Details"},{"location":"user_guide/project_details/#what-is-scrapli_cfg","text":"scrapli_cfg is a library that sits \"on top\" of scrapli \"core\" and makes merging or replacing device configurations over Telnet or SSH easy. Why over Telnet or SSH? Because you pretty much will always have one of these options available to you, whereas you may not have eAPI or NETCONF ready and enabled (think day zero provisioning, or crazy security requirements locking down ports).","title":"What is scrapli_cfg"},{"location":"user_guide/project_details/#so-its-like-napalm","text":"If you are familiar with the configuration management abilities of the excellent NAPALM library then you are already generally familiar with what scrapli_cfg is capable of. The primary differences between scrapli_cfg and NAPALM are as follows: scrapli_cfg has, and never will (unless I change my mind), have \"getters\" outside the \"get_config\" and \"get_version\" getters. This means there will not be anything like \"get_interfaces\" in scrapli_cfg. scrapli_cfg has no dependency on any APIs being available -- configurations are all handled via Telnet or SSH. This may sound \"bad\" because the cli is so \"bad\", but it means that there are no requirements for additional ports to be opened or services to be enabled (i.e. eAPI or NETCONF), it even means (with a bit of work to handle initially logging into a terminal server and getting to the right port) you could use scrapli_cfg to fully manage device configuration over terminal server connections. scrapli_cfg has no Python dependencies other than scrapli -- this means there are no vendor libraries necessary, no eznc, no pyeapi, and no pyiosxr. Fewer dependencies isn't a huge deal, but it does mean that the scrapli community is fully \"in control\" of all requirements which is pretty nice! scrapli_cfg, just like \"normal\" scrapli provides supports both synchronous and asynchronous code with the same API scrapli_cfg, provides a render_substituted_config method that helps you easily merge templated configurations with real device configuration -- so you can do \"full config replace\" without having to template out every last line of config!","title":"So its like NAPALM?"},{"location":"user_guide/project_details/#supported-platforms","text":"Just like scrapli \"core\", scrapli_cfg covers the \"core\" NAPALM platforms -- Cisco IOS-XE, IOS-XR, NX-OS, Arista EOS, and Juniper JunOS (eventually, no JunOS support just yet). Below are the core driver platforms and regularly tested version. Cisco IOS-XE (tested on: 16.12.03) Cisco NX-OS (tested on: 9.2.4) Juniper JunOS (tested on: 17.3R2.10) Cisco IOS-XR (tested on: 6.5.3) Arista EOS (tested on: 4.22.1F) Specific platform support requirements are listed below.","title":"Supported Platforms"},{"location":"user_guide/project_details/#arista-eos","text":"scrapli_cfg uses configuration sessions in EOS, this feature was added somewhere around the 4.14 release. Early versions of EOS that support configuration sessions did not allow configuration sessions to be aborted from privilege exec, the clear_config_sessions will not work on these versions, however all other scrapli_cfg features should work.","title":"Arista EOS"},{"location":"user_guide/project_details/#cisco-iosxe","text":"IOSXE behavior is very similar to NAPALM, using the archive feature to help with config management and diffs, as such scrapli_cfg requires IOS versions > 12.4(20)T -- all IOSXE versions should be supported (please open an issue or find me on Slack/Twitter if this is incorrect!).","title":"Cisco IOSXE"},{"location":"user_guide/project_details/#cisco-iosxr","text":"scrapli_cfg has worked on every IOSXR version that it has been tested on -- due to IOSXR natively supporting configuration merging/replacing this should work on most IOSXR devices.","title":"Cisco IOSXR"},{"location":"user_guide/project_details/#cisco-nxos","text":"scrapli_cfg should work on most versions of NXOS, there is no requirement for NX-API, instead scrapli_cfg simply relies on the tclsh.","title":"Cisco NXOS"},{"location":"user_guide/project_details/#juniper-junos","text":"scrapli_cfg should work on JunOS too -- though JunOS has likely received the least amount of testing at this point.","title":"Juniper JunOS"},{"location":"user_guide/quickstart/","text":"Quick Start Guide \u00b6 Installation \u00b6 In most cases installation via pip is the simplest and best way to install scrapli_cfg. See here for advanced installation details. 1 pip install scrapli-cfg A Simple Example \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 from scrapli import Scrapli from scrapli_cfg import ScrapliCfg device = { \"host\" : \"172.18.0.11\" , \"auth_username\" : \"vrnetlab\" , \"auth_password\" : \"VR-netlab9\" , \"auth_strict_key\" : False , \"platform\" : \"cisco_iosxe\" } with open ( \"myconfig\" , \"r\" ) as f : my_config = f . read () with Scrapli ( ** device ) as conn : cfg_conn = ScrapliCfg ( conn = conn ) cfg_conn . prepare () cfg_conn . load_config ( config = my_config , replace = True ) diff = cfg_conn . diff_config () print ( diff . side_by_side_diff ) cfg_conn . commit_config () More Examples \u00b6 Basic Usage Selective Configuration Replace","title":"Quick Start Guide"},{"location":"user_guide/quickstart/#quick-start-guide","text":"","title":"Quick Start Guide"},{"location":"user_guide/quickstart/#installation","text":"In most cases installation via pip is the simplest and best way to install scrapli_cfg. See here for advanced installation details. 1 pip install scrapli-cfg","title":"Installation"},{"location":"user_guide/quickstart/#a-simple-example","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 from scrapli import Scrapli from scrapli_cfg import ScrapliCfg device = { \"host\" : \"172.18.0.11\" , \"auth_username\" : \"vrnetlab\" , \"auth_password\" : \"VR-netlab9\" , \"auth_strict_key\" : False , \"platform\" : \"cisco_iosxe\" } with open ( \"myconfig\" , \"r\" ) as f : my_config = f . read () with Scrapli ( ** device ) as conn : cfg_conn = ScrapliCfg ( conn = conn ) cfg_conn . prepare () cfg_conn . load_config ( config = my_config , replace = True ) diff = cfg_conn . diff_config () print ( diff . side_by_side_diff ) cfg_conn . commit_config ()","title":"A Simple Example"},{"location":"user_guide/quickstart/#more-examples","text":"Basic Usage Selective Configuration Replace","title":"More Examples"},{"location":"user_guide/versioning/","text":"Versioning \u00b6 Just like scrapli, scrapli_cfg uses the CalVer versioning standard. All release versions follow the format YYYY.MM.DD , however PyPi will shorten/standardize this to remove leading zeros. The reason for choosing CalVer is simply to make it very clear how old a given release of scrapli is. While there are clearly some potential challenges around indicating when a \"breaking\" change occurs due to there not being the concept of a \"major\" version, this is hopefully not too big a deal for scrapli, and thus far the \"core\" API has been very stable -- there are only so many things you can/need to do over SSH after all! Please also note that the CHANGELOG contains notes about each version (and is updated in develop branch while updates are happening). Releases will be made semi-yearly; if you need a feature between releases, there will be periodic pre-releases cut so that folks can easily pip install the prerelease versions for testing and getting any new features/fixes. A final note regarding versioning: scrapli updates are released as often as necessary/there are things to update . This means you should ALWAYS PIN YOUR REQUIREMENTS when using scrapli!! As stated, the \"core\" API has been very stable, but things will change over time -- always pin your requirements, and keep an eye on the changelog/api docs -- you can \"watch\" this repository to ensure you are notified of any releases.","title":"Versioning"},{"location":"user_guide/versioning/#versioning","text":"Just like scrapli, scrapli_cfg uses the CalVer versioning standard. All release versions follow the format YYYY.MM.DD , however PyPi will shorten/standardize this to remove leading zeros. The reason for choosing CalVer is simply to make it very clear how old a given release of scrapli is. While there are clearly some potential challenges around indicating when a \"breaking\" change occurs due to there not being the concept of a \"major\" version, this is hopefully not too big a deal for scrapli, and thus far the \"core\" API has been very stable -- there are only so many things you can/need to do over SSH after all! Please also note that the CHANGELOG contains notes about each version (and is updated in develop branch while updates are happening). Releases will be made semi-yearly; if you need a feature between releases, there will be periodic pre-releases cut so that folks can easily pip install the prerelease versions for testing and getting any new features/fixes. A final note regarding versioning: scrapli updates are released as often as necessary/there are things to update . This means you should ALWAYS PIN YOUR REQUIREMENTS when using scrapli!! As stated, the \"core\" API has been very stable, but things will change over time -- always pin your requirements, and keep an eye on the changelog/api docs -- you can \"watch\" this repository to ensure you are notified of any releases.","title":"Versioning"}]}